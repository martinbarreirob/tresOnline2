{"ast":null,"code":"import { CustomRepositoryDoesNotHaveEntityError } from \"../error/CustomRepositoryDoesNotHaveEntityError\";\nimport { getMetadataArgsStorage } from \"../globals\";\nimport { CustomRepositoryNotFoundError } from \"../error/CustomRepositoryNotFoundError\";\n/**\n * Provides abstract class for custom repositories that do not inherit from original orm Repository.\n * Contains all most-necessary methods to simplify code in the custom repository.\n * All methods are protected thus not exposed and it allows to create encapsulated custom repository.\n *\n * @deprecated use Repository.extend function to create a custom repository\n */\nexport class AbstractRepository {\n  // -------------------------------------------------------------------------\n  // Protected Accessors\n  // -------------------------------------------------------------------------\n  /**\n   * Gets the original ORM repository for the entity that is managed by this repository.\n   * If current repository does not manage any entity, then exception will be thrown.\n   */\n  get repository() {\n    const target = this.getCustomRepositoryTarget(this);\n    if (!target) throw new CustomRepositoryDoesNotHaveEntityError(this.constructor);\n    return this.manager.getRepository(target);\n  }\n  /**\n   * Gets the original ORM tree repository for the entity that is managed by this repository.\n   * If current repository does not manage any entity, then exception will be thrown.\n   */\n  get treeRepository() {\n    const target = this.getCustomRepositoryTarget(this);\n    if (!target) throw new CustomRepositoryDoesNotHaveEntityError(this.constructor);\n    return this.manager.getTreeRepository(target);\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Creates a new query builder for the repository's entity that can be used to build a SQL query.\n   * If current repository does not manage any entity, then exception will be thrown.\n   */\n  createQueryBuilder(alias) {\n    const target = this.getCustomRepositoryTarget(this.constructor);\n    if (!target) throw new CustomRepositoryDoesNotHaveEntityError(this.constructor);\n    return this.manager.getRepository(target).createQueryBuilder(alias);\n  }\n  /**\n   * Creates a new query builder for the given entity that can be used to build a SQL query.\n   */\n  createQueryBuilderFor(entity, alias) {\n    return this.getRepositoryFor(entity).createQueryBuilder(alias);\n  }\n  /**\n   * Gets the original ORM repository for the given entity class.\n   */\n  getRepositoryFor(entity) {\n    return this.manager.getRepository(entity);\n  }\n  /**\n   * Gets the original ORM tree repository for the given entity class.\n   */\n  getTreeRepositoryFor(entity) {\n    return this.manager.getTreeRepository(entity);\n  }\n  // -------------------------------------------------------------------------\n  // Private Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Gets custom repository's managed entity.\n   * If given custom repository does not manage any entity then undefined will be returned.\n   */\n  getCustomRepositoryTarget(customRepository) {\n    const entityRepositoryMetadataArgs = getMetadataArgsStorage().entityRepositories.find(repository => {\n      return repository.target === (typeof customRepository === \"function\" ? customRepository : customRepository.constructor);\n    });\n    if (!entityRepositoryMetadataArgs) throw new CustomRepositoryNotFoundError(customRepository);\n    return entityRepositoryMetadataArgs.entity;\n  }\n}","map":{"version":3,"names":["CustomRepositoryDoesNotHaveEntityError","getMetadataArgsStorage","CustomRepositoryNotFoundError","AbstractRepository","repository","target","getCustomRepositoryTarget","constructor","manager","getRepository","treeRepository","getTreeRepository","createQueryBuilder","alias","createQueryBuilderFor","entity","getRepositoryFor","getTreeRepositoryFor","customRepository","entityRepositoryMetadataArgs","entityRepositories","find"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/repository/AbstractRepository.js"],"sourcesContent":["import { CustomRepositoryDoesNotHaveEntityError } from \"../error/CustomRepositoryDoesNotHaveEntityError\";\nimport { getMetadataArgsStorage } from \"../globals\";\nimport { CustomRepositoryNotFoundError } from \"../error/CustomRepositoryNotFoundError\";\n/**\n * Provides abstract class for custom repositories that do not inherit from original orm Repository.\n * Contains all most-necessary methods to simplify code in the custom repository.\n * All methods are protected thus not exposed and it allows to create encapsulated custom repository.\n *\n * @deprecated use Repository.extend function to create a custom repository\n */\nexport class AbstractRepository {\n    // -------------------------------------------------------------------------\n    // Protected Accessors\n    // -------------------------------------------------------------------------\n    /**\n     * Gets the original ORM repository for the entity that is managed by this repository.\n     * If current repository does not manage any entity, then exception will be thrown.\n     */\n    get repository() {\n        const target = this.getCustomRepositoryTarget(this);\n        if (!target)\n            throw new CustomRepositoryDoesNotHaveEntityError(this.constructor);\n        return this.manager.getRepository(target);\n    }\n    /**\n     * Gets the original ORM tree repository for the entity that is managed by this repository.\n     * If current repository does not manage any entity, then exception will be thrown.\n     */\n    get treeRepository() {\n        const target = this.getCustomRepositoryTarget(this);\n        if (!target)\n            throw new CustomRepositoryDoesNotHaveEntityError(this.constructor);\n        return this.manager.getTreeRepository(target);\n    }\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Creates a new query builder for the repository's entity that can be used to build a SQL query.\n     * If current repository does not manage any entity, then exception will be thrown.\n     */\n    createQueryBuilder(alias) {\n        const target = this.getCustomRepositoryTarget(this.constructor);\n        if (!target)\n            throw new CustomRepositoryDoesNotHaveEntityError(this.constructor);\n        return this.manager\n            .getRepository(target)\n            .createQueryBuilder(alias);\n    }\n    /**\n     * Creates a new query builder for the given entity that can be used to build a SQL query.\n     */\n    createQueryBuilderFor(entity, alias) {\n        return this.getRepositoryFor(entity).createQueryBuilder(alias);\n    }\n    /**\n     * Gets the original ORM repository for the given entity class.\n     */\n    getRepositoryFor(entity) {\n        return this.manager.getRepository(entity);\n    }\n    /**\n     * Gets the original ORM tree repository for the given entity class.\n     */\n    getTreeRepositoryFor(entity) {\n        return this.manager.getTreeRepository(entity);\n    }\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Gets custom repository's managed entity.\n     * If given custom repository does not manage any entity then undefined will be returned.\n     */\n    getCustomRepositoryTarget(customRepository) {\n        const entityRepositoryMetadataArgs = getMetadataArgsStorage().entityRepositories.find((repository) => {\n            return (repository.target ===\n                (typeof customRepository === \"function\"\n                    ? customRepository\n                    : customRepository.constructor));\n        });\n        if (!entityRepositoryMetadataArgs)\n            throw new CustomRepositoryNotFoundError(customRepository);\n        return entityRepositoryMetadataArgs.entity;\n    }\n}\n\n"],"mappings":"AAAA,SAASA,sCAAsC,QAAQ,iDAAiD;AACxG,SAASC,sBAAsB,QAAQ,YAAY;AACnD,SAASC,6BAA6B,QAAQ,wCAAwC;AACtF;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,kBAAkB,CAAC;EAC5B;EACA;EACA;EACA;AACJ;AACA;AACA;EACI,IAAIC,UAAUA,CAAA,EAAG;IACb,MAAMC,MAAM,GAAG,IAAI,CAACC,yBAAyB,CAAC,IAAI,CAAC;IACnD,IAAI,CAACD,MAAM,EACP,MAAM,IAAIL,sCAAsC,CAAC,IAAI,CAACO,WAAW,CAAC;IACtE,OAAO,IAAI,CAACC,OAAO,CAACC,aAAa,CAACJ,MAAM,CAAC;EAC7C;EACA;AACJ;AACA;AACA;EACI,IAAIK,cAAcA,CAAA,EAAG;IACjB,MAAML,MAAM,GAAG,IAAI,CAACC,yBAAyB,CAAC,IAAI,CAAC;IACnD,IAAI,CAACD,MAAM,EACP,MAAM,IAAIL,sCAAsC,CAAC,IAAI,CAACO,WAAW,CAAC;IACtE,OAAO,IAAI,CAACC,OAAO,CAACG,iBAAiB,CAACN,MAAM,CAAC;EACjD;EACA;EACA;EACA;EACA;AACJ;AACA;AACA;EACIO,kBAAkBA,CAACC,KAAK,EAAE;IACtB,MAAMR,MAAM,GAAG,IAAI,CAACC,yBAAyB,CAAC,IAAI,CAACC,WAAW,CAAC;IAC/D,IAAI,CAACF,MAAM,EACP,MAAM,IAAIL,sCAAsC,CAAC,IAAI,CAACO,WAAW,CAAC;IACtE,OAAO,IAAI,CAACC,OAAO,CACdC,aAAa,CAACJ,MAAM,CAAC,CACrBO,kBAAkB,CAACC,KAAK,CAAC;EAClC;EACA;AACJ;AACA;EACIC,qBAAqBA,CAACC,MAAM,EAAEF,KAAK,EAAE;IACjC,OAAO,IAAI,CAACG,gBAAgB,CAACD,MAAM,CAAC,CAACH,kBAAkB,CAACC,KAAK,CAAC;EAClE;EACA;AACJ;AACA;EACIG,gBAAgBA,CAACD,MAAM,EAAE;IACrB,OAAO,IAAI,CAACP,OAAO,CAACC,aAAa,CAACM,MAAM,CAAC;EAC7C;EACA;AACJ;AACA;EACIE,oBAAoBA,CAACF,MAAM,EAAE;IACzB,OAAO,IAAI,CAACP,OAAO,CAACG,iBAAiB,CAACI,MAAM,CAAC;EACjD;EACA;EACA;EACA;EACA;AACJ;AACA;AACA;EACIT,yBAAyBA,CAACY,gBAAgB,EAAE;IACxC,MAAMC,4BAA4B,GAAGlB,sBAAsB,CAAC,CAAC,CAACmB,kBAAkB,CAACC,IAAI,CAAEjB,UAAU,IAAK;MAClG,OAAQA,UAAU,CAACC,MAAM,MACpB,OAAOa,gBAAgB,KAAK,UAAU,GACjCA,gBAAgB,GAChBA,gBAAgB,CAACX,WAAW,CAAC;IAC3C,CAAC,CAAC;IACF,IAAI,CAACY,4BAA4B,EAC7B,MAAM,IAAIjB,6BAA6B,CAACgB,gBAAgB,CAAC;IAC7D,OAAOC,4BAA4B,CAACJ,MAAM;EAC9C;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}