{"ast":null,"code":"import { TypeORMError } from \"../error\";\n/**\n * Orders insert or remove subjects in proper order (using topological sorting)\n * to make sure insert or remove operations are executed in a proper order.\n */\nexport class SubjectTopoligicalSorter {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(subjects) {\n    this.subjects = [...subjects]; // copy subjects to prevent changing of sent array\n    this.metadatas = this.getUniqueMetadatas(this.subjects);\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Sorts (orders) subjects in their topological order.\n   */\n  sort(direction) {\n    // if there are no metadatas it probably mean there is no subjects... we don't have to do anything here\n    if (!this.metadatas.length) return this.subjects;\n    const sortedSubjects = [];\n    // first if we sort for deletion all junction subjects\n    // junction subjects are subjects without entity and database entity set\n    if (direction === \"delete\") {\n      const junctionSubjects = this.subjects.filter(subject => !subject.entity && !subject.databaseEntity);\n      sortedSubjects.push(...junctionSubjects);\n      this.removeAlreadySorted(junctionSubjects);\n    }\n    // next we always insert entities with non-nullable relations, sort them first\n    const nonNullableDependencies = this.getNonNullableDependencies();\n    let sortedNonNullableEntityTargets = this.toposort(nonNullableDependencies);\n    if (direction === \"insert\") sortedNonNullableEntityTargets = sortedNonNullableEntityTargets.reverse();\n    // so we have a sorted entity targets\n    // go thought each of them and find all subjects with sorted entity target\n    // add those sorted targets and remove them from original array of targets\n    sortedNonNullableEntityTargets.forEach(sortedEntityTarget => {\n      const entityTargetSubjects = this.subjects.filter(subject => subject.metadata.targetName === sortedEntityTarget || subject.metadata.inheritanceTree.some(s => s.name === sortedEntityTarget));\n      sortedSubjects.push(...entityTargetSubjects);\n      this.removeAlreadySorted(entityTargetSubjects);\n    });\n    // next sort all other entities\n    // same process as in above but with other entities\n    const otherDependencies = this.getDependencies();\n    let sortedOtherEntityTargets = this.toposort(otherDependencies);\n    if (direction === \"insert\") sortedOtherEntityTargets = sortedOtherEntityTargets.reverse();\n    sortedOtherEntityTargets.forEach(sortedEntityTarget => {\n      const entityTargetSubjects = this.subjects.filter(subject => subject.metadata.targetName === sortedEntityTarget);\n      sortedSubjects.push(...entityTargetSubjects);\n      this.removeAlreadySorted(entityTargetSubjects);\n    });\n    // if we have something left in the subjects add them as well\n    sortedSubjects.push(...this.subjects);\n    return sortedSubjects;\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Removes already sorted subjects from this.subjects list of subjects.\n   */\n  removeAlreadySorted(subjects) {\n    subjects.forEach(subject => {\n      this.subjects.splice(this.subjects.indexOf(subject), 1);\n    });\n  }\n  /**\n   * Extracts all unique metadatas from the given subjects.\n   */\n  getUniqueMetadatas(subjects) {\n    const metadatas = [];\n    subjects.forEach(subject => {\n      if (metadatas.indexOf(subject.metadata) === -1) metadatas.push(subject.metadata);\n    });\n    return metadatas;\n  }\n  /**\n   * Gets dependency tree for all entity metadatas with non-nullable relations.\n   * We need to execute insertions first for entities which non-nullable relations.\n   */\n  getNonNullableDependencies() {\n    return this.metadatas.reduce((dependencies, metadata) => {\n      metadata.relationsWithJoinColumns.forEach(relation => {\n        if (relation.isNullable) return;\n        dependencies.push([metadata.targetName, relation.inverseEntityMetadata.targetName]);\n      });\n      return dependencies;\n    }, []);\n  }\n  /**\n   * Gets dependency tree for all entity metadatas with non-nullable relations.\n   * We need to execute insertions first for entities which non-nullable relations.\n   */\n  getDependencies() {\n    return this.metadatas.reduce((dependencies, metadata) => {\n      metadata.relationsWithJoinColumns.forEach(relation => {\n        // if relation is self-referenced we skip it\n        if (relation.inverseEntityMetadata === metadata) return;\n        dependencies.push([metadata.targetName, relation.inverseEntityMetadata.targetName]);\n      });\n      return dependencies;\n    }, []);\n  }\n  /**\n   * Sorts given graph using topological sorting algorithm.\n   *\n   * Algorithm is kindly taken from https://github.com/marcelklehr/toposort repository.\n   */\n  toposort(edges) {\n    function uniqueNodes(arr) {\n      let res = [];\n      for (let i = 0, len = arr.length; i < len; i++) {\n        let edge = arr[i];\n        if (res.indexOf(edge[0]) < 0) res.push(edge[0]);\n        if (res.indexOf(edge[1]) < 0) res.push(edge[1]);\n      }\n      return res;\n    }\n    const nodes = uniqueNodes(edges);\n    let cursor = nodes.length,\n      sorted = new Array(cursor),\n      visited = {},\n      i = cursor;\n    while (i--) {\n      if (!visited[i]) visit(nodes[i], i, []);\n    }\n    function visit(node, i, predecessors) {\n      if (predecessors.indexOf(node) >= 0) {\n        throw new TypeORMError(\"Cyclic dependency: \" + JSON.stringify(node)); // todo: better error\n      }\n\n      if (!~nodes.indexOf(node)) {\n        throw new TypeORMError(\"Found unknown node. Make sure to provided all involved nodes. Unknown node: \" + JSON.stringify(node));\n      }\n      if (visited[i]) return;\n      visited[i] = true;\n      // outgoing edges\n      let outgoing = edges.filter(function (edge) {\n        return edge[0] === node;\n      });\n      if (i = outgoing.length) {\n        let preds = predecessors.concat(node);\n        do {\n          let child = outgoing[--i][1];\n          visit(child, nodes.indexOf(child), preds);\n        } while (i);\n      }\n      sorted[--cursor] = node;\n    }\n    return sorted;\n  }\n}","map":{"version":3,"names":["TypeORMError","SubjectTopoligicalSorter","constructor","subjects","metadatas","getUniqueMetadatas","sort","direction","length","sortedSubjects","junctionSubjects","filter","subject","entity","databaseEntity","push","removeAlreadySorted","nonNullableDependencies","getNonNullableDependencies","sortedNonNullableEntityTargets","toposort","reverse","forEach","sortedEntityTarget","entityTargetSubjects","metadata","targetName","inheritanceTree","some","s","name","otherDependencies","getDependencies","sortedOtherEntityTargets","splice","indexOf","reduce","dependencies","relationsWithJoinColumns","relation","isNullable","inverseEntityMetadata","edges","uniqueNodes","arr","res","i","len","edge","nodes","cursor","sorted","Array","visited","visit","node","predecessors","JSON","stringify","outgoing","preds","concat","child"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/persistence/SubjectTopoligicalSorter.js"],"sourcesContent":["import { TypeORMError } from \"../error\";\n/**\n * Orders insert or remove subjects in proper order (using topological sorting)\n * to make sure insert or remove operations are executed in a proper order.\n */\nexport class SubjectTopoligicalSorter {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n    constructor(subjects) {\n        this.subjects = [...subjects]; // copy subjects to prevent changing of sent array\n        this.metadatas = this.getUniqueMetadatas(this.subjects);\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Sorts (orders) subjects in their topological order.\n     */\n    sort(direction) {\n        // if there are no metadatas it probably mean there is no subjects... we don't have to do anything here\n        if (!this.metadatas.length)\n            return this.subjects;\n        const sortedSubjects = [];\n        // first if we sort for deletion all junction subjects\n        // junction subjects are subjects without entity and database entity set\n        if (direction === \"delete\") {\n            const junctionSubjects = this.subjects.filter((subject) => !subject.entity && !subject.databaseEntity);\n            sortedSubjects.push(...junctionSubjects);\n            this.removeAlreadySorted(junctionSubjects);\n        }\n        // next we always insert entities with non-nullable relations, sort them first\n        const nonNullableDependencies = this.getNonNullableDependencies();\n        let sortedNonNullableEntityTargets = this.toposort(nonNullableDependencies);\n        if (direction === \"insert\")\n            sortedNonNullableEntityTargets =\n                sortedNonNullableEntityTargets.reverse();\n        // so we have a sorted entity targets\n        // go thought each of them and find all subjects with sorted entity target\n        // add those sorted targets and remove them from original array of targets\n        sortedNonNullableEntityTargets.forEach((sortedEntityTarget) => {\n            const entityTargetSubjects = this.subjects.filter((subject) => subject.metadata.targetName === sortedEntityTarget ||\n                subject.metadata.inheritanceTree.some((s) => s.name === sortedEntityTarget));\n            sortedSubjects.push(...entityTargetSubjects);\n            this.removeAlreadySorted(entityTargetSubjects);\n        });\n        // next sort all other entities\n        // same process as in above but with other entities\n        const otherDependencies = this.getDependencies();\n        let sortedOtherEntityTargets = this.toposort(otherDependencies);\n        if (direction === \"insert\")\n            sortedOtherEntityTargets = sortedOtherEntityTargets.reverse();\n        sortedOtherEntityTargets.forEach((sortedEntityTarget) => {\n            const entityTargetSubjects = this.subjects.filter((subject) => subject.metadata.targetName === sortedEntityTarget);\n            sortedSubjects.push(...entityTargetSubjects);\n            this.removeAlreadySorted(entityTargetSubjects);\n        });\n        // if we have something left in the subjects add them as well\n        sortedSubjects.push(...this.subjects);\n        return sortedSubjects;\n    }\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Removes already sorted subjects from this.subjects list of subjects.\n     */\n    removeAlreadySorted(subjects) {\n        subjects.forEach((subject) => {\n            this.subjects.splice(this.subjects.indexOf(subject), 1);\n        });\n    }\n    /**\n     * Extracts all unique metadatas from the given subjects.\n     */\n    getUniqueMetadatas(subjects) {\n        const metadatas = [];\n        subjects.forEach((subject) => {\n            if (metadatas.indexOf(subject.metadata) === -1)\n                metadatas.push(subject.metadata);\n        });\n        return metadatas;\n    }\n    /**\n     * Gets dependency tree for all entity metadatas with non-nullable relations.\n     * We need to execute insertions first for entities which non-nullable relations.\n     */\n    getNonNullableDependencies() {\n        return this.metadatas.reduce((dependencies, metadata) => {\n            metadata.relationsWithJoinColumns.forEach((relation) => {\n                if (relation.isNullable)\n                    return;\n                dependencies.push([\n                    metadata.targetName,\n                    relation.inverseEntityMetadata.targetName,\n                ]);\n            });\n            return dependencies;\n        }, []);\n    }\n    /**\n     * Gets dependency tree for all entity metadatas with non-nullable relations.\n     * We need to execute insertions first for entities which non-nullable relations.\n     */\n    getDependencies() {\n        return this.metadatas.reduce((dependencies, metadata) => {\n            metadata.relationsWithJoinColumns.forEach((relation) => {\n                // if relation is self-referenced we skip it\n                if (relation.inverseEntityMetadata === metadata)\n                    return;\n                dependencies.push([\n                    metadata.targetName,\n                    relation.inverseEntityMetadata.targetName,\n                ]);\n            });\n            return dependencies;\n        }, []);\n    }\n    /**\n     * Sorts given graph using topological sorting algorithm.\n     *\n     * Algorithm is kindly taken from https://github.com/marcelklehr/toposort repository.\n     */\n    toposort(edges) {\n        function uniqueNodes(arr) {\n            let res = [];\n            for (let i = 0, len = arr.length; i < len; i++) {\n                let edge = arr[i];\n                if (res.indexOf(edge[0]) < 0)\n                    res.push(edge[0]);\n                if (res.indexOf(edge[1]) < 0)\n                    res.push(edge[1]);\n            }\n            return res;\n        }\n        const nodes = uniqueNodes(edges);\n        let cursor = nodes.length, sorted = new Array(cursor), visited = {}, i = cursor;\n        while (i--) {\n            if (!visited[i])\n                visit(nodes[i], i, []);\n        }\n        function visit(node, i, predecessors) {\n            if (predecessors.indexOf(node) >= 0) {\n                throw new TypeORMError(\"Cyclic dependency: \" + JSON.stringify(node)); // todo: better error\n            }\n            if (!~nodes.indexOf(node)) {\n                throw new TypeORMError(\"Found unknown node. Make sure to provided all involved nodes. Unknown node: \" +\n                    JSON.stringify(node));\n            }\n            if (visited[i])\n                return;\n            visited[i] = true;\n            // outgoing edges\n            let outgoing = edges.filter(function (edge) {\n                return edge[0] === node;\n            });\n            if ((i = outgoing.length)) {\n                let preds = predecessors.concat(node);\n                do {\n                    let child = outgoing[--i][1];\n                    visit(child, nodes.indexOf(child), preds);\n                } while (i);\n            }\n            sorted[--cursor] = node;\n        }\n        return sorted;\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}