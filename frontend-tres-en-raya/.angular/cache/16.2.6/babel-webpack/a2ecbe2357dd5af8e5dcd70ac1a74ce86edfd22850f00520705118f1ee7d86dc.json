{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/practicas/Downloads/angular/tresOnline/frontend-tres-en-raya/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\n/**\n * Loads database entities for all operate subjects which do not have database entity set.\n * All entities that we load database entities for are marked as updated or inserted.\n * To understand which of them really needs to be inserted or updated we need to load\n * their original representations from the database.\n */\nexport class SubjectDatabaseEntityLoader {\n  // ---------------------------------------------------------------------\n  // Constructor\n  // ---------------------------------------------------------------------\n  constructor(queryRunner, subjects) {\n    this.queryRunner = queryRunner;\n    this.subjects = subjects;\n  }\n  // ---------------------------------------------------------------------\n  // Public Methods\n  // ---------------------------------------------------------------------\n  /**\n   * Loads database entities for all subjects.\n   *\n   * loadAllRelations flag is used to load all relation ids of the object, no matter if they present in subject entity or not.\n   * This option is used for deletion.\n   */\n  load(operationType) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      // we are grouping subjects by target to perform more optimized queries using WHERE IN operator\n      // go through the groups and perform loading of database entities of each subject in the group\n      const promises = _this.groupByEntityTargets().map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (subjectGroup) {\n          // prepare entity ids of the subjects we need to load\n          const allIds = [];\n          const allSubjects = [];\n          subjectGroup.subjects.forEach(subject => {\n            // we don't load if subject already has a database entity loaded\n            if (subject.databaseEntity || !subject.identifier) return;\n            allIds.push(subject.identifier);\n            allSubjects.push(subject);\n          });\n          // if there no ids found (means all entities are new and have generated ids) - then nothing to load there\n          if (!allIds.length) return;\n          const loadRelationPropertyPaths = [];\n          // for the save, soft-remove and recover operation\n          // extract all property paths of the relations we need to load relation ids for\n          // this is for optimization purpose - this way we don't load relation ids for entities\n          // whose relations are undefined, and since they are undefined its really pointless to\n          // load something for them, since undefined properties are skipped by the orm\n          if (operationType === \"save\" || operationType === \"soft-remove\" || operationType === \"recover\") {\n            subjectGroup.subjects.forEach(subject => {\n              // gets all relation property paths that exist in the persisted entity.\n              subject.metadata.relations.forEach(relation => {\n                const value = relation.getEntityValue(subject.entityWithFulfilledIds);\n                if (value === undefined) return;\n                if (loadRelationPropertyPaths.indexOf(relation.propertyPath) === -1) loadRelationPropertyPaths.push(relation.propertyPath);\n              });\n            });\n          } else {\n            // remove\n            // for remove operation\n            // we only need to load junction relation ids since only they are removed by cascades\n            loadRelationPropertyPaths.push(...subjectGroup.subjects[0].metadata.manyToManyRelations.map(relation => relation.propertyPath));\n          }\n          const findOptions = {\n            loadEagerRelations: false,\n            loadRelationIds: {\n              relations: loadRelationPropertyPaths,\n              disableMixedMap: true\n            },\n            // the soft-deleted entities should be included in the loaded entities for recover operation\n            withDeleted: true\n          };\n          // load database entities for all given ids\n          let entities = [];\n          if (_this.queryRunner.connection.driver.options.type === \"mongodb\") {\n            const mongoRepo = _this.queryRunner.manager.getRepository(subjectGroup.target);\n            entities = yield mongoRepo.findByIds(allIds, findOptions);\n          } else {\n            entities = yield _this.queryRunner.manager.getRepository(subjectGroup.target).createQueryBuilder().setFindOptions(findOptions).whereInIds(allIds).getMany();\n          }\n          // now when we have entities we need to find subject of each entity\n          // and insert that entity into database entity of the found subjects\n          entities.forEach(entity => {\n            const subjects = _this.findByPersistEntityLike(subjectGroup.target, entity);\n            subjects.forEach(subject => {\n              subject.databaseEntity = entity;\n              if (!subject.identifier) subject.identifier = subject.metadata.hasAllPrimaryKeys(entity) ? subject.metadata.getEntityIdMap(entity) : undefined;\n            });\n          });\n          // this way we tell what subjects we tried to load database entities of\n          for (let subject of allSubjects) {\n            subject.databaseEntityLoaded = true;\n          }\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n      yield Promise.all(promises);\n    })();\n  }\n  // ---------------------------------------------------------------------\n  // Protected Methods\n  // ---------------------------------------------------------------------\n  /**\n   * Finds subjects where entity like given subject's entity.\n   * Comparison made by entity id.\n   * Multiple subjects may be returned if duplicates are present in the subject array.\n   * This will likely result in the same row being updated multiple times during a transaction.\n   */\n  findByPersistEntityLike(entityTarget, entity) {\n    return this.subjects.filter(subject => {\n      if (!subject.entity) return false;\n      if (subject.entity === entity) return true;\n      return subject.metadata.target === entityTarget && subject.metadata.compareEntities(subject.entityWithFulfilledIds, entity);\n    });\n  }\n  /**\n   * Groups given Subject objects into groups separated by entity targets.\n   */\n  groupByEntityTargets() {\n    return this.subjects.reduce((groups, operatedEntity) => {\n      let group = groups.find(group => group.target === operatedEntity.metadata.target);\n      if (!group) {\n        group = {\n          target: operatedEntity.metadata.target,\n          subjects: []\n        };\n        groups.push(group);\n      }\n      group.subjects.push(operatedEntity);\n      return groups;\n    }, []);\n  }\n}","map":{"version":3,"names":["SubjectDatabaseEntityLoader","constructor","queryRunner","subjects","load","operationType","_this","_asyncToGenerator","promises","groupByEntityTargets","map","_ref","subjectGroup","allIds","allSubjects","forEach","subject","databaseEntity","identifier","push","length","loadRelationPropertyPaths","metadata","relations","relation","value","getEntityValue","entityWithFulfilledIds","undefined","indexOf","propertyPath","manyToManyRelations","findOptions","loadEagerRelations","loadRelationIds","disableMixedMap","withDeleted","entities","connection","driver","options","type","mongoRepo","manager","getRepository","target","findByIds","createQueryBuilder","setFindOptions","whereInIds","getMany","entity","findByPersistEntityLike","hasAllPrimaryKeys","getEntityIdMap","databaseEntityLoaded","_x","apply","arguments","Promise","all","entityTarget","filter","compareEntities","reduce","groups","operatedEntity","group","find"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/persistence/SubjectDatabaseEntityLoader.js"],"sourcesContent":["/**\n * Loads database entities for all operate subjects which do not have database entity set.\n * All entities that we load database entities for are marked as updated or inserted.\n * To understand which of them really needs to be inserted or updated we need to load\n * their original representations from the database.\n */\nexport class SubjectDatabaseEntityLoader {\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n    constructor(queryRunner, subjects) {\n        this.queryRunner = queryRunner;\n        this.subjects = subjects;\n    }\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n    /**\n     * Loads database entities for all subjects.\n     *\n     * loadAllRelations flag is used to load all relation ids of the object, no matter if they present in subject entity or not.\n     * This option is used for deletion.\n     */\n    async load(operationType) {\n        // we are grouping subjects by target to perform more optimized queries using WHERE IN operator\n        // go through the groups and perform loading of database entities of each subject in the group\n        const promises = this.groupByEntityTargets().map(async (subjectGroup) => {\n            // prepare entity ids of the subjects we need to load\n            const allIds = [];\n            const allSubjects = [];\n            subjectGroup.subjects.forEach((subject) => {\n                // we don't load if subject already has a database entity loaded\n                if (subject.databaseEntity || !subject.identifier)\n                    return;\n                allIds.push(subject.identifier);\n                allSubjects.push(subject);\n            });\n            // if there no ids found (means all entities are new and have generated ids) - then nothing to load there\n            if (!allIds.length)\n                return;\n            const loadRelationPropertyPaths = [];\n            // for the save, soft-remove and recover operation\n            // extract all property paths of the relations we need to load relation ids for\n            // this is for optimization purpose - this way we don't load relation ids for entities\n            // whose relations are undefined, and since they are undefined its really pointless to\n            // load something for them, since undefined properties are skipped by the orm\n            if (operationType === \"save\" ||\n                operationType === \"soft-remove\" ||\n                operationType === \"recover\") {\n                subjectGroup.subjects.forEach((subject) => {\n                    // gets all relation property paths that exist in the persisted entity.\n                    subject.metadata.relations.forEach((relation) => {\n                        const value = relation.getEntityValue(subject.entityWithFulfilledIds);\n                        if (value === undefined)\n                            return;\n                        if (loadRelationPropertyPaths.indexOf(relation.propertyPath) === -1)\n                            loadRelationPropertyPaths.push(relation.propertyPath);\n                    });\n                });\n            }\n            else {\n                // remove\n                // for remove operation\n                // we only need to load junction relation ids since only they are removed by cascades\n                loadRelationPropertyPaths.push(...subjectGroup.subjects[0].metadata.manyToManyRelations.map((relation) => relation.propertyPath));\n            }\n            const findOptions = {\n                loadEagerRelations: false,\n                loadRelationIds: {\n                    relations: loadRelationPropertyPaths,\n                    disableMixedMap: true,\n                },\n                // the soft-deleted entities should be included in the loaded entities for recover operation\n                withDeleted: true,\n            };\n            // load database entities for all given ids\n            let entities = [];\n            if (this.queryRunner.connection.driver.options.type ===\n                \"mongodb\") {\n                const mongoRepo = this.queryRunner.manager.getRepository(subjectGroup.target);\n                entities = await mongoRepo.findByIds(allIds, findOptions);\n            }\n            else {\n                entities = await this.queryRunner.manager\n                    .getRepository(subjectGroup.target)\n                    .createQueryBuilder()\n                    .setFindOptions(findOptions)\n                    .whereInIds(allIds)\n                    .getMany();\n            }\n            // now when we have entities we need to find subject of each entity\n            // and insert that entity into database entity of the found subjects\n            entities.forEach((entity) => {\n                const subjects = this.findByPersistEntityLike(subjectGroup.target, entity);\n                subjects.forEach((subject) => {\n                    subject.databaseEntity = entity;\n                    if (!subject.identifier)\n                        subject.identifier =\n                            subject.metadata.hasAllPrimaryKeys(entity)\n                                ? subject.metadata.getEntityIdMap(entity)\n                                : undefined;\n                });\n            });\n            // this way we tell what subjects we tried to load database entities of\n            for (let subject of allSubjects) {\n                subject.databaseEntityLoaded = true;\n            }\n        });\n        await Promise.all(promises);\n    }\n    // ---------------------------------------------------------------------\n    // Protected Methods\n    // ---------------------------------------------------------------------\n    /**\n     * Finds subjects where entity like given subject's entity.\n     * Comparison made by entity id.\n     * Multiple subjects may be returned if duplicates are present in the subject array.\n     * This will likely result in the same row being updated multiple times during a transaction.\n     */\n    findByPersistEntityLike(entityTarget, entity) {\n        return this.subjects.filter((subject) => {\n            if (!subject.entity)\n                return false;\n            if (subject.entity === entity)\n                return true;\n            return (subject.metadata.target === entityTarget &&\n                subject.metadata.compareEntities(subject.entityWithFulfilledIds, entity));\n        });\n    }\n    /**\n     * Groups given Subject objects into groups separated by entity targets.\n     */\n    groupByEntityTargets() {\n        return this.subjects.reduce((groups, operatedEntity) => {\n            let group = groups.find((group) => group.target === operatedEntity.metadata.target);\n            if (!group) {\n                group = { target: operatedEntity.metadata.target, subjects: [] };\n                groups.push(group);\n            }\n            group.subjects.push(operatedEntity);\n            return groups;\n        }, []);\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}