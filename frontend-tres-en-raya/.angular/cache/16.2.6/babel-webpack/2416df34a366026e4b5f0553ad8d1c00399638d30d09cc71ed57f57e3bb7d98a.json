{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/practicas/Downloads/angular/tresOnline/frontend-tres-en-raya/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\nimport { NestedSetMultipleRootError } from \"../../error/NestedSetMultipleRootError\";\nclass NestedSetIds {}\n/**\n * Executes subject operations for nested set tree entities.\n */\nexport class NestedSetSubjectExecutor {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(queryRunner) {\n    this.queryRunner = queryRunner;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Executes operations when subject is being inserted.\n   */\n  insert(subject) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const escape = alias => _this.queryRunner.connection.driver.escape(alias);\n      const tableName = _this.getTableName(subject.metadata.tablePath);\n      const leftColumnName = escape(subject.metadata.nestedSetLeftColumn.databaseName);\n      const rightColumnName = escape(subject.metadata.nestedSetRightColumn.databaseName);\n      let parent = subject.metadata.treeParentRelation.getEntityValue(subject.entity); // if entity was attached via parent\n      if (!parent && subject.parentSubject && subject.parentSubject.entity)\n        // if entity was attached via children\n        parent = subject.parentSubject.insertedValueSet ? subject.parentSubject.insertedValueSet : subject.parentSubject.entity;\n      const parentId = subject.metadata.getEntityIdMap(parent);\n      let parentNsRight = undefined;\n      if (parentId) {\n        parentNsRight = yield _this.queryRunner.manager.createQueryBuilder().select(subject.metadata.targetName + \".\" + subject.metadata.nestedSetRightColumn.propertyPath, \"right\").from(subject.metadata.target, subject.metadata.targetName).whereInIds(parentId).getRawOne().then(result => {\n          const value = result ? result[\"right\"] : undefined;\n          // CockroachDB returns numeric types as string\n          return typeof value === \"string\" ? parseInt(value) : value;\n        });\n      }\n      if (parentNsRight !== undefined) {\n        yield _this.queryRunner.query(`UPDATE ${tableName} SET ` + `${leftColumnName} = CASE WHEN ${leftColumnName} > ${parentNsRight} THEN ${leftColumnName} + 2 ELSE ${leftColumnName} END,` + `${rightColumnName} = ${rightColumnName} + 2 ` + `WHERE ${rightColumnName} >= ${parentNsRight}`);\n        OrmUtils.mergeDeep(subject.insertedValueSet, subject.metadata.nestedSetLeftColumn.createValueMap(parentNsRight), subject.metadata.nestedSetRightColumn.createValueMap(parentNsRight + 1));\n      } else {\n        const isUniqueRoot = yield _this.isUniqueRootEntity(subject, parent);\n        // Validate if a root entity already exits and throw an exception\n        if (!isUniqueRoot) throw new NestedSetMultipleRootError();\n        OrmUtils.mergeDeep(subject.insertedValueSet, subject.metadata.nestedSetLeftColumn.createValueMap(1), subject.metadata.nestedSetRightColumn.createValueMap(2));\n      }\n    })();\n  }\n  /**\n   * Executes operations when subject is being updated.\n   */\n  update(subject) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      let parent = subject.metadata.treeParentRelation.getEntityValue(subject.entity); // if entity was attached via parent\n      if (!parent && subject.parentSubject && subject.parentSubject.entity)\n        // if entity was attached via children\n        parent = subject.parentSubject.entity;\n      let entity = subject.databaseEntity; // if entity was attached via parent\n      if (!entity && parent)\n        // if entity was attached via children\n        entity = subject.metadata.treeChildrenRelation.getEntityValue(parent).find(child => {\n          return Object.entries(subject.identifier).every(([key, value]) => child[key] === value);\n        });\n      // Exit if the parent or the entity where never set\n      if (entity === undefined || parent === undefined) {\n        return;\n      }\n      const oldParent = subject.metadata.treeParentRelation.getEntityValue(entity);\n      const oldParentId = subject.metadata.getEntityIdMap(oldParent);\n      const parentId = subject.metadata.getEntityIdMap(parent);\n      // Exit if the new and old parents are the same\n      if (OrmUtils.compareIds(oldParentId, parentId)) {\n        return;\n      }\n      if (parent) {\n        const escape = alias => _this2.queryRunner.connection.driver.escape(alias);\n        const tableName = _this2.getTableName(subject.metadata.tablePath);\n        const leftColumnName = escape(subject.metadata.nestedSetLeftColumn.databaseName);\n        const rightColumnName = escape(subject.metadata.nestedSetRightColumn.databaseName);\n        const entityId = subject.metadata.getEntityIdMap(entity);\n        let entityNs = undefined;\n        if (entityId) {\n          entityNs = (yield _this2.getNestedSetIds(subject.metadata, entityId))[0];\n        }\n        let parentNs = undefined;\n        if (parentId) {\n          parentNs = (yield _this2.getNestedSetIds(subject.metadata, parentId))[0];\n        }\n        if (entityNs !== undefined && parentNs !== undefined) {\n          const isMovingUp = parentNs.left > entityNs.left;\n          const treeSize = entityNs.right - entityNs.left + 1;\n          let entitySize;\n          if (isMovingUp) {\n            entitySize = parentNs.left - entityNs.right;\n          } else {\n            entitySize = parentNs.right - entityNs.left;\n          }\n          // Moved entity logic\n          const updateLeftSide = `WHEN ${leftColumnName} >= ${entityNs.left} AND ` + `${leftColumnName} < ${entityNs.right} ` + `THEN ${leftColumnName} + ${entitySize} `;\n          const updateRightSide = `WHEN ${rightColumnName} > ${entityNs.left} AND ` + `${rightColumnName} <= ${entityNs.right} ` + `THEN ${rightColumnName} + ${entitySize} `;\n          // Update the surrounding entities\n          if (isMovingUp) {\n            yield _this2.queryRunner.query(`UPDATE ${tableName} ` + `SET ${leftColumnName} = CASE ` + `WHEN ${leftColumnName} > ${entityNs.right} AND ` + `${leftColumnName} <= ${parentNs.left} ` + `THEN ${leftColumnName} - ${treeSize} ` + updateLeftSide + `ELSE ${leftColumnName} ` + `END, ` + `${rightColumnName} = CASE ` + `WHEN ${rightColumnName} > ${entityNs.right} AND ` + `${rightColumnName} < ${parentNs.left} ` + `THEN ${rightColumnName} - ${treeSize} ` + updateRightSide + `ELSE ${rightColumnName} ` + `END`);\n          } else {\n            yield _this2.queryRunner.query(`UPDATE ${tableName} ` + `SET ${leftColumnName} = CASE ` + `WHEN ${leftColumnName} < ${entityNs.left} AND ` + `${leftColumnName} > ${parentNs.right} ` + `THEN ${leftColumnName} + ${treeSize} ` + updateLeftSide + `ELSE ${leftColumnName} ` + `END, ` + `${rightColumnName} = CASE ` + `WHEN ${rightColumnName} < ${entityNs.left} AND ` + `${rightColumnName} >= ${parentNs.right} ` + `THEN ${rightColumnName} + ${treeSize} ` + updateRightSide + `ELSE ${rightColumnName} ` + `END`);\n          }\n        }\n      } else {\n        const isUniqueRoot = yield _this2.isUniqueRootEntity(subject, parent);\n        // Validate if a root entity already exits and throw an exception\n        if (!isUniqueRoot) throw new NestedSetMultipleRootError();\n      }\n    })();\n  }\n  /**\n   * Executes operations when subject is being removed.\n   */\n  remove(subjects) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (!Array.isArray(subjects)) subjects = [subjects];\n      const metadata = subjects[0].metadata;\n      const escape = alias => _this3.queryRunner.connection.driver.escape(alias);\n      const tableName = _this3.getTableName(metadata.tablePath);\n      const leftColumnName = escape(metadata.nestedSetLeftColumn.databaseName);\n      const rightColumnName = escape(metadata.nestedSetRightColumn.databaseName);\n      let entitiesIds = [];\n      for (const subject of subjects) {\n        const entityId = metadata.getEntityIdMap(subject.entity);\n        if (entityId) {\n          entitiesIds.push(entityId);\n        }\n      }\n      let entitiesNs = yield _this3.getNestedSetIds(metadata, entitiesIds);\n      for (const entity of entitiesNs) {\n        const treeSize = entity.right - entity.left + 1;\n        yield _this3.queryRunner.query(`UPDATE ${tableName} ` + `SET ${leftColumnName} = CASE ` + `WHEN ${leftColumnName} > ${entity.left} THEN ${leftColumnName} - ${treeSize} ` + `ELSE ${leftColumnName} ` + `END, ` + `${rightColumnName} = CASE ` + `WHEN ${rightColumnName} > ${entity.right} THEN ${rightColumnName} - ${treeSize} ` + `ELSE ${rightColumnName} ` + `END`);\n      }\n    })();\n  }\n  /**\n   * Get the nested set ids for a given entity\n   */\n  getNestedSetIds(metadata, ids) {\n    const select = {\n      left: `${metadata.targetName}.${metadata.nestedSetLeftColumn.propertyPath}`,\n      right: `${metadata.targetName}.${metadata.nestedSetRightColumn.propertyPath}`\n    };\n    const queryBuilder = this.queryRunner.manager.createQueryBuilder();\n    Object.entries(select).forEach(([key, value]) => {\n      queryBuilder.addSelect(value, key);\n    });\n    return queryBuilder.from(metadata.target, metadata.targetName).whereInIds(ids).orderBy(select.right, \"DESC\").getRawMany().then(results => {\n      const data = [];\n      for (const result of results) {\n        const entry = {};\n        for (const key of Object.keys(select)) {\n          const value = result ? result[key] : undefined;\n          // CockroachDB returns numeric types as string\n          entry[key] = typeof value === \"string\" ? parseInt(value) : value;\n        }\n        data.push(entry);\n      }\n      return data;\n    });\n  }\n  isUniqueRootEntity(subject, parent) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const escape = alias => _this4.queryRunner.connection.driver.escape(alias);\n      const tableName = _this4.getTableName(subject.metadata.tablePath);\n      const parameters = [];\n      const whereCondition = subject.metadata.treeParentRelation.joinColumns.map(column => {\n        const columnName = escape(column.databaseName);\n        const parameter = column.getEntityValue(parent);\n        if (parameter == null) {\n          return `${columnName} IS NULL`;\n        }\n        parameters.push(parameter);\n        const parameterName = _this4.queryRunner.connection.driver.createParameter(\"entity_\" + column.databaseName, parameters.length - 1);\n        return `${columnName} = ${parameterName}`;\n      }).join(\" AND \");\n      const countAlias = \"count\";\n      const result = yield _this4.queryRunner.query(`SELECT COUNT(1) AS ${escape(countAlias)} FROM ${tableName} WHERE ${whereCondition}`, parameters, true);\n      return parseInt(result.records[0][countAlias]) === 0;\n    })();\n  }\n  /**\n   * Gets escaped table name with schema name if SqlServer or Postgres driver used with custom\n   * schema name, otherwise returns escaped table name.\n   */\n  getTableName(tablePath) {\n    return tablePath.split(\".\").map(i => {\n      // this condition need because in SQL Server driver when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string\n      return i === \"\" ? i : this.queryRunner.connection.driver.escape(i);\n    }).join(\".\");\n  }\n}","map":{"version":3,"names":["OrmUtils","NestedSetMultipleRootError","NestedSetIds","NestedSetSubjectExecutor","constructor","queryRunner","insert","subject","_this","_asyncToGenerator","escape","alias","connection","driver","tableName","getTableName","metadata","tablePath","leftColumnName","nestedSetLeftColumn","databaseName","rightColumnName","nestedSetRightColumn","parent","treeParentRelation","getEntityValue","entity","parentSubject","insertedValueSet","parentId","getEntityIdMap","parentNsRight","undefined","manager","createQueryBuilder","select","targetName","propertyPath","from","target","whereInIds","getRawOne","then","result","value","parseInt","query","mergeDeep","createValueMap","isUniqueRoot","isUniqueRootEntity","update","_this2","databaseEntity","treeChildrenRelation","find","child","Object","entries","identifier","every","key","oldParent","oldParentId","compareIds","entityId","entityNs","getNestedSetIds","parentNs","isMovingUp","left","treeSize","right","entitySize","updateLeftSide","updateRightSide","remove","subjects","_this3","Array","isArray","entitiesIds","push","entitiesNs","ids","queryBuilder","forEach","addSelect","orderBy","getRawMany","results","data","entry","keys","_this4","parameters","whereCondition","joinColumns","map","column","columnName","parameter","parameterName","createParameter","length","join","countAlias","records","split","i"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/persistence/tree/NestedSetSubjectExecutor.js"],"sourcesContent":["import { OrmUtils } from \"../../util/OrmUtils\";\nimport { NestedSetMultipleRootError } from \"../../error/NestedSetMultipleRootError\";\nclass NestedSetIds {\n}\n/**\n * Executes subject operations for nested set tree entities.\n */\nexport class NestedSetSubjectExecutor {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n    constructor(queryRunner) {\n        this.queryRunner = queryRunner;\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Executes operations when subject is being inserted.\n     */\n    async insert(subject) {\n        const escape = (alias) => this.queryRunner.connection.driver.escape(alias);\n        const tableName = this.getTableName(subject.metadata.tablePath);\n        const leftColumnName = escape(subject.metadata.nestedSetLeftColumn.databaseName);\n        const rightColumnName = escape(subject.metadata.nestedSetRightColumn.databaseName);\n        let parent = subject.metadata.treeParentRelation.getEntityValue(subject.entity); // if entity was attached via parent\n        if (!parent && subject.parentSubject && subject.parentSubject.entity)\n            // if entity was attached via children\n            parent = subject.parentSubject.insertedValueSet\n                ? subject.parentSubject.insertedValueSet\n                : subject.parentSubject.entity;\n        const parentId = subject.metadata.getEntityIdMap(parent);\n        let parentNsRight = undefined;\n        if (parentId) {\n            parentNsRight = await this.queryRunner.manager\n                .createQueryBuilder()\n                .select(subject.metadata.targetName +\n                \".\" +\n                subject.metadata.nestedSetRightColumn.propertyPath, \"right\")\n                .from(subject.metadata.target, subject.metadata.targetName)\n                .whereInIds(parentId)\n                .getRawOne()\n                .then((result) => {\n                const value = result ? result[\"right\"] : undefined;\n                // CockroachDB returns numeric types as string\n                return typeof value === \"string\" ? parseInt(value) : value;\n            });\n        }\n        if (parentNsRight !== undefined) {\n            await this.queryRunner.query(`UPDATE ${tableName} SET ` +\n                `${leftColumnName} = CASE WHEN ${leftColumnName} > ${parentNsRight} THEN ${leftColumnName} + 2 ELSE ${leftColumnName} END,` +\n                `${rightColumnName} = ${rightColumnName} + 2 ` +\n                `WHERE ${rightColumnName} >= ${parentNsRight}`);\n            OrmUtils.mergeDeep(subject.insertedValueSet, subject.metadata.nestedSetLeftColumn.createValueMap(parentNsRight), subject.metadata.nestedSetRightColumn.createValueMap(parentNsRight + 1));\n        }\n        else {\n            const isUniqueRoot = await this.isUniqueRootEntity(subject, parent);\n            // Validate if a root entity already exits and throw an exception\n            if (!isUniqueRoot)\n                throw new NestedSetMultipleRootError();\n            OrmUtils.mergeDeep(subject.insertedValueSet, subject.metadata.nestedSetLeftColumn.createValueMap(1), subject.metadata.nestedSetRightColumn.createValueMap(2));\n        }\n    }\n    /**\n     * Executes operations when subject is being updated.\n     */\n    async update(subject) {\n        let parent = subject.metadata.treeParentRelation.getEntityValue(subject.entity); // if entity was attached via parent\n        if (!parent && subject.parentSubject && subject.parentSubject.entity)\n            // if entity was attached via children\n            parent = subject.parentSubject.entity;\n        let entity = subject.databaseEntity; // if entity was attached via parent\n        if (!entity && parent)\n            // if entity was attached via children\n            entity = subject.metadata\n                .treeChildrenRelation.getEntityValue(parent)\n                .find((child) => {\n                return Object.entries(subject.identifier).every(([key, value]) => child[key] === value);\n            });\n        // Exit if the parent or the entity where never set\n        if (entity === undefined || parent === undefined) {\n            return;\n        }\n        const oldParent = subject.metadata.treeParentRelation.getEntityValue(entity);\n        const oldParentId = subject.metadata.getEntityIdMap(oldParent);\n        const parentId = subject.metadata.getEntityIdMap(parent);\n        // Exit if the new and old parents are the same\n        if (OrmUtils.compareIds(oldParentId, parentId)) {\n            return;\n        }\n        if (parent) {\n            const escape = (alias) => this.queryRunner.connection.driver.escape(alias);\n            const tableName = this.getTableName(subject.metadata.tablePath);\n            const leftColumnName = escape(subject.metadata.nestedSetLeftColumn.databaseName);\n            const rightColumnName = escape(subject.metadata.nestedSetRightColumn.databaseName);\n            const entityId = subject.metadata.getEntityIdMap(entity);\n            let entityNs = undefined;\n            if (entityId) {\n                entityNs = (await this.getNestedSetIds(subject.metadata, entityId))[0];\n            }\n            let parentNs = undefined;\n            if (parentId) {\n                parentNs = (await this.getNestedSetIds(subject.metadata, parentId))[0];\n            }\n            if (entityNs !== undefined && parentNs !== undefined) {\n                const isMovingUp = parentNs.left > entityNs.left;\n                const treeSize = entityNs.right - entityNs.left + 1;\n                let entitySize;\n                if (isMovingUp) {\n                    entitySize = parentNs.left - entityNs.right;\n                }\n                else {\n                    entitySize = parentNs.right - entityNs.left;\n                }\n                // Moved entity logic\n                const updateLeftSide = `WHEN ${leftColumnName} >= ${entityNs.left} AND ` +\n                    `${leftColumnName} < ${entityNs.right} ` +\n                    `THEN ${leftColumnName} + ${entitySize} `;\n                const updateRightSide = `WHEN ${rightColumnName} > ${entityNs.left} AND ` +\n                    `${rightColumnName} <= ${entityNs.right} ` +\n                    `THEN ${rightColumnName} + ${entitySize} `;\n                // Update the surrounding entities\n                if (isMovingUp) {\n                    await this.queryRunner.query(`UPDATE ${tableName} ` +\n                        `SET ${leftColumnName} = CASE ` +\n                        `WHEN ${leftColumnName} > ${entityNs.right} AND ` +\n                        `${leftColumnName} <= ${parentNs.left} ` +\n                        `THEN ${leftColumnName} - ${treeSize} ` +\n                        updateLeftSide +\n                        `ELSE ${leftColumnName} ` +\n                        `END, ` +\n                        `${rightColumnName} = CASE ` +\n                        `WHEN ${rightColumnName} > ${entityNs.right} AND ` +\n                        `${rightColumnName} < ${parentNs.left} ` +\n                        `THEN ${rightColumnName} - ${treeSize} ` +\n                        updateRightSide +\n                        `ELSE ${rightColumnName} ` +\n                        `END`);\n                }\n                else {\n                    await this.queryRunner.query(`UPDATE ${tableName} ` +\n                        `SET ${leftColumnName} = CASE ` +\n                        `WHEN ${leftColumnName} < ${entityNs.left} AND ` +\n                        `${leftColumnName} > ${parentNs.right} ` +\n                        `THEN ${leftColumnName} + ${treeSize} ` +\n                        updateLeftSide +\n                        `ELSE ${leftColumnName} ` +\n                        `END, ` +\n                        `${rightColumnName} = CASE ` +\n                        `WHEN ${rightColumnName} < ${entityNs.left} AND ` +\n                        `${rightColumnName} >= ${parentNs.right} ` +\n                        `THEN ${rightColumnName} + ${treeSize} ` +\n                        updateRightSide +\n                        `ELSE ${rightColumnName} ` +\n                        `END`);\n                }\n            }\n        }\n        else {\n            const isUniqueRoot = await this.isUniqueRootEntity(subject, parent);\n            // Validate if a root entity already exits and throw an exception\n            if (!isUniqueRoot)\n                throw new NestedSetMultipleRootError();\n        }\n    }\n    /**\n     * Executes operations when subject is being removed.\n     */\n    async remove(subjects) {\n        if (!Array.isArray(subjects))\n            subjects = [subjects];\n        const metadata = subjects[0].metadata;\n        const escape = (alias) => this.queryRunner.connection.driver.escape(alias);\n        const tableName = this.getTableName(metadata.tablePath);\n        const leftColumnName = escape(metadata.nestedSetLeftColumn.databaseName);\n        const rightColumnName = escape(metadata.nestedSetRightColumn.databaseName);\n        let entitiesIds = [];\n        for (const subject of subjects) {\n            const entityId = metadata.getEntityIdMap(subject.entity);\n            if (entityId) {\n                entitiesIds.push(entityId);\n            }\n        }\n        let entitiesNs = await this.getNestedSetIds(metadata, entitiesIds);\n        for (const entity of entitiesNs) {\n            const treeSize = entity.right - entity.left + 1;\n            await this.queryRunner.query(`UPDATE ${tableName} ` +\n                `SET ${leftColumnName} = CASE ` +\n                `WHEN ${leftColumnName} > ${entity.left} THEN ${leftColumnName} - ${treeSize} ` +\n                `ELSE ${leftColumnName} ` +\n                `END, ` +\n                `${rightColumnName} = CASE ` +\n                `WHEN ${rightColumnName} > ${entity.right} THEN ${rightColumnName} - ${treeSize} ` +\n                `ELSE ${rightColumnName} ` +\n                `END`);\n        }\n    }\n    /**\n     * Get the nested set ids for a given entity\n     */\n    getNestedSetIds(metadata, ids) {\n        const select = {\n            left: `${metadata.targetName}.${metadata.nestedSetLeftColumn.propertyPath}`,\n            right: `${metadata.targetName}.${metadata.nestedSetRightColumn.propertyPath}`,\n        };\n        const queryBuilder = this.queryRunner.manager.createQueryBuilder();\n        Object.entries(select).forEach(([key, value]) => {\n            queryBuilder.addSelect(value, key);\n        });\n        return queryBuilder\n            .from(metadata.target, metadata.targetName)\n            .whereInIds(ids)\n            .orderBy(select.right, \"DESC\")\n            .getRawMany()\n            .then((results) => {\n            const data = [];\n            for (const result of results) {\n                const entry = {};\n                for (const key of Object.keys(select)) {\n                    const value = result ? result[key] : undefined;\n                    // CockroachDB returns numeric types as string\n                    entry[key] =\n                        typeof value === \"string\" ? parseInt(value) : value;\n                }\n                data.push(entry);\n            }\n            return data;\n        });\n    }\n    async isUniqueRootEntity(subject, parent) {\n        const escape = (alias) => this.queryRunner.connection.driver.escape(alias);\n        const tableName = this.getTableName(subject.metadata.tablePath);\n        const parameters = [];\n        const whereCondition = subject.metadata\n            .treeParentRelation.joinColumns.map((column) => {\n            const columnName = escape(column.databaseName);\n            const parameter = column.getEntityValue(parent);\n            if (parameter == null) {\n                return `${columnName} IS NULL`;\n            }\n            parameters.push(parameter);\n            const parameterName = this.queryRunner.connection.driver.createParameter(\"entity_\" + column.databaseName, parameters.length - 1);\n            return `${columnName} = ${parameterName}`;\n        })\n            .join(\" AND \");\n        const countAlias = \"count\";\n        const result = await this.queryRunner.query(`SELECT COUNT(1) AS ${escape(countAlias)} FROM ${tableName} WHERE ${whereCondition}`, parameters, true);\n        return parseInt(result.records[0][countAlias]) === 0;\n    }\n    /**\n     * Gets escaped table name with schema name if SqlServer or Postgres driver used with custom\n     * schema name, otherwise returns escaped table name.\n     */\n    getTableName(tablePath) {\n        return tablePath\n            .split(\".\")\n            .map((i) => {\n            // this condition need because in SQL Server driver when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string\n            return i === \"\"\n                ? i\n                : this.queryRunner.connection.driver.escape(i);\n        })\n            .join(\".\");\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}