{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/practicas/Downloads/angular/tresOnline/frontend-tres-en-raya/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { TypeORMError } from \"../../error\";\nimport { QueryFailedError } from \"../../error/QueryFailedError\";\nimport { QueryRunnerAlreadyReleasedError } from \"../../error/QueryRunnerAlreadyReleasedError\";\nimport { TransactionNotStartedError } from \"../../error/TransactionNotStartedError\";\nimport { BaseQueryRunner } from \"../../query-runner/BaseQueryRunner\";\nimport { QueryResult } from \"../../query-runner/QueryResult\";\nimport { Table } from \"../../schema-builder/table/Table\";\nimport { TableCheck } from \"../../schema-builder/table/TableCheck\";\nimport { TableColumn } from \"../../schema-builder/table/TableColumn\";\nimport { TableExclusion } from \"../../schema-builder/table/TableExclusion\";\nimport { TableForeignKey } from \"../../schema-builder/table/TableForeignKey\";\nimport { TableIndex } from \"../../schema-builder/table/TableIndex\";\nimport { TableUnique } from \"../../schema-builder/table/TableUnique\";\nimport { View } from \"../../schema-builder/view/View\";\nimport { Broadcaster } from \"../../subscriber/Broadcaster\";\nimport { InstanceChecker } from \"../../util/InstanceChecker\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\nimport { VersionUtils } from \"../../util/VersionUtils\";\nimport { Query } from \"../Query\";\nimport { MetadataTableType } from \"../types/MetadataTableType\";\n/**\n * Runs queries on a single postgres database connection.\n */\nexport class PostgresQueryRunner extends BaseQueryRunner {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(driver, mode) {\n    super();\n    this.driver = driver;\n    this.connection = driver.connection;\n    this.mode = mode;\n    this.broadcaster = new Broadcaster(this);\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Creates/uses database connection from the connection pool to perform further operations.\n   * Returns obtained database connection.\n   */\n  connect() {\n    if (this.databaseConnection) return Promise.resolve(this.databaseConnection);\n    if (this.databaseConnectionPromise) return this.databaseConnectionPromise;\n    if (this.mode === \"slave\" && this.driver.isReplicated) {\n      this.databaseConnectionPromise = this.driver.obtainSlaveConnection().then(([connection, release]) => {\n        this.driver.connectedQueryRunners.push(this);\n        this.databaseConnection = connection;\n        const onErrorCallback = err => this.releasePostgresConnection(err);\n        this.releaseCallback = err => {\n          this.databaseConnection.removeListener(\"error\", onErrorCallback);\n          release(err);\n        };\n        this.databaseConnection.on(\"error\", onErrorCallback);\n        return this.databaseConnection;\n      });\n    } else {\n      // master\n      this.databaseConnectionPromise = this.driver.obtainMasterConnection().then(([connection, release]) => {\n        this.driver.connectedQueryRunners.push(this);\n        this.databaseConnection = connection;\n        const onErrorCallback = err => this.releasePostgresConnection(err);\n        this.releaseCallback = err => {\n          this.databaseConnection.removeListener(\"error\", onErrorCallback);\n          release(err);\n        };\n        this.databaseConnection.on(\"error\", onErrorCallback);\n        return this.databaseConnection;\n      });\n    }\n    return this.databaseConnectionPromise;\n  }\n  /**\n   * Release a connection back to the pool, optionally specifying an Error to release with.\n   * Per pg-pool documentation this will prevent the pool from re-using the broken connection.\n   */\n  releasePostgresConnection(err) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (_this.isReleased) {\n        return;\n      }\n      _this.isReleased = true;\n      if (_this.releaseCallback) {\n        _this.releaseCallback(err);\n        _this.releaseCallback = undefined;\n      }\n      const index = _this.driver.connectedQueryRunners.indexOf(_this);\n      if (index !== -1) {\n        _this.driver.connectedQueryRunners.splice(index, 1);\n      }\n    })();\n  }\n  /**\n   * Releases used database connection.\n   * You cannot use query runner methods once its released.\n   */\n  release() {\n    return this.releasePostgresConnection();\n  }\n  /**\n   * Starts transaction.\n   */\n  startTransaction(isolationLevel) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      _this2.isTransactionActive = true;\n      try {\n        yield _this2.broadcaster.broadcast(\"BeforeTransactionStart\");\n      } catch (err) {\n        _this2.isTransactionActive = false;\n        throw err;\n      }\n      if (_this2.transactionDepth === 0) {\n        yield _this2.query(\"START TRANSACTION\");\n        if (isolationLevel) {\n          yield _this2.query(\"SET TRANSACTION ISOLATION LEVEL \" + isolationLevel);\n        }\n      } else {\n        yield _this2.query(`SAVEPOINT typeorm_${_this2.transactionDepth}`);\n      }\n      _this2.transactionDepth += 1;\n      yield _this2.broadcaster.broadcast(\"AfterTransactionStart\");\n    })();\n  }\n  /**\n   * Commits transaction.\n   * Error will be thrown if transaction was not started.\n   */\n  commitTransaction() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this3.isTransactionActive) throw new TransactionNotStartedError();\n      yield _this3.broadcaster.broadcast(\"BeforeTransactionCommit\");\n      if (_this3.transactionDepth > 1) {\n        yield _this3.query(`RELEASE SAVEPOINT typeorm_${_this3.transactionDepth - 1}`);\n      } else {\n        yield _this3.query(\"COMMIT\");\n        _this3.isTransactionActive = false;\n      }\n      _this3.transactionDepth -= 1;\n      yield _this3.broadcaster.broadcast(\"AfterTransactionCommit\");\n    })();\n  }\n  /**\n   * Rollbacks transaction.\n   * Error will be thrown if transaction was not started.\n   */\n  rollbackTransaction() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this4.isTransactionActive) throw new TransactionNotStartedError();\n      yield _this4.broadcaster.broadcast(\"BeforeTransactionRollback\");\n      if (_this4.transactionDepth > 1) {\n        yield _this4.query(`ROLLBACK TO SAVEPOINT typeorm_${_this4.transactionDepth - 1}`);\n      } else {\n        yield _this4.query(\"ROLLBACK\");\n        _this4.isTransactionActive = false;\n      }\n      _this4.transactionDepth -= 1;\n      yield _this4.broadcaster.broadcast(\"AfterTransactionRollback\");\n    })();\n  }\n  /**\n   * Executes a given SQL query.\n   */\n  query(query, parameters, useStructuredResult = false) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      if (_this5.isReleased) throw new QueryRunnerAlreadyReleasedError();\n      const databaseConnection = yield _this5.connect();\n      _this5.driver.connection.logger.logQuery(query, parameters, _this5);\n      try {\n        const queryStartTime = +new Date();\n        const raw = yield databaseConnection.query(query, parameters);\n        // log slow queries if maxQueryExecution time is set\n        const maxQueryExecutionTime = _this5.driver.options.maxQueryExecutionTime;\n        const queryEndTime = +new Date();\n        const queryExecutionTime = queryEndTime - queryStartTime;\n        if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) _this5.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, _this5);\n        const result = new QueryResult();\n        if (raw) {\n          if (raw.hasOwnProperty(\"rows\")) {\n            result.records = raw.rows;\n          }\n          if (raw.hasOwnProperty(\"rowCount\")) {\n            result.affected = raw.rowCount;\n          }\n          switch (raw.command) {\n            case \"DELETE\":\n            case \"UPDATE\":\n              // for UPDATE and DELETE query additionally return number of affected rows\n              result.raw = [raw.rows, raw.rowCount];\n              break;\n            default:\n              result.raw = raw.rows;\n          }\n          if (!useStructuredResult) {\n            return result.raw;\n          }\n        }\n        return result;\n      } catch (err) {\n        _this5.driver.connection.logger.logQueryError(err, query, parameters, _this5);\n        throw new QueryFailedError(query, parameters, err);\n      }\n    })();\n  }\n  /**\n   * Returns raw data stream.\n   */\n  stream(query, parameters, onEnd, onError) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const QueryStream = _this6.driver.loadStreamDependency();\n      if (_this6.isReleased) throw new QueryRunnerAlreadyReleasedError();\n      const databaseConnection = yield _this6.connect();\n      _this6.driver.connection.logger.logQuery(query, parameters, _this6);\n      const stream = databaseConnection.query(new QueryStream(query, parameters));\n      if (onEnd) stream.on(\"end\", onEnd);\n      if (onError) stream.on(\"error\", onError);\n      return stream;\n    })();\n  }\n  /**\n   * Returns all available database names including system databases.\n   */\n  getDatabases() {\n    return _asyncToGenerator(function* () {\n      return Promise.resolve([]);\n    })();\n  }\n  /**\n   * Returns all available schema names including system schemas.\n   * If database parameter specified, returns schemas of that database.\n   */\n  getSchemas(database) {\n    return _asyncToGenerator(function* () {\n      return Promise.resolve([]);\n    })();\n  }\n  /**\n   * Checks if database with the given name exist.\n   */\n  hasDatabase(database) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const result = yield _this7.query(`SELECT * FROM pg_database WHERE datname='${database}';`);\n      return result.length ? true : false;\n    })();\n  }\n  /**\n   * Loads currently using database\n   */\n  getCurrentDatabase() {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const query = yield _this8.query(`SELECT * FROM current_database()`);\n      return query[0][\"current_database\"];\n    })();\n  }\n  /**\n   * Checks if schema with the given name exist.\n   */\n  hasSchema(schema) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      const result = yield _this9.query(`SELECT * FROM \"information_schema\".\"schemata\" WHERE \"schema_name\" = '${schema}'`);\n      return result.length ? true : false;\n    })();\n  }\n  /**\n   * Loads currently using database schema\n   */\n  getCurrentSchema() {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      const query = yield _this10.query(`SELECT * FROM current_schema()`);\n      return query[0][\"current_schema\"];\n    })();\n  }\n  /**\n   * Checks if table with the given name exist in the database.\n   */\n  hasTable(tableOrName) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      const parsedTableName = _this11.driver.parseTableName(tableOrName);\n      if (!parsedTableName.schema) {\n        parsedTableName.schema = yield _this11.getCurrentSchema();\n      }\n      const sql = `SELECT * FROM \"information_schema\".\"tables\" WHERE \"table_schema\" = '${parsedTableName.schema}' AND \"table_name\" = '${parsedTableName.tableName}'`;\n      const result = yield _this11.query(sql);\n      return result.length ? true : false;\n    })();\n  }\n  /**\n   * Checks if column with the given name exist in the given table.\n   */\n  hasColumn(tableOrName, columnName) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      const parsedTableName = _this12.driver.parseTableName(tableOrName);\n      if (!parsedTableName.schema) {\n        parsedTableName.schema = yield _this12.getCurrentSchema();\n      }\n      const sql = `SELECT * FROM \"information_schema\".\"columns\" WHERE \"table_schema\" = '${parsedTableName.schema}' AND \"table_name\" = '${parsedTableName.tableName}' AND \"column_name\" = '${columnName}'`;\n      const result = yield _this12.query(sql);\n      return result.length ? true : false;\n    })();\n  }\n  /**\n   * Creates a new database.\n   * Note: Postgres does not support database creation inside a transaction block.\n   */\n  createDatabase(database, ifNotExist) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      if (ifNotExist) {\n        const databaseAlreadyExists = yield _this13.hasDatabase(database);\n        if (databaseAlreadyExists) return Promise.resolve();\n      }\n      const up = `CREATE DATABASE \"${database}\"`;\n      const down = `DROP DATABASE \"${database}\"`;\n      yield _this13.executeQueries(new Query(up), new Query(down));\n    })();\n  }\n  /**\n   * Drops database.\n   * Note: Postgres does not support database dropping inside a transaction block.\n   */\n  dropDatabase(database, ifExist) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      const up = ifExist ? `DROP DATABASE IF EXISTS \"${database}\"` : `DROP DATABASE \"${database}\"`;\n      const down = `CREATE DATABASE \"${database}\"`;\n      yield _this14.executeQueries(new Query(up), new Query(down));\n    })();\n  }\n  /**\n   * Creates a new table schema.\n   */\n  createSchema(schemaPath, ifNotExist) {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      const schema = schemaPath.indexOf(\".\") === -1 ? schemaPath : schemaPath.split(\".\")[1];\n      const up = ifNotExist ? `CREATE SCHEMA IF NOT EXISTS \"${schema}\"` : `CREATE SCHEMA \"${schema}\"`;\n      const down = `DROP SCHEMA \"${schema}\" CASCADE`;\n      yield _this15.executeQueries(new Query(up), new Query(down));\n    })();\n  }\n  /**\n   * Drops table schema.\n   */\n  dropSchema(schemaPath, ifExist, isCascade) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      const schema = schemaPath.indexOf(\".\") === -1 ? schemaPath : schemaPath.split(\".\")[1];\n      const up = ifExist ? `DROP SCHEMA IF EXISTS \"${schema}\" ${isCascade ? \"CASCADE\" : \"\"}` : `DROP SCHEMA \"${schema}\" ${isCascade ? \"CASCADE\" : \"\"}`;\n      const down = `CREATE SCHEMA \"${schema}\"`;\n      yield _this16.executeQueries(new Query(up), new Query(down));\n    })();\n  }\n  /**\n   * Creates a new table.\n   */\n  createTable(table, ifNotExist = false, createForeignKeys = true, createIndices = true) {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      if (ifNotExist) {\n        const isTableExist = yield _this17.hasTable(table);\n        if (isTableExist) return Promise.resolve();\n      }\n      const upQueries = [];\n      const downQueries = [];\n      // if table have column with ENUM type, we must create this type in postgres.\n      const enumColumns = table.columns.filter(column => column.type === \"enum\" || column.type === \"simple-enum\");\n      const createdEnumTypes = [];\n      for (const column of enumColumns) {\n        // TODO: Should also check if values of existing type matches expected ones\n        const hasEnum = yield _this17.hasEnumType(table, column);\n        const enumName = _this17.buildEnumName(table, column);\n        // if enum with the same \"enumName\" is defined more then once, me must prevent double creation\n        if (!hasEnum && createdEnumTypes.indexOf(enumName) === -1) {\n          createdEnumTypes.push(enumName);\n          upQueries.push(_this17.createEnumTypeSql(table, column, enumName));\n          downQueries.push(_this17.dropEnumTypeSql(table, column, enumName));\n        }\n      }\n      // if table have column with generated type, we must add the expression to the metadata table\n      const generatedColumns = table.columns.filter(column => column.generatedType === \"STORED\" && column.asExpression);\n      for (const column of generatedColumns) {\n        const tableNameWithSchema = (yield _this17.getTableNameWithSchema(table.name)).split(\".\");\n        const tableName = tableNameWithSchema[1];\n        const schema = tableNameWithSchema[0];\n        const insertQuery = _this17.insertTypeormMetadataSql({\n          database: _this17.driver.database,\n          schema,\n          table: tableName,\n          type: MetadataTableType.GENERATED_COLUMN,\n          name: column.name,\n          value: column.asExpression\n        });\n        const deleteQuery = _this17.deleteTypeormMetadataSql({\n          database: _this17.driver.database,\n          schema,\n          table: tableName,\n          type: MetadataTableType.GENERATED_COLUMN,\n          name: column.name\n        });\n        upQueries.push(insertQuery);\n        downQueries.push(deleteQuery);\n      }\n      upQueries.push(_this17.createTableSql(table, createForeignKeys));\n      downQueries.push(_this17.dropTableSql(table));\n      // if createForeignKeys is true, we must drop created foreign keys in down query.\n      // createTable does not need separate method to create foreign keys, because it create fk's in the same query with table creation.\n      if (createForeignKeys) table.foreignKeys.forEach(foreignKey => downQueries.push(_this17.dropForeignKeySql(table, foreignKey)));\n      if (createIndices) {\n        table.indices.forEach(index => {\n          // new index may be passed without name. In this case we generate index name manually.\n          if (!index.name) index.name = _this17.connection.namingStrategy.indexName(table, index.columnNames, index.where);\n          upQueries.push(_this17.createIndexSql(table, index));\n          downQueries.push(_this17.dropIndexSql(table, index));\n        });\n      }\n      yield _this17.executeQueries(upQueries, downQueries);\n    })();\n  }\n  /**\n   * Drops the table.\n   */\n  dropTable(target, ifExist, dropForeignKeys = true, dropIndices = true) {\n    var _this18 = this;\n    return _asyncToGenerator(function* () {\n      // It needs because if table does not exist and dropForeignKeys or dropIndices is true, we don't need\n      // to perform drop queries for foreign keys and indices.\n      if (ifExist) {\n        const isTableExist = yield _this18.hasTable(target);\n        if (!isTableExist) return Promise.resolve();\n      }\n      // if dropTable called with dropForeignKeys = true, we must create foreign keys in down query.\n      const createForeignKeys = dropForeignKeys;\n      const tablePath = _this18.getTablePath(target);\n      const table = yield _this18.getCachedTable(tablePath);\n      const upQueries = [];\n      const downQueries = [];\n      if (dropIndices) {\n        table.indices.forEach(index => {\n          upQueries.push(_this18.dropIndexSql(table, index));\n          downQueries.push(_this18.createIndexSql(table, index));\n        });\n      }\n      if (dropForeignKeys) table.foreignKeys.forEach(foreignKey => upQueries.push(_this18.dropForeignKeySql(table, foreignKey)));\n      upQueries.push(_this18.dropTableSql(table));\n      downQueries.push(_this18.createTableSql(table, createForeignKeys));\n      // if table had columns with generated type, we must remove the expression from the metadata table\n      const generatedColumns = table.columns.filter(column => column.generatedType && column.asExpression);\n      for (const column of generatedColumns) {\n        const tableNameWithSchema = (yield _this18.getTableNameWithSchema(table.name)).split(\".\");\n        const tableName = tableNameWithSchema[1];\n        const schema = tableNameWithSchema[0];\n        const deleteQuery = _this18.deleteTypeormMetadataSql({\n          database: _this18.driver.database,\n          schema,\n          table: tableName,\n          type: MetadataTableType.GENERATED_COLUMN,\n          name: column.name\n        });\n        const insertQuery = _this18.insertTypeormMetadataSql({\n          database: _this18.driver.database,\n          schema,\n          table: tableName,\n          type: MetadataTableType.GENERATED_COLUMN,\n          name: column.name,\n          value: column.asExpression\n        });\n        upQueries.push(deleteQuery);\n        downQueries.push(insertQuery);\n      }\n      yield _this18.executeQueries(upQueries, downQueries);\n    })();\n  }\n  /**\n   * Creates a new view.\n   */\n  createView(view, syncWithMetadata = false) {\n    var _this19 = this;\n    return _asyncToGenerator(function* () {\n      const upQueries = [];\n      const downQueries = [];\n      upQueries.push(_this19.createViewSql(view));\n      if (syncWithMetadata) upQueries.push(yield _this19.insertViewDefinitionSql(view));\n      downQueries.push(_this19.dropViewSql(view));\n      if (syncWithMetadata) downQueries.push(yield _this19.deleteViewDefinitionSql(view));\n      yield _this19.executeQueries(upQueries, downQueries);\n    })();\n  }\n  /**\n   * Drops the view.\n   */\n  dropView(target) {\n    var _this20 = this;\n    return _asyncToGenerator(function* () {\n      const viewName = InstanceChecker.isView(target) ? target.name : target;\n      const view = yield _this20.getCachedView(viewName);\n      const upQueries = [];\n      const downQueries = [];\n      upQueries.push(yield _this20.deleteViewDefinitionSql(view));\n      upQueries.push(_this20.dropViewSql(view));\n      downQueries.push(yield _this20.insertViewDefinitionSql(view));\n      downQueries.push(_this20.createViewSql(view));\n      yield _this20.executeQueries(upQueries, downQueries);\n    })();\n  }\n  /**\n   * Renames the given table.\n   */\n  renameTable(oldTableOrName, newTableName) {\n    var _this21 = this;\n    return _asyncToGenerator(function* () {\n      const upQueries = [];\n      const downQueries = [];\n      const oldTable = InstanceChecker.isTable(oldTableOrName) ? oldTableOrName : yield _this21.getCachedTable(oldTableOrName);\n      const newTable = oldTable.clone();\n      const {\n        schema: schemaName,\n        tableName: oldTableName\n      } = _this21.driver.parseTableName(oldTable);\n      newTable.name = schemaName ? `${schemaName}.${newTableName}` : newTableName;\n      upQueries.push(new Query(`ALTER TABLE ${_this21.escapePath(oldTable)} RENAME TO \"${newTableName}\"`));\n      downQueries.push(new Query(`ALTER TABLE ${_this21.escapePath(newTable)} RENAME TO \"${oldTableName}\"`));\n      // rename column primary key constraint if it has default constraint name\n      if (newTable.primaryColumns.length > 0 && !newTable.primaryColumns[0].primaryKeyConstraintName) {\n        const columnNames = newTable.primaryColumns.map(column => column.name);\n        const oldPkName = _this21.connection.namingStrategy.primaryKeyName(oldTable, columnNames);\n        const newPkName = _this21.connection.namingStrategy.primaryKeyName(newTable, columnNames);\n        upQueries.push(new Query(`ALTER TABLE ${_this21.escapePath(newTable)} RENAME CONSTRAINT \"${oldPkName}\" TO \"${newPkName}\"`));\n        downQueries.push(new Query(`ALTER TABLE ${_this21.escapePath(newTable)} RENAME CONSTRAINT \"${newPkName}\" TO \"${oldPkName}\"`));\n      }\n      // rename sequences\n      newTable.columns.map(col => {\n        if (col.isGenerated && col.generationStrategy === \"increment\") {\n          const sequencePath = _this21.buildSequencePath(oldTable, col.name);\n          const sequenceName = _this21.buildSequenceName(oldTable, col.name);\n          const newSequencePath = _this21.buildSequencePath(newTable, col.name);\n          const newSequenceName = _this21.buildSequenceName(newTable, col.name);\n          const up = `ALTER SEQUENCE ${_this21.escapePath(sequencePath)} RENAME TO \"${newSequenceName}\"`;\n          const down = `ALTER SEQUENCE ${_this21.escapePath(newSequencePath)} RENAME TO \"${sequenceName}\"`;\n          upQueries.push(new Query(up));\n          downQueries.push(new Query(down));\n        }\n      });\n      // rename unique constraints\n      newTable.uniques.forEach(unique => {\n        const oldUniqueName = _this21.connection.namingStrategy.uniqueConstraintName(oldTable, unique.columnNames);\n        // Skip renaming if Unique has user defined constraint name\n        if (unique.name !== oldUniqueName) return;\n        // build new constraint name\n        const newUniqueName = _this21.connection.namingStrategy.uniqueConstraintName(newTable, unique.columnNames);\n        // build queries\n        upQueries.push(new Query(`ALTER TABLE ${_this21.escapePath(newTable)} RENAME CONSTRAINT \"${unique.name}\" TO \"${newUniqueName}\"`));\n        downQueries.push(new Query(`ALTER TABLE ${_this21.escapePath(newTable)} RENAME CONSTRAINT \"${newUniqueName}\" TO \"${unique.name}\"`));\n        // replace constraint name\n        unique.name = newUniqueName;\n      });\n      // rename index constraints\n      newTable.indices.forEach(index => {\n        const oldIndexName = _this21.connection.namingStrategy.indexName(oldTable, index.columnNames, index.where);\n        // Skip renaming if Index has user defined constraint name\n        if (index.name !== oldIndexName) return;\n        // build new constraint name\n        const {\n          schema\n        } = _this21.driver.parseTableName(newTable);\n        const newIndexName = _this21.connection.namingStrategy.indexName(newTable, index.columnNames, index.where);\n        // build queries\n        const up = schema ? `ALTER INDEX \"${schema}\".\"${index.name}\" RENAME TO \"${newIndexName}\"` : `ALTER INDEX \"${index.name}\" RENAME TO \"${newIndexName}\"`;\n        const down = schema ? `ALTER INDEX \"${schema}\".\"${newIndexName}\" RENAME TO \"${index.name}\"` : `ALTER INDEX \"${newIndexName}\" RENAME TO \"${index.name}\"`;\n        upQueries.push(new Query(up));\n        downQueries.push(new Query(down));\n        // replace constraint name\n        index.name = newIndexName;\n      });\n      // rename foreign key constraints\n      newTable.foreignKeys.forEach(foreignKey => {\n        const oldForeignKeyName = _this21.connection.namingStrategy.foreignKeyName(oldTable, foreignKey.columnNames, _this21.getTablePath(foreignKey), foreignKey.referencedColumnNames);\n        // Skip renaming if foreign key has user defined constraint name\n        if (foreignKey.name !== oldForeignKeyName) return;\n        // build new constraint name\n        const newForeignKeyName = _this21.connection.namingStrategy.foreignKeyName(newTable, foreignKey.columnNames, _this21.getTablePath(foreignKey), foreignKey.referencedColumnNames);\n        // build queries\n        upQueries.push(new Query(`ALTER TABLE ${_this21.escapePath(newTable)} RENAME CONSTRAINT \"${foreignKey.name}\" TO \"${newForeignKeyName}\"`));\n        downQueries.push(new Query(`ALTER TABLE ${_this21.escapePath(newTable)} RENAME CONSTRAINT \"${newForeignKeyName}\" TO \"${foreignKey.name}\"`));\n        // replace constraint name\n        foreignKey.name = newForeignKeyName;\n      });\n      // rename ENUM types\n      const enumColumns = newTable.columns.filter(column => column.type === \"enum\" || column.type === \"simple-enum\");\n      for (let column of enumColumns) {\n        // skip renaming for user-defined enum name\n        if (column.enumName) continue;\n        const oldEnumType = yield _this21.getUserDefinedTypeName(oldTable, column);\n        upQueries.push(new Query(`ALTER TYPE \"${oldEnumType.schema}\".\"${oldEnumType.name}\" RENAME TO ${_this21.buildEnumName(newTable, column, false)}`));\n        downQueries.push(new Query(`ALTER TYPE ${_this21.buildEnumName(newTable, column)} RENAME TO \"${oldEnumType.name}\"`));\n      }\n      yield _this21.executeQueries(upQueries, downQueries);\n    })();\n  }\n  /**\n   * Creates a new column from the column in the table.\n   */\n  addColumn(tableOrName, column) {\n    var _this22 = this;\n    return _asyncToGenerator(function* () {\n      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield _this22.getCachedTable(tableOrName);\n      const clonedTable = table.clone();\n      const upQueries = [];\n      const downQueries = [];\n      if (column.type === \"enum\" || column.type === \"simple-enum\") {\n        const hasEnum = yield _this22.hasEnumType(table, column);\n        if (!hasEnum) {\n          upQueries.push(_this22.createEnumTypeSql(table, column));\n          downQueries.push(_this22.dropEnumTypeSql(table, column));\n        }\n      }\n      upQueries.push(new Query(`ALTER TABLE ${_this22.escapePath(table)} ADD ${_this22.buildCreateColumnSql(table, column)}`));\n      downQueries.push(new Query(`ALTER TABLE ${_this22.escapePath(table)} DROP COLUMN \"${column.name}\"`));\n      // create or update primary key constraint\n      if (column.isPrimary) {\n        const primaryColumns = clonedTable.primaryColumns;\n        // if table already have primary key, me must drop it and recreate again\n        if (primaryColumns.length > 0) {\n          const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : _this22.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map(column => column.name));\n          const columnNames = primaryColumns.map(column => `\"${column.name}\"`).join(\", \");\n          upQueries.push(new Query(`ALTER TABLE ${_this22.escapePath(table)} DROP CONSTRAINT \"${pkName}\"`));\n          downQueries.push(new Query(`ALTER TABLE ${_this22.escapePath(table)} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`));\n        }\n        primaryColumns.push(column);\n        const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : _this22.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map(column => column.name));\n        const columnNames = primaryColumns.map(column => `\"${column.name}\"`).join(\", \");\n        upQueries.push(new Query(`ALTER TABLE ${_this22.escapePath(table)} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`));\n        downQueries.push(new Query(`ALTER TABLE ${_this22.escapePath(table)} DROP CONSTRAINT \"${pkName}\"`));\n      }\n      // create column index\n      const columnIndex = clonedTable.indices.find(index => index.columnNames.length === 1 && index.columnNames[0] === column.name);\n      if (columnIndex) {\n        upQueries.push(_this22.createIndexSql(table, columnIndex));\n        downQueries.push(_this22.dropIndexSql(table, columnIndex));\n      }\n      // create unique constraint\n      if (column.isUnique) {\n        const uniqueConstraint = new TableUnique({\n          name: _this22.connection.namingStrategy.uniqueConstraintName(table, [column.name]),\n          columnNames: [column.name]\n        });\n        clonedTable.uniques.push(uniqueConstraint);\n        upQueries.push(new Query(`ALTER TABLE ${_this22.escapePath(table)} ADD CONSTRAINT \"${uniqueConstraint.name}\" UNIQUE (\"${column.name}\")`));\n        downQueries.push(new Query(`ALTER TABLE ${_this22.escapePath(table)} DROP CONSTRAINT \"${uniqueConstraint.name}\"`));\n      }\n      if (column.generatedType === \"STORED\" && column.asExpression) {\n        const tableNameWithSchema = (yield _this22.getTableNameWithSchema(table.name)).split(\".\");\n        const tableName = tableNameWithSchema[1];\n        const schema = tableNameWithSchema[0];\n        const insertQuery = _this22.insertTypeormMetadataSql({\n          database: _this22.driver.database,\n          schema,\n          table: tableName,\n          type: MetadataTableType.GENERATED_COLUMN,\n          name: column.name,\n          value: column.asExpression\n        });\n        const deleteQuery = _this22.deleteTypeormMetadataSql({\n          database: _this22.driver.database,\n          schema,\n          table: tableName,\n          type: MetadataTableType.GENERATED_COLUMN,\n          name: column.name\n        });\n        upQueries.push(insertQuery);\n        downQueries.push(deleteQuery);\n      }\n      // create column's comment\n      if (column.comment) {\n        upQueries.push(new Query(`COMMENT ON COLUMN ${_this22.escapePath(table)}.\"${column.name}\" IS ${_this22.escapeComment(column.comment)}`));\n        downQueries.push(new Query(`COMMENT ON COLUMN ${_this22.escapePath(table)}.\"${column.name}\" IS ${_this22.escapeComment(column.comment)}`));\n      }\n      yield _this22.executeQueries(upQueries, downQueries);\n      clonedTable.addColumn(column);\n      _this22.replaceCachedTable(table, clonedTable);\n    })();\n  }\n  /**\n   * Creates a new columns from the column in the table.\n   */\n  addColumns(tableOrName, columns) {\n    var _this23 = this;\n    return _asyncToGenerator(function* () {\n      for (const column of columns) {\n        yield _this23.addColumn(tableOrName, column);\n      }\n    })();\n  }\n  /**\n   * Renames column in the given table.\n   */\n  renameColumn(tableOrName, oldTableColumnOrName, newTableColumnOrName) {\n    var _this24 = this;\n    return _asyncToGenerator(function* () {\n      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield _this24.getCachedTable(tableOrName);\n      const oldColumn = InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find(c => c.name === oldTableColumnOrName);\n      if (!oldColumn) throw new TypeORMError(`Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`);\n      let newColumn;\n      if (InstanceChecker.isTableColumn(newTableColumnOrName)) {\n        newColumn = newTableColumnOrName;\n      } else {\n        newColumn = oldColumn.clone();\n        newColumn.name = newTableColumnOrName;\n      }\n      return _this24.changeColumn(table, oldColumn, newColumn);\n    })();\n  }\n  /**\n   * Changes a column in the table.\n   */\n  changeColumn(tableOrName, oldTableColumnOrName, newColumn) {\n    var _this25 = this;\n    return _asyncToGenerator(function* () {\n      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield _this25.getCachedTable(tableOrName);\n      let clonedTable = table.clone();\n      const upQueries = [];\n      const downQueries = [];\n      let defaultValueChanged = false;\n      const oldColumn = InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find(column => column.name === oldTableColumnOrName);\n      if (!oldColumn) throw new TypeORMError(`Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`);\n      if (oldColumn.type !== newColumn.type || oldColumn.length !== newColumn.length || newColumn.isArray !== oldColumn.isArray || !oldColumn.generatedType && newColumn.generatedType === \"STORED\" || oldColumn.asExpression !== newColumn.asExpression && newColumn.generatedType === \"STORED\") {\n        // To avoid data conversion, we just recreate column\n        yield _this25.dropColumn(table, oldColumn);\n        yield _this25.addColumn(table, newColumn);\n        // update cloned table\n        clonedTable = table.clone();\n      } else {\n        if (oldColumn.name !== newColumn.name) {\n          // rename column\n          upQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} RENAME COLUMN \"${oldColumn.name}\" TO \"${newColumn.name}\"`));\n          downQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} RENAME COLUMN \"${newColumn.name}\" TO \"${oldColumn.name}\"`));\n          // rename ENUM type\n          if (oldColumn.type === \"enum\" || oldColumn.type === \"simple-enum\") {\n            const oldEnumType = yield _this25.getUserDefinedTypeName(table, oldColumn);\n            upQueries.push(new Query(`ALTER TYPE \"${oldEnumType.schema}\".\"${oldEnumType.name}\" RENAME TO ${_this25.buildEnumName(table, newColumn, false)}`));\n            downQueries.push(new Query(`ALTER TYPE ${_this25.buildEnumName(table, newColumn)} RENAME TO \"${oldEnumType.name}\"`));\n          }\n          // rename column primary key constraint\n          if (oldColumn.isPrimary === true && !oldColumn.primaryKeyConstraintName) {\n            const primaryColumns = clonedTable.primaryColumns;\n            // build old primary constraint name\n            const columnNames = primaryColumns.map(column => column.name);\n            const oldPkName = _this25.connection.namingStrategy.primaryKeyName(clonedTable, columnNames);\n            // replace old column name with new column name\n            columnNames.splice(columnNames.indexOf(oldColumn.name), 1);\n            columnNames.push(newColumn.name);\n            // build new primary constraint name\n            const newPkName = _this25.connection.namingStrategy.primaryKeyName(clonedTable, columnNames);\n            upQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} RENAME CONSTRAINT \"${oldPkName}\" TO \"${newPkName}\"`));\n            downQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} RENAME CONSTRAINT \"${newPkName}\" TO \"${oldPkName}\"`));\n          }\n          // rename column sequence\n          if (oldColumn.isGenerated === true && newColumn.generationStrategy === \"increment\") {\n            const sequencePath = _this25.buildSequencePath(table, oldColumn.name);\n            const sequenceName = _this25.buildSequenceName(table, oldColumn.name);\n            const newSequencePath = _this25.buildSequencePath(table, newColumn.name);\n            const newSequenceName = _this25.buildSequenceName(table, newColumn.name);\n            const up = `ALTER SEQUENCE ${_this25.escapePath(sequencePath)} RENAME TO \"${newSequenceName}\"`;\n            const down = `ALTER SEQUENCE ${_this25.escapePath(newSequencePath)} RENAME TO \"${sequenceName}\"`;\n            upQueries.push(new Query(up));\n            downQueries.push(new Query(down));\n          }\n          // rename unique constraints\n          clonedTable.findColumnUniques(oldColumn).forEach(unique => {\n            const oldUniqueName = _this25.connection.namingStrategy.uniqueConstraintName(clonedTable, unique.columnNames);\n            // Skip renaming if Unique has user defined constraint name\n            if (unique.name !== oldUniqueName) return;\n            // build new constraint name\n            unique.columnNames.splice(unique.columnNames.indexOf(oldColumn.name), 1);\n            unique.columnNames.push(newColumn.name);\n            const newUniqueName = _this25.connection.namingStrategy.uniqueConstraintName(clonedTable, unique.columnNames);\n            // build queries\n            upQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} RENAME CONSTRAINT \"${unique.name}\" TO \"${newUniqueName}\"`));\n            downQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} RENAME CONSTRAINT \"${newUniqueName}\" TO \"${unique.name}\"`));\n            // replace constraint name\n            unique.name = newUniqueName;\n          });\n          // rename index constraints\n          clonedTable.findColumnIndices(oldColumn).forEach(index => {\n            const oldIndexName = _this25.connection.namingStrategy.indexName(clonedTable, index.columnNames, index.where);\n            // Skip renaming if Index has user defined constraint name\n            if (index.name !== oldIndexName) return;\n            // build new constraint name\n            index.columnNames.splice(index.columnNames.indexOf(oldColumn.name), 1);\n            index.columnNames.push(newColumn.name);\n            const {\n              schema\n            } = _this25.driver.parseTableName(table);\n            const newIndexName = _this25.connection.namingStrategy.indexName(clonedTable, index.columnNames, index.where);\n            // build queries\n            const up = schema ? `ALTER INDEX \"${schema}\".\"${index.name}\" RENAME TO \"${newIndexName}\"` : `ALTER INDEX \"${index.name}\" RENAME TO \"${newIndexName}\"`;\n            const down = schema ? `ALTER INDEX \"${schema}\".\"${newIndexName}\" RENAME TO \"${index.name}\"` : `ALTER INDEX \"${newIndexName}\" RENAME TO \"${index.name}\"`;\n            upQueries.push(new Query(up));\n            downQueries.push(new Query(down));\n            // replace constraint name\n            index.name = newIndexName;\n          });\n          // rename foreign key constraints\n          clonedTable.findColumnForeignKeys(oldColumn).forEach(foreignKey => {\n            const foreignKeyName = _this25.connection.namingStrategy.foreignKeyName(clonedTable, foreignKey.columnNames, _this25.getTablePath(foreignKey), foreignKey.referencedColumnNames);\n            // Skip renaming if foreign key has user defined constraint name\n            if (foreignKey.name !== foreignKeyName) return;\n            // build new constraint name\n            foreignKey.columnNames.splice(foreignKey.columnNames.indexOf(oldColumn.name), 1);\n            foreignKey.columnNames.push(newColumn.name);\n            const newForeignKeyName = _this25.connection.namingStrategy.foreignKeyName(clonedTable, foreignKey.columnNames, _this25.getTablePath(foreignKey), foreignKey.referencedColumnNames);\n            // build queries\n            upQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} RENAME CONSTRAINT \"${foreignKey.name}\" TO \"${newForeignKeyName}\"`));\n            downQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} RENAME CONSTRAINT \"${newForeignKeyName}\" TO \"${foreignKey.name}\"`));\n            // replace constraint name\n            foreignKey.name = newForeignKeyName;\n          });\n          // rename old column in the Table object\n          const oldTableColumn = clonedTable.columns.find(column => column.name === oldColumn.name);\n          clonedTable.columns[clonedTable.columns.indexOf(oldTableColumn)].name = newColumn.name;\n          oldColumn.name = newColumn.name;\n        }\n        if (newColumn.precision !== oldColumn.precision || newColumn.scale !== oldColumn.scale) {\n          upQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" TYPE ${_this25.driver.createFullType(newColumn)}`));\n          downQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" TYPE ${_this25.driver.createFullType(oldColumn)}`));\n        }\n        if ((newColumn.type === \"enum\" || newColumn.type === \"simple-enum\") && (oldColumn.type === \"enum\" || oldColumn.type === \"simple-enum\") && (!OrmUtils.isArraysEqual(newColumn.enum, oldColumn.enum) || newColumn.enumName !== oldColumn.enumName)) {\n          const arraySuffix = newColumn.isArray ? \"[]\" : \"\";\n          // \"public\".\"new_enum\"\n          const newEnumName = _this25.buildEnumName(table, newColumn);\n          // \"public\".\"old_enum\"\n          const oldEnumName = _this25.buildEnumName(table, oldColumn);\n          // \"old_enum\"\n          const oldEnumNameWithoutSchema = _this25.buildEnumName(table, oldColumn, false);\n          //\"public\".\"old_enum_old\"\n          const oldEnumNameWithSchema_old = _this25.buildEnumName(table, oldColumn, true, false, true);\n          //\"old_enum_old\"\n          const oldEnumNameWithoutSchema_old = _this25.buildEnumName(table, oldColumn, false, false, true);\n          // rename old ENUM\n          upQueries.push(new Query(`ALTER TYPE ${oldEnumName} RENAME TO ${oldEnumNameWithoutSchema_old}`));\n          downQueries.push(new Query(`ALTER TYPE ${oldEnumNameWithSchema_old} RENAME TO ${oldEnumNameWithoutSchema}`));\n          // create new ENUM\n          upQueries.push(_this25.createEnumTypeSql(table, newColumn, newEnumName));\n          downQueries.push(_this25.dropEnumTypeSql(table, newColumn, newEnumName));\n          // if column have default value, we must drop it to avoid issues with type casting\n          if (oldColumn.default !== null && oldColumn.default !== undefined) {\n            // mark default as changed to prevent double update\n            defaultValueChanged = true;\n            upQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" DROP DEFAULT`));\n            downQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" SET DEFAULT ${oldColumn.default}`));\n          }\n          // build column types\n          const upType = `${newEnumName}${arraySuffix} USING \"${newColumn.name}\"::\"text\"::${newEnumName}${arraySuffix}`;\n          const downType = `${oldEnumNameWithSchema_old}${arraySuffix} USING \"${newColumn.name}\"::\"text\"::${oldEnumNameWithSchema_old}${arraySuffix}`;\n          // update column to use new type\n          upQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" TYPE ${upType}`));\n          downQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" TYPE ${downType}`));\n          // restore column default or create new one\n          if (newColumn.default !== null && newColumn.default !== undefined) {\n            upQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT ${newColumn.default}`));\n            downQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" DROP DEFAULT`));\n          }\n          // remove old ENUM\n          upQueries.push(_this25.dropEnumTypeSql(table, oldColumn, oldEnumNameWithSchema_old));\n          downQueries.push(_this25.createEnumTypeSql(table, oldColumn, oldEnumNameWithSchema_old));\n        }\n        if (oldColumn.isNullable !== newColumn.isNullable) {\n          if (newColumn.isNullable) {\n            upQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" DROP NOT NULL`));\n            downQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" SET NOT NULL`));\n          } else {\n            upQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" SET NOT NULL`));\n            downQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" DROP NOT NULL`));\n          }\n        }\n        if (oldColumn.comment !== newColumn.comment) {\n          upQueries.push(new Query(`COMMENT ON COLUMN ${_this25.escapePath(table)}.\"${oldColumn.name}\" IS ${_this25.escapeComment(newColumn.comment)}`));\n          downQueries.push(new Query(`COMMENT ON COLUMN ${_this25.escapePath(table)}.\"${newColumn.name}\" IS ${_this25.escapeComment(oldColumn.comment)}`));\n        }\n        if (newColumn.isPrimary !== oldColumn.isPrimary) {\n          const primaryColumns = clonedTable.primaryColumns;\n          // if primary column state changed, we must always drop existed constraint.\n          if (primaryColumns.length > 0) {\n            const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : _this25.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map(column => column.name));\n            const columnNames = primaryColumns.map(column => `\"${column.name}\"`).join(\", \");\n            upQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} DROP CONSTRAINT \"${pkName}\"`));\n            downQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`));\n          }\n          if (newColumn.isPrimary === true) {\n            primaryColumns.push(newColumn);\n            // update column in table\n            const column = clonedTable.columns.find(column => column.name === newColumn.name);\n            column.isPrimary = true;\n            const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : _this25.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map(column => column.name));\n            const columnNames = primaryColumns.map(column => `\"${column.name}\"`).join(\", \");\n            upQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`));\n            downQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} DROP CONSTRAINT \"${pkName}\"`));\n          } else {\n            const primaryColumn = primaryColumns.find(c => c.name === newColumn.name);\n            primaryColumns.splice(primaryColumns.indexOf(primaryColumn), 1);\n            // update column in table\n            const column = clonedTable.columns.find(column => column.name === newColumn.name);\n            column.isPrimary = false;\n            // if we have another primary keys, we must recreate constraint.\n            if (primaryColumns.length > 0) {\n              const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : _this25.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map(column => column.name));\n              const columnNames = primaryColumns.map(column => `\"${column.name}\"`).join(\", \");\n              upQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`));\n              downQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} DROP CONSTRAINT \"${pkName}\"`));\n            }\n          }\n        }\n        if (newColumn.isUnique !== oldColumn.isUnique) {\n          if (newColumn.isUnique === true) {\n            const uniqueConstraint = new TableUnique({\n              name: _this25.connection.namingStrategy.uniqueConstraintName(table, [newColumn.name]),\n              columnNames: [newColumn.name]\n            });\n            clonedTable.uniques.push(uniqueConstraint);\n            upQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} ADD CONSTRAINT \"${uniqueConstraint.name}\" UNIQUE (\"${newColumn.name}\")`));\n            downQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} DROP CONSTRAINT \"${uniqueConstraint.name}\"`));\n          } else {\n            const uniqueConstraint = clonedTable.uniques.find(unique => {\n              return unique.columnNames.length === 1 && !!unique.columnNames.find(columnName => columnName === newColumn.name);\n            });\n            clonedTable.uniques.splice(clonedTable.uniques.indexOf(uniqueConstraint), 1);\n            upQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} DROP CONSTRAINT \"${uniqueConstraint.name}\"`));\n            downQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} ADD CONSTRAINT \"${uniqueConstraint.name}\" UNIQUE (\"${newColumn.name}\")`));\n          }\n        }\n        if (oldColumn.isGenerated !== newColumn.isGenerated) {\n          // if old column was \"generated\", we should clear defaults\n          if (oldColumn.isGenerated) {\n            if (oldColumn.generationStrategy === \"uuid\") {\n              upQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" DROP DEFAULT`));\n              downQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" SET DEFAULT ${_this25.driver.uuidGenerator}`));\n            } else if (oldColumn.generationStrategy === \"increment\") {\n              upQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" DROP DEFAULT`));\n              downQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT nextval('${_this25.escapePath(_this25.buildSequencePath(table, newColumn))}')`));\n              upQueries.push(new Query(`DROP SEQUENCE ${_this25.escapePath(_this25.buildSequencePath(table, newColumn))}`));\n              downQueries.push(new Query(`CREATE SEQUENCE IF NOT EXISTS ${_this25.escapePath(_this25.buildSequencePath(table, newColumn))} OWNED BY ${_this25.escapePath(table)}.\"${newColumn.name}\"`));\n            }\n          }\n          if (newColumn.generationStrategy === \"uuid\") {\n            if (newColumn.isGenerated === true) {\n              upQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT ${_this25.driver.uuidGenerator}`));\n              downQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" DROP DEFAULT`));\n            } else {\n              upQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" DROP DEFAULT`));\n              downQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT ${_this25.driver.uuidGenerator}`));\n            }\n          } else if (newColumn.generationStrategy === \"increment\") {\n            if (newColumn.isGenerated === true) {\n              upQueries.push(new Query(`CREATE SEQUENCE IF NOT EXISTS ${_this25.escapePath(_this25.buildSequencePath(table, newColumn))} OWNED BY ${_this25.escapePath(table)}.\"${newColumn.name}\"`));\n              downQueries.push(new Query(`DROP SEQUENCE ${_this25.escapePath(_this25.buildSequencePath(table, newColumn))}`));\n              upQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT nextval('${_this25.escapePath(_this25.buildSequencePath(table, newColumn))}')`));\n              downQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" DROP DEFAULT`));\n            } else {\n              upQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" DROP DEFAULT`));\n              downQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT nextval('${_this25.escapePath(_this25.buildSequencePath(table, newColumn))}')`));\n              upQueries.push(new Query(`DROP SEQUENCE ${_this25.escapePath(_this25.buildSequencePath(table, newColumn))}`));\n              downQueries.push(new Query(`CREATE SEQUENCE IF NOT EXISTS ${_this25.escapePath(_this25.buildSequencePath(table, newColumn))} OWNED BY ${_this25.escapePath(table)}.\"${newColumn.name}\"`));\n            }\n          }\n        }\n        // the default might have changed when the enum changed\n        if (newColumn.default !== oldColumn.default && !defaultValueChanged) {\n          if (newColumn.default !== null && newColumn.default !== undefined) {\n            upQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT ${newColumn.default}`));\n            if (oldColumn.default !== null && oldColumn.default !== undefined) {\n              downQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT ${oldColumn.default}`));\n            } else {\n              downQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" DROP DEFAULT`));\n            }\n          } else if (oldColumn.default !== null && oldColumn.default !== undefined) {\n            upQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" DROP DEFAULT`));\n            downQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT ${oldColumn.default}`));\n          }\n        }\n        if ((newColumn.spatialFeatureType || \"\").toLowerCase() !== (oldColumn.spatialFeatureType || \"\").toLowerCase() || newColumn.srid !== oldColumn.srid) {\n          upQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" TYPE ${_this25.driver.createFullType(newColumn)}`));\n          downQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" TYPE ${_this25.driver.createFullType(oldColumn)}`));\n        }\n        if (newColumn.generatedType !== oldColumn.generatedType) {\n          // Convert generated column data to normal column\n          if (!newColumn.generatedType || newColumn.generatedType === \"VIRTUAL\") {\n            // We can copy the generated data to the new column\n            const tableNameWithSchema = (yield _this25.getTableNameWithSchema(table.name)).split(\".\");\n            const tableName = tableNameWithSchema[1];\n            const schema = tableNameWithSchema[0];\n            upQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} RENAME COLUMN \"${oldColumn.name}\" TO \"TEMP_OLD_${oldColumn.name}\"`));\n            upQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} ADD ${_this25.buildCreateColumnSql(table, newColumn)}`));\n            upQueries.push(new Query(`UPDATE ${_this25.escapePath(table)} SET \"${newColumn.name}\" = \"TEMP_OLD_${oldColumn.name}\"`));\n            upQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} DROP COLUMN \"TEMP_OLD_${oldColumn.name}\"`));\n            upQueries.push(_this25.deleteTypeormMetadataSql({\n              database: _this25.driver.database,\n              schema,\n              table: tableName,\n              type: MetadataTableType.GENERATED_COLUMN,\n              name: oldColumn.name\n            }));\n            // However, we can't copy it back on downgrade. It needs to regenerate.\n            downQueries.push(_this25.insertTypeormMetadataSql({\n              database: _this25.driver.database,\n              schema,\n              table: tableName,\n              type: MetadataTableType.GENERATED_COLUMN,\n              name: oldColumn.name,\n              value: oldColumn.asExpression\n            }));\n            downQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} ADD ${_this25.buildCreateColumnSql(table, oldColumn)}`));\n            downQueries.push(new Query(`ALTER TABLE ${_this25.escapePath(table)} DROP COLUMN \"${newColumn.name}\"`));\n            // downQueries.push(\n            //     this.deleteTypeormMetadataSql({\n            //         database: this.driver.database,\n            //         schema,\n            //         table: tableName,\n            //         type: MetadataTableType.GENERATED_COLUMN,\n            //         name: newColumn.name,\n            //     }),\n            // )\n          }\n        }\n      }\n\n      yield _this25.executeQueries(upQueries, downQueries);\n      _this25.replaceCachedTable(table, clonedTable);\n    })();\n  }\n  /**\n   * Changes a column in the table.\n   */\n  changeColumns(tableOrName, changedColumns) {\n    var _this26 = this;\n    return _asyncToGenerator(function* () {\n      for (const {\n        oldColumn,\n        newColumn\n      } of changedColumns) {\n        yield _this26.changeColumn(tableOrName, oldColumn, newColumn);\n      }\n    })();\n  }\n  /**\n   * Drops column in the table.\n   */\n  dropColumn(tableOrName, columnOrName) {\n    var _this27 = this;\n    return _asyncToGenerator(function* () {\n      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield _this27.getCachedTable(tableOrName);\n      const column = InstanceChecker.isTableColumn(columnOrName) ? columnOrName : table.findColumnByName(columnOrName);\n      if (!column) throw new TypeORMError(`Column \"${columnOrName}\" was not found in table \"${table.name}\"`);\n      const clonedTable = table.clone();\n      const upQueries = [];\n      const downQueries = [];\n      // drop primary key constraint\n      if (column.isPrimary) {\n        const pkName = column.primaryKeyConstraintName ? column.primaryKeyConstraintName : _this27.connection.namingStrategy.primaryKeyName(clonedTable, clonedTable.primaryColumns.map(column => column.name));\n        const columnNames = clonedTable.primaryColumns.map(primaryColumn => `\"${primaryColumn.name}\"`).join(\", \");\n        upQueries.push(new Query(`ALTER TABLE ${_this27.escapePath(clonedTable)} DROP CONSTRAINT \"${pkName}\"`));\n        downQueries.push(new Query(`ALTER TABLE ${_this27.escapePath(clonedTable)} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`));\n        // update column in table\n        const tableColumn = clonedTable.findColumnByName(column.name);\n        tableColumn.isPrimary = false;\n        // if primary key have multiple columns, we must recreate it without dropped column\n        if (clonedTable.primaryColumns.length > 0) {\n          const pkName = clonedTable.primaryColumns[0].primaryKeyConstraintName ? clonedTable.primaryColumns[0].primaryKeyConstraintName : _this27.connection.namingStrategy.primaryKeyName(clonedTable, clonedTable.primaryColumns.map(column => column.name));\n          const columnNames = clonedTable.primaryColumns.map(primaryColumn => `\"${primaryColumn.name}\"`).join(\", \");\n          upQueries.push(new Query(`ALTER TABLE ${_this27.escapePath(clonedTable)} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`));\n          downQueries.push(new Query(`ALTER TABLE ${_this27.escapePath(clonedTable)} DROP CONSTRAINT \"${pkName}\"`));\n        }\n      }\n      // drop column index\n      const columnIndex = clonedTable.indices.find(index => index.columnNames.length === 1 && index.columnNames[0] === column.name);\n      if (columnIndex) {\n        clonedTable.indices.splice(clonedTable.indices.indexOf(columnIndex), 1);\n        upQueries.push(_this27.dropIndexSql(table, columnIndex));\n        downQueries.push(_this27.createIndexSql(table, columnIndex));\n      }\n      // drop column check\n      const columnCheck = clonedTable.checks.find(check => !!check.columnNames && check.columnNames.length === 1 && check.columnNames[0] === column.name);\n      if (columnCheck) {\n        clonedTable.checks.splice(clonedTable.checks.indexOf(columnCheck), 1);\n        upQueries.push(_this27.dropCheckConstraintSql(table, columnCheck));\n        downQueries.push(_this27.createCheckConstraintSql(table, columnCheck));\n      }\n      // drop column unique\n      const columnUnique = clonedTable.uniques.find(unique => unique.columnNames.length === 1 && unique.columnNames[0] === column.name);\n      if (columnUnique) {\n        clonedTable.uniques.splice(clonedTable.uniques.indexOf(columnUnique), 1);\n        upQueries.push(_this27.dropUniqueConstraintSql(table, columnUnique));\n        downQueries.push(_this27.createUniqueConstraintSql(table, columnUnique));\n      }\n      upQueries.push(new Query(`ALTER TABLE ${_this27.escapePath(table)} DROP COLUMN \"${column.name}\"`));\n      downQueries.push(new Query(`ALTER TABLE ${_this27.escapePath(table)} ADD ${_this27.buildCreateColumnSql(table, column)}`));\n      // drop enum type\n      if (column.type === \"enum\" || column.type === \"simple-enum\") {\n        const hasEnum = yield _this27.hasEnumType(table, column);\n        if (hasEnum) {\n          const enumType = yield _this27.getUserDefinedTypeName(table, column);\n          const escapedEnumName = `\"${enumType.schema}\".\"${enumType.name}\"`;\n          upQueries.push(_this27.dropEnumTypeSql(table, column, escapedEnumName));\n          downQueries.push(_this27.createEnumTypeSql(table, column, escapedEnumName));\n        }\n      }\n      if (column.generatedType === \"STORED\") {\n        const tableNameWithSchema = (yield _this27.getTableNameWithSchema(table.name)).split(\".\");\n        const tableName = tableNameWithSchema[1];\n        const schema = tableNameWithSchema[0];\n        const deleteQuery = _this27.deleteTypeormMetadataSql({\n          database: _this27.driver.database,\n          schema,\n          table: tableName,\n          type: MetadataTableType.GENERATED_COLUMN,\n          name: column.name\n        });\n        const insertQuery = _this27.insertTypeormMetadataSql({\n          database: _this27.driver.database,\n          schema,\n          table: tableName,\n          type: MetadataTableType.GENERATED_COLUMN,\n          name: column.name,\n          value: column.asExpression\n        });\n        upQueries.push(deleteQuery);\n        downQueries.push(insertQuery);\n      }\n      yield _this27.executeQueries(upQueries, downQueries);\n      clonedTable.removeColumn(column);\n      _this27.replaceCachedTable(table, clonedTable);\n    })();\n  }\n  /**\n   * Drops the columns in the table.\n   */\n  dropColumns(tableOrName, columns) {\n    var _this28 = this;\n    return _asyncToGenerator(function* () {\n      for (const column of columns) {\n        yield _this28.dropColumn(tableOrName, column);\n      }\n    })();\n  }\n  /**\n   * Creates a new primary key.\n   */\n  createPrimaryKey(tableOrName, columnNames, constraintName) {\n    var _this29 = this;\n    return _asyncToGenerator(function* () {\n      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield _this29.getCachedTable(tableOrName);\n      const clonedTable = table.clone();\n      const up = _this29.createPrimaryKeySql(table, columnNames, constraintName);\n      // mark columns as primary, because dropPrimaryKeySql build constraint name from table primary column names.\n      clonedTable.columns.forEach(column => {\n        if (columnNames.find(columnName => columnName === column.name)) column.isPrimary = true;\n      });\n      const down = _this29.dropPrimaryKeySql(clonedTable);\n      yield _this29.executeQueries(up, down);\n      _this29.replaceCachedTable(table, clonedTable);\n    })();\n  }\n  /**\n   * Updates composite primary keys.\n   */\n  updatePrimaryKeys(tableOrName, columns) {\n    var _this30 = this;\n    return _asyncToGenerator(function* () {\n      var _a;\n      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield _this30.getCachedTable(tableOrName);\n      const clonedTable = table.clone();\n      const columnNames = columns.map(column => column.name);\n      const upQueries = [];\n      const downQueries = [];\n      // if table already have primary columns, we must drop them.\n      const primaryColumns = clonedTable.primaryColumns;\n      if (primaryColumns.length > 0) {\n        const pkName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : _this30.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map(column => column.name));\n        const columnNamesString = primaryColumns.map(column => `\"${column.name}\"`).join(\", \");\n        upQueries.push(new Query(`ALTER TABLE ${_this30.escapePath(table)} DROP CONSTRAINT \"${pkName}\"`));\n        downQueries.push(new Query(`ALTER TABLE ${_this30.escapePath(table)} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNamesString})`));\n      }\n      // update columns in table.\n      clonedTable.columns.filter(column => columnNames.indexOf(column.name) !== -1).forEach(column => column.isPrimary = true);\n      const pkName = ((_a = primaryColumns[0]) === null || _a === void 0 ? void 0 : _a.primaryKeyConstraintName) ? primaryColumns[0].primaryKeyConstraintName : _this30.connection.namingStrategy.primaryKeyName(clonedTable, columnNames);\n      const columnNamesString = columnNames.map(columnName => `\"${columnName}\"`).join(\", \");\n      upQueries.push(new Query(`ALTER TABLE ${_this30.escapePath(table)} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNamesString})`));\n      downQueries.push(new Query(`ALTER TABLE ${_this30.escapePath(table)} DROP CONSTRAINT \"${pkName}\"`));\n      yield _this30.executeQueries(upQueries, downQueries);\n      _this30.replaceCachedTable(table, clonedTable);\n    })();\n  }\n  /**\n   * Drops a primary key.\n   */\n  dropPrimaryKey(tableOrName, constraintName) {\n    var _this31 = this;\n    return _asyncToGenerator(function* () {\n      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield _this31.getCachedTable(tableOrName);\n      const up = _this31.dropPrimaryKeySql(table);\n      const down = _this31.createPrimaryKeySql(table, table.primaryColumns.map(column => column.name), constraintName);\n      yield _this31.executeQueries(up, down);\n      table.primaryColumns.forEach(column => {\n        column.isPrimary = false;\n      });\n    })();\n  }\n  /**\n   * Creates new unique constraint.\n   */\n  createUniqueConstraint(tableOrName, uniqueConstraint) {\n    var _this32 = this;\n    return _asyncToGenerator(function* () {\n      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield _this32.getCachedTable(tableOrName);\n      // new unique constraint may be passed without name. In this case we generate unique name manually.\n      if (!uniqueConstraint.name) uniqueConstraint.name = _this32.connection.namingStrategy.uniqueConstraintName(table, uniqueConstraint.columnNames);\n      const up = _this32.createUniqueConstraintSql(table, uniqueConstraint);\n      const down = _this32.dropUniqueConstraintSql(table, uniqueConstraint);\n      yield _this32.executeQueries(up, down);\n      table.addUniqueConstraint(uniqueConstraint);\n    })();\n  }\n  /**\n   * Creates new unique constraints.\n   */\n  createUniqueConstraints(tableOrName, uniqueConstraints) {\n    var _this33 = this;\n    return _asyncToGenerator(function* () {\n      for (const uniqueConstraint of uniqueConstraints) {\n        yield _this33.createUniqueConstraint(tableOrName, uniqueConstraint);\n      }\n    })();\n  }\n  /**\n   * Drops unique constraint.\n   */\n  dropUniqueConstraint(tableOrName, uniqueOrName) {\n    var _this34 = this;\n    return _asyncToGenerator(function* () {\n      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield _this34.getCachedTable(tableOrName);\n      const uniqueConstraint = InstanceChecker.isTableUnique(uniqueOrName) ? uniqueOrName : table.uniques.find(u => u.name === uniqueOrName);\n      if (!uniqueConstraint) throw new TypeORMError(`Supplied unique constraint was not found in table ${table.name}`);\n      const up = _this34.dropUniqueConstraintSql(table, uniqueConstraint);\n      const down = _this34.createUniqueConstraintSql(table, uniqueConstraint);\n      yield _this34.executeQueries(up, down);\n      table.removeUniqueConstraint(uniqueConstraint);\n    })();\n  }\n  /**\n   * Drops unique constraints.\n   */\n  dropUniqueConstraints(tableOrName, uniqueConstraints) {\n    var _this35 = this;\n    return _asyncToGenerator(function* () {\n      for (const uniqueConstraint of uniqueConstraints) {\n        yield _this35.dropUniqueConstraint(tableOrName, uniqueConstraint);\n      }\n    })();\n  }\n  /**\n   * Creates new check constraint.\n   */\n  createCheckConstraint(tableOrName, checkConstraint) {\n    var _this36 = this;\n    return _asyncToGenerator(function* () {\n      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield _this36.getCachedTable(tableOrName);\n      // new unique constraint may be passed without name. In this case we generate unique name manually.\n      if (!checkConstraint.name) checkConstraint.name = _this36.connection.namingStrategy.checkConstraintName(table, checkConstraint.expression);\n      const up = _this36.createCheckConstraintSql(table, checkConstraint);\n      const down = _this36.dropCheckConstraintSql(table, checkConstraint);\n      yield _this36.executeQueries(up, down);\n      table.addCheckConstraint(checkConstraint);\n    })();\n  }\n  /**\n   * Creates new check constraints.\n   */\n  createCheckConstraints(tableOrName, checkConstraints) {\n    var _this37 = this;\n    return _asyncToGenerator(function* () {\n      const promises = checkConstraints.map(checkConstraint => _this37.createCheckConstraint(tableOrName, checkConstraint));\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Drops check constraint.\n   */\n  dropCheckConstraint(tableOrName, checkOrName) {\n    var _this38 = this;\n    return _asyncToGenerator(function* () {\n      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield _this38.getCachedTable(tableOrName);\n      const checkConstraint = InstanceChecker.isTableCheck(checkOrName) ? checkOrName : table.checks.find(c => c.name === checkOrName);\n      if (!checkConstraint) throw new TypeORMError(`Supplied check constraint was not found in table ${table.name}`);\n      const up = _this38.dropCheckConstraintSql(table, checkConstraint);\n      const down = _this38.createCheckConstraintSql(table, checkConstraint);\n      yield _this38.executeQueries(up, down);\n      table.removeCheckConstraint(checkConstraint);\n    })();\n  }\n  /**\n   * Drops check constraints.\n   */\n  dropCheckConstraints(tableOrName, checkConstraints) {\n    var _this39 = this;\n    return _asyncToGenerator(function* () {\n      const promises = checkConstraints.map(checkConstraint => _this39.dropCheckConstraint(tableOrName, checkConstraint));\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Creates new exclusion constraint.\n   */\n  createExclusionConstraint(tableOrName, exclusionConstraint) {\n    var _this40 = this;\n    return _asyncToGenerator(function* () {\n      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield _this40.getCachedTable(tableOrName);\n      // new unique constraint may be passed without name. In this case we generate unique name manually.\n      if (!exclusionConstraint.name) exclusionConstraint.name = _this40.connection.namingStrategy.exclusionConstraintName(table, exclusionConstraint.expression);\n      const up = _this40.createExclusionConstraintSql(table, exclusionConstraint);\n      const down = _this40.dropExclusionConstraintSql(table, exclusionConstraint);\n      yield _this40.executeQueries(up, down);\n      table.addExclusionConstraint(exclusionConstraint);\n    })();\n  }\n  /**\n   * Creates new exclusion constraints.\n   */\n  createExclusionConstraints(tableOrName, exclusionConstraints) {\n    var _this41 = this;\n    return _asyncToGenerator(function* () {\n      const promises = exclusionConstraints.map(exclusionConstraint => _this41.createExclusionConstraint(tableOrName, exclusionConstraint));\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Drops exclusion constraint.\n   */\n  dropExclusionConstraint(tableOrName, exclusionOrName) {\n    var _this42 = this;\n    return _asyncToGenerator(function* () {\n      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield _this42.getCachedTable(tableOrName);\n      const exclusionConstraint = InstanceChecker.isTableExclusion(exclusionOrName) ? exclusionOrName : table.exclusions.find(c => c.name === exclusionOrName);\n      if (!exclusionConstraint) throw new TypeORMError(`Supplied exclusion constraint was not found in table ${table.name}`);\n      const up = _this42.dropExclusionConstraintSql(table, exclusionConstraint);\n      const down = _this42.createExclusionConstraintSql(table, exclusionConstraint);\n      yield _this42.executeQueries(up, down);\n      table.removeExclusionConstraint(exclusionConstraint);\n    })();\n  }\n  /**\n   * Drops exclusion constraints.\n   */\n  dropExclusionConstraints(tableOrName, exclusionConstraints) {\n    var _this43 = this;\n    return _asyncToGenerator(function* () {\n      const promises = exclusionConstraints.map(exclusionConstraint => _this43.dropExclusionConstraint(tableOrName, exclusionConstraint));\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Creates a new foreign key.\n   */\n  createForeignKey(tableOrName, foreignKey) {\n    var _this44 = this;\n    return _asyncToGenerator(function* () {\n      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield _this44.getCachedTable(tableOrName);\n      // new FK may be passed without name. In this case we generate FK name manually.\n      if (!foreignKey.name) foreignKey.name = _this44.connection.namingStrategy.foreignKeyName(table, foreignKey.columnNames, _this44.getTablePath(foreignKey), foreignKey.referencedColumnNames);\n      const up = _this44.createForeignKeySql(table, foreignKey);\n      const down = _this44.dropForeignKeySql(table, foreignKey);\n      yield _this44.executeQueries(up, down);\n      table.addForeignKey(foreignKey);\n    })();\n  }\n  /**\n   * Creates a new foreign keys.\n   */\n  createForeignKeys(tableOrName, foreignKeys) {\n    var _this45 = this;\n    return _asyncToGenerator(function* () {\n      for (const foreignKey of foreignKeys) {\n        yield _this45.createForeignKey(tableOrName, foreignKey);\n      }\n    })();\n  }\n  /**\n   * Drops a foreign key from the table.\n   */\n  dropForeignKey(tableOrName, foreignKeyOrName) {\n    var _this46 = this;\n    return _asyncToGenerator(function* () {\n      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield _this46.getCachedTable(tableOrName);\n      const foreignKey = InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName : table.foreignKeys.find(fk => fk.name === foreignKeyOrName);\n      if (!foreignKey) throw new TypeORMError(`Supplied foreign key was not found in table ${table.name}`);\n      if (!foreignKey.name) {\n        foreignKey.name = _this46.connection.namingStrategy.foreignKeyName(table, foreignKey.columnNames, _this46.getTablePath(foreignKey), foreignKey.referencedColumnNames);\n      }\n      const up = _this46.dropForeignKeySql(table, foreignKey);\n      const down = _this46.createForeignKeySql(table, foreignKey);\n      yield _this46.executeQueries(up, down);\n      table.removeForeignKey(foreignKey);\n    })();\n  }\n  /**\n   * Drops a foreign keys from the table.\n   */\n  dropForeignKeys(tableOrName, foreignKeys) {\n    var _this47 = this;\n    return _asyncToGenerator(function* () {\n      for (const foreignKey of foreignKeys) {\n        yield _this47.dropForeignKey(tableOrName, foreignKey);\n      }\n    })();\n  }\n  /**\n   * Creates a new index.\n   */\n  createIndex(tableOrName, index) {\n    var _this48 = this;\n    return _asyncToGenerator(function* () {\n      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield _this48.getCachedTable(tableOrName);\n      // new index may be passed without name. In this case we generate index name manually.\n      if (!index.name) index.name = _this48.generateIndexName(table, index);\n      const up = _this48.createIndexSql(table, index);\n      const down = _this48.dropIndexSql(table, index);\n      yield _this48.executeQueries(up, down);\n      table.addIndex(index);\n    })();\n  }\n  /**\n   * Create a new view index.\n   */\n  createViewIndex(viewOrName, index) {\n    var _this49 = this;\n    return _asyncToGenerator(function* () {\n      const view = InstanceChecker.isView(viewOrName) ? viewOrName : yield _this49.getCachedView(viewOrName);\n      // new index may be passed without name. In this case we generate index name manually.\n      if (!index.name) index.name = _this49.generateIndexName(view, index);\n      const up = _this49.createViewIndexSql(view, index);\n      const down = _this49.dropIndexSql(view, index);\n      yield _this49.executeQueries(up, down);\n      view.addIndex(index);\n    })();\n  }\n  /**\n   * Creates a new indices\n   */\n  createIndices(tableOrName, indices) {\n    var _this50 = this;\n    return _asyncToGenerator(function* () {\n      for (const index of indices) {\n        yield _this50.createIndex(tableOrName, index);\n      }\n    })();\n  }\n  /**\n   * Creates new view indices\n   */\n  createViewIndices(viewOrName, indices) {\n    var _this51 = this;\n    return _asyncToGenerator(function* () {\n      for (const index of indices) {\n        yield _this51.createViewIndex(viewOrName, index);\n      }\n    })();\n  }\n  /**\n   * Drops an index from the table.\n   */\n  dropIndex(tableOrName, indexOrName) {\n    var _this52 = this;\n    return _asyncToGenerator(function* () {\n      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield _this52.getCachedTable(tableOrName);\n      const index = InstanceChecker.isTableIndex(indexOrName) ? indexOrName : table.indices.find(i => i.name === indexOrName);\n      if (!index) throw new TypeORMError(`Supplied index ${indexOrName} was not found in table ${table.name}`);\n      // old index may be passed without name. In this case we generate index name manually.\n      if (!index.name) index.name = _this52.generateIndexName(table, index);\n      const up = _this52.dropIndexSql(table, index);\n      const down = _this52.createIndexSql(table, index);\n      yield _this52.executeQueries(up, down);\n      table.removeIndex(index);\n    })();\n  }\n  /**\n   * Drops an index from a view.\n   */\n  dropViewIndex(viewOrName, indexOrName) {\n    var _this53 = this;\n    return _asyncToGenerator(function* () {\n      const view = InstanceChecker.isView(viewOrName) ? viewOrName : yield _this53.getCachedView(viewOrName);\n      const index = InstanceChecker.isTableIndex(indexOrName) ? indexOrName : view.indices.find(i => i.name === indexOrName);\n      if (!index) throw new TypeORMError(`Supplied index ${indexOrName} was not found in view ${view.name}`);\n      // old index may be passed without name. In this case we generate index name manually.\n      if (!index.name) index.name = _this53.generateIndexName(view, index);\n      const up = _this53.dropIndexSql(view, index);\n      const down = _this53.createViewIndexSql(view, index);\n      yield _this53.executeQueries(up, down);\n      view.removeIndex(index);\n    })();\n  }\n  /**\n   * Drops an indices from the table.\n   */\n  dropIndices(tableOrName, indices) {\n    var _this54 = this;\n    return _asyncToGenerator(function* () {\n      for (const index of indices) {\n        yield _this54.dropIndex(tableOrName, index);\n      }\n    })();\n  }\n  /**\n   * Clears all table contents.\n   * Note: this operation uses SQL's TRUNCATE query which cannot be reverted in transactions.\n   */\n  clearTable(tableName) {\n    var _this55 = this;\n    return _asyncToGenerator(function* () {\n      yield _this55.query(`TRUNCATE TABLE ${_this55.escapePath(tableName)}`);\n    })();\n  }\n  /**\n   * Removes all tables from the currently connected database.\n   */\n  clearDatabase() {\n    var _this56 = this;\n    return _asyncToGenerator(function* () {\n      const schemas = [];\n      _this56.connection.entityMetadatas.filter(metadata => metadata.schema).forEach(metadata => {\n        const isSchemaExist = !!schemas.find(schema => schema === metadata.schema);\n        if (!isSchemaExist) schemas.push(metadata.schema);\n      });\n      schemas.push(_this56.driver.options.schema || \"current_schema()\");\n      const schemaNamesString = schemas.map(name => {\n        return name === \"current_schema()\" ? name : \"'\" + name + \"'\";\n      }).join(\", \");\n      const isAnotherTransactionActive = _this56.isTransactionActive;\n      if (!isAnotherTransactionActive) yield _this56.startTransaction();\n      try {\n        const version = yield _this56.getVersion();\n        // drop views\n        const selectViewDropsQuery = `SELECT 'DROP VIEW IF EXISTS \"' || schemaname || '\".\"' || viewname || '\" CASCADE;' as \"query\" ` + `FROM \"pg_views\" WHERE \"schemaname\" IN (${schemaNamesString}) AND \"viewname\" NOT IN ('geography_columns', 'geometry_columns', 'raster_columns', 'raster_overviews')`;\n        const dropViewQueries = yield _this56.query(selectViewDropsQuery);\n        yield Promise.all(dropViewQueries.map(q => _this56.query(q[\"query\"])));\n        // drop materialized views\n        // Note: materialized views introduced in Postgres 9.3\n        if (VersionUtils.isGreaterOrEqual(version, \"9.3\")) {\n          const selectMatViewDropsQuery = `SELECT 'DROP MATERIALIZED VIEW IF EXISTS \"' || schemaname || '\".\"' || matviewname || '\" CASCADE;' as \"query\" ` + `FROM \"pg_matviews\" WHERE \"schemaname\" IN (${schemaNamesString})`;\n          const dropMatViewQueries = yield _this56.query(selectMatViewDropsQuery);\n          yield Promise.all(dropMatViewQueries.map(q => _this56.query(q[\"query\"])));\n        }\n        // ignore spatial_ref_sys; it's a special table supporting PostGIS\n        // TODO generalize this as this.driver.ignoreTables\n        // drop tables\n        const selectTableDropsQuery = `SELECT 'DROP TABLE IF EXISTS \"' || schemaname || '\".\"' || tablename || '\" CASCADE;' as \"query\" FROM \"pg_tables\" WHERE \"schemaname\" IN (${schemaNamesString}) AND \"tablename\" NOT IN ('spatial_ref_sys')`;\n        const dropTableQueries = yield _this56.query(selectTableDropsQuery);\n        yield Promise.all(dropTableQueries.map(q => _this56.query(q[\"query\"])));\n        // drop enum types\n        yield _this56.dropEnumTypes(schemaNamesString);\n        if (!isAnotherTransactionActive) {\n          yield _this56.commitTransaction();\n        }\n      } catch (error) {\n        try {\n          // we throw original error even if rollback thrown an error\n          if (!isAnotherTransactionActive) {\n            yield _this56.rollbackTransaction();\n          }\n        } catch (rollbackError) {}\n        throw error;\n      }\n    })();\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  loadViews(viewNames) {\n    var _this57 = this;\n    return _asyncToGenerator(function* () {\n      const hasTable = yield _this57.hasTable(_this57.getTypeormMetadataTableName());\n      if (!hasTable) return [];\n      if (!viewNames) {\n        viewNames = [];\n      }\n      const currentDatabase = yield _this57.getCurrentDatabase();\n      const currentSchema = yield _this57.getCurrentSchema();\n      const viewsCondition = viewNames.length === 0 ? \"1=1\" : viewNames.map(tableName => _this57.driver.parseTableName(tableName)).map(({\n        schema,\n        tableName\n      }) => {\n        if (!schema) {\n          schema = _this57.driver.options.schema || currentSchema;\n        }\n        return `(\"t\".\"schema\" = '${schema}' AND \"t\".\"name\" = '${tableName}')`;\n      }).join(\" OR \");\n      const constraintsCondition = viewNames.length === 0 ? \"1=1\" : viewNames.map(tableName => _this57.driver.parseTableName(tableName)).map(({\n        schema,\n        tableName\n      }) => {\n        if (!schema) {\n          schema = _this57.driver.options.schema || currentSchema;\n        }\n        return `(\"ns\".\"nspname\" = '${schema}' AND \"t\".\"relname\" = '${tableName}')`;\n      }).join(\" OR \");\n      const indicesSql = `SELECT \"ns\".\"nspname\" AS \"table_schema\", \"t\".\"relname\" AS \"table_name\", \"i\".\"relname\" AS \"constraint_name\", \"a\".\"attname\" AS \"column_name\", ` + `CASE \"ix\".\"indisunique\" WHEN 't' THEN 'TRUE' ELSE'FALSE' END AS \"is_unique\", pg_get_expr(\"ix\".\"indpred\", \"ix\".\"indrelid\") AS \"condition\", ` + `\"types\".\"typname\" AS \"type_name\" ` + `FROM \"pg_class\" \"t\" ` + `INNER JOIN \"pg_index\" \"ix\" ON \"ix\".\"indrelid\" = \"t\".\"oid\" ` + `INNER JOIN \"pg_attribute\" \"a\" ON \"a\".\"attrelid\" = \"t\".\"oid\"  AND \"a\".\"attnum\" = ANY (\"ix\".\"indkey\") ` + `INNER JOIN \"pg_namespace\" \"ns\" ON \"ns\".\"oid\" = \"t\".\"relnamespace\" ` + `INNER JOIN \"pg_class\" \"i\" ON \"i\".\"oid\" = \"ix\".\"indexrelid\" ` + `INNER JOIN \"pg_type\" \"types\" ON \"types\".\"oid\" = \"a\".\"atttypid\" ` + `LEFT JOIN \"pg_constraint\" \"cnst\" ON \"cnst\".\"conname\" = \"i\".\"relname\" ` + `WHERE \"t\".\"relkind\" IN ('m') AND \"cnst\".\"contype\" IS NULL AND (${constraintsCondition})`;\n      const query = `SELECT \"t\".* FROM ${_this57.escapePath(_this57.getTypeormMetadataTableName())} \"t\" ` + `INNER JOIN \"pg_catalog\".\"pg_class\" \"c\" ON \"c\".\"relname\" = \"t\".\"name\" ` + `INNER JOIN \"pg_namespace\" \"n\" ON \"n\".\"oid\" = \"c\".\"relnamespace\" AND \"n\".\"nspname\" = \"t\".\"schema\" ` + `WHERE \"t\".\"type\" IN ('${MetadataTableType.VIEW}', '${MetadataTableType.MATERIALIZED_VIEW}') ${viewsCondition ? `AND (${viewsCondition})` : \"\"}`;\n      const dbViews = yield _this57.query(query);\n      const dbIndices = yield _this57.query(indicesSql);\n      return dbViews.map(dbView => {\n        // find index constraints of table, group them by constraint name and build TableIndex.\n        const tableIndexConstraints = OrmUtils.uniq(dbIndices.filter(dbIndex => {\n          return dbIndex[\"table_name\"] === dbView[\"name\"] && dbIndex[\"table_schema\"] === dbView[\"schema\"];\n        }), dbIndex => dbIndex[\"constraint_name\"]);\n        const view = new View();\n        const schema = dbView[\"schema\"] === currentSchema && !_this57.driver.options.schema ? undefined : dbView[\"schema\"];\n        view.database = currentDatabase;\n        view.schema = dbView[\"schema\"];\n        view.name = _this57.driver.buildTableName(dbView[\"name\"], schema);\n        view.expression = dbView[\"value\"];\n        view.materialized = dbView[\"type\"] === MetadataTableType.MATERIALIZED_VIEW;\n        view.indices = tableIndexConstraints.map(constraint => {\n          const indices = dbIndices.filter(index => {\n            return index[\"table_schema\"] === constraint[\"table_schema\"] && index[\"table_name\"] === constraint[\"table_name\"] && index[\"constraint_name\"] === constraint[\"constraint_name\"];\n          });\n          return new TableIndex({\n            view: view,\n            name: constraint[\"constraint_name\"],\n            columnNames: indices.map(i => i[\"column_name\"]),\n            isUnique: constraint[\"is_unique\"] === \"TRUE\",\n            where: constraint[\"condition\"],\n            isFulltext: false\n          });\n        });\n        return view;\n      });\n    })();\n  }\n  /**\n   * Loads all tables (with given names) from the database and creates a Table from them.\n   */\n  loadTables(tableNames) {\n    var _this58 = this;\n    return _asyncToGenerator(function* () {\n      // if no tables given then no need to proceed\n      if (tableNames && tableNames.length === 0) {\n        return [];\n      }\n      const currentSchema = yield _this58.getCurrentSchema();\n      const currentDatabase = yield _this58.getCurrentDatabase();\n      const dbTables = [];\n      if (!tableNames) {\n        const tablesSql = `SELECT \"table_schema\", \"table_name\" FROM \"information_schema\".\"tables\"`;\n        dbTables.push(...(yield _this58.query(tablesSql)));\n      } else {\n        const tablesCondition = tableNames.map(tableName => _this58.driver.parseTableName(tableName)).map(({\n          schema,\n          tableName\n        }) => {\n          return `(\"table_schema\" = '${schema || currentSchema}' AND \"table_name\" = '${tableName}')`;\n        }).join(\" OR \");\n        const tablesSql = `SELECT \"table_schema\", \"table_name\" FROM \"information_schema\".\"tables\" WHERE ` + tablesCondition;\n        dbTables.push(...(yield _this58.query(tablesSql)));\n      }\n      // if tables were not found in the db, no need to proceed\n      if (dbTables.length === 0) {\n        return [];\n      }\n      /**\n       * Uses standard SQL information_schema.columns table and postgres-specific\n       * pg_catalog.pg_attribute table to get column information.\n       * @see https://stackoverflow.com/a/19541865\n       */\n      const columnsCondition = dbTables.map(({\n        table_schema,\n        table_name\n      }) => {\n        return `(\"table_schema\" = '${table_schema}' AND \"table_name\" = '${table_name}')`;\n      }).join(\" OR \");\n      const columnsSql = `SELECT columns.*, pg_catalog.col_description(('\"' || table_catalog || '\".\"' || table_schema || '\".\"' || table_name || '\"')::regclass::oid, ordinal_position) AS description, ` + `('\"' || \"udt_schema\" || '\".\"' || \"udt_name\" || '\"')::\"regtype\" AS \"regtype\", pg_catalog.format_type(\"col_attr\".\"atttypid\", \"col_attr\".\"atttypmod\") AS \"format_type\" ` + `FROM \"information_schema\".\"columns\" ` + `LEFT JOIN \"pg_catalog\".\"pg_attribute\" AS \"col_attr\" ON \"col_attr\".\"attname\" = \"columns\".\"column_name\" ` + `AND \"col_attr\".\"attrelid\" = ( ` + `SELECT \"cls\".\"oid\" FROM \"pg_catalog\".\"pg_class\" AS \"cls\" ` + `LEFT JOIN \"pg_catalog\".\"pg_namespace\" AS \"ns\" ON \"ns\".\"oid\" = \"cls\".\"relnamespace\" ` + `WHERE \"cls\".\"relname\" = \"columns\".\"table_name\" ` + `AND \"ns\".\"nspname\" = \"columns\".\"table_schema\" ` + `) ` + `WHERE ` + columnsCondition;\n      const constraintsCondition = dbTables.map(({\n        table_schema,\n        table_name\n      }) => {\n        return `(\"ns\".\"nspname\" = '${table_schema}' AND \"t\".\"relname\" = '${table_name}')`;\n      }).join(\" OR \");\n      const constraintsSql = `SELECT \"ns\".\"nspname\" AS \"table_schema\", \"t\".\"relname\" AS \"table_name\", \"cnst\".\"conname\" AS \"constraint_name\", ` + `pg_get_constraintdef(\"cnst\".\"oid\") AS \"expression\", ` + `CASE \"cnst\".\"contype\" WHEN 'p' THEN 'PRIMARY' WHEN 'u' THEN 'UNIQUE' WHEN 'c' THEN 'CHECK' WHEN 'x' THEN 'EXCLUDE' END AS \"constraint_type\", \"a\".\"attname\" AS \"column_name\" ` + `FROM \"pg_constraint\" \"cnst\" ` + `INNER JOIN \"pg_class\" \"t\" ON \"t\".\"oid\" = \"cnst\".\"conrelid\" ` + `INNER JOIN \"pg_namespace\" \"ns\" ON \"ns\".\"oid\" = \"cnst\".\"connamespace\" ` + `LEFT JOIN \"pg_attribute\" \"a\" ON \"a\".\"attrelid\" = \"cnst\".\"conrelid\" AND \"a\".\"attnum\" = ANY (\"cnst\".\"conkey\") ` + `WHERE \"t\".\"relkind\" IN ('r', 'p') AND (${constraintsCondition})`;\n      const indicesSql = `SELECT \"ns\".\"nspname\" AS \"table_schema\", \"t\".\"relname\" AS \"table_name\", \"i\".\"relname\" AS \"constraint_name\", \"a\".\"attname\" AS \"column_name\", ` + `CASE \"ix\".\"indisunique\" WHEN 't' THEN 'TRUE' ELSE'FALSE' END AS \"is_unique\", pg_get_expr(\"ix\".\"indpred\", \"ix\".\"indrelid\") AS \"condition\", ` + `\"types\".\"typname\" AS \"type_name\" ` + `FROM \"pg_class\" \"t\" ` + `INNER JOIN \"pg_index\" \"ix\" ON \"ix\".\"indrelid\" = \"t\".\"oid\" ` + `INNER JOIN \"pg_attribute\" \"a\" ON \"a\".\"attrelid\" = \"t\".\"oid\"  AND \"a\".\"attnum\" = ANY (\"ix\".\"indkey\") ` + `INNER JOIN \"pg_namespace\" \"ns\" ON \"ns\".\"oid\" = \"t\".\"relnamespace\" ` + `INNER JOIN \"pg_class\" \"i\" ON \"i\".\"oid\" = \"ix\".\"indexrelid\" ` + `INNER JOIN \"pg_type\" \"types\" ON \"types\".\"oid\" = \"a\".\"atttypid\" ` + `LEFT JOIN \"pg_constraint\" \"cnst\" ON \"cnst\".\"conname\" = \"i\".\"relname\" ` + `WHERE \"t\".\"relkind\" IN ('r', 'p') AND \"cnst\".\"contype\" IS NULL AND (${constraintsCondition})`;\n      const foreignKeysCondition = dbTables.map(({\n        table_schema,\n        table_name\n      }) => {\n        return `(\"ns\".\"nspname\" = '${table_schema}' AND \"cl\".\"relname\" = '${table_name}')`;\n      }).join(\" OR \");\n      const hasRelispartitionColumn = yield _this58.hasSupportForPartitionedTables();\n      const isPartitionCondition = hasRelispartitionColumn ? ` AND \"cl\".\"relispartition\" = 'f'` : \"\";\n      const foreignKeysSql = `SELECT \"con\".\"conname\" AS \"constraint_name\", \"con\".\"nspname\" AS \"table_schema\", \"con\".\"relname\" AS \"table_name\", \"att2\".\"attname\" AS \"column_name\", ` + `\"ns\".\"nspname\" AS \"referenced_table_schema\", \"cl\".\"relname\" AS \"referenced_table_name\", \"att\".\"attname\" AS \"referenced_column_name\", \"con\".\"confdeltype\" AS \"on_delete\", ` + `\"con\".\"confupdtype\" AS \"on_update\", \"con\".\"condeferrable\" AS \"deferrable\", \"con\".\"condeferred\" AS \"deferred\" ` + `FROM ( ` + `SELECT UNNEST (\"con1\".\"conkey\") AS \"parent\", UNNEST (\"con1\".\"confkey\") AS \"child\", \"con1\".\"confrelid\", \"con1\".\"conrelid\", \"con1\".\"conname\", \"con1\".\"contype\", \"ns\".\"nspname\", ` + `\"cl\".\"relname\", \"con1\".\"condeferrable\", ` + `CASE WHEN \"con1\".\"condeferred\" THEN 'INITIALLY DEFERRED' ELSE 'INITIALLY IMMEDIATE' END as condeferred, ` + `CASE \"con1\".\"confdeltype\" WHEN 'a' THEN 'NO ACTION' WHEN 'r' THEN 'RESTRICT' WHEN 'c' THEN 'CASCADE' WHEN 'n' THEN 'SET NULL' WHEN 'd' THEN 'SET DEFAULT' END as \"confdeltype\", ` + `CASE \"con1\".\"confupdtype\" WHEN 'a' THEN 'NO ACTION' WHEN 'r' THEN 'RESTRICT' WHEN 'c' THEN 'CASCADE' WHEN 'n' THEN 'SET NULL' WHEN 'd' THEN 'SET DEFAULT' END as \"confupdtype\" ` + `FROM \"pg_class\" \"cl\" ` + `INNER JOIN \"pg_namespace\" \"ns\" ON \"cl\".\"relnamespace\" = \"ns\".\"oid\" ` + `INNER JOIN \"pg_constraint\" \"con1\" ON \"con1\".\"conrelid\" = \"cl\".\"oid\" ` + `WHERE \"con1\".\"contype\" = 'f' AND (${foreignKeysCondition}) ` + `) \"con\" ` + `INNER JOIN \"pg_attribute\" \"att\" ON \"att\".\"attrelid\" = \"con\".\"confrelid\" AND \"att\".\"attnum\" = \"con\".\"child\" ` + `INNER JOIN \"pg_class\" \"cl\" ON \"cl\".\"oid\" = \"con\".\"confrelid\" ${isPartitionCondition}` + `INNER JOIN \"pg_namespace\" \"ns\" ON \"cl\".\"relnamespace\" = \"ns\".\"oid\" ` + `INNER JOIN \"pg_attribute\" \"att2\" ON \"att2\".\"attrelid\" = \"con\".\"conrelid\" AND \"att2\".\"attnum\" = \"con\".\"parent\"`;\n      const [dbColumns, dbConstraints, dbIndices, dbForeignKeys] = yield Promise.all([_this58.query(columnsSql), _this58.query(constraintsSql), _this58.query(indicesSql), _this58.query(foreignKeysSql)]);\n      // create tables for loaded tables\n      return Promise.all(dbTables.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (dbTable) {\n          const table = new Table();\n          const getSchemaFromKey = (dbObject, key) => {\n            return dbObject[key] === currentSchema && (!_this58.driver.options.schema || _this58.driver.options.schema === currentSchema) ? undefined : dbObject[key];\n          };\n          // We do not need to join schema name, when database is by default.\n          const schema = getSchemaFromKey(dbTable, \"table_schema\");\n          table.database = currentDatabase;\n          table.schema = dbTable[\"table_schema\"];\n          table.name = _this58.driver.buildTableName(dbTable[\"table_name\"], schema);\n          // create columns from the loaded columns\n          table.columns = yield Promise.all(dbColumns.filter(dbColumn => dbColumn[\"table_name\"] === dbTable[\"table_name\"] && dbColumn[\"table_schema\"] === dbTable[\"table_schema\"]).map( /*#__PURE__*/function () {\n            var _ref2 = _asyncToGenerator(function* (dbColumn) {\n              const columnConstraints = dbConstraints.filter(dbConstraint => {\n                return dbConstraint[\"table_name\"] === dbColumn[\"table_name\"] && dbConstraint[\"table_schema\"] === dbColumn[\"table_schema\"] && dbConstraint[\"column_name\"] === dbColumn[\"column_name\"];\n              });\n              const tableColumn = new TableColumn();\n              tableColumn.name = dbColumn[\"column_name\"];\n              tableColumn.type = dbColumn[\"regtype\"].toLowerCase();\n              if (tableColumn.type === \"numeric\" || tableColumn.type === \"decimal\" || tableColumn.type === \"float\") {\n                // If one of these properties was set, and another was not, Postgres sets '0' in to unspecified property\n                // we set 'undefined' in to unspecified property to avoid changing column on sync\n                if (dbColumn[\"numeric_precision\"] !== null && !_this58.isDefaultColumnPrecision(table, tableColumn, dbColumn[\"numeric_precision\"])) {\n                  tableColumn.precision = dbColumn[\"numeric_precision\"];\n                } else if (dbColumn[\"numeric_scale\"] !== null && !_this58.isDefaultColumnScale(table, tableColumn, dbColumn[\"numeric_scale\"])) {\n                  tableColumn.precision = undefined;\n                }\n                if (dbColumn[\"numeric_scale\"] !== null && !_this58.isDefaultColumnScale(table, tableColumn, dbColumn[\"numeric_scale\"])) {\n                  tableColumn.scale = dbColumn[\"numeric_scale\"];\n                } else if (dbColumn[\"numeric_precision\"] !== null && !_this58.isDefaultColumnPrecision(table, tableColumn, dbColumn[\"numeric_precision\"])) {\n                  tableColumn.scale = undefined;\n                }\n              }\n              if (tableColumn.type === \"interval\" || tableColumn.type === \"time without time zone\" || tableColumn.type === \"time with time zone\" || tableColumn.type === \"timestamp without time zone\" || tableColumn.type === \"timestamp with time zone\") {\n                tableColumn.precision = !_this58.isDefaultColumnPrecision(table, tableColumn, dbColumn[\"datetime_precision\"]) ? dbColumn[\"datetime_precision\"] : undefined;\n              }\n              // check if column has user-defined data type.\n              // NOTE: if ENUM type defined with \"array:true\" it comes with ARRAY type instead of USER-DEFINED\n              if (dbColumn[\"data_type\"] === \"USER-DEFINED\" || dbColumn[\"data_type\"] === \"ARRAY\") {\n                const {\n                  name\n                } = yield _this58.getUserDefinedTypeName(table, tableColumn);\n                // check if `enumName` is specified by user\n                const builtEnumName = _this58.buildEnumName(table, tableColumn, false, true);\n                const enumName = builtEnumName !== name ? name : undefined;\n                // check if type is ENUM\n                const sql = `SELECT \"e\".\"enumlabel\" AS \"value\" FROM \"pg_enum\" \"e\" ` + `INNER JOIN \"pg_type\" \"t\" ON \"t\".\"oid\" = \"e\".\"enumtypid\" ` + `INNER JOIN \"pg_namespace\" \"n\" ON \"n\".\"oid\" = \"t\".\"typnamespace\" ` + `WHERE \"n\".\"nspname\" = '${dbTable[\"table_schema\"]}' AND \"t\".\"typname\" = '${enumName || name}'`;\n                const results = yield _this58.query(sql);\n                if (results.length) {\n                  tableColumn.type = \"enum\";\n                  tableColumn.enum = results.map(result => result[\"value\"]);\n                  tableColumn.enumName = enumName;\n                }\n                if (dbColumn[\"data_type\"] === \"ARRAY\") {\n                  tableColumn.isArray = true;\n                  const type = tableColumn.type.replace(\"[]\", \"\");\n                  tableColumn.type = _this58.connection.driver.normalizeType({\n                    type: type\n                  });\n                }\n              }\n              if (tableColumn.type === \"geometry\" || tableColumn.type === \"geography\") {\n                const sql = `SELECT * FROM (` + `SELECT \"f_table_schema\" \"table_schema\", \"f_table_name\" \"table_name\", ` + `\"f_${tableColumn.type}_column\" \"column_name\", \"srid\", \"type\" ` + `FROM \"${tableColumn.type}_columns\"` + `) AS _ ` + `WHERE \"column_name\" = '${dbColumn[\"column_name\"]}' AND ` + `\"table_schema\" = '${dbColumn[\"table_schema\"]}' AND ` + `\"table_name\" = '${dbColumn[\"table_name\"]}'`;\n                const results = yield _this58.query(sql);\n                if (results.length > 0) {\n                  tableColumn.spatialFeatureType = results[0].type;\n                  tableColumn.srid = results[0].srid;\n                }\n              }\n              // check only columns that have length property\n              if (_this58.driver.withLengthColumnTypes.indexOf(tableColumn.type) !== -1) {\n                let length;\n                if (tableColumn.isArray) {\n                  const match = /\\((\\d+)\\)/.exec(dbColumn[\"format_type\"]);\n                  length = match ? match[1] : undefined;\n                } else if (dbColumn[\"character_maximum_length\"]) {\n                  length = dbColumn[\"character_maximum_length\"].toString();\n                }\n                if (length) {\n                  tableColumn.length = !_this58.isDefaultColumnLength(table, tableColumn, length) ? length : \"\";\n                }\n              }\n              tableColumn.isNullable = dbColumn[\"is_nullable\"] === \"YES\";\n              const primaryConstraint = columnConstraints.find(constraint => constraint[\"constraint_type\"] === \"PRIMARY\");\n              if (primaryConstraint) {\n                tableColumn.isPrimary = true;\n                // find another columns involved in primary key constraint\n                const anotherPrimaryConstraints = dbConstraints.filter(constraint => constraint[\"table_name\"] === dbColumn[\"table_name\"] && constraint[\"table_schema\"] === dbColumn[\"table_schema\"] && constraint[\"column_name\"] !== dbColumn[\"column_name\"] && constraint[\"constraint_type\"] === \"PRIMARY\");\n                // collect all column names\n                const columnNames = anotherPrimaryConstraints.map(constraint => constraint[\"column_name\"]);\n                columnNames.push(dbColumn[\"column_name\"]);\n                // build default primary key constraint name\n                const pkName = _this58.connection.namingStrategy.primaryKeyName(table, columnNames);\n                // if primary key has user-defined constraint name, write it in table column\n                if (primaryConstraint[\"constraint_name\"] !== pkName) {\n                  tableColumn.primaryKeyConstraintName = primaryConstraint[\"constraint_name\"];\n                }\n              }\n              const uniqueConstraints = columnConstraints.filter(constraint => constraint[\"constraint_type\"] === \"UNIQUE\");\n              const isConstraintComposite = uniqueConstraints.every(uniqueConstraint => {\n                return dbConstraints.some(dbConstraint => dbConstraint[\"constraint_type\"] === \"UNIQUE\" && dbConstraint[\"constraint_name\"] === uniqueConstraint[\"constraint_name\"] && dbConstraint[\"column_name\"] !== dbColumn[\"column_name\"]);\n              });\n              tableColumn.isUnique = uniqueConstraints.length > 0 && !isConstraintComposite;\n              if (dbColumn.is_identity === \"YES\") {\n                // Postgres 10+ Identity column\n                tableColumn.isGenerated = true;\n                tableColumn.generationStrategy = \"identity\";\n                tableColumn.generatedIdentity = dbColumn.identity_generation;\n              } else if (dbColumn[\"column_default\"] !== null && dbColumn[\"column_default\"] !== undefined) {\n                const serialDefaultName = `nextval('${_this58.buildSequenceName(table, dbColumn[\"column_name\"])}'::regclass)`;\n                const serialDefaultPath = `nextval('${_this58.buildSequencePath(table, dbColumn[\"column_name\"])}'::regclass)`;\n                const defaultWithoutQuotes = dbColumn[\"column_default\"].replace(/\"/g, \"\");\n                if (defaultWithoutQuotes === serialDefaultName || defaultWithoutQuotes === serialDefaultPath) {\n                  tableColumn.isGenerated = true;\n                  tableColumn.generationStrategy = \"increment\";\n                } else if (dbColumn[\"column_default\"] === \"gen_random_uuid()\" || /^uuid_generate_v\\d\\(\\)/.test(dbColumn[\"column_default\"])) {\n                  if (tableColumn.type === \"uuid\") {\n                    tableColumn.isGenerated = true;\n                    tableColumn.generationStrategy = \"uuid\";\n                  } else {\n                    tableColumn.default = dbColumn[\"column_default\"];\n                  }\n                } else if (dbColumn[\"column_default\"] === \"now()\" || dbColumn[\"column_default\"].indexOf(\"'now'::text\") !== -1) {\n                  tableColumn.default = dbColumn[\"column_default\"];\n                } else {\n                  tableColumn.default = dbColumn[\"column_default\"].replace(/::[\\w\\s.\\[\\]\\-\"]+/g, \"\");\n                  tableColumn.default = tableColumn.default.replace(/^(-?\\d+)$/, \"'$1'\");\n                }\n              }\n              if (dbColumn[\"is_generated\"] === \"ALWAYS\" && dbColumn[\"generation_expression\"]) {\n                // In postgres there is no VIRTUAL generated column type\n                tableColumn.generatedType = \"STORED\";\n                // We cannot relay on information_schema.columns.generation_expression, because it is formatted different.\n                const asExpressionQuery = yield _this58.selectTypeormMetadataSql({\n                  database: currentDatabase,\n                  schema: dbTable[\"table_schema\"],\n                  table: dbTable[\"table_name\"],\n                  type: MetadataTableType.GENERATED_COLUMN,\n                  name: tableColumn.name\n                });\n                const results = yield _this58.query(asExpressionQuery.query, asExpressionQuery.parameters);\n                if (results[0] && results[0].value) {\n                  tableColumn.asExpression = results[0].value;\n                } else {\n                  tableColumn.asExpression = \"\";\n                }\n              }\n              tableColumn.comment = dbColumn[\"description\"] ? dbColumn[\"description\"] : undefined;\n              if (dbColumn[\"character_set_name\"]) tableColumn.charset = dbColumn[\"character_set_name\"];\n              if (dbColumn[\"collation_name\"]) tableColumn.collation = dbColumn[\"collation_name\"];\n              return tableColumn;\n            });\n            return function (_x2) {\n              return _ref2.apply(this, arguments);\n            };\n          }()));\n          // find unique constraints of table, group them by constraint name and build TableUnique.\n          const tableUniqueConstraints = OrmUtils.uniq(dbConstraints.filter(dbConstraint => {\n            return dbConstraint[\"table_name\"] === dbTable[\"table_name\"] && dbConstraint[\"table_schema\"] === dbTable[\"table_schema\"] && dbConstraint[\"constraint_type\"] === \"UNIQUE\";\n          }), dbConstraint => dbConstraint[\"constraint_name\"]);\n          table.uniques = tableUniqueConstraints.map(constraint => {\n            const uniques = dbConstraints.filter(dbC => dbC[\"constraint_name\"] === constraint[\"constraint_name\"]);\n            return new TableUnique({\n              name: constraint[\"constraint_name\"],\n              columnNames: uniques.map(u => u[\"column_name\"]),\n              deferrable: constraint[\"deferrable\"] ? constraint[\"deferred\"] : undefined\n            });\n          });\n          // find check constraints of table, group them by constraint name and build TableCheck.\n          const tableCheckConstraints = OrmUtils.uniq(dbConstraints.filter(dbConstraint => {\n            return dbConstraint[\"table_name\"] === dbTable[\"table_name\"] && dbConstraint[\"table_schema\"] === dbTable[\"table_schema\"] && dbConstraint[\"constraint_type\"] === \"CHECK\";\n          }), dbConstraint => dbConstraint[\"constraint_name\"]);\n          table.checks = tableCheckConstraints.map(constraint => {\n            const checks = dbConstraints.filter(dbC => dbC[\"constraint_name\"] === constraint[\"constraint_name\"]);\n            return new TableCheck({\n              name: constraint[\"constraint_name\"],\n              columnNames: checks.map(c => c[\"column_name\"]),\n              expression: constraint[\"expression\"].replace(/^\\s*CHECK\\s*\\((.*)\\)\\s*$/i, \"$1\")\n            });\n          });\n          // find exclusion constraints of table, group them by constraint name and build TableExclusion.\n          const tableExclusionConstraints = OrmUtils.uniq(dbConstraints.filter(dbConstraint => {\n            return dbConstraint[\"table_name\"] === dbTable[\"table_name\"] && dbConstraint[\"table_schema\"] === dbTable[\"table_schema\"] && dbConstraint[\"constraint_type\"] === \"EXCLUDE\";\n          }), dbConstraint => dbConstraint[\"constraint_name\"]);\n          table.exclusions = tableExclusionConstraints.map(constraint => {\n            return new TableExclusion({\n              name: constraint[\"constraint_name\"],\n              expression: constraint[\"expression\"].substring(8) // trim EXCLUDE from start of expression\n            });\n          });\n          // find foreign key constraints of table, group them by constraint name and build TableForeignKey.\n          const tableForeignKeyConstraints = OrmUtils.uniq(dbForeignKeys.filter(dbForeignKey => {\n            return dbForeignKey[\"table_name\"] === dbTable[\"table_name\"] && dbForeignKey[\"table_schema\"] === dbTable[\"table_schema\"];\n          }), dbForeignKey => dbForeignKey[\"constraint_name\"]);\n          table.foreignKeys = tableForeignKeyConstraints.map(dbForeignKey => {\n            const foreignKeys = dbForeignKeys.filter(dbFk => dbFk[\"constraint_name\"] === dbForeignKey[\"constraint_name\"]);\n            // if referenced table located in currently used schema, we don't need to concat schema name to table name.\n            const schema = getSchemaFromKey(dbForeignKey, \"referenced_table_schema\");\n            const referencedTableName = _this58.driver.buildTableName(dbForeignKey[\"referenced_table_name\"], schema);\n            return new TableForeignKey({\n              name: dbForeignKey[\"constraint_name\"],\n              columnNames: foreignKeys.map(dbFk => dbFk[\"column_name\"]),\n              referencedSchema: dbForeignKey[\"referenced_table_schema\"],\n              referencedTableName: referencedTableName,\n              referencedColumnNames: foreignKeys.map(dbFk => dbFk[\"referenced_column_name\"]),\n              onDelete: dbForeignKey[\"on_delete\"],\n              onUpdate: dbForeignKey[\"on_update\"],\n              deferrable: dbForeignKey[\"deferrable\"] ? dbForeignKey[\"deferred\"] : undefined\n            });\n          });\n          // find index constraints of table, group them by constraint name and build TableIndex.\n          const tableIndexConstraints = OrmUtils.uniq(dbIndices.filter(dbIndex => {\n            return dbIndex[\"table_name\"] === dbTable[\"table_name\"] && dbIndex[\"table_schema\"] === dbTable[\"table_schema\"];\n          }), dbIndex => dbIndex[\"constraint_name\"]);\n          table.indices = tableIndexConstraints.map(constraint => {\n            const indices = dbIndices.filter(index => {\n              return index[\"table_schema\"] === constraint[\"table_schema\"] && index[\"table_name\"] === constraint[\"table_name\"] && index[\"constraint_name\"] === constraint[\"constraint_name\"];\n            });\n            return new TableIndex({\n              table: table,\n              name: constraint[\"constraint_name\"],\n              columnNames: indices.map(i => i[\"column_name\"]),\n              isUnique: constraint[\"is_unique\"] === \"TRUE\",\n              where: constraint[\"condition\"],\n              isSpatial: indices.every(i => _this58.driver.spatialTypes.indexOf(i[\"type_name\"]) >= 0),\n              isFulltext: false\n            });\n          });\n          return table;\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n    })();\n  }\n  /**\n   * Builds create table sql.\n   */\n  createTableSql(table, createForeignKeys) {\n    const columnDefinitions = table.columns.map(column => this.buildCreateColumnSql(table, column)).join(\", \");\n    let sql = `CREATE TABLE ${this.escapePath(table)} (${columnDefinitions}`;\n    table.columns.filter(column => column.isUnique).forEach(column => {\n      const isUniqueExist = table.uniques.some(unique => unique.columnNames.length === 1 && unique.columnNames[0] === column.name);\n      if (!isUniqueExist) table.uniques.push(new TableUnique({\n        name: this.connection.namingStrategy.uniqueConstraintName(table, [column.name]),\n        columnNames: [column.name]\n      }));\n    });\n    if (table.uniques.length > 0) {\n      const uniquesSql = table.uniques.map(unique => {\n        const uniqueName = unique.name ? unique.name : this.connection.namingStrategy.uniqueConstraintName(table, unique.columnNames);\n        const columnNames = unique.columnNames.map(columnName => `\"${columnName}\"`).join(\", \");\n        let constraint = `CONSTRAINT \"${uniqueName}\" UNIQUE (${columnNames})`;\n        if (unique.deferrable) constraint += ` DEFERRABLE ${unique.deferrable}`;\n        return constraint;\n      }).join(\", \");\n      sql += `, ${uniquesSql}`;\n    }\n    if (table.checks.length > 0) {\n      const checksSql = table.checks.map(check => {\n        const checkName = check.name ? check.name : this.connection.namingStrategy.checkConstraintName(table, check.expression);\n        return `CONSTRAINT \"${checkName}\" CHECK (${check.expression})`;\n      }).join(\", \");\n      sql += `, ${checksSql}`;\n    }\n    if (table.exclusions.length > 0) {\n      const exclusionsSql = table.exclusions.map(exclusion => {\n        const exclusionName = exclusion.name ? exclusion.name : this.connection.namingStrategy.exclusionConstraintName(table, exclusion.expression);\n        return `CONSTRAINT \"${exclusionName}\" EXCLUDE ${exclusion.expression}`;\n      }).join(\", \");\n      sql += `, ${exclusionsSql}`;\n    }\n    if (table.foreignKeys.length > 0 && createForeignKeys) {\n      const foreignKeysSql = table.foreignKeys.map(fk => {\n        const columnNames = fk.columnNames.map(columnName => `\"${columnName}\"`).join(\", \");\n        if (!fk.name) fk.name = this.connection.namingStrategy.foreignKeyName(table, fk.columnNames, this.getTablePath(fk), fk.referencedColumnNames);\n        const referencedColumnNames = fk.referencedColumnNames.map(columnName => `\"${columnName}\"`).join(\", \");\n        let constraint = `CONSTRAINT \"${fk.name}\" FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(fk))} (${referencedColumnNames})`;\n        if (fk.onDelete) constraint += ` ON DELETE ${fk.onDelete}`;\n        if (fk.onUpdate) constraint += ` ON UPDATE ${fk.onUpdate}`;\n        if (fk.deferrable) constraint += ` DEFERRABLE ${fk.deferrable}`;\n        return constraint;\n      }).join(\", \");\n      sql += `, ${foreignKeysSql}`;\n    }\n    const primaryColumns = table.columns.filter(column => column.isPrimary);\n    if (primaryColumns.length > 0) {\n      const primaryKeyName = primaryColumns[0].primaryKeyConstraintName ? primaryColumns[0].primaryKeyConstraintName : this.connection.namingStrategy.primaryKeyName(table, primaryColumns.map(column => column.name));\n      const columnNames = primaryColumns.map(column => `\"${column.name}\"`).join(\", \");\n      sql += `, CONSTRAINT \"${primaryKeyName}\" PRIMARY KEY (${columnNames})`;\n    }\n    sql += `)`;\n    table.columns.filter(it => it.comment).forEach(it => sql += `; COMMENT ON COLUMN ${this.escapePath(table)}.\"${it.name}\" IS ${this.escapeComment(it.comment)}`);\n    return new Query(sql);\n  }\n  /**\n   * Loads Postgres version.\n   */\n  getVersion() {\n    var _this59 = this;\n    return _asyncToGenerator(function* () {\n      const result = yield _this59.query(`SELECT version()`);\n      return result[0][\"version\"].replace(/^PostgreSQL ([\\d\\.]+) .*$/, \"$1\");\n    })();\n  }\n  /**\n   * Builds drop table sql.\n   */\n  dropTableSql(tableOrPath) {\n    return new Query(`DROP TABLE ${this.escapePath(tableOrPath)}`);\n  }\n  createViewSql(view) {\n    const materializedClause = view.materialized ? \"MATERIALIZED \" : \"\";\n    const viewName = this.escapePath(view);\n    if (typeof view.expression === \"string\") {\n      return new Query(`CREATE ${materializedClause}VIEW ${viewName} AS ${view.expression}`);\n    } else {\n      return new Query(`CREATE ${materializedClause}VIEW ${viewName} AS ${view.expression(this.connection).getQuery()}`);\n    }\n  }\n  insertViewDefinitionSql(view) {\n    var _this60 = this;\n    return _asyncToGenerator(function* () {\n      const currentSchema = yield _this60.getCurrentSchema();\n      let {\n        schema,\n        tableName: name\n      } = _this60.driver.parseTableName(view);\n      if (!schema) {\n        schema = currentSchema;\n      }\n      const type = view.materialized ? MetadataTableType.MATERIALIZED_VIEW : MetadataTableType.VIEW;\n      const expression = typeof view.expression === \"string\" ? view.expression.trim() : view.expression(_this60.connection).getQuery();\n      return _this60.insertTypeormMetadataSql({\n        type,\n        schema,\n        name,\n        value: expression\n      });\n    })();\n  }\n  /**\n   * Builds drop view sql.\n   */\n  dropViewSql(view) {\n    const materializedClause = view.materialized ? \"MATERIALIZED \" : \"\";\n    return new Query(`DROP ${materializedClause}VIEW ${this.escapePath(view)}`);\n  }\n  /**\n   * Builds remove view sql.\n   */\n  deleteViewDefinitionSql(view) {\n    var _this61 = this;\n    return _asyncToGenerator(function* () {\n      const currentSchema = yield _this61.getCurrentSchema();\n      let {\n        schema,\n        tableName: name\n      } = _this61.driver.parseTableName(view);\n      if (!schema) {\n        schema = currentSchema;\n      }\n      const type = view.materialized ? MetadataTableType.MATERIALIZED_VIEW : MetadataTableType.VIEW;\n      return _this61.deleteTypeormMetadataSql({\n        type,\n        schema,\n        name\n      });\n    })();\n  }\n  /**\n   * Drops ENUM type from given schemas.\n   */\n  dropEnumTypes(schemaNames) {\n    var _this62 = this;\n    return _asyncToGenerator(function* () {\n      const selectDropsQuery = `SELECT 'DROP TYPE IF EXISTS \"' || n.nspname || '\".\"' || t.typname || '\" CASCADE;' as \"query\" FROM \"pg_type\" \"t\" ` + `INNER JOIN \"pg_enum\" \"e\" ON \"e\".\"enumtypid\" = \"t\".\"oid\" ` + `INNER JOIN \"pg_namespace\" \"n\" ON \"n\".\"oid\" = \"t\".\"typnamespace\" ` + `WHERE \"n\".\"nspname\" IN (${schemaNames}) GROUP BY \"n\".\"nspname\", \"t\".\"typname\"`;\n      const dropQueries = yield _this62.query(selectDropsQuery);\n      yield Promise.all(dropQueries.map(q => _this62.query(q[\"query\"])));\n    })();\n  }\n  /**\n   * Checks if enum with the given name exist in the database.\n   */\n  hasEnumType(table, column) {\n    var _this63 = this;\n    return _asyncToGenerator(function* () {\n      let {\n        schema\n      } = _this63.driver.parseTableName(table);\n      if (!schema) {\n        schema = yield _this63.getCurrentSchema();\n      }\n      const enumName = _this63.buildEnumName(table, column, false, true);\n      const sql = `SELECT \"n\".\"nspname\", \"t\".\"typname\" FROM \"pg_type\" \"t\" ` + `INNER JOIN \"pg_namespace\" \"n\" ON \"n\".\"oid\" = \"t\".\"typnamespace\" ` + `WHERE \"n\".\"nspname\" = '${schema}' AND \"t\".\"typname\" = '${enumName}'`;\n      const result = yield _this63.query(sql);\n      return result.length ? true : false;\n    })();\n  }\n  /**\n   * Builds create ENUM type sql.\n   */\n  createEnumTypeSql(table, column, enumName) {\n    if (!enumName) enumName = this.buildEnumName(table, column);\n    const enumValues = column.enum.map(value => `'${value.replace(\"'\", \"''\")}'`).join(\", \");\n    return new Query(`CREATE TYPE ${enumName} AS ENUM(${enumValues})`);\n  }\n  /**\n   * Builds create ENUM type sql.\n   */\n  dropEnumTypeSql(table, column, enumName) {\n    if (!enumName) enumName = this.buildEnumName(table, column);\n    return new Query(`DROP TYPE ${enumName}`);\n  }\n  /**\n   * Builds create index sql.\n   */\n  createIndexSql(table, index) {\n    const columns = index.columnNames.map(columnName => `\"${columnName}\"`).join(\", \");\n    return new Query(`CREATE ${index.isUnique ? \"UNIQUE \" : \"\"}INDEX \"${index.name}\" ON ${this.escapePath(table)} ${index.isSpatial ? \"USING GiST \" : \"\"}(${columns}) ${index.where ? \"WHERE \" + index.where : \"\"}`);\n  }\n  /**\n   * Builds create view index sql.\n   */\n  createViewIndexSql(view, index) {\n    const columns = index.columnNames.map(columnName => `\"${columnName}\"`).join(\", \");\n    return new Query(`CREATE ${index.isUnique ? \"UNIQUE \" : \"\"}INDEX \"${index.name}\" ON ${this.escapePath(view)} (${columns}) ${index.where ? \"WHERE \" + index.where : \"\"}`);\n  }\n  /**\n   * Builds drop index sql.\n   */\n  dropIndexSql(table, indexOrName) {\n    let indexName = InstanceChecker.isTableIndex(indexOrName) ? indexOrName.name : indexOrName;\n    const {\n      schema\n    } = this.driver.parseTableName(table);\n    return schema ? new Query(`DROP INDEX \"${schema}\".\"${indexName}\"`) : new Query(`DROP INDEX \"${indexName}\"`);\n  }\n  /**\n   * Builds create primary key sql.\n   */\n  createPrimaryKeySql(table, columnNames, constraintName) {\n    const primaryKeyName = constraintName ? constraintName : this.connection.namingStrategy.primaryKeyName(table, columnNames);\n    const columnNamesString = columnNames.map(columnName => `\"${columnName}\"`).join(\", \");\n    return new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${primaryKeyName}\" PRIMARY KEY (${columnNamesString})`);\n  }\n  /**\n   * Builds drop primary key sql.\n   */\n  dropPrimaryKeySql(table) {\n    if (!table.primaryColumns.length) throw new TypeORMError(`Table ${table} has no primary keys.`);\n    const columnNames = table.primaryColumns.map(column => column.name);\n    const constraintName = table.primaryColumns[0].primaryKeyConstraintName;\n    const primaryKeyName = constraintName ? constraintName : this.connection.namingStrategy.primaryKeyName(table, columnNames);\n    return new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${primaryKeyName}\"`);\n  }\n  /**\n   * Builds create unique constraint sql.\n   */\n  createUniqueConstraintSql(table, uniqueConstraint) {\n    const columnNames = uniqueConstraint.columnNames.map(column => `\"` + column + `\"`).join(\", \");\n    let sql = `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${uniqueConstraint.name}\" UNIQUE (${columnNames})`;\n    if (uniqueConstraint.deferrable) sql += ` DEFERRABLE ${uniqueConstraint.deferrable}`;\n    return new Query(sql);\n  }\n  /**\n   * Builds drop unique constraint sql.\n   */\n  dropUniqueConstraintSql(table, uniqueOrName) {\n    const uniqueName = InstanceChecker.isTableUnique(uniqueOrName) ? uniqueOrName.name : uniqueOrName;\n    return new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${uniqueName}\"`);\n  }\n  /**\n   * Builds create check constraint sql.\n   */\n  createCheckConstraintSql(table, checkConstraint) {\n    return new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${checkConstraint.name}\" CHECK (${checkConstraint.expression})`);\n  }\n  /**\n   * Builds drop check constraint sql.\n   */\n  dropCheckConstraintSql(table, checkOrName) {\n    const checkName = InstanceChecker.isTableCheck(checkOrName) ? checkOrName.name : checkOrName;\n    return new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${checkName}\"`);\n  }\n  /**\n   * Builds create exclusion constraint sql.\n   */\n  createExclusionConstraintSql(table, exclusionConstraint) {\n    return new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${exclusionConstraint.name}\" EXCLUDE ${exclusionConstraint.expression}`);\n  }\n  /**\n   * Builds drop exclusion constraint sql.\n   */\n  dropExclusionConstraintSql(table, exclusionOrName) {\n    const exclusionName = InstanceChecker.isTableExclusion(exclusionOrName) ? exclusionOrName.name : exclusionOrName;\n    return new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${exclusionName}\"`);\n  }\n  /**\n   * Builds create foreign key sql.\n   */\n  createForeignKeySql(table, foreignKey) {\n    const columnNames = foreignKey.columnNames.map(column => `\"` + column + `\"`).join(\", \");\n    const referencedColumnNames = foreignKey.referencedColumnNames.map(column => `\"` + column + `\"`).join(\",\");\n    let sql = `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${foreignKey.name}\" FOREIGN KEY (${columnNames}) ` + `REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;\n    if (foreignKey.onDelete) sql += ` ON DELETE ${foreignKey.onDelete}`;\n    if (foreignKey.onUpdate) sql += ` ON UPDATE ${foreignKey.onUpdate}`;\n    if (foreignKey.deferrable) sql += ` DEFERRABLE ${foreignKey.deferrable}`;\n    return new Query(sql);\n  }\n  /**\n   * Builds drop foreign key sql.\n   */\n  dropForeignKeySql(table, foreignKeyOrName) {\n    const foreignKeyName = InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName.name : foreignKeyOrName;\n    return new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${foreignKeyName}\"`);\n  }\n  /**\n   * Builds sequence name from given table and column.\n   */\n  buildSequenceName(table, columnOrName) {\n    const {\n      tableName\n    } = this.driver.parseTableName(table);\n    const columnName = InstanceChecker.isTableColumn(columnOrName) ? columnOrName.name : columnOrName;\n    let seqName = `${tableName}_${columnName}_seq`;\n    if (seqName.length > this.connection.driver.maxAliasLength) {\n      // note doesn't yet handle corner cases where .length differs from number of UTF-8 bytes\n      seqName = `${tableName.substring(0, 29)}_${columnName.substring(0, Math.max(29, 63 - table.name.length - 5))}_seq`;\n    }\n    return seqName;\n  }\n  buildSequencePath(table, columnOrName) {\n    const {\n      schema\n    } = this.driver.parseTableName(table);\n    return schema ? `${schema}.${this.buildSequenceName(table, columnOrName)}` : this.buildSequenceName(table, columnOrName);\n  }\n  /**\n   * Builds ENUM type name from given table and column.\n   */\n  buildEnumName(table, column, withSchema = true, disableEscape, toOld) {\n    const {\n      schema,\n      tableName\n    } = this.driver.parseTableName(table);\n    let enumName = column.enumName ? column.enumName : `${tableName}_${column.name.toLowerCase()}_enum`;\n    if (schema && withSchema) enumName = `${schema}.${enumName}`;\n    if (toOld) enumName = enumName + \"_old\";\n    return enumName.split(\".\").map(i => {\n      return disableEscape ? i : `\"${i}\"`;\n    }).join(\".\");\n  }\n  getUserDefinedTypeName(table, column) {\n    var _this64 = this;\n    return _asyncToGenerator(function* () {\n      let {\n        schema,\n        tableName: name\n      } = _this64.driver.parseTableName(table);\n      if (!schema) {\n        schema = yield _this64.getCurrentSchema();\n      }\n      const result = yield _this64.query(`SELECT \"udt_schema\", \"udt_name\" ` + `FROM \"information_schema\".\"columns\" WHERE \"table_schema\" = '${schema}' AND \"table_name\" = '${name}' AND \"column_name\"='${column.name}'`);\n      // docs: https://www.postgresql.org/docs/current/xtypes.html\n      // When you define a new base type, PostgreSQL automatically provides support for arrays of that type.\n      // The array type typically has the same name as the base type with the underscore character (_) prepended.\n      // ----\n      // so, we must remove this underscore character from enum type name\n      let udtName = result[0][\"udt_name\"];\n      if (udtName.indexOf(\"_\") === 0) {\n        udtName = udtName.substr(1, udtName.length);\n      }\n      return {\n        schema: result[0][\"udt_schema\"],\n        name: udtName\n      };\n    })();\n  }\n  /**\n   * Escapes a given comment so it's safe to include in a query.\n   */\n  escapeComment(comment) {\n    if (!comment || comment.length === 0) {\n      return \"NULL\";\n    }\n    comment = comment.replace(/'/g, \"''\").replace(/\\u0000/g, \"\"); // Null bytes aren't allowed in comments\n    return `'${comment}'`;\n  }\n  /**\n   * Escapes given table or view path.\n   */\n  escapePath(target) {\n    const {\n      schema,\n      tableName\n    } = this.driver.parseTableName(target);\n    if (schema && schema !== this.driver.searchSchema) {\n      return `\"${schema}\".\"${tableName}\"`;\n    }\n    return `\"${tableName}\"`;\n  }\n  /**\n   * Get the table name with table schema\n   * Note: Without ' or \"\n   */\n  getTableNameWithSchema(target) {\n    var _this65 = this;\n    return _asyncToGenerator(function* () {\n      const tableName = InstanceChecker.isTable(target) ? target.name : target;\n      if (tableName.indexOf(\".\") === -1) {\n        const schemaResult = yield _this65.query(`SELECT current_schema()`);\n        const schema = schemaResult[0][\"current_schema\"];\n        return `${schema}.${tableName}`;\n      } else {\n        return `${tableName.split(\".\")[0]}.${tableName.split(\".\")[1]}`;\n      }\n    })();\n  }\n  /**\n   * Builds a query for create column.\n   */\n  buildCreateColumnSql(table, column) {\n    let c = '\"' + column.name + '\"';\n    if (column.isGenerated === true && column.generationStrategy !== \"uuid\") {\n      if (column.generationStrategy === \"identity\") {\n        // Postgres 10+ Identity generated column\n        const generatedIdentityOrDefault = column.generatedIdentity || \"BY DEFAULT\";\n        c += ` ${column.type} GENERATED ${generatedIdentityOrDefault} AS IDENTITY`;\n      } else {\n        // classic SERIAL primary column\n        if (column.type === \"integer\" || column.type === \"int\" || column.type === \"int4\") c += \" SERIAL\";\n        if (column.type === \"smallint\" || column.type === \"int2\") c += \" SMALLSERIAL\";\n        if (column.type === \"bigint\" || column.type === \"int8\") c += \" BIGSERIAL\";\n      }\n    }\n    if (column.type === \"enum\" || column.type === \"simple-enum\") {\n      c += \" \" + this.buildEnumName(table, column);\n      if (column.isArray) c += \" array\";\n    } else if (!column.isGenerated || column.type === \"uuid\") {\n      c += \" \" + this.connection.driver.createFullType(column);\n    }\n    // Postgres only supports the stored generated column type\n    if (column.generatedType === \"STORED\" && column.asExpression) {\n      c += ` GENERATED ALWAYS AS (${column.asExpression}) STORED`;\n    }\n    if (column.charset) c += ' CHARACTER SET \"' + column.charset + '\"';\n    if (column.collation) c += ' COLLATE \"' + column.collation + '\"';\n    if (column.isNullable !== true) c += \" NOT NULL\";\n    if (column.default !== undefined && column.default !== null) c += \" DEFAULT \" + column.default;\n    if (column.isGenerated && column.generationStrategy === \"uuid\" && !column.default) c += ` DEFAULT ${this.driver.uuidGenerator}`;\n    return c;\n  }\n  /**\n   * Checks if the PostgreSQL server has support for partitioned tables\n   */\n  hasSupportForPartitionedTables() {\n    var _this66 = this;\n    return _asyncToGenerator(function* () {\n      const result = yield _this66.query(`SELECT TRUE FROM information_schema.columns WHERE table_name = 'pg_class' and column_name = 'relispartition'`);\n      return result.length ? true : false;\n    })();\n  }\n}","map":{"version":3,"names":["TypeORMError","QueryFailedError","QueryRunnerAlreadyReleasedError","TransactionNotStartedError","BaseQueryRunner","QueryResult","Table","TableCheck","TableColumn","TableExclusion","TableForeignKey","TableIndex","TableUnique","View","Broadcaster","InstanceChecker","OrmUtils","VersionUtils","Query","MetadataTableType","PostgresQueryRunner","constructor","driver","mode","connection","broadcaster","connect","databaseConnection","Promise","resolve","databaseConnectionPromise","isReplicated","obtainSlaveConnection","then","release","connectedQueryRunners","push","onErrorCallback","err","releasePostgresConnection","releaseCallback","removeListener","on","obtainMasterConnection","_this","_asyncToGenerator","isReleased","undefined","index","indexOf","splice","startTransaction","isolationLevel","_this2","isTransactionActive","broadcast","transactionDepth","query","commitTransaction","_this3","rollbackTransaction","_this4","parameters","useStructuredResult","_this5","logger","logQuery","queryStartTime","Date","raw","maxQueryExecutionTime","options","queryEndTime","queryExecutionTime","logQuerySlow","result","hasOwnProperty","records","rows","affected","rowCount","command","logQueryError","stream","onEnd","onError","_this6","QueryStream","loadStreamDependency","getDatabases","getSchemas","database","hasDatabase","_this7","length","getCurrentDatabase","_this8","hasSchema","schema","_this9","getCurrentSchema","_this10","hasTable","tableOrName","_this11","parsedTableName","parseTableName","sql","tableName","hasColumn","columnName","_this12","createDatabase","ifNotExist","_this13","databaseAlreadyExists","up","down","executeQueries","dropDatabase","ifExist","_this14","createSchema","schemaPath","_this15","split","dropSchema","isCascade","_this16","createTable","table","createForeignKeys","createIndices","_this17","isTableExist","upQueries","downQueries","enumColumns","columns","filter","column","type","createdEnumTypes","hasEnum","hasEnumType","enumName","buildEnumName","createEnumTypeSql","dropEnumTypeSql","generatedColumns","generatedType","asExpression","tableNameWithSchema","getTableNameWithSchema","name","insertQuery","insertTypeormMetadataSql","GENERATED_COLUMN","value","deleteQuery","deleteTypeormMetadataSql","createTableSql","dropTableSql","foreignKeys","forEach","foreignKey","dropForeignKeySql","indices","namingStrategy","indexName","columnNames","where","createIndexSql","dropIndexSql","dropTable","target","dropForeignKeys","dropIndices","_this18","tablePath","getTablePath","getCachedTable","createView","view","syncWithMetadata","_this19","createViewSql","insertViewDefinitionSql","dropViewSql","deleteViewDefinitionSql","dropView","_this20","viewName","isView","getCachedView","renameTable","oldTableOrName","newTableName","_this21","oldTable","isTable","newTable","clone","schemaName","oldTableName","escapePath","primaryColumns","primaryKeyConstraintName","map","oldPkName","primaryKeyName","newPkName","col","isGenerated","generationStrategy","sequencePath","buildSequencePath","sequenceName","buildSequenceName","newSequencePath","newSequenceName","uniques","unique","oldUniqueName","uniqueConstraintName","newUniqueName","oldIndexName","newIndexName","oldForeignKeyName","foreignKeyName","referencedColumnNames","newForeignKeyName","oldEnumType","getUserDefinedTypeName","addColumn","_this22","clonedTable","buildCreateColumnSql","isPrimary","pkName","join","columnIndex","find","isUnique","uniqueConstraint","comment","escapeComment","replaceCachedTable","addColumns","_this23","renameColumn","oldTableColumnOrName","newTableColumnOrName","_this24","oldColumn","isTableColumn","c","newColumn","changeColumn","_this25","defaultValueChanged","isArray","dropColumn","findColumnUniques","findColumnIndices","findColumnForeignKeys","oldTableColumn","precision","scale","createFullType","isArraysEqual","enum","arraySuffix","newEnumName","oldEnumName","oldEnumNameWithoutSchema","oldEnumNameWithSchema_old","oldEnumNameWithoutSchema_old","default","upType","downType","isNullable","primaryColumn","uuidGenerator","spatialFeatureType","toLowerCase","srid","changeColumns","changedColumns","_this26","columnOrName","_this27","findColumnByName","tableColumn","columnCheck","checks","check","dropCheckConstraintSql","createCheckConstraintSql","columnUnique","dropUniqueConstraintSql","createUniqueConstraintSql","enumType","escapedEnumName","removeColumn","dropColumns","_this28","createPrimaryKey","constraintName","_this29","createPrimaryKeySql","dropPrimaryKeySql","updatePrimaryKeys","_this30","_a","columnNamesString","dropPrimaryKey","_this31","createUniqueConstraint","_this32","addUniqueConstraint","createUniqueConstraints","uniqueConstraints","_this33","dropUniqueConstraint","uniqueOrName","_this34","isTableUnique","u","removeUniqueConstraint","dropUniqueConstraints","_this35","createCheckConstraint","checkConstraint","_this36","checkConstraintName","expression","addCheckConstraint","createCheckConstraints","checkConstraints","_this37","promises","all","dropCheckConstraint","checkOrName","_this38","isTableCheck","removeCheckConstraint","dropCheckConstraints","_this39","createExclusionConstraint","exclusionConstraint","_this40","exclusionConstraintName","createExclusionConstraintSql","dropExclusionConstraintSql","addExclusionConstraint","createExclusionConstraints","exclusionConstraints","_this41","dropExclusionConstraint","exclusionOrName","_this42","isTableExclusion","exclusions","removeExclusionConstraint","dropExclusionConstraints","_this43","createForeignKey","_this44","createForeignKeySql","addForeignKey","_this45","dropForeignKey","foreignKeyOrName","_this46","isTableForeignKey","fk","removeForeignKey","_this47","createIndex","_this48","generateIndexName","addIndex","createViewIndex","viewOrName","_this49","createViewIndexSql","_this50","createViewIndices","_this51","dropIndex","indexOrName","_this52","isTableIndex","i","removeIndex","dropViewIndex","_this53","_this54","clearTable","_this55","clearDatabase","_this56","schemas","entityMetadatas","metadata","isSchemaExist","schemaNamesString","isAnotherTransactionActive","version","getVersion","selectViewDropsQuery","dropViewQueries","q","isGreaterOrEqual","selectMatViewDropsQuery","dropMatViewQueries","selectTableDropsQuery","dropTableQueries","dropEnumTypes","error","rollbackError","loadViews","viewNames","_this57","getTypeormMetadataTableName","currentDatabase","currentSchema","viewsCondition","constraintsCondition","indicesSql","VIEW","MATERIALIZED_VIEW","dbViews","dbIndices","dbView","tableIndexConstraints","uniq","dbIndex","buildTableName","materialized","constraint","isFulltext","loadTables","tableNames","_this58","dbTables","tablesSql","tablesCondition","columnsCondition","table_schema","table_name","columnsSql","constraintsSql","foreignKeysCondition","hasRelispartitionColumn","hasSupportForPartitionedTables","isPartitionCondition","foreignKeysSql","dbColumns","dbConstraints","dbForeignKeys","_ref","dbTable","getSchemaFromKey","dbObject","key","dbColumn","_ref2","columnConstraints","dbConstraint","isDefaultColumnPrecision","isDefaultColumnScale","builtEnumName","results","replace","normalizeType","withLengthColumnTypes","match","exec","toString","isDefaultColumnLength","primaryConstraint","anotherPrimaryConstraints","isConstraintComposite","every","some","is_identity","generatedIdentity","identity_generation","serialDefaultName","serialDefaultPath","defaultWithoutQuotes","test","asExpressionQuery","selectTypeormMetadataSql","charset","collation","_x2","apply","arguments","tableUniqueConstraints","dbC","deferrable","tableCheckConstraints","tableExclusionConstraints","substring","tableForeignKeyConstraints","dbForeignKey","dbFk","referencedTableName","referencedSchema","onDelete","onUpdate","isSpatial","spatialTypes","_x","columnDefinitions","isUniqueExist","uniquesSql","uniqueName","checksSql","checkName","exclusionsSql","exclusion","exclusionName","it","_this59","tableOrPath","materializedClause","getQuery","_this60","trim","_this61","schemaNames","_this62","selectDropsQuery","dropQueries","_this63","enumValues","seqName","maxAliasLength","Math","max","withSchema","disableEscape","toOld","_this64","udtName","substr","searchSchema","_this65","schemaResult","generatedIdentityOrDefault","_this66"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/driver/postgres/PostgresQueryRunner.js"],"sourcesContent":["import { TypeORMError } from \"../../error\";\nimport { QueryFailedError } from \"../../error/QueryFailedError\";\nimport { QueryRunnerAlreadyReleasedError } from \"../../error/QueryRunnerAlreadyReleasedError\";\nimport { TransactionNotStartedError } from \"../../error/TransactionNotStartedError\";\nimport { BaseQueryRunner } from \"../../query-runner/BaseQueryRunner\";\nimport { QueryResult } from \"../../query-runner/QueryResult\";\nimport { Table } from \"../../schema-builder/table/Table\";\nimport { TableCheck } from \"../../schema-builder/table/TableCheck\";\nimport { TableColumn } from \"../../schema-builder/table/TableColumn\";\nimport { TableExclusion } from \"../../schema-builder/table/TableExclusion\";\nimport { TableForeignKey } from \"../../schema-builder/table/TableForeignKey\";\nimport { TableIndex } from \"../../schema-builder/table/TableIndex\";\nimport { TableUnique } from \"../../schema-builder/table/TableUnique\";\nimport { View } from \"../../schema-builder/view/View\";\nimport { Broadcaster } from \"../../subscriber/Broadcaster\";\nimport { InstanceChecker } from \"../../util/InstanceChecker\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\nimport { VersionUtils } from \"../../util/VersionUtils\";\nimport { Query } from \"../Query\";\nimport { MetadataTableType } from \"../types/MetadataTableType\";\n/**\n * Runs queries on a single postgres database connection.\n */\nexport class PostgresQueryRunner extends BaseQueryRunner {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n    constructor(driver, mode) {\n        super();\n        this.driver = driver;\n        this.connection = driver.connection;\n        this.mode = mode;\n        this.broadcaster = new Broadcaster(this);\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Creates/uses database connection from the connection pool to perform further operations.\n     * Returns obtained database connection.\n     */\n    connect() {\n        if (this.databaseConnection)\n            return Promise.resolve(this.databaseConnection);\n        if (this.databaseConnectionPromise)\n            return this.databaseConnectionPromise;\n        if (this.mode === \"slave\" && this.driver.isReplicated) {\n            this.databaseConnectionPromise = this.driver\n                .obtainSlaveConnection()\n                .then(([connection, release]) => {\n                this.driver.connectedQueryRunners.push(this);\n                this.databaseConnection = connection;\n                const onErrorCallback = (err) => this.releasePostgresConnection(err);\n                this.releaseCallback = (err) => {\n                    this.databaseConnection.removeListener(\"error\", onErrorCallback);\n                    release(err);\n                };\n                this.databaseConnection.on(\"error\", onErrorCallback);\n                return this.databaseConnection;\n            });\n        }\n        else {\n            // master\n            this.databaseConnectionPromise = this.driver\n                .obtainMasterConnection()\n                .then(([connection, release]) => {\n                this.driver.connectedQueryRunners.push(this);\n                this.databaseConnection = connection;\n                const onErrorCallback = (err) => this.releasePostgresConnection(err);\n                this.releaseCallback = (err) => {\n                    this.databaseConnection.removeListener(\"error\", onErrorCallback);\n                    release(err);\n                };\n                this.databaseConnection.on(\"error\", onErrorCallback);\n                return this.databaseConnection;\n            });\n        }\n        return this.databaseConnectionPromise;\n    }\n    /**\n     * Release a connection back to the pool, optionally specifying an Error to release with.\n     * Per pg-pool documentation this will prevent the pool from re-using the broken connection.\n     */\n    async releasePostgresConnection(err) {\n        if (this.isReleased) {\n            return;\n        }\n        this.isReleased = true;\n        if (this.releaseCallback) {\n            this.releaseCallback(err);\n            this.releaseCallback = undefined;\n        }\n        const index = this.driver.connectedQueryRunners.indexOf(this);\n        if (index !== -1) {\n            this.driver.connectedQueryRunners.splice(index, 1);\n        }\n    }\n    /**\n     * Releases used database connection.\n     * You cannot use query runner methods once its released.\n     */\n    release() {\n        return this.releasePostgresConnection();\n    }\n    /**\n     * Starts transaction.\n     */\n    async startTransaction(isolationLevel) {\n        this.isTransactionActive = true;\n        try {\n            await this.broadcaster.broadcast(\"BeforeTransactionStart\");\n        }\n        catch (err) {\n            this.isTransactionActive = false;\n            throw err;\n        }\n        if (this.transactionDepth === 0) {\n            await this.query(\"START TRANSACTION\");\n            if (isolationLevel) {\n                await this.query(\"SET TRANSACTION ISOLATION LEVEL \" + isolationLevel);\n            }\n        }\n        else {\n            await this.query(`SAVEPOINT typeorm_${this.transactionDepth}`);\n        }\n        this.transactionDepth += 1;\n        await this.broadcaster.broadcast(\"AfterTransactionStart\");\n    }\n    /**\n     * Commits transaction.\n     * Error will be thrown if transaction was not started.\n     */\n    async commitTransaction() {\n        if (!this.isTransactionActive)\n            throw new TransactionNotStartedError();\n        await this.broadcaster.broadcast(\"BeforeTransactionCommit\");\n        if (this.transactionDepth > 1) {\n            await this.query(`RELEASE SAVEPOINT typeorm_${this.transactionDepth - 1}`);\n        }\n        else {\n            await this.query(\"COMMIT\");\n            this.isTransactionActive = false;\n        }\n        this.transactionDepth -= 1;\n        await this.broadcaster.broadcast(\"AfterTransactionCommit\");\n    }\n    /**\n     * Rollbacks transaction.\n     * Error will be thrown if transaction was not started.\n     */\n    async rollbackTransaction() {\n        if (!this.isTransactionActive)\n            throw new TransactionNotStartedError();\n        await this.broadcaster.broadcast(\"BeforeTransactionRollback\");\n        if (this.transactionDepth > 1) {\n            await this.query(`ROLLBACK TO SAVEPOINT typeorm_${this.transactionDepth - 1}`);\n        }\n        else {\n            await this.query(\"ROLLBACK\");\n            this.isTransactionActive = false;\n        }\n        this.transactionDepth -= 1;\n        await this.broadcaster.broadcast(\"AfterTransactionRollback\");\n    }\n    /**\n     * Executes a given SQL query.\n     */\n    async query(query, parameters, useStructuredResult = false) {\n        if (this.isReleased)\n            throw new QueryRunnerAlreadyReleasedError();\n        const databaseConnection = await this.connect();\n        this.driver.connection.logger.logQuery(query, parameters, this);\n        try {\n            const queryStartTime = +new Date();\n            const raw = await databaseConnection.query(query, parameters);\n            // log slow queries if maxQueryExecution time is set\n            const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;\n            const queryEndTime = +new Date();\n            const queryExecutionTime = queryEndTime - queryStartTime;\n            if (maxQueryExecutionTime &&\n                queryExecutionTime > maxQueryExecutionTime)\n                this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);\n            const result = new QueryResult();\n            if (raw) {\n                if (raw.hasOwnProperty(\"rows\")) {\n                    result.records = raw.rows;\n                }\n                if (raw.hasOwnProperty(\"rowCount\")) {\n                    result.affected = raw.rowCount;\n                }\n                switch (raw.command) {\n                    case \"DELETE\":\n                    case \"UPDATE\":\n                        // for UPDATE and DELETE query additionally return number of affected rows\n                        result.raw = [raw.rows, raw.rowCount];\n                        break;\n                    default:\n                        result.raw = raw.rows;\n                }\n                if (!useStructuredResult) {\n                    return result.raw;\n                }\n            }\n            return result;\n        }\n        catch (err) {\n            this.driver.connection.logger.logQueryError(err, query, parameters, this);\n            throw new QueryFailedError(query, parameters, err);\n        }\n    }\n    /**\n     * Returns raw data stream.\n     */\n    async stream(query, parameters, onEnd, onError) {\n        const QueryStream = this.driver.loadStreamDependency();\n        if (this.isReleased)\n            throw new QueryRunnerAlreadyReleasedError();\n        const databaseConnection = await this.connect();\n        this.driver.connection.logger.logQuery(query, parameters, this);\n        const stream = databaseConnection.query(new QueryStream(query, parameters));\n        if (onEnd)\n            stream.on(\"end\", onEnd);\n        if (onError)\n            stream.on(\"error\", onError);\n        return stream;\n    }\n    /**\n     * Returns all available database names including system databases.\n     */\n    async getDatabases() {\n        return Promise.resolve([]);\n    }\n    /**\n     * Returns all available schema names including system schemas.\n     * If database parameter specified, returns schemas of that database.\n     */\n    async getSchemas(database) {\n        return Promise.resolve([]);\n    }\n    /**\n     * Checks if database with the given name exist.\n     */\n    async hasDatabase(database) {\n        const result = await this.query(`SELECT * FROM pg_database WHERE datname='${database}';`);\n        return result.length ? true : false;\n    }\n    /**\n     * Loads currently using database\n     */\n    async getCurrentDatabase() {\n        const query = await this.query(`SELECT * FROM current_database()`);\n        return query[0][\"current_database\"];\n    }\n    /**\n     * Checks if schema with the given name exist.\n     */\n    async hasSchema(schema) {\n        const result = await this.query(`SELECT * FROM \"information_schema\".\"schemata\" WHERE \"schema_name\" = '${schema}'`);\n        return result.length ? true : false;\n    }\n    /**\n     * Loads currently using database schema\n     */\n    async getCurrentSchema() {\n        const query = await this.query(`SELECT * FROM current_schema()`);\n        return query[0][\"current_schema\"];\n    }\n    /**\n     * Checks if table with the given name exist in the database.\n     */\n    async hasTable(tableOrName) {\n        const parsedTableName = this.driver.parseTableName(tableOrName);\n        if (!parsedTableName.schema) {\n            parsedTableName.schema = await this.getCurrentSchema();\n        }\n        const sql = `SELECT * FROM \"information_schema\".\"tables\" WHERE \"table_schema\" = '${parsedTableName.schema}' AND \"table_name\" = '${parsedTableName.tableName}'`;\n        const result = await this.query(sql);\n        return result.length ? true : false;\n    }\n    /**\n     * Checks if column with the given name exist in the given table.\n     */\n    async hasColumn(tableOrName, columnName) {\n        const parsedTableName = this.driver.parseTableName(tableOrName);\n        if (!parsedTableName.schema) {\n            parsedTableName.schema = await this.getCurrentSchema();\n        }\n        const sql = `SELECT * FROM \"information_schema\".\"columns\" WHERE \"table_schema\" = '${parsedTableName.schema}' AND \"table_name\" = '${parsedTableName.tableName}' AND \"column_name\" = '${columnName}'`;\n        const result = await this.query(sql);\n        return result.length ? true : false;\n    }\n    /**\n     * Creates a new database.\n     * Note: Postgres does not support database creation inside a transaction block.\n     */\n    async createDatabase(database, ifNotExist) {\n        if (ifNotExist) {\n            const databaseAlreadyExists = await this.hasDatabase(database);\n            if (databaseAlreadyExists)\n                return Promise.resolve();\n        }\n        const up = `CREATE DATABASE \"${database}\"`;\n        const down = `DROP DATABASE \"${database}\"`;\n        await this.executeQueries(new Query(up), new Query(down));\n    }\n    /**\n     * Drops database.\n     * Note: Postgres does not support database dropping inside a transaction block.\n     */\n    async dropDatabase(database, ifExist) {\n        const up = ifExist\n            ? `DROP DATABASE IF EXISTS \"${database}\"`\n            : `DROP DATABASE \"${database}\"`;\n        const down = `CREATE DATABASE \"${database}\"`;\n        await this.executeQueries(new Query(up), new Query(down));\n    }\n    /**\n     * Creates a new table schema.\n     */\n    async createSchema(schemaPath, ifNotExist) {\n        const schema = schemaPath.indexOf(\".\") === -1\n            ? schemaPath\n            : schemaPath.split(\".\")[1];\n        const up = ifNotExist\n            ? `CREATE SCHEMA IF NOT EXISTS \"${schema}\"`\n            : `CREATE SCHEMA \"${schema}\"`;\n        const down = `DROP SCHEMA \"${schema}\" CASCADE`;\n        await this.executeQueries(new Query(up), new Query(down));\n    }\n    /**\n     * Drops table schema.\n     */\n    async dropSchema(schemaPath, ifExist, isCascade) {\n        const schema = schemaPath.indexOf(\".\") === -1\n            ? schemaPath\n            : schemaPath.split(\".\")[1];\n        const up = ifExist\n            ? `DROP SCHEMA IF EXISTS \"${schema}\" ${isCascade ? \"CASCADE\" : \"\"}`\n            : `DROP SCHEMA \"${schema}\" ${isCascade ? \"CASCADE\" : \"\"}`;\n        const down = `CREATE SCHEMA \"${schema}\"`;\n        await this.executeQueries(new Query(up), new Query(down));\n    }\n    /**\n     * Creates a new table.\n     */\n    async createTable(table, ifNotExist = false, createForeignKeys = true, createIndices = true) {\n        if (ifNotExist) {\n            const isTableExist = await this.hasTable(table);\n            if (isTableExist)\n                return Promise.resolve();\n        }\n        const upQueries = [];\n        const downQueries = [];\n        // if table have column with ENUM type, we must create this type in postgres.\n        const enumColumns = table.columns.filter((column) => column.type === \"enum\" || column.type === \"simple-enum\");\n        const createdEnumTypes = [];\n        for (const column of enumColumns) {\n            // TODO: Should also check if values of existing type matches expected ones\n            const hasEnum = await this.hasEnumType(table, column);\n            const enumName = this.buildEnumName(table, column);\n            // if enum with the same \"enumName\" is defined more then once, me must prevent double creation\n            if (!hasEnum && createdEnumTypes.indexOf(enumName) === -1) {\n                createdEnumTypes.push(enumName);\n                upQueries.push(this.createEnumTypeSql(table, column, enumName));\n                downQueries.push(this.dropEnumTypeSql(table, column, enumName));\n            }\n        }\n        // if table have column with generated type, we must add the expression to the metadata table\n        const generatedColumns = table.columns.filter((column) => column.generatedType === \"STORED\" && column.asExpression);\n        for (const column of generatedColumns) {\n            const tableNameWithSchema = (await this.getTableNameWithSchema(table.name)).split(\".\");\n            const tableName = tableNameWithSchema[1];\n            const schema = tableNameWithSchema[0];\n            const insertQuery = this.insertTypeormMetadataSql({\n                database: this.driver.database,\n                schema,\n                table: tableName,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n                value: column.asExpression,\n            });\n            const deleteQuery = this.deleteTypeormMetadataSql({\n                database: this.driver.database,\n                schema,\n                table: tableName,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n            });\n            upQueries.push(insertQuery);\n            downQueries.push(deleteQuery);\n        }\n        upQueries.push(this.createTableSql(table, createForeignKeys));\n        downQueries.push(this.dropTableSql(table));\n        // if createForeignKeys is true, we must drop created foreign keys in down query.\n        // createTable does not need separate method to create foreign keys, because it create fk's in the same query with table creation.\n        if (createForeignKeys)\n            table.foreignKeys.forEach((foreignKey) => downQueries.push(this.dropForeignKeySql(table, foreignKey)));\n        if (createIndices) {\n            table.indices.forEach((index) => {\n                // new index may be passed without name. In this case we generate index name manually.\n                if (!index.name)\n                    index.name = this.connection.namingStrategy.indexName(table, index.columnNames, index.where);\n                upQueries.push(this.createIndexSql(table, index));\n                downQueries.push(this.dropIndexSql(table, index));\n            });\n        }\n        await this.executeQueries(upQueries, downQueries);\n    }\n    /**\n     * Drops the table.\n     */\n    async dropTable(target, ifExist, dropForeignKeys = true, dropIndices = true) {\n        // It needs because if table does not exist and dropForeignKeys or dropIndices is true, we don't need\n        // to perform drop queries for foreign keys and indices.\n        if (ifExist) {\n            const isTableExist = await this.hasTable(target);\n            if (!isTableExist)\n                return Promise.resolve();\n        }\n        // if dropTable called with dropForeignKeys = true, we must create foreign keys in down query.\n        const createForeignKeys = dropForeignKeys;\n        const tablePath = this.getTablePath(target);\n        const table = await this.getCachedTable(tablePath);\n        const upQueries = [];\n        const downQueries = [];\n        if (dropIndices) {\n            table.indices.forEach((index) => {\n                upQueries.push(this.dropIndexSql(table, index));\n                downQueries.push(this.createIndexSql(table, index));\n            });\n        }\n        if (dropForeignKeys)\n            table.foreignKeys.forEach((foreignKey) => upQueries.push(this.dropForeignKeySql(table, foreignKey)));\n        upQueries.push(this.dropTableSql(table));\n        downQueries.push(this.createTableSql(table, createForeignKeys));\n        // if table had columns with generated type, we must remove the expression from the metadata table\n        const generatedColumns = table.columns.filter((column) => column.generatedType && column.asExpression);\n        for (const column of generatedColumns) {\n            const tableNameWithSchema = (await this.getTableNameWithSchema(table.name)).split(\".\");\n            const tableName = tableNameWithSchema[1];\n            const schema = tableNameWithSchema[0];\n            const deleteQuery = this.deleteTypeormMetadataSql({\n                database: this.driver.database,\n                schema,\n                table: tableName,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n            });\n            const insertQuery = this.insertTypeormMetadataSql({\n                database: this.driver.database,\n                schema,\n                table: tableName,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n                value: column.asExpression,\n            });\n            upQueries.push(deleteQuery);\n            downQueries.push(insertQuery);\n        }\n        await this.executeQueries(upQueries, downQueries);\n    }\n    /**\n     * Creates a new view.\n     */\n    async createView(view, syncWithMetadata = false) {\n        const upQueries = [];\n        const downQueries = [];\n        upQueries.push(this.createViewSql(view));\n        if (syncWithMetadata)\n            upQueries.push(await this.insertViewDefinitionSql(view));\n        downQueries.push(this.dropViewSql(view));\n        if (syncWithMetadata)\n            downQueries.push(await this.deleteViewDefinitionSql(view));\n        await this.executeQueries(upQueries, downQueries);\n    }\n    /**\n     * Drops the view.\n     */\n    async dropView(target) {\n        const viewName = InstanceChecker.isView(target) ? target.name : target;\n        const view = await this.getCachedView(viewName);\n        const upQueries = [];\n        const downQueries = [];\n        upQueries.push(await this.deleteViewDefinitionSql(view));\n        upQueries.push(this.dropViewSql(view));\n        downQueries.push(await this.insertViewDefinitionSql(view));\n        downQueries.push(this.createViewSql(view));\n        await this.executeQueries(upQueries, downQueries);\n    }\n    /**\n     * Renames the given table.\n     */\n    async renameTable(oldTableOrName, newTableName) {\n        const upQueries = [];\n        const downQueries = [];\n        const oldTable = InstanceChecker.isTable(oldTableOrName)\n            ? oldTableOrName\n            : await this.getCachedTable(oldTableOrName);\n        const newTable = oldTable.clone();\n        const { schema: schemaName, tableName: oldTableName } = this.driver.parseTableName(oldTable);\n        newTable.name = schemaName\n            ? `${schemaName}.${newTableName}`\n            : newTableName;\n        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(oldTable)} RENAME TO \"${newTableName}\"`));\n        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME TO \"${oldTableName}\"`));\n        // rename column primary key constraint if it has default constraint name\n        if (newTable.primaryColumns.length > 0 &&\n            !newTable.primaryColumns[0].primaryKeyConstraintName) {\n            const columnNames = newTable.primaryColumns.map((column) => column.name);\n            const oldPkName = this.connection.namingStrategy.primaryKeyName(oldTable, columnNames);\n            const newPkName = this.connection.namingStrategy.primaryKeyName(newTable, columnNames);\n            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT \"${oldPkName}\" TO \"${newPkName}\"`));\n            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT \"${newPkName}\" TO \"${oldPkName}\"`));\n        }\n        // rename sequences\n        newTable.columns.map((col) => {\n            if (col.isGenerated && col.generationStrategy === \"increment\") {\n                const sequencePath = this.buildSequencePath(oldTable, col.name);\n                const sequenceName = this.buildSequenceName(oldTable, col.name);\n                const newSequencePath = this.buildSequencePath(newTable, col.name);\n                const newSequenceName = this.buildSequenceName(newTable, col.name);\n                const up = `ALTER SEQUENCE ${this.escapePath(sequencePath)} RENAME TO \"${newSequenceName}\"`;\n                const down = `ALTER SEQUENCE ${this.escapePath(newSequencePath)} RENAME TO \"${sequenceName}\"`;\n                upQueries.push(new Query(up));\n                downQueries.push(new Query(down));\n            }\n        });\n        // rename unique constraints\n        newTable.uniques.forEach((unique) => {\n            const oldUniqueName = this.connection.namingStrategy.uniqueConstraintName(oldTable, unique.columnNames);\n            // Skip renaming if Unique has user defined constraint name\n            if (unique.name !== oldUniqueName)\n                return;\n            // build new constraint name\n            const newUniqueName = this.connection.namingStrategy.uniqueConstraintName(newTable, unique.columnNames);\n            // build queries\n            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT \"${unique.name}\" TO \"${newUniqueName}\"`));\n            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT \"${newUniqueName}\" TO \"${unique.name}\"`));\n            // replace constraint name\n            unique.name = newUniqueName;\n        });\n        // rename index constraints\n        newTable.indices.forEach((index) => {\n            const oldIndexName = this.connection.namingStrategy.indexName(oldTable, index.columnNames, index.where);\n            // Skip renaming if Index has user defined constraint name\n            if (index.name !== oldIndexName)\n                return;\n            // build new constraint name\n            const { schema } = this.driver.parseTableName(newTable);\n            const newIndexName = this.connection.namingStrategy.indexName(newTable, index.columnNames, index.where);\n            // build queries\n            const up = schema\n                ? `ALTER INDEX \"${schema}\".\"${index.name}\" RENAME TO \"${newIndexName}\"`\n                : `ALTER INDEX \"${index.name}\" RENAME TO \"${newIndexName}\"`;\n            const down = schema\n                ? `ALTER INDEX \"${schema}\".\"${newIndexName}\" RENAME TO \"${index.name}\"`\n                : `ALTER INDEX \"${newIndexName}\" RENAME TO \"${index.name}\"`;\n            upQueries.push(new Query(up));\n            downQueries.push(new Query(down));\n            // replace constraint name\n            index.name = newIndexName;\n        });\n        // rename foreign key constraints\n        newTable.foreignKeys.forEach((foreignKey) => {\n            const oldForeignKeyName = this.connection.namingStrategy.foreignKeyName(oldTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);\n            // Skip renaming if foreign key has user defined constraint name\n            if (foreignKey.name !== oldForeignKeyName)\n                return;\n            // build new constraint name\n            const newForeignKeyName = this.connection.namingStrategy.foreignKeyName(newTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);\n            // build queries\n            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT \"${foreignKey.name}\" TO \"${newForeignKeyName}\"`));\n            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(newTable)} RENAME CONSTRAINT \"${newForeignKeyName}\" TO \"${foreignKey.name}\"`));\n            // replace constraint name\n            foreignKey.name = newForeignKeyName;\n        });\n        // rename ENUM types\n        const enumColumns = newTable.columns.filter((column) => column.type === \"enum\" || column.type === \"simple-enum\");\n        for (let column of enumColumns) {\n            // skip renaming for user-defined enum name\n            if (column.enumName)\n                continue;\n            const oldEnumType = await this.getUserDefinedTypeName(oldTable, column);\n            upQueries.push(new Query(`ALTER TYPE \"${oldEnumType.schema}\".\"${oldEnumType.name}\" RENAME TO ${this.buildEnumName(newTable, column, false)}`));\n            downQueries.push(new Query(`ALTER TYPE ${this.buildEnumName(newTable, column)} RENAME TO \"${oldEnumType.name}\"`));\n        }\n        await this.executeQueries(upQueries, downQueries);\n    }\n    /**\n     * Creates a new column from the column in the table.\n     */\n    async addColumn(tableOrName, column) {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        const clonedTable = table.clone();\n        const upQueries = [];\n        const downQueries = [];\n        if (column.type === \"enum\" || column.type === \"simple-enum\") {\n            const hasEnum = await this.hasEnumType(table, column);\n            if (!hasEnum) {\n                upQueries.push(this.createEnumTypeSql(table, column));\n                downQueries.push(this.dropEnumTypeSql(table, column));\n            }\n        }\n        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(table, column)}`));\n        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN \"${column.name}\"`));\n        // create or update primary key constraint\n        if (column.isPrimary) {\n            const primaryColumns = clonedTable.primaryColumns;\n            // if table already have primary key, me must drop it and recreate again\n            if (primaryColumns.length > 0) {\n                const pkName = primaryColumns[0].primaryKeyConstraintName\n                    ? primaryColumns[0].primaryKeyConstraintName\n                    : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column) => column.name));\n                const columnNames = primaryColumns\n                    .map((column) => `\"${column.name}\"`)\n                    .join(\", \");\n                upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${pkName}\"`));\n                downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`));\n            }\n            primaryColumns.push(column);\n            const pkName = primaryColumns[0].primaryKeyConstraintName\n                ? primaryColumns[0].primaryKeyConstraintName\n                : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column) => column.name));\n            const columnNames = primaryColumns\n                .map((column) => `\"${column.name}\"`)\n                .join(\", \");\n            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`));\n            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${pkName}\"`));\n        }\n        // create column index\n        const columnIndex = clonedTable.indices.find((index) => index.columnNames.length === 1 &&\n            index.columnNames[0] === column.name);\n        if (columnIndex) {\n            upQueries.push(this.createIndexSql(table, columnIndex));\n            downQueries.push(this.dropIndexSql(table, columnIndex));\n        }\n        // create unique constraint\n        if (column.isUnique) {\n            const uniqueConstraint = new TableUnique({\n                name: this.connection.namingStrategy.uniqueConstraintName(table, [column.name]),\n                columnNames: [column.name],\n            });\n            clonedTable.uniques.push(uniqueConstraint);\n            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${uniqueConstraint.name}\" UNIQUE (\"${column.name}\")`));\n            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${uniqueConstraint.name}\"`));\n        }\n        if (column.generatedType === \"STORED\" && column.asExpression) {\n            const tableNameWithSchema = (await this.getTableNameWithSchema(table.name)).split(\".\");\n            const tableName = tableNameWithSchema[1];\n            const schema = tableNameWithSchema[0];\n            const insertQuery = this.insertTypeormMetadataSql({\n                database: this.driver.database,\n                schema,\n                table: tableName,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n                value: column.asExpression,\n            });\n            const deleteQuery = this.deleteTypeormMetadataSql({\n                database: this.driver.database,\n                schema,\n                table: tableName,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n            });\n            upQueries.push(insertQuery);\n            downQueries.push(deleteQuery);\n        }\n        // create column's comment\n        if (column.comment) {\n            upQueries.push(new Query(`COMMENT ON COLUMN ${this.escapePath(table)}.\"${column.name}\" IS ${this.escapeComment(column.comment)}`));\n            downQueries.push(new Query(`COMMENT ON COLUMN ${this.escapePath(table)}.\"${column.name}\" IS ${this.escapeComment(column.comment)}`));\n        }\n        await this.executeQueries(upQueries, downQueries);\n        clonedTable.addColumn(column);\n        this.replaceCachedTable(table, clonedTable);\n    }\n    /**\n     * Creates a new columns from the column in the table.\n     */\n    async addColumns(tableOrName, columns) {\n        for (const column of columns) {\n            await this.addColumn(tableOrName, column);\n        }\n    }\n    /**\n     * Renames column in the given table.\n     */\n    async renameColumn(tableOrName, oldTableColumnOrName, newTableColumnOrName) {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        const oldColumn = InstanceChecker.isTableColumn(oldTableColumnOrName)\n            ? oldTableColumnOrName\n            : table.columns.find((c) => c.name === oldTableColumnOrName);\n        if (!oldColumn)\n            throw new TypeORMError(`Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`);\n        let newColumn;\n        if (InstanceChecker.isTableColumn(newTableColumnOrName)) {\n            newColumn = newTableColumnOrName;\n        }\n        else {\n            newColumn = oldColumn.clone();\n            newColumn.name = newTableColumnOrName;\n        }\n        return this.changeColumn(table, oldColumn, newColumn);\n    }\n    /**\n     * Changes a column in the table.\n     */\n    async changeColumn(tableOrName, oldTableColumnOrName, newColumn) {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        let clonedTable = table.clone();\n        const upQueries = [];\n        const downQueries = [];\n        let defaultValueChanged = false;\n        const oldColumn = InstanceChecker.isTableColumn(oldTableColumnOrName)\n            ? oldTableColumnOrName\n            : table.columns.find((column) => column.name === oldTableColumnOrName);\n        if (!oldColumn)\n            throw new TypeORMError(`Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`);\n        if (oldColumn.type !== newColumn.type ||\n            oldColumn.length !== newColumn.length ||\n            newColumn.isArray !== oldColumn.isArray ||\n            (!oldColumn.generatedType &&\n                newColumn.generatedType === \"STORED\") ||\n            (oldColumn.asExpression !== newColumn.asExpression &&\n                newColumn.generatedType === \"STORED\")) {\n            // To avoid data conversion, we just recreate column\n            await this.dropColumn(table, oldColumn);\n            await this.addColumn(table, newColumn);\n            // update cloned table\n            clonedTable = table.clone();\n        }\n        else {\n            if (oldColumn.name !== newColumn.name) {\n                // rename column\n                upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} RENAME COLUMN \"${oldColumn.name}\" TO \"${newColumn.name}\"`));\n                downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} RENAME COLUMN \"${newColumn.name}\" TO \"${oldColumn.name}\"`));\n                // rename ENUM type\n                if (oldColumn.type === \"enum\" ||\n                    oldColumn.type === \"simple-enum\") {\n                    const oldEnumType = await this.getUserDefinedTypeName(table, oldColumn);\n                    upQueries.push(new Query(`ALTER TYPE \"${oldEnumType.schema}\".\"${oldEnumType.name}\" RENAME TO ${this.buildEnumName(table, newColumn, false)}`));\n                    downQueries.push(new Query(`ALTER TYPE ${this.buildEnumName(table, newColumn)} RENAME TO \"${oldEnumType.name}\"`));\n                }\n                // rename column primary key constraint\n                if (oldColumn.isPrimary === true &&\n                    !oldColumn.primaryKeyConstraintName) {\n                    const primaryColumns = clonedTable.primaryColumns;\n                    // build old primary constraint name\n                    const columnNames = primaryColumns.map((column) => column.name);\n                    const oldPkName = this.connection.namingStrategy.primaryKeyName(clonedTable, columnNames);\n                    // replace old column name with new column name\n                    columnNames.splice(columnNames.indexOf(oldColumn.name), 1);\n                    columnNames.push(newColumn.name);\n                    // build new primary constraint name\n                    const newPkName = this.connection.namingStrategy.primaryKeyName(clonedTable, columnNames);\n                    upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT \"${oldPkName}\" TO \"${newPkName}\"`));\n                    downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT \"${newPkName}\" TO \"${oldPkName}\"`));\n                }\n                // rename column sequence\n                if (oldColumn.isGenerated === true &&\n                    newColumn.generationStrategy === \"increment\") {\n                    const sequencePath = this.buildSequencePath(table, oldColumn.name);\n                    const sequenceName = this.buildSequenceName(table, oldColumn.name);\n                    const newSequencePath = this.buildSequencePath(table, newColumn.name);\n                    const newSequenceName = this.buildSequenceName(table, newColumn.name);\n                    const up = `ALTER SEQUENCE ${this.escapePath(sequencePath)} RENAME TO \"${newSequenceName}\"`;\n                    const down = `ALTER SEQUENCE ${this.escapePath(newSequencePath)} RENAME TO \"${sequenceName}\"`;\n                    upQueries.push(new Query(up));\n                    downQueries.push(new Query(down));\n                }\n                // rename unique constraints\n                clonedTable.findColumnUniques(oldColumn).forEach((unique) => {\n                    const oldUniqueName = this.connection.namingStrategy.uniqueConstraintName(clonedTable, unique.columnNames);\n                    // Skip renaming if Unique has user defined constraint name\n                    if (unique.name !== oldUniqueName)\n                        return;\n                    // build new constraint name\n                    unique.columnNames.splice(unique.columnNames.indexOf(oldColumn.name), 1);\n                    unique.columnNames.push(newColumn.name);\n                    const newUniqueName = this.connection.namingStrategy.uniqueConstraintName(clonedTable, unique.columnNames);\n                    // build queries\n                    upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT \"${unique.name}\" TO \"${newUniqueName}\"`));\n                    downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT \"${newUniqueName}\" TO \"${unique.name}\"`));\n                    // replace constraint name\n                    unique.name = newUniqueName;\n                });\n                // rename index constraints\n                clonedTable.findColumnIndices(oldColumn).forEach((index) => {\n                    const oldIndexName = this.connection.namingStrategy.indexName(clonedTable, index.columnNames, index.where);\n                    // Skip renaming if Index has user defined constraint name\n                    if (index.name !== oldIndexName)\n                        return;\n                    // build new constraint name\n                    index.columnNames.splice(index.columnNames.indexOf(oldColumn.name), 1);\n                    index.columnNames.push(newColumn.name);\n                    const { schema } = this.driver.parseTableName(table);\n                    const newIndexName = this.connection.namingStrategy.indexName(clonedTable, index.columnNames, index.where);\n                    // build queries\n                    const up = schema\n                        ? `ALTER INDEX \"${schema}\".\"${index.name}\" RENAME TO \"${newIndexName}\"`\n                        : `ALTER INDEX \"${index.name}\" RENAME TO \"${newIndexName}\"`;\n                    const down = schema\n                        ? `ALTER INDEX \"${schema}\".\"${newIndexName}\" RENAME TO \"${index.name}\"`\n                        : `ALTER INDEX \"${newIndexName}\" RENAME TO \"${index.name}\"`;\n                    upQueries.push(new Query(up));\n                    downQueries.push(new Query(down));\n                    // replace constraint name\n                    index.name = newIndexName;\n                });\n                // rename foreign key constraints\n                clonedTable\n                    .findColumnForeignKeys(oldColumn)\n                    .forEach((foreignKey) => {\n                    const foreignKeyName = this.connection.namingStrategy.foreignKeyName(clonedTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);\n                    // Skip renaming if foreign key has user defined constraint name\n                    if (foreignKey.name !== foreignKeyName)\n                        return;\n                    // build new constraint name\n                    foreignKey.columnNames.splice(foreignKey.columnNames.indexOf(oldColumn.name), 1);\n                    foreignKey.columnNames.push(newColumn.name);\n                    const newForeignKeyName = this.connection.namingStrategy.foreignKeyName(clonedTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);\n                    // build queries\n                    upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT \"${foreignKey.name}\" TO \"${newForeignKeyName}\"`));\n                    downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} RENAME CONSTRAINT \"${newForeignKeyName}\" TO \"${foreignKey.name}\"`));\n                    // replace constraint name\n                    foreignKey.name = newForeignKeyName;\n                });\n                // rename old column in the Table object\n                const oldTableColumn = clonedTable.columns.find((column) => column.name === oldColumn.name);\n                clonedTable.columns[clonedTable.columns.indexOf(oldTableColumn)].name = newColumn.name;\n                oldColumn.name = newColumn.name;\n            }\n            if (newColumn.precision !== oldColumn.precision ||\n                newColumn.scale !== oldColumn.scale) {\n                upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" TYPE ${this.driver.createFullType(newColumn)}`));\n                downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" TYPE ${this.driver.createFullType(oldColumn)}`));\n            }\n            if ((newColumn.type === \"enum\" ||\n                newColumn.type === \"simple-enum\") &&\n                (oldColumn.type === \"enum\" ||\n                    oldColumn.type === \"simple-enum\") &&\n                (!OrmUtils.isArraysEqual(newColumn.enum, oldColumn.enum) ||\n                    newColumn.enumName !== oldColumn.enumName)) {\n                const arraySuffix = newColumn.isArray ? \"[]\" : \"\";\n                // \"public\".\"new_enum\"\n                const newEnumName = this.buildEnumName(table, newColumn);\n                // \"public\".\"old_enum\"\n                const oldEnumName = this.buildEnumName(table, oldColumn);\n                // \"old_enum\"\n                const oldEnumNameWithoutSchema = this.buildEnumName(table, oldColumn, false);\n                //\"public\".\"old_enum_old\"\n                const oldEnumNameWithSchema_old = this.buildEnumName(table, oldColumn, true, false, true);\n                //\"old_enum_old\"\n                const oldEnumNameWithoutSchema_old = this.buildEnumName(table, oldColumn, false, false, true);\n                // rename old ENUM\n                upQueries.push(new Query(`ALTER TYPE ${oldEnumName} RENAME TO ${oldEnumNameWithoutSchema_old}`));\n                downQueries.push(new Query(`ALTER TYPE ${oldEnumNameWithSchema_old} RENAME TO ${oldEnumNameWithoutSchema}`));\n                // create new ENUM\n                upQueries.push(this.createEnumTypeSql(table, newColumn, newEnumName));\n                downQueries.push(this.dropEnumTypeSql(table, newColumn, newEnumName));\n                // if column have default value, we must drop it to avoid issues with type casting\n                if (oldColumn.default !== null &&\n                    oldColumn.default !== undefined) {\n                    // mark default as changed to prevent double update\n                    defaultValueChanged = true;\n                    upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" DROP DEFAULT`));\n                    downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" SET DEFAULT ${oldColumn.default}`));\n                }\n                // build column types\n                const upType = `${newEnumName}${arraySuffix} USING \"${newColumn.name}\"::\"text\"::${newEnumName}${arraySuffix}`;\n                const downType = `${oldEnumNameWithSchema_old}${arraySuffix} USING \"${newColumn.name}\"::\"text\"::${oldEnumNameWithSchema_old}${arraySuffix}`;\n                // update column to use new type\n                upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" TYPE ${upType}`));\n                downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" TYPE ${downType}`));\n                // restore column default or create new one\n                if (newColumn.default !== null &&\n                    newColumn.default !== undefined) {\n                    upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT ${newColumn.default}`));\n                    downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" DROP DEFAULT`));\n                }\n                // remove old ENUM\n                upQueries.push(this.dropEnumTypeSql(table, oldColumn, oldEnumNameWithSchema_old));\n                downQueries.push(this.createEnumTypeSql(table, oldColumn, oldEnumNameWithSchema_old));\n            }\n            if (oldColumn.isNullable !== newColumn.isNullable) {\n                if (newColumn.isNullable) {\n                    upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" DROP NOT NULL`));\n                    downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" SET NOT NULL`));\n                }\n                else {\n                    upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" SET NOT NULL`));\n                    downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" DROP NOT NULL`));\n                }\n            }\n            if (oldColumn.comment !== newColumn.comment) {\n                upQueries.push(new Query(`COMMENT ON COLUMN ${this.escapePath(table)}.\"${oldColumn.name}\" IS ${this.escapeComment(newColumn.comment)}`));\n                downQueries.push(new Query(`COMMENT ON COLUMN ${this.escapePath(table)}.\"${newColumn.name}\" IS ${this.escapeComment(oldColumn.comment)}`));\n            }\n            if (newColumn.isPrimary !== oldColumn.isPrimary) {\n                const primaryColumns = clonedTable.primaryColumns;\n                // if primary column state changed, we must always drop existed constraint.\n                if (primaryColumns.length > 0) {\n                    const pkName = primaryColumns[0].primaryKeyConstraintName\n                        ? primaryColumns[0].primaryKeyConstraintName\n                        : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column) => column.name));\n                    const columnNames = primaryColumns\n                        .map((column) => `\"${column.name}\"`)\n                        .join(\", \");\n                    upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${pkName}\"`));\n                    downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`));\n                }\n                if (newColumn.isPrimary === true) {\n                    primaryColumns.push(newColumn);\n                    // update column in table\n                    const column = clonedTable.columns.find((column) => column.name === newColumn.name);\n                    column.isPrimary = true;\n                    const pkName = primaryColumns[0].primaryKeyConstraintName\n                        ? primaryColumns[0].primaryKeyConstraintName\n                        : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column) => column.name));\n                    const columnNames = primaryColumns\n                        .map((column) => `\"${column.name}\"`)\n                        .join(\", \");\n                    upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`));\n                    downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${pkName}\"`));\n                }\n                else {\n                    const primaryColumn = primaryColumns.find((c) => c.name === newColumn.name);\n                    primaryColumns.splice(primaryColumns.indexOf(primaryColumn), 1);\n                    // update column in table\n                    const column = clonedTable.columns.find((column) => column.name === newColumn.name);\n                    column.isPrimary = false;\n                    // if we have another primary keys, we must recreate constraint.\n                    if (primaryColumns.length > 0) {\n                        const pkName = primaryColumns[0]\n                            .primaryKeyConstraintName\n                            ? primaryColumns[0].primaryKeyConstraintName\n                            : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column) => column.name));\n                        const columnNames = primaryColumns\n                            .map((column) => `\"${column.name}\"`)\n                            .join(\", \");\n                        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`));\n                        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${pkName}\"`));\n                    }\n                }\n            }\n            if (newColumn.isUnique !== oldColumn.isUnique) {\n                if (newColumn.isUnique === true) {\n                    const uniqueConstraint = new TableUnique({\n                        name: this.connection.namingStrategy.uniqueConstraintName(table, [newColumn.name]),\n                        columnNames: [newColumn.name],\n                    });\n                    clonedTable.uniques.push(uniqueConstraint);\n                    upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${uniqueConstraint.name}\" UNIQUE (\"${newColumn.name}\")`));\n                    downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${uniqueConstraint.name}\"`));\n                }\n                else {\n                    const uniqueConstraint = clonedTable.uniques.find((unique) => {\n                        return (unique.columnNames.length === 1 &&\n                            !!unique.columnNames.find((columnName) => columnName === newColumn.name));\n                    });\n                    clonedTable.uniques.splice(clonedTable.uniques.indexOf(uniqueConstraint), 1);\n                    upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${uniqueConstraint.name}\"`));\n                    downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${uniqueConstraint.name}\" UNIQUE (\"${newColumn.name}\")`));\n                }\n            }\n            if (oldColumn.isGenerated !== newColumn.isGenerated) {\n                // if old column was \"generated\", we should clear defaults\n                if (oldColumn.isGenerated) {\n                    if (oldColumn.generationStrategy === \"uuid\") {\n                        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" DROP DEFAULT`));\n                        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" SET DEFAULT ${this.driver.uuidGenerator}`));\n                    }\n                    else if (oldColumn.generationStrategy === \"increment\") {\n                        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" DROP DEFAULT`));\n                        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT nextval('${this.escapePath(this.buildSequencePath(table, newColumn))}')`));\n                        upQueries.push(new Query(`DROP SEQUENCE ${this.escapePath(this.buildSequencePath(table, newColumn))}`));\n                        downQueries.push(new Query(`CREATE SEQUENCE IF NOT EXISTS ${this.escapePath(this.buildSequencePath(table, newColumn))} OWNED BY ${this.escapePath(table)}.\"${newColumn.name}\"`));\n                    }\n                }\n                if (newColumn.generationStrategy === \"uuid\") {\n                    if (newColumn.isGenerated === true) {\n                        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT ${this.driver.uuidGenerator}`));\n                        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" DROP DEFAULT`));\n                    }\n                    else {\n                        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" DROP DEFAULT`));\n                        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT ${this.driver.uuidGenerator}`));\n                    }\n                }\n                else if (newColumn.generationStrategy === \"increment\") {\n                    if (newColumn.isGenerated === true) {\n                        upQueries.push(new Query(`CREATE SEQUENCE IF NOT EXISTS ${this.escapePath(this.buildSequencePath(table, newColumn))} OWNED BY ${this.escapePath(table)}.\"${newColumn.name}\"`));\n                        downQueries.push(new Query(`DROP SEQUENCE ${this.escapePath(this.buildSequencePath(table, newColumn))}`));\n                        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT nextval('${this.escapePath(this.buildSequencePath(table, newColumn))}')`));\n                        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" DROP DEFAULT`));\n                    }\n                    else {\n                        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" DROP DEFAULT`));\n                        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT nextval('${this.escapePath(this.buildSequencePath(table, newColumn))}')`));\n                        upQueries.push(new Query(`DROP SEQUENCE ${this.escapePath(this.buildSequencePath(table, newColumn))}`));\n                        downQueries.push(new Query(`CREATE SEQUENCE IF NOT EXISTS ${this.escapePath(this.buildSequencePath(table, newColumn))} OWNED BY ${this.escapePath(table)}.\"${newColumn.name}\"`));\n                    }\n                }\n            }\n            // the default might have changed when the enum changed\n            if (newColumn.default !== oldColumn.default &&\n                !defaultValueChanged) {\n                if (newColumn.default !== null &&\n                    newColumn.default !== undefined) {\n                    upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT ${newColumn.default}`));\n                    if (oldColumn.default !== null &&\n                        oldColumn.default !== undefined) {\n                        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT ${oldColumn.default}`));\n                    }\n                    else {\n                        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" DROP DEFAULT`));\n                    }\n                }\n                else if (oldColumn.default !== null &&\n                    oldColumn.default !== undefined) {\n                    upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" DROP DEFAULT`));\n                    downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" SET DEFAULT ${oldColumn.default}`));\n                }\n            }\n            if ((newColumn.spatialFeatureType || \"\").toLowerCase() !==\n                (oldColumn.spatialFeatureType || \"\").toLowerCase() ||\n                newColumn.srid !== oldColumn.srid) {\n                upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" TYPE ${this.driver.createFullType(newColumn)}`));\n                downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" TYPE ${this.driver.createFullType(oldColumn)}`));\n            }\n            if (newColumn.generatedType !== oldColumn.generatedType) {\n                // Convert generated column data to normal column\n                if (!newColumn.generatedType ||\n                    newColumn.generatedType === \"VIRTUAL\") {\n                    // We can copy the generated data to the new column\n                    const tableNameWithSchema = (await this.getTableNameWithSchema(table.name)).split(\".\");\n                    const tableName = tableNameWithSchema[1];\n                    const schema = tableNameWithSchema[0];\n                    upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} RENAME COLUMN \"${oldColumn.name}\" TO \"TEMP_OLD_${oldColumn.name}\"`));\n                    upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(table, newColumn)}`));\n                    upQueries.push(new Query(`UPDATE ${this.escapePath(table)} SET \"${newColumn.name}\" = \"TEMP_OLD_${oldColumn.name}\"`));\n                    upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN \"TEMP_OLD_${oldColumn.name}\"`));\n                    upQueries.push(this.deleteTypeormMetadataSql({\n                        database: this.driver.database,\n                        schema,\n                        table: tableName,\n                        type: MetadataTableType.GENERATED_COLUMN,\n                        name: oldColumn.name,\n                    }));\n                    // However, we can't copy it back on downgrade. It needs to regenerate.\n                    downQueries.push(this.insertTypeormMetadataSql({\n                        database: this.driver.database,\n                        schema,\n                        table: tableName,\n                        type: MetadataTableType.GENERATED_COLUMN,\n                        name: oldColumn.name,\n                        value: oldColumn.asExpression,\n                    }));\n                    downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(table, oldColumn)}`));\n                    downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN \"${newColumn.name}\"`));\n                    // downQueries.push(\n                    //     this.deleteTypeormMetadataSql({\n                    //         database: this.driver.database,\n                    //         schema,\n                    //         table: tableName,\n                    //         type: MetadataTableType.GENERATED_COLUMN,\n                    //         name: newColumn.name,\n                    //     }),\n                    // )\n                }\n            }\n        }\n        await this.executeQueries(upQueries, downQueries);\n        this.replaceCachedTable(table, clonedTable);\n    }\n    /**\n     * Changes a column in the table.\n     */\n    async changeColumns(tableOrName, changedColumns) {\n        for (const { oldColumn, newColumn } of changedColumns) {\n            await this.changeColumn(tableOrName, oldColumn, newColumn);\n        }\n    }\n    /**\n     * Drops column in the table.\n     */\n    async dropColumn(tableOrName, columnOrName) {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        const column = InstanceChecker.isTableColumn(columnOrName)\n            ? columnOrName\n            : table.findColumnByName(columnOrName);\n        if (!column)\n            throw new TypeORMError(`Column \"${columnOrName}\" was not found in table \"${table.name}\"`);\n        const clonedTable = table.clone();\n        const upQueries = [];\n        const downQueries = [];\n        // drop primary key constraint\n        if (column.isPrimary) {\n            const pkName = column.primaryKeyConstraintName\n                ? column.primaryKeyConstraintName\n                : this.connection.namingStrategy.primaryKeyName(clonedTable, clonedTable.primaryColumns.map((column) => column.name));\n            const columnNames = clonedTable.primaryColumns\n                .map((primaryColumn) => `\"${primaryColumn.name}\"`)\n                .join(\", \");\n            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(clonedTable)} DROP CONSTRAINT \"${pkName}\"`));\n            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(clonedTable)} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`));\n            // update column in table\n            const tableColumn = clonedTable.findColumnByName(column.name);\n            tableColumn.isPrimary = false;\n            // if primary key have multiple columns, we must recreate it without dropped column\n            if (clonedTable.primaryColumns.length > 0) {\n                const pkName = clonedTable.primaryColumns[0]\n                    .primaryKeyConstraintName\n                    ? clonedTable.primaryColumns[0].primaryKeyConstraintName\n                    : this.connection.namingStrategy.primaryKeyName(clonedTable, clonedTable.primaryColumns.map((column) => column.name));\n                const columnNames = clonedTable.primaryColumns\n                    .map((primaryColumn) => `\"${primaryColumn.name}\"`)\n                    .join(\", \");\n                upQueries.push(new Query(`ALTER TABLE ${this.escapePath(clonedTable)} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNames})`));\n                downQueries.push(new Query(`ALTER TABLE ${this.escapePath(clonedTable)} DROP CONSTRAINT \"${pkName}\"`));\n            }\n        }\n        // drop column index\n        const columnIndex = clonedTable.indices.find((index) => index.columnNames.length === 1 &&\n            index.columnNames[0] === column.name);\n        if (columnIndex) {\n            clonedTable.indices.splice(clonedTable.indices.indexOf(columnIndex), 1);\n            upQueries.push(this.dropIndexSql(table, columnIndex));\n            downQueries.push(this.createIndexSql(table, columnIndex));\n        }\n        // drop column check\n        const columnCheck = clonedTable.checks.find((check) => !!check.columnNames &&\n            check.columnNames.length === 1 &&\n            check.columnNames[0] === column.name);\n        if (columnCheck) {\n            clonedTable.checks.splice(clonedTable.checks.indexOf(columnCheck), 1);\n            upQueries.push(this.dropCheckConstraintSql(table, columnCheck));\n            downQueries.push(this.createCheckConstraintSql(table, columnCheck));\n        }\n        // drop column unique\n        const columnUnique = clonedTable.uniques.find((unique) => unique.columnNames.length === 1 &&\n            unique.columnNames[0] === column.name);\n        if (columnUnique) {\n            clonedTable.uniques.splice(clonedTable.uniques.indexOf(columnUnique), 1);\n            upQueries.push(this.dropUniqueConstraintSql(table, columnUnique));\n            downQueries.push(this.createUniqueConstraintSql(table, columnUnique));\n        }\n        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN \"${column.name}\"`));\n        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(table, column)}`));\n        // drop enum type\n        if (column.type === \"enum\" || column.type === \"simple-enum\") {\n            const hasEnum = await this.hasEnumType(table, column);\n            if (hasEnum) {\n                const enumType = await this.getUserDefinedTypeName(table, column);\n                const escapedEnumName = `\"${enumType.schema}\".\"${enumType.name}\"`;\n                upQueries.push(this.dropEnumTypeSql(table, column, escapedEnumName));\n                downQueries.push(this.createEnumTypeSql(table, column, escapedEnumName));\n            }\n        }\n        if (column.generatedType === \"STORED\") {\n            const tableNameWithSchema = (await this.getTableNameWithSchema(table.name)).split(\".\");\n            const tableName = tableNameWithSchema[1];\n            const schema = tableNameWithSchema[0];\n            const deleteQuery = this.deleteTypeormMetadataSql({\n                database: this.driver.database,\n                schema,\n                table: tableName,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n            });\n            const insertQuery = this.insertTypeormMetadataSql({\n                database: this.driver.database,\n                schema,\n                table: tableName,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n                value: column.asExpression,\n            });\n            upQueries.push(deleteQuery);\n            downQueries.push(insertQuery);\n        }\n        await this.executeQueries(upQueries, downQueries);\n        clonedTable.removeColumn(column);\n        this.replaceCachedTable(table, clonedTable);\n    }\n    /**\n     * Drops the columns in the table.\n     */\n    async dropColumns(tableOrName, columns) {\n        for (const column of columns) {\n            await this.dropColumn(tableOrName, column);\n        }\n    }\n    /**\n     * Creates a new primary key.\n     */\n    async createPrimaryKey(tableOrName, columnNames, constraintName) {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        const clonedTable = table.clone();\n        const up = this.createPrimaryKeySql(table, columnNames, constraintName);\n        // mark columns as primary, because dropPrimaryKeySql build constraint name from table primary column names.\n        clonedTable.columns.forEach((column) => {\n            if (columnNames.find((columnName) => columnName === column.name))\n                column.isPrimary = true;\n        });\n        const down = this.dropPrimaryKeySql(clonedTable);\n        await this.executeQueries(up, down);\n        this.replaceCachedTable(table, clonedTable);\n    }\n    /**\n     * Updates composite primary keys.\n     */\n    async updatePrimaryKeys(tableOrName, columns) {\n        var _a;\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        const clonedTable = table.clone();\n        const columnNames = columns.map((column) => column.name);\n        const upQueries = [];\n        const downQueries = [];\n        // if table already have primary columns, we must drop them.\n        const primaryColumns = clonedTable.primaryColumns;\n        if (primaryColumns.length > 0) {\n            const pkName = primaryColumns[0].primaryKeyConstraintName\n                ? primaryColumns[0].primaryKeyConstraintName\n                : this.connection.namingStrategy.primaryKeyName(clonedTable, primaryColumns.map((column) => column.name));\n            const columnNamesString = primaryColumns\n                .map((column) => `\"${column.name}\"`)\n                .join(\", \");\n            upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${pkName}\"`));\n            downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNamesString})`));\n        }\n        // update columns in table.\n        clonedTable.columns\n            .filter((column) => columnNames.indexOf(column.name) !== -1)\n            .forEach((column) => (column.isPrimary = true));\n        const pkName = ((_a = primaryColumns[0]) === null || _a === void 0 ? void 0 : _a.primaryKeyConstraintName)\n            ? primaryColumns[0].primaryKeyConstraintName\n            : this.connection.namingStrategy.primaryKeyName(clonedTable, columnNames);\n        const columnNamesString = columnNames\n            .map((columnName) => `\"${columnName}\"`)\n            .join(\", \");\n        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${pkName}\" PRIMARY KEY (${columnNamesString})`));\n        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${pkName}\"`));\n        await this.executeQueries(upQueries, downQueries);\n        this.replaceCachedTable(table, clonedTable);\n    }\n    /**\n     * Drops a primary key.\n     */\n    async dropPrimaryKey(tableOrName, constraintName) {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        const up = this.dropPrimaryKeySql(table);\n        const down = this.createPrimaryKeySql(table, table.primaryColumns.map((column) => column.name), constraintName);\n        await this.executeQueries(up, down);\n        table.primaryColumns.forEach((column) => {\n            column.isPrimary = false;\n        });\n    }\n    /**\n     * Creates new unique constraint.\n     */\n    async createUniqueConstraint(tableOrName, uniqueConstraint) {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        // new unique constraint may be passed without name. In this case we generate unique name manually.\n        if (!uniqueConstraint.name)\n            uniqueConstraint.name =\n                this.connection.namingStrategy.uniqueConstraintName(table, uniqueConstraint.columnNames);\n        const up = this.createUniqueConstraintSql(table, uniqueConstraint);\n        const down = this.dropUniqueConstraintSql(table, uniqueConstraint);\n        await this.executeQueries(up, down);\n        table.addUniqueConstraint(uniqueConstraint);\n    }\n    /**\n     * Creates new unique constraints.\n     */\n    async createUniqueConstraints(tableOrName, uniqueConstraints) {\n        for (const uniqueConstraint of uniqueConstraints) {\n            await this.createUniqueConstraint(tableOrName, uniqueConstraint);\n        }\n    }\n    /**\n     * Drops unique constraint.\n     */\n    async dropUniqueConstraint(tableOrName, uniqueOrName) {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        const uniqueConstraint = InstanceChecker.isTableUnique(uniqueOrName)\n            ? uniqueOrName\n            : table.uniques.find((u) => u.name === uniqueOrName);\n        if (!uniqueConstraint)\n            throw new TypeORMError(`Supplied unique constraint was not found in table ${table.name}`);\n        const up = this.dropUniqueConstraintSql(table, uniqueConstraint);\n        const down = this.createUniqueConstraintSql(table, uniqueConstraint);\n        await this.executeQueries(up, down);\n        table.removeUniqueConstraint(uniqueConstraint);\n    }\n    /**\n     * Drops unique constraints.\n     */\n    async dropUniqueConstraints(tableOrName, uniqueConstraints) {\n        for (const uniqueConstraint of uniqueConstraints) {\n            await this.dropUniqueConstraint(tableOrName, uniqueConstraint);\n        }\n    }\n    /**\n     * Creates new check constraint.\n     */\n    async createCheckConstraint(tableOrName, checkConstraint) {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        // new unique constraint may be passed without name. In this case we generate unique name manually.\n        if (!checkConstraint.name)\n            checkConstraint.name =\n                this.connection.namingStrategy.checkConstraintName(table, checkConstraint.expression);\n        const up = this.createCheckConstraintSql(table, checkConstraint);\n        const down = this.dropCheckConstraintSql(table, checkConstraint);\n        await this.executeQueries(up, down);\n        table.addCheckConstraint(checkConstraint);\n    }\n    /**\n     * Creates new check constraints.\n     */\n    async createCheckConstraints(tableOrName, checkConstraints) {\n        const promises = checkConstraints.map((checkConstraint) => this.createCheckConstraint(tableOrName, checkConstraint));\n        await Promise.all(promises);\n    }\n    /**\n     * Drops check constraint.\n     */\n    async dropCheckConstraint(tableOrName, checkOrName) {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        const checkConstraint = InstanceChecker.isTableCheck(checkOrName)\n            ? checkOrName\n            : table.checks.find((c) => c.name === checkOrName);\n        if (!checkConstraint)\n            throw new TypeORMError(`Supplied check constraint was not found in table ${table.name}`);\n        const up = this.dropCheckConstraintSql(table, checkConstraint);\n        const down = this.createCheckConstraintSql(table, checkConstraint);\n        await this.executeQueries(up, down);\n        table.removeCheckConstraint(checkConstraint);\n    }\n    /**\n     * Drops check constraints.\n     */\n    async dropCheckConstraints(tableOrName, checkConstraints) {\n        const promises = checkConstraints.map((checkConstraint) => this.dropCheckConstraint(tableOrName, checkConstraint));\n        await Promise.all(promises);\n    }\n    /**\n     * Creates new exclusion constraint.\n     */\n    async createExclusionConstraint(tableOrName, exclusionConstraint) {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        // new unique constraint may be passed without name. In this case we generate unique name manually.\n        if (!exclusionConstraint.name)\n            exclusionConstraint.name =\n                this.connection.namingStrategy.exclusionConstraintName(table, exclusionConstraint.expression);\n        const up = this.createExclusionConstraintSql(table, exclusionConstraint);\n        const down = this.dropExclusionConstraintSql(table, exclusionConstraint);\n        await this.executeQueries(up, down);\n        table.addExclusionConstraint(exclusionConstraint);\n    }\n    /**\n     * Creates new exclusion constraints.\n     */\n    async createExclusionConstraints(tableOrName, exclusionConstraints) {\n        const promises = exclusionConstraints.map((exclusionConstraint) => this.createExclusionConstraint(tableOrName, exclusionConstraint));\n        await Promise.all(promises);\n    }\n    /**\n     * Drops exclusion constraint.\n     */\n    async dropExclusionConstraint(tableOrName, exclusionOrName) {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        const exclusionConstraint = InstanceChecker.isTableExclusion(exclusionOrName)\n            ? exclusionOrName\n            : table.exclusions.find((c) => c.name === exclusionOrName);\n        if (!exclusionConstraint)\n            throw new TypeORMError(`Supplied exclusion constraint was not found in table ${table.name}`);\n        const up = this.dropExclusionConstraintSql(table, exclusionConstraint);\n        const down = this.createExclusionConstraintSql(table, exclusionConstraint);\n        await this.executeQueries(up, down);\n        table.removeExclusionConstraint(exclusionConstraint);\n    }\n    /**\n     * Drops exclusion constraints.\n     */\n    async dropExclusionConstraints(tableOrName, exclusionConstraints) {\n        const promises = exclusionConstraints.map((exclusionConstraint) => this.dropExclusionConstraint(tableOrName, exclusionConstraint));\n        await Promise.all(promises);\n    }\n    /**\n     * Creates a new foreign key.\n     */\n    async createForeignKey(tableOrName, foreignKey) {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        // new FK may be passed without name. In this case we generate FK name manually.\n        if (!foreignKey.name)\n            foreignKey.name = this.connection.namingStrategy.foreignKeyName(table, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);\n        const up = this.createForeignKeySql(table, foreignKey);\n        const down = this.dropForeignKeySql(table, foreignKey);\n        await this.executeQueries(up, down);\n        table.addForeignKey(foreignKey);\n    }\n    /**\n     * Creates a new foreign keys.\n     */\n    async createForeignKeys(tableOrName, foreignKeys) {\n        for (const foreignKey of foreignKeys) {\n            await this.createForeignKey(tableOrName, foreignKey);\n        }\n    }\n    /**\n     * Drops a foreign key from the table.\n     */\n    async dropForeignKey(tableOrName, foreignKeyOrName) {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        const foreignKey = InstanceChecker.isTableForeignKey(foreignKeyOrName)\n            ? foreignKeyOrName\n            : table.foreignKeys.find((fk) => fk.name === foreignKeyOrName);\n        if (!foreignKey)\n            throw new TypeORMError(`Supplied foreign key was not found in table ${table.name}`);\n        if (!foreignKey.name) {\n            foreignKey.name = this.connection.namingStrategy.foreignKeyName(table, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);\n        }\n        const up = this.dropForeignKeySql(table, foreignKey);\n        const down = this.createForeignKeySql(table, foreignKey);\n        await this.executeQueries(up, down);\n        table.removeForeignKey(foreignKey);\n    }\n    /**\n     * Drops a foreign keys from the table.\n     */\n    async dropForeignKeys(tableOrName, foreignKeys) {\n        for (const foreignKey of foreignKeys) {\n            await this.dropForeignKey(tableOrName, foreignKey);\n        }\n    }\n    /**\n     * Creates a new index.\n     */\n    async createIndex(tableOrName, index) {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        // new index may be passed without name. In this case we generate index name manually.\n        if (!index.name)\n            index.name = this.generateIndexName(table, index);\n        const up = this.createIndexSql(table, index);\n        const down = this.dropIndexSql(table, index);\n        await this.executeQueries(up, down);\n        table.addIndex(index);\n    }\n    /**\n     * Create a new view index.\n     */\n    async createViewIndex(viewOrName, index) {\n        const view = InstanceChecker.isView(viewOrName)\n            ? viewOrName\n            : await this.getCachedView(viewOrName);\n        // new index may be passed without name. In this case we generate index name manually.\n        if (!index.name)\n            index.name = this.generateIndexName(view, index);\n        const up = this.createViewIndexSql(view, index);\n        const down = this.dropIndexSql(view, index);\n        await this.executeQueries(up, down);\n        view.addIndex(index);\n    }\n    /**\n     * Creates a new indices\n     */\n    async createIndices(tableOrName, indices) {\n        for (const index of indices) {\n            await this.createIndex(tableOrName, index);\n        }\n    }\n    /**\n     * Creates new view indices\n     */\n    async createViewIndices(viewOrName, indices) {\n        for (const index of indices) {\n            await this.createViewIndex(viewOrName, index);\n        }\n    }\n    /**\n     * Drops an index from the table.\n     */\n    async dropIndex(tableOrName, indexOrName) {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        const index = InstanceChecker.isTableIndex(indexOrName)\n            ? indexOrName\n            : table.indices.find((i) => i.name === indexOrName);\n        if (!index)\n            throw new TypeORMError(`Supplied index ${indexOrName} was not found in table ${table.name}`);\n        // old index may be passed without name. In this case we generate index name manually.\n        if (!index.name)\n            index.name = this.generateIndexName(table, index);\n        const up = this.dropIndexSql(table, index);\n        const down = this.createIndexSql(table, index);\n        await this.executeQueries(up, down);\n        table.removeIndex(index);\n    }\n    /**\n     * Drops an index from a view.\n     */\n    async dropViewIndex(viewOrName, indexOrName) {\n        const view = InstanceChecker.isView(viewOrName)\n            ? viewOrName\n            : await this.getCachedView(viewOrName);\n        const index = InstanceChecker.isTableIndex(indexOrName)\n            ? indexOrName\n            : view.indices.find((i) => i.name === indexOrName);\n        if (!index)\n            throw new TypeORMError(`Supplied index ${indexOrName} was not found in view ${view.name}`);\n        // old index may be passed without name. In this case we generate index name manually.\n        if (!index.name)\n            index.name = this.generateIndexName(view, index);\n        const up = this.dropIndexSql(view, index);\n        const down = this.createViewIndexSql(view, index);\n        await this.executeQueries(up, down);\n        view.removeIndex(index);\n    }\n    /**\n     * Drops an indices from the table.\n     */\n    async dropIndices(tableOrName, indices) {\n        for (const index of indices) {\n            await this.dropIndex(tableOrName, index);\n        }\n    }\n    /**\n     * Clears all table contents.\n     * Note: this operation uses SQL's TRUNCATE query which cannot be reverted in transactions.\n     */\n    async clearTable(tableName) {\n        await this.query(`TRUNCATE TABLE ${this.escapePath(tableName)}`);\n    }\n    /**\n     * Removes all tables from the currently connected database.\n     */\n    async clearDatabase() {\n        const schemas = [];\n        this.connection.entityMetadatas\n            .filter((metadata) => metadata.schema)\n            .forEach((metadata) => {\n            const isSchemaExist = !!schemas.find((schema) => schema === metadata.schema);\n            if (!isSchemaExist)\n                schemas.push(metadata.schema);\n        });\n        schemas.push(this.driver.options.schema || \"current_schema()\");\n        const schemaNamesString = schemas\n            .map((name) => {\n            return name === \"current_schema()\" ? name : \"'\" + name + \"'\";\n        })\n            .join(\", \");\n        const isAnotherTransactionActive = this.isTransactionActive;\n        if (!isAnotherTransactionActive)\n            await this.startTransaction();\n        try {\n            const version = await this.getVersion();\n            // drop views\n            const selectViewDropsQuery = `SELECT 'DROP VIEW IF EXISTS \"' || schemaname || '\".\"' || viewname || '\" CASCADE;' as \"query\" ` +\n                `FROM \"pg_views\" WHERE \"schemaname\" IN (${schemaNamesString}) AND \"viewname\" NOT IN ('geography_columns', 'geometry_columns', 'raster_columns', 'raster_overviews')`;\n            const dropViewQueries = await this.query(selectViewDropsQuery);\n            await Promise.all(dropViewQueries.map((q) => this.query(q[\"query\"])));\n            // drop materialized views\n            // Note: materialized views introduced in Postgres 9.3\n            if (VersionUtils.isGreaterOrEqual(version, \"9.3\")) {\n                const selectMatViewDropsQuery = `SELECT 'DROP MATERIALIZED VIEW IF EXISTS \"' || schemaname || '\".\"' || matviewname || '\" CASCADE;' as \"query\" ` +\n                    `FROM \"pg_matviews\" WHERE \"schemaname\" IN (${schemaNamesString})`;\n                const dropMatViewQueries = await this.query(selectMatViewDropsQuery);\n                await Promise.all(dropMatViewQueries.map((q) => this.query(q[\"query\"])));\n            }\n            // ignore spatial_ref_sys; it's a special table supporting PostGIS\n            // TODO generalize this as this.driver.ignoreTables\n            // drop tables\n            const selectTableDropsQuery = `SELECT 'DROP TABLE IF EXISTS \"' || schemaname || '\".\"' || tablename || '\" CASCADE;' as \"query\" FROM \"pg_tables\" WHERE \"schemaname\" IN (${schemaNamesString}) AND \"tablename\" NOT IN ('spatial_ref_sys')`;\n            const dropTableQueries = await this.query(selectTableDropsQuery);\n            await Promise.all(dropTableQueries.map((q) => this.query(q[\"query\"])));\n            // drop enum types\n            await this.dropEnumTypes(schemaNamesString);\n            if (!isAnotherTransactionActive) {\n                await this.commitTransaction();\n            }\n        }\n        catch (error) {\n            try {\n                // we throw original error even if rollback thrown an error\n                if (!isAnotherTransactionActive) {\n                    await this.rollbackTransaction();\n                }\n            }\n            catch (rollbackError) { }\n            throw error;\n        }\n    }\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n    async loadViews(viewNames) {\n        const hasTable = await this.hasTable(this.getTypeormMetadataTableName());\n        if (!hasTable)\n            return [];\n        if (!viewNames) {\n            viewNames = [];\n        }\n        const currentDatabase = await this.getCurrentDatabase();\n        const currentSchema = await this.getCurrentSchema();\n        const viewsCondition = viewNames.length === 0\n            ? \"1=1\"\n            : viewNames\n                .map((tableName) => this.driver.parseTableName(tableName))\n                .map(({ schema, tableName }) => {\n                if (!schema) {\n                    schema =\n                        this.driver.options.schema || currentSchema;\n                }\n                return `(\"t\".\"schema\" = '${schema}' AND \"t\".\"name\" = '${tableName}')`;\n            })\n                .join(\" OR \");\n        const constraintsCondition = viewNames.length === 0\n            ? \"1=1\"\n            : viewNames\n                .map((tableName) => this.driver.parseTableName(tableName))\n                .map(({ schema, tableName }) => {\n                if (!schema) {\n                    schema =\n                        this.driver.options.schema || currentSchema;\n                }\n                return `(\"ns\".\"nspname\" = '${schema}' AND \"t\".\"relname\" = '${tableName}')`;\n            })\n                .join(\" OR \");\n        const indicesSql = `SELECT \"ns\".\"nspname\" AS \"table_schema\", \"t\".\"relname\" AS \"table_name\", \"i\".\"relname\" AS \"constraint_name\", \"a\".\"attname\" AS \"column_name\", ` +\n            `CASE \"ix\".\"indisunique\" WHEN 't' THEN 'TRUE' ELSE'FALSE' END AS \"is_unique\", pg_get_expr(\"ix\".\"indpred\", \"ix\".\"indrelid\") AS \"condition\", ` +\n            `\"types\".\"typname\" AS \"type_name\" ` +\n            `FROM \"pg_class\" \"t\" ` +\n            `INNER JOIN \"pg_index\" \"ix\" ON \"ix\".\"indrelid\" = \"t\".\"oid\" ` +\n            `INNER JOIN \"pg_attribute\" \"a\" ON \"a\".\"attrelid\" = \"t\".\"oid\"  AND \"a\".\"attnum\" = ANY (\"ix\".\"indkey\") ` +\n            `INNER JOIN \"pg_namespace\" \"ns\" ON \"ns\".\"oid\" = \"t\".\"relnamespace\" ` +\n            `INNER JOIN \"pg_class\" \"i\" ON \"i\".\"oid\" = \"ix\".\"indexrelid\" ` +\n            `INNER JOIN \"pg_type\" \"types\" ON \"types\".\"oid\" = \"a\".\"atttypid\" ` +\n            `LEFT JOIN \"pg_constraint\" \"cnst\" ON \"cnst\".\"conname\" = \"i\".\"relname\" ` +\n            `WHERE \"t\".\"relkind\" IN ('m') AND \"cnst\".\"contype\" IS NULL AND (${constraintsCondition})`;\n        const query = `SELECT \"t\".* FROM ${this.escapePath(this.getTypeormMetadataTableName())} \"t\" ` +\n            `INNER JOIN \"pg_catalog\".\"pg_class\" \"c\" ON \"c\".\"relname\" = \"t\".\"name\" ` +\n            `INNER JOIN \"pg_namespace\" \"n\" ON \"n\".\"oid\" = \"c\".\"relnamespace\" AND \"n\".\"nspname\" = \"t\".\"schema\" ` +\n            `WHERE \"t\".\"type\" IN ('${MetadataTableType.VIEW}', '${MetadataTableType.MATERIALIZED_VIEW}') ${viewsCondition ? `AND (${viewsCondition})` : \"\"}`;\n        const dbViews = await this.query(query);\n        const dbIndices = await this.query(indicesSql);\n        return dbViews.map((dbView) => {\n            // find index constraints of table, group them by constraint name and build TableIndex.\n            const tableIndexConstraints = OrmUtils.uniq(dbIndices.filter((dbIndex) => {\n                return (dbIndex[\"table_name\"] === dbView[\"name\"] &&\n                    dbIndex[\"table_schema\"] === dbView[\"schema\"]);\n            }), (dbIndex) => dbIndex[\"constraint_name\"]);\n            const view = new View();\n            const schema = dbView[\"schema\"] === currentSchema &&\n                !this.driver.options.schema\n                ? undefined\n                : dbView[\"schema\"];\n            view.database = currentDatabase;\n            view.schema = dbView[\"schema\"];\n            view.name = this.driver.buildTableName(dbView[\"name\"], schema);\n            view.expression = dbView[\"value\"];\n            view.materialized =\n                dbView[\"type\"] === MetadataTableType.MATERIALIZED_VIEW;\n            view.indices = tableIndexConstraints.map((constraint) => {\n                const indices = dbIndices.filter((index) => {\n                    return (index[\"table_schema\"] === constraint[\"table_schema\"] &&\n                        index[\"table_name\"] === constraint[\"table_name\"] &&\n                        index[\"constraint_name\"] ===\n                            constraint[\"constraint_name\"]);\n                });\n                return new TableIndex({\n                    view: view,\n                    name: constraint[\"constraint_name\"],\n                    columnNames: indices.map((i) => i[\"column_name\"]),\n                    isUnique: constraint[\"is_unique\"] === \"TRUE\",\n                    where: constraint[\"condition\"],\n                    isFulltext: false,\n                });\n            });\n            return view;\n        });\n    }\n    /**\n     * Loads all tables (with given names) from the database and creates a Table from them.\n     */\n    async loadTables(tableNames) {\n        // if no tables given then no need to proceed\n        if (tableNames && tableNames.length === 0) {\n            return [];\n        }\n        const currentSchema = await this.getCurrentSchema();\n        const currentDatabase = await this.getCurrentDatabase();\n        const dbTables = [];\n        if (!tableNames) {\n            const tablesSql = `SELECT \"table_schema\", \"table_name\" FROM \"information_schema\".\"tables\"`;\n            dbTables.push(...(await this.query(tablesSql)));\n        }\n        else {\n            const tablesCondition = tableNames\n                .map((tableName) => this.driver.parseTableName(tableName))\n                .map(({ schema, tableName }) => {\n                return `(\"table_schema\" = '${schema || currentSchema}' AND \"table_name\" = '${tableName}')`;\n            })\n                .join(\" OR \");\n            const tablesSql = `SELECT \"table_schema\", \"table_name\" FROM \"information_schema\".\"tables\" WHERE ` +\n                tablesCondition;\n            dbTables.push(...(await this.query(tablesSql)));\n        }\n        // if tables were not found in the db, no need to proceed\n        if (dbTables.length === 0) {\n            return [];\n        }\n        /**\n         * Uses standard SQL information_schema.columns table and postgres-specific\n         * pg_catalog.pg_attribute table to get column information.\n         * @see https://stackoverflow.com/a/19541865\n         */\n        const columnsCondition = dbTables\n            .map(({ table_schema, table_name }) => {\n            return `(\"table_schema\" = '${table_schema}' AND \"table_name\" = '${table_name}')`;\n        })\n            .join(\" OR \");\n        const columnsSql = `SELECT columns.*, pg_catalog.col_description(('\"' || table_catalog || '\".\"' || table_schema || '\".\"' || table_name || '\"')::regclass::oid, ordinal_position) AS description, ` +\n            `('\"' || \"udt_schema\" || '\".\"' || \"udt_name\" || '\"')::\"regtype\" AS \"regtype\", pg_catalog.format_type(\"col_attr\".\"atttypid\", \"col_attr\".\"atttypmod\") AS \"format_type\" ` +\n            `FROM \"information_schema\".\"columns\" ` +\n            `LEFT JOIN \"pg_catalog\".\"pg_attribute\" AS \"col_attr\" ON \"col_attr\".\"attname\" = \"columns\".\"column_name\" ` +\n            `AND \"col_attr\".\"attrelid\" = ( ` +\n            `SELECT \"cls\".\"oid\" FROM \"pg_catalog\".\"pg_class\" AS \"cls\" ` +\n            `LEFT JOIN \"pg_catalog\".\"pg_namespace\" AS \"ns\" ON \"ns\".\"oid\" = \"cls\".\"relnamespace\" ` +\n            `WHERE \"cls\".\"relname\" = \"columns\".\"table_name\" ` +\n            `AND \"ns\".\"nspname\" = \"columns\".\"table_schema\" ` +\n            `) ` +\n            `WHERE ` +\n            columnsCondition;\n        const constraintsCondition = dbTables\n            .map(({ table_schema, table_name }) => {\n            return `(\"ns\".\"nspname\" = '${table_schema}' AND \"t\".\"relname\" = '${table_name}')`;\n        })\n            .join(\" OR \");\n        const constraintsSql = `SELECT \"ns\".\"nspname\" AS \"table_schema\", \"t\".\"relname\" AS \"table_name\", \"cnst\".\"conname\" AS \"constraint_name\", ` +\n            `pg_get_constraintdef(\"cnst\".\"oid\") AS \"expression\", ` +\n            `CASE \"cnst\".\"contype\" WHEN 'p' THEN 'PRIMARY' WHEN 'u' THEN 'UNIQUE' WHEN 'c' THEN 'CHECK' WHEN 'x' THEN 'EXCLUDE' END AS \"constraint_type\", \"a\".\"attname\" AS \"column_name\" ` +\n            `FROM \"pg_constraint\" \"cnst\" ` +\n            `INNER JOIN \"pg_class\" \"t\" ON \"t\".\"oid\" = \"cnst\".\"conrelid\" ` +\n            `INNER JOIN \"pg_namespace\" \"ns\" ON \"ns\".\"oid\" = \"cnst\".\"connamespace\" ` +\n            `LEFT JOIN \"pg_attribute\" \"a\" ON \"a\".\"attrelid\" = \"cnst\".\"conrelid\" AND \"a\".\"attnum\" = ANY (\"cnst\".\"conkey\") ` +\n            `WHERE \"t\".\"relkind\" IN ('r', 'p') AND (${constraintsCondition})`;\n        const indicesSql = `SELECT \"ns\".\"nspname\" AS \"table_schema\", \"t\".\"relname\" AS \"table_name\", \"i\".\"relname\" AS \"constraint_name\", \"a\".\"attname\" AS \"column_name\", ` +\n            `CASE \"ix\".\"indisunique\" WHEN 't' THEN 'TRUE' ELSE'FALSE' END AS \"is_unique\", pg_get_expr(\"ix\".\"indpred\", \"ix\".\"indrelid\") AS \"condition\", ` +\n            `\"types\".\"typname\" AS \"type_name\" ` +\n            `FROM \"pg_class\" \"t\" ` +\n            `INNER JOIN \"pg_index\" \"ix\" ON \"ix\".\"indrelid\" = \"t\".\"oid\" ` +\n            `INNER JOIN \"pg_attribute\" \"a\" ON \"a\".\"attrelid\" = \"t\".\"oid\"  AND \"a\".\"attnum\" = ANY (\"ix\".\"indkey\") ` +\n            `INNER JOIN \"pg_namespace\" \"ns\" ON \"ns\".\"oid\" = \"t\".\"relnamespace\" ` +\n            `INNER JOIN \"pg_class\" \"i\" ON \"i\".\"oid\" = \"ix\".\"indexrelid\" ` +\n            `INNER JOIN \"pg_type\" \"types\" ON \"types\".\"oid\" = \"a\".\"atttypid\" ` +\n            `LEFT JOIN \"pg_constraint\" \"cnst\" ON \"cnst\".\"conname\" = \"i\".\"relname\" ` +\n            `WHERE \"t\".\"relkind\" IN ('r', 'p') AND \"cnst\".\"contype\" IS NULL AND (${constraintsCondition})`;\n        const foreignKeysCondition = dbTables\n            .map(({ table_schema, table_name }) => {\n            return `(\"ns\".\"nspname\" = '${table_schema}' AND \"cl\".\"relname\" = '${table_name}')`;\n        })\n            .join(\" OR \");\n        const hasRelispartitionColumn = await this.hasSupportForPartitionedTables();\n        const isPartitionCondition = hasRelispartitionColumn\n            ? ` AND \"cl\".\"relispartition\" = 'f'`\n            : \"\";\n        const foreignKeysSql = `SELECT \"con\".\"conname\" AS \"constraint_name\", \"con\".\"nspname\" AS \"table_schema\", \"con\".\"relname\" AS \"table_name\", \"att2\".\"attname\" AS \"column_name\", ` +\n            `\"ns\".\"nspname\" AS \"referenced_table_schema\", \"cl\".\"relname\" AS \"referenced_table_name\", \"att\".\"attname\" AS \"referenced_column_name\", \"con\".\"confdeltype\" AS \"on_delete\", ` +\n            `\"con\".\"confupdtype\" AS \"on_update\", \"con\".\"condeferrable\" AS \"deferrable\", \"con\".\"condeferred\" AS \"deferred\" ` +\n            `FROM ( ` +\n            `SELECT UNNEST (\"con1\".\"conkey\") AS \"parent\", UNNEST (\"con1\".\"confkey\") AS \"child\", \"con1\".\"confrelid\", \"con1\".\"conrelid\", \"con1\".\"conname\", \"con1\".\"contype\", \"ns\".\"nspname\", ` +\n            `\"cl\".\"relname\", \"con1\".\"condeferrable\", ` +\n            `CASE WHEN \"con1\".\"condeferred\" THEN 'INITIALLY DEFERRED' ELSE 'INITIALLY IMMEDIATE' END as condeferred, ` +\n            `CASE \"con1\".\"confdeltype\" WHEN 'a' THEN 'NO ACTION' WHEN 'r' THEN 'RESTRICT' WHEN 'c' THEN 'CASCADE' WHEN 'n' THEN 'SET NULL' WHEN 'd' THEN 'SET DEFAULT' END as \"confdeltype\", ` +\n            `CASE \"con1\".\"confupdtype\" WHEN 'a' THEN 'NO ACTION' WHEN 'r' THEN 'RESTRICT' WHEN 'c' THEN 'CASCADE' WHEN 'n' THEN 'SET NULL' WHEN 'd' THEN 'SET DEFAULT' END as \"confupdtype\" ` +\n            `FROM \"pg_class\" \"cl\" ` +\n            `INNER JOIN \"pg_namespace\" \"ns\" ON \"cl\".\"relnamespace\" = \"ns\".\"oid\" ` +\n            `INNER JOIN \"pg_constraint\" \"con1\" ON \"con1\".\"conrelid\" = \"cl\".\"oid\" ` +\n            `WHERE \"con1\".\"contype\" = 'f' AND (${foreignKeysCondition}) ` +\n            `) \"con\" ` +\n            `INNER JOIN \"pg_attribute\" \"att\" ON \"att\".\"attrelid\" = \"con\".\"confrelid\" AND \"att\".\"attnum\" = \"con\".\"child\" ` +\n            `INNER JOIN \"pg_class\" \"cl\" ON \"cl\".\"oid\" = \"con\".\"confrelid\" ${isPartitionCondition}` +\n            `INNER JOIN \"pg_namespace\" \"ns\" ON \"cl\".\"relnamespace\" = \"ns\".\"oid\" ` +\n            `INNER JOIN \"pg_attribute\" \"att2\" ON \"att2\".\"attrelid\" = \"con\".\"conrelid\" AND \"att2\".\"attnum\" = \"con\".\"parent\"`;\n        const [dbColumns, dbConstraints, dbIndices, dbForeignKeys,] = await Promise.all([\n            this.query(columnsSql),\n            this.query(constraintsSql),\n            this.query(indicesSql),\n            this.query(foreignKeysSql),\n        ]);\n        // create tables for loaded tables\n        return Promise.all(dbTables.map(async (dbTable) => {\n            const table = new Table();\n            const getSchemaFromKey = (dbObject, key) => {\n                return dbObject[key] === currentSchema &&\n                    (!this.driver.options.schema ||\n                        this.driver.options.schema === currentSchema)\n                    ? undefined\n                    : dbObject[key];\n            };\n            // We do not need to join schema name, when database is by default.\n            const schema = getSchemaFromKey(dbTable, \"table_schema\");\n            table.database = currentDatabase;\n            table.schema = dbTable[\"table_schema\"];\n            table.name = this.driver.buildTableName(dbTable[\"table_name\"], schema);\n            // create columns from the loaded columns\n            table.columns = await Promise.all(dbColumns\n                .filter((dbColumn) => dbColumn[\"table_name\"] ===\n                dbTable[\"table_name\"] &&\n                dbColumn[\"table_schema\"] ===\n                    dbTable[\"table_schema\"])\n                .map(async (dbColumn) => {\n                const columnConstraints = dbConstraints.filter((dbConstraint) => {\n                    return (dbConstraint[\"table_name\"] ===\n                        dbColumn[\"table_name\"] &&\n                        dbConstraint[\"table_schema\"] ===\n                            dbColumn[\"table_schema\"] &&\n                        dbConstraint[\"column_name\"] ===\n                            dbColumn[\"column_name\"]);\n                });\n                const tableColumn = new TableColumn();\n                tableColumn.name = dbColumn[\"column_name\"];\n                tableColumn.type = dbColumn[\"regtype\"].toLowerCase();\n                if (tableColumn.type === \"numeric\" ||\n                    tableColumn.type === \"decimal\" ||\n                    tableColumn.type === \"float\") {\n                    // If one of these properties was set, and another was not, Postgres sets '0' in to unspecified property\n                    // we set 'undefined' in to unspecified property to avoid changing column on sync\n                    if (dbColumn[\"numeric_precision\"] !== null &&\n                        !this.isDefaultColumnPrecision(table, tableColumn, dbColumn[\"numeric_precision\"])) {\n                        tableColumn.precision =\n                            dbColumn[\"numeric_precision\"];\n                    }\n                    else if (dbColumn[\"numeric_scale\"] !== null &&\n                        !this.isDefaultColumnScale(table, tableColumn, dbColumn[\"numeric_scale\"])) {\n                        tableColumn.precision = undefined;\n                    }\n                    if (dbColumn[\"numeric_scale\"] !== null &&\n                        !this.isDefaultColumnScale(table, tableColumn, dbColumn[\"numeric_scale\"])) {\n                        tableColumn.scale =\n                            dbColumn[\"numeric_scale\"];\n                    }\n                    else if (dbColumn[\"numeric_precision\"] !== null &&\n                        !this.isDefaultColumnPrecision(table, tableColumn, dbColumn[\"numeric_precision\"])) {\n                        tableColumn.scale = undefined;\n                    }\n                }\n                if (tableColumn.type === \"interval\" ||\n                    tableColumn.type === \"time without time zone\" ||\n                    tableColumn.type === \"time with time zone\" ||\n                    tableColumn.type ===\n                        \"timestamp without time zone\" ||\n                    tableColumn.type === \"timestamp with time zone\") {\n                    tableColumn.precision =\n                        !this.isDefaultColumnPrecision(table, tableColumn, dbColumn[\"datetime_precision\"])\n                            ? dbColumn[\"datetime_precision\"]\n                            : undefined;\n                }\n                // check if column has user-defined data type.\n                // NOTE: if ENUM type defined with \"array:true\" it comes with ARRAY type instead of USER-DEFINED\n                if (dbColumn[\"data_type\"] === \"USER-DEFINED\" ||\n                    dbColumn[\"data_type\"] === \"ARRAY\") {\n                    const { name } = await this.getUserDefinedTypeName(table, tableColumn);\n                    // check if `enumName` is specified by user\n                    const builtEnumName = this.buildEnumName(table, tableColumn, false, true);\n                    const enumName = builtEnumName !== name ? name : undefined;\n                    // check if type is ENUM\n                    const sql = `SELECT \"e\".\"enumlabel\" AS \"value\" FROM \"pg_enum\" \"e\" ` +\n                        `INNER JOIN \"pg_type\" \"t\" ON \"t\".\"oid\" = \"e\".\"enumtypid\" ` +\n                        `INNER JOIN \"pg_namespace\" \"n\" ON \"n\".\"oid\" = \"t\".\"typnamespace\" ` +\n                        `WHERE \"n\".\"nspname\" = '${dbTable[\"table_schema\"]}' AND \"t\".\"typname\" = '${enumName || name}'`;\n                    const results = await this.query(sql);\n                    if (results.length) {\n                        tableColumn.type = \"enum\";\n                        tableColumn.enum = results.map((result) => result[\"value\"]);\n                        tableColumn.enumName = enumName;\n                    }\n                    if (dbColumn[\"data_type\"] === \"ARRAY\") {\n                        tableColumn.isArray = true;\n                        const type = tableColumn.type.replace(\"[]\", \"\");\n                        tableColumn.type =\n                            this.connection.driver.normalizeType({\n                                type: type,\n                            });\n                    }\n                }\n                if (tableColumn.type === \"geometry\" ||\n                    tableColumn.type === \"geography\") {\n                    const sql = `SELECT * FROM (` +\n                        `SELECT \"f_table_schema\" \"table_schema\", \"f_table_name\" \"table_name\", ` +\n                        `\"f_${tableColumn.type}_column\" \"column_name\", \"srid\", \"type\" ` +\n                        `FROM \"${tableColumn.type}_columns\"` +\n                        `) AS _ ` +\n                        `WHERE \"column_name\" = '${dbColumn[\"column_name\"]}' AND ` +\n                        `\"table_schema\" = '${dbColumn[\"table_schema\"]}' AND ` +\n                        `\"table_name\" = '${dbColumn[\"table_name\"]}'`;\n                    const results = await this.query(sql);\n                    if (results.length > 0) {\n                        tableColumn.spatialFeatureType =\n                            results[0].type;\n                        tableColumn.srid = results[0].srid;\n                    }\n                }\n                // check only columns that have length property\n                if (this.driver.withLengthColumnTypes.indexOf(tableColumn.type) !== -1) {\n                    let length;\n                    if (tableColumn.isArray) {\n                        const match = /\\((\\d+)\\)/.exec(dbColumn[\"format_type\"]);\n                        length = match ? match[1] : undefined;\n                    }\n                    else if (dbColumn[\"character_maximum_length\"]) {\n                        length =\n                            dbColumn[\"character_maximum_length\"].toString();\n                    }\n                    if (length) {\n                        tableColumn.length =\n                            !this.isDefaultColumnLength(table, tableColumn, length)\n                                ? length\n                                : \"\";\n                    }\n                }\n                tableColumn.isNullable =\n                    dbColumn[\"is_nullable\"] === \"YES\";\n                const primaryConstraint = columnConstraints.find((constraint) => constraint[\"constraint_type\"] === \"PRIMARY\");\n                if (primaryConstraint) {\n                    tableColumn.isPrimary = true;\n                    // find another columns involved in primary key constraint\n                    const anotherPrimaryConstraints = dbConstraints.filter((constraint) => constraint[\"table_name\"] ===\n                        dbColumn[\"table_name\"] &&\n                        constraint[\"table_schema\"] ===\n                            dbColumn[\"table_schema\"] &&\n                        constraint[\"column_name\"] !==\n                            dbColumn[\"column_name\"] &&\n                        constraint[\"constraint_type\"] ===\n                            \"PRIMARY\");\n                    // collect all column names\n                    const columnNames = anotherPrimaryConstraints.map((constraint) => constraint[\"column_name\"]);\n                    columnNames.push(dbColumn[\"column_name\"]);\n                    // build default primary key constraint name\n                    const pkName = this.connection.namingStrategy.primaryKeyName(table, columnNames);\n                    // if primary key has user-defined constraint name, write it in table column\n                    if (primaryConstraint[\"constraint_name\"] !==\n                        pkName) {\n                        tableColumn.primaryKeyConstraintName =\n                            primaryConstraint[\"constraint_name\"];\n                    }\n                }\n                const uniqueConstraints = columnConstraints.filter((constraint) => constraint[\"constraint_type\"] === \"UNIQUE\");\n                const isConstraintComposite = uniqueConstraints.every((uniqueConstraint) => {\n                    return dbConstraints.some((dbConstraint) => dbConstraint[\"constraint_type\"] ===\n                        \"UNIQUE\" &&\n                        dbConstraint[\"constraint_name\"] ===\n                            uniqueConstraint[\"constraint_name\"] &&\n                        dbConstraint[\"column_name\"] !==\n                            dbColumn[\"column_name\"]);\n                });\n                tableColumn.isUnique =\n                    uniqueConstraints.length > 0 &&\n                        !isConstraintComposite;\n                if (dbColumn.is_identity === \"YES\") {\n                    // Postgres 10+ Identity column\n                    tableColumn.isGenerated = true;\n                    tableColumn.generationStrategy = \"identity\";\n                    tableColumn.generatedIdentity =\n                        dbColumn.identity_generation;\n                }\n                else if (dbColumn[\"column_default\"] !== null &&\n                    dbColumn[\"column_default\"] !== undefined) {\n                    const serialDefaultName = `nextval('${this.buildSequenceName(table, dbColumn[\"column_name\"])}'::regclass)`;\n                    const serialDefaultPath = `nextval('${this.buildSequencePath(table, dbColumn[\"column_name\"])}'::regclass)`;\n                    const defaultWithoutQuotes = dbColumn[\"column_default\"].replace(/\"/g, \"\");\n                    if (defaultWithoutQuotes ===\n                        serialDefaultName ||\n                        defaultWithoutQuotes === serialDefaultPath) {\n                        tableColumn.isGenerated = true;\n                        tableColumn.generationStrategy = \"increment\";\n                    }\n                    else if (dbColumn[\"column_default\"] ===\n                        \"gen_random_uuid()\" ||\n                        /^uuid_generate_v\\d\\(\\)/.test(dbColumn[\"column_default\"])) {\n                        if (tableColumn.type === \"uuid\") {\n                            tableColumn.isGenerated = true;\n                            tableColumn.generationStrategy = \"uuid\";\n                        }\n                        else {\n                            tableColumn.default =\n                                dbColumn[\"column_default\"];\n                        }\n                    }\n                    else if (dbColumn[\"column_default\"] === \"now()\" ||\n                        dbColumn[\"column_default\"].indexOf(\"'now'::text\") !== -1) {\n                        tableColumn.default =\n                            dbColumn[\"column_default\"];\n                    }\n                    else {\n                        tableColumn.default = dbColumn[\"column_default\"].replace(/::[\\w\\s.\\[\\]\\-\"]+/g, \"\");\n                        tableColumn.default =\n                            tableColumn.default.replace(/^(-?\\d+)$/, \"'$1'\");\n                    }\n                }\n                if (dbColumn[\"is_generated\"] === \"ALWAYS\" &&\n                    dbColumn[\"generation_expression\"]) {\n                    // In postgres there is no VIRTUAL generated column type\n                    tableColumn.generatedType = \"STORED\";\n                    // We cannot relay on information_schema.columns.generation_expression, because it is formatted different.\n                    const asExpressionQuery = await this.selectTypeormMetadataSql({\n                        database: currentDatabase,\n                        schema: dbTable[\"table_schema\"],\n                        table: dbTable[\"table_name\"],\n                        type: MetadataTableType.GENERATED_COLUMN,\n                        name: tableColumn.name,\n                    });\n                    const results = await this.query(asExpressionQuery.query, asExpressionQuery.parameters);\n                    if (results[0] && results[0].value) {\n                        tableColumn.asExpression = results[0].value;\n                    }\n                    else {\n                        tableColumn.asExpression = \"\";\n                    }\n                }\n                tableColumn.comment = dbColumn[\"description\"]\n                    ? dbColumn[\"description\"]\n                    : undefined;\n                if (dbColumn[\"character_set_name\"])\n                    tableColumn.charset =\n                        dbColumn[\"character_set_name\"];\n                if (dbColumn[\"collation_name\"])\n                    tableColumn.collation =\n                        dbColumn[\"collation_name\"];\n                return tableColumn;\n            }));\n            // find unique constraints of table, group them by constraint name and build TableUnique.\n            const tableUniqueConstraints = OrmUtils.uniq(dbConstraints.filter((dbConstraint) => {\n                return (dbConstraint[\"table_name\"] ===\n                    dbTable[\"table_name\"] &&\n                    dbConstraint[\"table_schema\"] ===\n                        dbTable[\"table_schema\"] &&\n                    dbConstraint[\"constraint_type\"] === \"UNIQUE\");\n            }), (dbConstraint) => dbConstraint[\"constraint_name\"]);\n            table.uniques = tableUniqueConstraints.map((constraint) => {\n                const uniques = dbConstraints.filter((dbC) => dbC[\"constraint_name\"] ===\n                    constraint[\"constraint_name\"]);\n                return new TableUnique({\n                    name: constraint[\"constraint_name\"],\n                    columnNames: uniques.map((u) => u[\"column_name\"]),\n                    deferrable: constraint[\"deferrable\"]\n                        ? constraint[\"deferred\"]\n                        : undefined,\n                });\n            });\n            // find check constraints of table, group them by constraint name and build TableCheck.\n            const tableCheckConstraints = OrmUtils.uniq(dbConstraints.filter((dbConstraint) => {\n                return (dbConstraint[\"table_name\"] ===\n                    dbTable[\"table_name\"] &&\n                    dbConstraint[\"table_schema\"] ===\n                        dbTable[\"table_schema\"] &&\n                    dbConstraint[\"constraint_type\"] === \"CHECK\");\n            }), (dbConstraint) => dbConstraint[\"constraint_name\"]);\n            table.checks = tableCheckConstraints.map((constraint) => {\n                const checks = dbConstraints.filter((dbC) => dbC[\"constraint_name\"] ===\n                    constraint[\"constraint_name\"]);\n                return new TableCheck({\n                    name: constraint[\"constraint_name\"],\n                    columnNames: checks.map((c) => c[\"column_name\"]),\n                    expression: constraint[\"expression\"].replace(/^\\s*CHECK\\s*\\((.*)\\)\\s*$/i, \"$1\"),\n                });\n            });\n            // find exclusion constraints of table, group them by constraint name and build TableExclusion.\n            const tableExclusionConstraints = OrmUtils.uniq(dbConstraints.filter((dbConstraint) => {\n                return (dbConstraint[\"table_name\"] ===\n                    dbTable[\"table_name\"] &&\n                    dbConstraint[\"table_schema\"] ===\n                        dbTable[\"table_schema\"] &&\n                    dbConstraint[\"constraint_type\"] === \"EXCLUDE\");\n            }), (dbConstraint) => dbConstraint[\"constraint_name\"]);\n            table.exclusions = tableExclusionConstraints.map((constraint) => {\n                return new TableExclusion({\n                    name: constraint[\"constraint_name\"],\n                    expression: constraint[\"expression\"].substring(8), // trim EXCLUDE from start of expression\n                });\n            });\n            // find foreign key constraints of table, group them by constraint name and build TableForeignKey.\n            const tableForeignKeyConstraints = OrmUtils.uniq(dbForeignKeys.filter((dbForeignKey) => {\n                return (dbForeignKey[\"table_name\"] ===\n                    dbTable[\"table_name\"] &&\n                    dbForeignKey[\"table_schema\"] ===\n                        dbTable[\"table_schema\"]);\n            }), (dbForeignKey) => dbForeignKey[\"constraint_name\"]);\n            table.foreignKeys = tableForeignKeyConstraints.map((dbForeignKey) => {\n                const foreignKeys = dbForeignKeys.filter((dbFk) => dbFk[\"constraint_name\"] ===\n                    dbForeignKey[\"constraint_name\"]);\n                // if referenced table located in currently used schema, we don't need to concat schema name to table name.\n                const schema = getSchemaFromKey(dbForeignKey, \"referenced_table_schema\");\n                const referencedTableName = this.driver.buildTableName(dbForeignKey[\"referenced_table_name\"], schema);\n                return new TableForeignKey({\n                    name: dbForeignKey[\"constraint_name\"],\n                    columnNames: foreignKeys.map((dbFk) => dbFk[\"column_name\"]),\n                    referencedSchema: dbForeignKey[\"referenced_table_schema\"],\n                    referencedTableName: referencedTableName,\n                    referencedColumnNames: foreignKeys.map((dbFk) => dbFk[\"referenced_column_name\"]),\n                    onDelete: dbForeignKey[\"on_delete\"],\n                    onUpdate: dbForeignKey[\"on_update\"],\n                    deferrable: dbForeignKey[\"deferrable\"]\n                        ? dbForeignKey[\"deferred\"]\n                        : undefined,\n                });\n            });\n            // find index constraints of table, group them by constraint name and build TableIndex.\n            const tableIndexConstraints = OrmUtils.uniq(dbIndices.filter((dbIndex) => {\n                return (dbIndex[\"table_name\"] === dbTable[\"table_name\"] &&\n                    dbIndex[\"table_schema\"] === dbTable[\"table_schema\"]);\n            }), (dbIndex) => dbIndex[\"constraint_name\"]);\n            table.indices = tableIndexConstraints.map((constraint) => {\n                const indices = dbIndices.filter((index) => {\n                    return (index[\"table_schema\"] ===\n                        constraint[\"table_schema\"] &&\n                        index[\"table_name\"] === constraint[\"table_name\"] &&\n                        index[\"constraint_name\"] ===\n                            constraint[\"constraint_name\"]);\n                });\n                return new TableIndex({\n                    table: table,\n                    name: constraint[\"constraint_name\"],\n                    columnNames: indices.map((i) => i[\"column_name\"]),\n                    isUnique: constraint[\"is_unique\"] === \"TRUE\",\n                    where: constraint[\"condition\"],\n                    isSpatial: indices.every((i) => this.driver.spatialTypes.indexOf(i[\"type_name\"]) >= 0),\n                    isFulltext: false,\n                });\n            });\n            return table;\n        }));\n    }\n    /**\n     * Builds create table sql.\n     */\n    createTableSql(table, createForeignKeys) {\n        const columnDefinitions = table.columns\n            .map((column) => this.buildCreateColumnSql(table, column))\n            .join(\", \");\n        let sql = `CREATE TABLE ${this.escapePath(table)} (${columnDefinitions}`;\n        table.columns\n            .filter((column) => column.isUnique)\n            .forEach((column) => {\n            const isUniqueExist = table.uniques.some((unique) => unique.columnNames.length === 1 &&\n                unique.columnNames[0] === column.name);\n            if (!isUniqueExist)\n                table.uniques.push(new TableUnique({\n                    name: this.connection.namingStrategy.uniqueConstraintName(table, [column.name]),\n                    columnNames: [column.name],\n                }));\n        });\n        if (table.uniques.length > 0) {\n            const uniquesSql = table.uniques\n                .map((unique) => {\n                const uniqueName = unique.name\n                    ? unique.name\n                    : this.connection.namingStrategy.uniqueConstraintName(table, unique.columnNames);\n                const columnNames = unique.columnNames\n                    .map((columnName) => `\"${columnName}\"`)\n                    .join(\", \");\n                let constraint = `CONSTRAINT \"${uniqueName}\" UNIQUE (${columnNames})`;\n                if (unique.deferrable)\n                    constraint += ` DEFERRABLE ${unique.deferrable}`;\n                return constraint;\n            })\n                .join(\", \");\n            sql += `, ${uniquesSql}`;\n        }\n        if (table.checks.length > 0) {\n            const checksSql = table.checks\n                .map((check) => {\n                const checkName = check.name\n                    ? check.name\n                    : this.connection.namingStrategy.checkConstraintName(table, check.expression);\n                return `CONSTRAINT \"${checkName}\" CHECK (${check.expression})`;\n            })\n                .join(\", \");\n            sql += `, ${checksSql}`;\n        }\n        if (table.exclusions.length > 0) {\n            const exclusionsSql = table.exclusions\n                .map((exclusion) => {\n                const exclusionName = exclusion.name\n                    ? exclusion.name\n                    : this.connection.namingStrategy.exclusionConstraintName(table, exclusion.expression);\n                return `CONSTRAINT \"${exclusionName}\" EXCLUDE ${exclusion.expression}`;\n            })\n                .join(\", \");\n            sql += `, ${exclusionsSql}`;\n        }\n        if (table.foreignKeys.length > 0 && createForeignKeys) {\n            const foreignKeysSql = table.foreignKeys\n                .map((fk) => {\n                const columnNames = fk.columnNames\n                    .map((columnName) => `\"${columnName}\"`)\n                    .join(\", \");\n                if (!fk.name)\n                    fk.name = this.connection.namingStrategy.foreignKeyName(table, fk.columnNames, this.getTablePath(fk), fk.referencedColumnNames);\n                const referencedColumnNames = fk.referencedColumnNames\n                    .map((columnName) => `\"${columnName}\"`)\n                    .join(\", \");\n                let constraint = `CONSTRAINT \"${fk.name}\" FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(fk))} (${referencedColumnNames})`;\n                if (fk.onDelete)\n                    constraint += ` ON DELETE ${fk.onDelete}`;\n                if (fk.onUpdate)\n                    constraint += ` ON UPDATE ${fk.onUpdate}`;\n                if (fk.deferrable)\n                    constraint += ` DEFERRABLE ${fk.deferrable}`;\n                return constraint;\n            })\n                .join(\", \");\n            sql += `, ${foreignKeysSql}`;\n        }\n        const primaryColumns = table.columns.filter((column) => column.isPrimary);\n        if (primaryColumns.length > 0) {\n            const primaryKeyName = primaryColumns[0].primaryKeyConstraintName\n                ? primaryColumns[0].primaryKeyConstraintName\n                : this.connection.namingStrategy.primaryKeyName(table, primaryColumns.map((column) => column.name));\n            const columnNames = primaryColumns\n                .map((column) => `\"${column.name}\"`)\n                .join(\", \");\n            sql += `, CONSTRAINT \"${primaryKeyName}\" PRIMARY KEY (${columnNames})`;\n        }\n        sql += `)`;\n        table.columns\n            .filter((it) => it.comment)\n            .forEach((it) => (sql += `; COMMENT ON COLUMN ${this.escapePath(table)}.\"${it.name}\" IS ${this.escapeComment(it.comment)}`));\n        return new Query(sql);\n    }\n    /**\n     * Loads Postgres version.\n     */\n    async getVersion() {\n        const result = await this.query(`SELECT version()`);\n        return result[0][\"version\"].replace(/^PostgreSQL ([\\d\\.]+) .*$/, \"$1\");\n    }\n    /**\n     * Builds drop table sql.\n     */\n    dropTableSql(tableOrPath) {\n        return new Query(`DROP TABLE ${this.escapePath(tableOrPath)}`);\n    }\n    createViewSql(view) {\n        const materializedClause = view.materialized ? \"MATERIALIZED \" : \"\";\n        const viewName = this.escapePath(view);\n        if (typeof view.expression === \"string\") {\n            return new Query(`CREATE ${materializedClause}VIEW ${viewName} AS ${view.expression}`);\n        }\n        else {\n            return new Query(`CREATE ${materializedClause}VIEW ${viewName} AS ${view\n                .expression(this.connection)\n                .getQuery()}`);\n        }\n    }\n    async insertViewDefinitionSql(view) {\n        const currentSchema = await this.getCurrentSchema();\n        let { schema, tableName: name } = this.driver.parseTableName(view);\n        if (!schema) {\n            schema = currentSchema;\n        }\n        const type = view.materialized\n            ? MetadataTableType.MATERIALIZED_VIEW\n            : MetadataTableType.VIEW;\n        const expression = typeof view.expression === \"string\"\n            ? view.expression.trim()\n            : view.expression(this.connection).getQuery();\n        return this.insertTypeormMetadataSql({\n            type,\n            schema,\n            name,\n            value: expression,\n        });\n    }\n    /**\n     * Builds drop view sql.\n     */\n    dropViewSql(view) {\n        const materializedClause = view.materialized ? \"MATERIALIZED \" : \"\";\n        return new Query(`DROP ${materializedClause}VIEW ${this.escapePath(view)}`);\n    }\n    /**\n     * Builds remove view sql.\n     */\n    async deleteViewDefinitionSql(view) {\n        const currentSchema = await this.getCurrentSchema();\n        let { schema, tableName: name } = this.driver.parseTableName(view);\n        if (!schema) {\n            schema = currentSchema;\n        }\n        const type = view.materialized\n            ? MetadataTableType.MATERIALIZED_VIEW\n            : MetadataTableType.VIEW;\n        return this.deleteTypeormMetadataSql({ type, schema, name });\n    }\n    /**\n     * Drops ENUM type from given schemas.\n     */\n    async dropEnumTypes(schemaNames) {\n        const selectDropsQuery = `SELECT 'DROP TYPE IF EXISTS \"' || n.nspname || '\".\"' || t.typname || '\" CASCADE;' as \"query\" FROM \"pg_type\" \"t\" ` +\n            `INNER JOIN \"pg_enum\" \"e\" ON \"e\".\"enumtypid\" = \"t\".\"oid\" ` +\n            `INNER JOIN \"pg_namespace\" \"n\" ON \"n\".\"oid\" = \"t\".\"typnamespace\" ` +\n            `WHERE \"n\".\"nspname\" IN (${schemaNames}) GROUP BY \"n\".\"nspname\", \"t\".\"typname\"`;\n        const dropQueries = await this.query(selectDropsQuery);\n        await Promise.all(dropQueries.map((q) => this.query(q[\"query\"])));\n    }\n    /**\n     * Checks if enum with the given name exist in the database.\n     */\n    async hasEnumType(table, column) {\n        let { schema } = this.driver.parseTableName(table);\n        if (!schema) {\n            schema = await this.getCurrentSchema();\n        }\n        const enumName = this.buildEnumName(table, column, false, true);\n        const sql = `SELECT \"n\".\"nspname\", \"t\".\"typname\" FROM \"pg_type\" \"t\" ` +\n            `INNER JOIN \"pg_namespace\" \"n\" ON \"n\".\"oid\" = \"t\".\"typnamespace\" ` +\n            `WHERE \"n\".\"nspname\" = '${schema}' AND \"t\".\"typname\" = '${enumName}'`;\n        const result = await this.query(sql);\n        return result.length ? true : false;\n    }\n    /**\n     * Builds create ENUM type sql.\n     */\n    createEnumTypeSql(table, column, enumName) {\n        if (!enumName)\n            enumName = this.buildEnumName(table, column);\n        const enumValues = column\n            .enum.map((value) => `'${value.replace(\"'\", \"''\")}'`)\n            .join(\", \");\n        return new Query(`CREATE TYPE ${enumName} AS ENUM(${enumValues})`);\n    }\n    /**\n     * Builds create ENUM type sql.\n     */\n    dropEnumTypeSql(table, column, enumName) {\n        if (!enumName)\n            enumName = this.buildEnumName(table, column);\n        return new Query(`DROP TYPE ${enumName}`);\n    }\n    /**\n     * Builds create index sql.\n     */\n    createIndexSql(table, index) {\n        const columns = index.columnNames\n            .map((columnName) => `\"${columnName}\"`)\n            .join(\", \");\n        return new Query(`CREATE ${index.isUnique ? \"UNIQUE \" : \"\"}INDEX \"${index.name}\" ON ${this.escapePath(table)} ${index.isSpatial ? \"USING GiST \" : \"\"}(${columns}) ${index.where ? \"WHERE \" + index.where : \"\"}`);\n    }\n    /**\n     * Builds create view index sql.\n     */\n    createViewIndexSql(view, index) {\n        const columns = index.columnNames\n            .map((columnName) => `\"${columnName}\"`)\n            .join(\", \");\n        return new Query(`CREATE ${index.isUnique ? \"UNIQUE \" : \"\"}INDEX \"${index.name}\" ON ${this.escapePath(view)} (${columns}) ${index.where ? \"WHERE \" + index.where : \"\"}`);\n    }\n    /**\n     * Builds drop index sql.\n     */\n    dropIndexSql(table, indexOrName) {\n        let indexName = InstanceChecker.isTableIndex(indexOrName)\n            ? indexOrName.name\n            : indexOrName;\n        const { schema } = this.driver.parseTableName(table);\n        return schema\n            ? new Query(`DROP INDEX \"${schema}\".\"${indexName}\"`)\n            : new Query(`DROP INDEX \"${indexName}\"`);\n    }\n    /**\n     * Builds create primary key sql.\n     */\n    createPrimaryKeySql(table, columnNames, constraintName) {\n        const primaryKeyName = constraintName\n            ? constraintName\n            : this.connection.namingStrategy.primaryKeyName(table, columnNames);\n        const columnNamesString = columnNames\n            .map((columnName) => `\"${columnName}\"`)\n            .join(\", \");\n        return new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${primaryKeyName}\" PRIMARY KEY (${columnNamesString})`);\n    }\n    /**\n     * Builds drop primary key sql.\n     */\n    dropPrimaryKeySql(table) {\n        if (!table.primaryColumns.length)\n            throw new TypeORMError(`Table ${table} has no primary keys.`);\n        const columnNames = table.primaryColumns.map((column) => column.name);\n        const constraintName = table.primaryColumns[0].primaryKeyConstraintName;\n        const primaryKeyName = constraintName\n            ? constraintName\n            : this.connection.namingStrategy.primaryKeyName(table, columnNames);\n        return new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${primaryKeyName}\"`);\n    }\n    /**\n     * Builds create unique constraint sql.\n     */\n    createUniqueConstraintSql(table, uniqueConstraint) {\n        const columnNames = uniqueConstraint.columnNames\n            .map((column) => `\"` + column + `\"`)\n            .join(\", \");\n        let sql = `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${uniqueConstraint.name}\" UNIQUE (${columnNames})`;\n        if (uniqueConstraint.deferrable)\n            sql += ` DEFERRABLE ${uniqueConstraint.deferrable}`;\n        return new Query(sql);\n    }\n    /**\n     * Builds drop unique constraint sql.\n     */\n    dropUniqueConstraintSql(table, uniqueOrName) {\n        const uniqueName = InstanceChecker.isTableUnique(uniqueOrName)\n            ? uniqueOrName.name\n            : uniqueOrName;\n        return new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${uniqueName}\"`);\n    }\n    /**\n     * Builds create check constraint sql.\n     */\n    createCheckConstraintSql(table, checkConstraint) {\n        return new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${checkConstraint.name}\" CHECK (${checkConstraint.expression})`);\n    }\n    /**\n     * Builds drop check constraint sql.\n     */\n    dropCheckConstraintSql(table, checkOrName) {\n        const checkName = InstanceChecker.isTableCheck(checkOrName)\n            ? checkOrName.name\n            : checkOrName;\n        return new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${checkName}\"`);\n    }\n    /**\n     * Builds create exclusion constraint sql.\n     */\n    createExclusionConstraintSql(table, exclusionConstraint) {\n        return new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${exclusionConstraint.name}\" EXCLUDE ${exclusionConstraint.expression}`);\n    }\n    /**\n     * Builds drop exclusion constraint sql.\n     */\n    dropExclusionConstraintSql(table, exclusionOrName) {\n        const exclusionName = InstanceChecker.isTableExclusion(exclusionOrName)\n            ? exclusionOrName.name\n            : exclusionOrName;\n        return new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${exclusionName}\"`);\n    }\n    /**\n     * Builds create foreign key sql.\n     */\n    createForeignKeySql(table, foreignKey) {\n        const columnNames = foreignKey.columnNames\n            .map((column) => `\"` + column + `\"`)\n            .join(\", \");\n        const referencedColumnNames = foreignKey.referencedColumnNames\n            .map((column) => `\"` + column + `\"`)\n            .join(\",\");\n        let sql = `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \"${foreignKey.name}\" FOREIGN KEY (${columnNames}) ` +\n            `REFERENCES ${this.escapePath(this.getTablePath(foreignKey))}(${referencedColumnNames})`;\n        if (foreignKey.onDelete)\n            sql += ` ON DELETE ${foreignKey.onDelete}`;\n        if (foreignKey.onUpdate)\n            sql += ` ON UPDATE ${foreignKey.onUpdate}`;\n        if (foreignKey.deferrable)\n            sql += ` DEFERRABLE ${foreignKey.deferrable}`;\n        return new Query(sql);\n    }\n    /**\n     * Builds drop foreign key sql.\n     */\n    dropForeignKeySql(table, foreignKeyOrName) {\n        const foreignKeyName = InstanceChecker.isTableForeignKey(foreignKeyOrName)\n            ? foreignKeyOrName.name\n            : foreignKeyOrName;\n        return new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \"${foreignKeyName}\"`);\n    }\n    /**\n     * Builds sequence name from given table and column.\n     */\n    buildSequenceName(table, columnOrName) {\n        const { tableName } = this.driver.parseTableName(table);\n        const columnName = InstanceChecker.isTableColumn(columnOrName)\n            ? columnOrName.name\n            : columnOrName;\n        let seqName = `${tableName}_${columnName}_seq`;\n        if (seqName.length > this.connection.driver.maxAliasLength) {\n            // note doesn't yet handle corner cases where .length differs from number of UTF-8 bytes\n            seqName = `${tableName.substring(0, 29)}_${columnName.substring(0, Math.max(29, 63 - table.name.length - 5))}_seq`;\n        }\n        return seqName;\n    }\n    buildSequencePath(table, columnOrName) {\n        const { schema } = this.driver.parseTableName(table);\n        return schema\n            ? `${schema}.${this.buildSequenceName(table, columnOrName)}`\n            : this.buildSequenceName(table, columnOrName);\n    }\n    /**\n     * Builds ENUM type name from given table and column.\n     */\n    buildEnumName(table, column, withSchema = true, disableEscape, toOld) {\n        const { schema, tableName } = this.driver.parseTableName(table);\n        let enumName = column.enumName\n            ? column.enumName\n            : `${tableName}_${column.name.toLowerCase()}_enum`;\n        if (schema && withSchema)\n            enumName = `${schema}.${enumName}`;\n        if (toOld)\n            enumName = enumName + \"_old\";\n        return enumName\n            .split(\".\")\n            .map((i) => {\n            return disableEscape ? i : `\"${i}\"`;\n        })\n            .join(\".\");\n    }\n    async getUserDefinedTypeName(table, column) {\n        let { schema, tableName: name } = this.driver.parseTableName(table);\n        if (!schema) {\n            schema = await this.getCurrentSchema();\n        }\n        const result = await this.query(`SELECT \"udt_schema\", \"udt_name\" ` +\n            `FROM \"information_schema\".\"columns\" WHERE \"table_schema\" = '${schema}' AND \"table_name\" = '${name}' AND \"column_name\"='${column.name}'`);\n        // docs: https://www.postgresql.org/docs/current/xtypes.html\n        // When you define a new base type, PostgreSQL automatically provides support for arrays of that type.\n        // The array type typically has the same name as the base type with the underscore character (_) prepended.\n        // ----\n        // so, we must remove this underscore character from enum type name\n        let udtName = result[0][\"udt_name\"];\n        if (udtName.indexOf(\"_\") === 0) {\n            udtName = udtName.substr(1, udtName.length);\n        }\n        return {\n            schema: result[0][\"udt_schema\"],\n            name: udtName,\n        };\n    }\n    /**\n     * Escapes a given comment so it's safe to include in a query.\n     */\n    escapeComment(comment) {\n        if (!comment || comment.length === 0) {\n            return \"NULL\";\n        }\n        comment = comment.replace(/'/g, \"''\").replace(/\\u0000/g, \"\"); // Null bytes aren't allowed in comments\n        return `'${comment}'`;\n    }\n    /**\n     * Escapes given table or view path.\n     */\n    escapePath(target) {\n        const { schema, tableName } = this.driver.parseTableName(target);\n        if (schema && schema !== this.driver.searchSchema) {\n            return `\"${schema}\".\"${tableName}\"`;\n        }\n        return `\"${tableName}\"`;\n    }\n    /**\n     * Get the table name with table schema\n     * Note: Without ' or \"\n     */\n    async getTableNameWithSchema(target) {\n        const tableName = InstanceChecker.isTable(target) ? target.name : target;\n        if (tableName.indexOf(\".\") === -1) {\n            const schemaResult = await this.query(`SELECT current_schema()`);\n            const schema = schemaResult[0][\"current_schema\"];\n            return `${schema}.${tableName}`;\n        }\n        else {\n            return `${tableName.split(\".\")[0]}.${tableName.split(\".\")[1]}`;\n        }\n    }\n    /**\n     * Builds a query for create column.\n     */\n    buildCreateColumnSql(table, column) {\n        let c = '\"' + column.name + '\"';\n        if (column.isGenerated === true &&\n            column.generationStrategy !== \"uuid\") {\n            if (column.generationStrategy === \"identity\") {\n                // Postgres 10+ Identity generated column\n                const generatedIdentityOrDefault = column.generatedIdentity || \"BY DEFAULT\";\n                c += ` ${column.type} GENERATED ${generatedIdentityOrDefault} AS IDENTITY`;\n            }\n            else {\n                // classic SERIAL primary column\n                if (column.type === \"integer\" ||\n                    column.type === \"int\" ||\n                    column.type === \"int4\")\n                    c += \" SERIAL\";\n                if (column.type === \"smallint\" || column.type === \"int2\")\n                    c += \" SMALLSERIAL\";\n                if (column.type === \"bigint\" || column.type === \"int8\")\n                    c += \" BIGSERIAL\";\n            }\n        }\n        if (column.type === \"enum\" || column.type === \"simple-enum\") {\n            c += \" \" + this.buildEnumName(table, column);\n            if (column.isArray)\n                c += \" array\";\n        }\n        else if (!column.isGenerated || column.type === \"uuid\") {\n            c += \" \" + this.connection.driver.createFullType(column);\n        }\n        // Postgres only supports the stored generated column type\n        if (column.generatedType === \"STORED\" && column.asExpression) {\n            c += ` GENERATED ALWAYS AS (${column.asExpression}) STORED`;\n        }\n        if (column.charset)\n            c += ' CHARACTER SET \"' + column.charset + '\"';\n        if (column.collation)\n            c += ' COLLATE \"' + column.collation + '\"';\n        if (column.isNullable !== true)\n            c += \" NOT NULL\";\n        if (column.default !== undefined && column.default !== null)\n            c += \" DEFAULT \" + column.default;\n        if (column.isGenerated &&\n            column.generationStrategy === \"uuid\" &&\n            !column.default)\n            c += ` DEFAULT ${this.driver.uuidGenerator}`;\n        return c;\n    }\n    /**\n     * Checks if the PostgreSQL server has support for partitioned tables\n     */\n    async hasSupportForPartitionedTables() {\n        const result = await this.query(`SELECT TRUE FROM information_schema.columns WHERE table_name = 'pg_class' and column_name = 'relispartition'`);\n        return result.length ? true : false;\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}