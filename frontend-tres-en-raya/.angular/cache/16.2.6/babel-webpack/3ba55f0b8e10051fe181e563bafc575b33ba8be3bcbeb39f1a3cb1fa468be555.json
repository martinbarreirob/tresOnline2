{"ast":null,"code":"export class OrmUtils {\n  // -------------------------------------------------------------------------\n  // Public methods\n  // -------------------------------------------------------------------------\n  /**\n   * Chunks array into pieces.\n   */\n  static chunk(array, size) {\n    return Array.from(Array(Math.ceil(array.length / size)), (_, i) => {\n      return array.slice(i * size, i * size + size);\n    });\n  }\n  static splitClassesAndStrings(classesAndStrings) {\n    return [classesAndStrings.filter(cls => typeof cls !== \"string\"), classesAndStrings.filter(str => typeof str === \"string\")];\n  }\n  static groupBy(array, propertyCallback) {\n    return array.reduce((groupedArray, value) => {\n      const key = propertyCallback(value);\n      let grouped = groupedArray.find(i => i.id === key);\n      if (!grouped) {\n        grouped = {\n          id: key,\n          items: []\n        };\n        groupedArray.push(grouped);\n      }\n      grouped.items.push(value);\n      return groupedArray;\n    }, []);\n  }\n  static uniq(array, criteriaOrProperty) {\n    return array.reduce((uniqueArray, item) => {\n      let found = false;\n      if (typeof criteriaOrProperty === \"function\") {\n        const itemValue = criteriaOrProperty(item);\n        found = !!uniqueArray.find(uniqueItem => criteriaOrProperty(uniqueItem) === itemValue);\n      } else if (typeof criteriaOrProperty === \"string\") {\n        found = !!uniqueArray.find(uniqueItem => uniqueItem[criteriaOrProperty] === item[criteriaOrProperty]);\n      } else {\n        found = uniqueArray.indexOf(item) !== -1;\n      }\n      if (!found) uniqueArray.push(item);\n      return uniqueArray;\n    }, []);\n  }\n  // Checks if it's an object made by Object.create(null), {} or new Object()\n  static isPlainObject(item) {\n    if (item === null || item === undefined) {\n      return false;\n    }\n    return !item.constructor || item.constructor === Object;\n  }\n  static mergeArrayKey(target, key, value, memo) {\n    // Have we seen this before?  Prevent infinite recursion.\n    if (memo.has(value)) {\n      target[key] = memo.get(value);\n      return;\n    }\n    if (value instanceof Promise) {\n      // Skip promises entirely.\n      // This is a hold-over from the old code & is because we don't want to pull in\n      // the lazy fields.  Ideally we'd remove these promises via another function first\n      // but for now we have to do it here.\n      return;\n    }\n    if (!this.isPlainObject(value) && !Array.isArray(value)) {\n      target[key] = value;\n      return;\n    }\n    if (!target[key]) {\n      target[key] = Array.isArray(value) ? [] : {};\n    }\n    memo.set(value, target[key]);\n    this.merge(target[key], value, memo);\n    memo.delete(value);\n  }\n  static mergeObjectKey(target, key, value, memo) {\n    // Have we seen this before?  Prevent infinite recursion.\n    if (memo.has(value)) {\n      Object.assign(target, {\n        [key]: memo.get(value)\n      });\n      return;\n    }\n    if (value instanceof Promise) {\n      // Skip promises entirely.\n      // This is a hold-over from the old code & is because we don't want to pull in\n      // the lazy fields.  Ideally we'd remove these promises via another function first\n      // but for now we have to do it here.\n      return;\n    }\n    if (!this.isPlainObject(value) && !Array.isArray(value)) {\n      Object.assign(target, {\n        [key]: value\n      });\n      return;\n    }\n    if (!target[key]) {\n      Object.assign(target, {\n        [key]: Array.isArray(value) ? [] : {}\n      });\n    }\n    memo.set(value, target[key]);\n    this.merge(target[key], value, memo);\n    memo.delete(value);\n  }\n  static merge(target, source, memo = new Map()) {\n    if (this.isPlainObject(target) && this.isPlainObject(source)) {\n      for (const key of Object.keys(source)) {\n        if (key === \"__proto__\") continue;\n        this.mergeObjectKey(target, key, source[key], memo);\n      }\n    }\n    if (Array.isArray(target) && Array.isArray(source)) {\n      for (let key = 0; key < source.length; key++) {\n        this.mergeArrayKey(target, key, source[key], memo);\n      }\n    }\n  }\n  /**\n   * Deep Object.assign.\n   */\n  static mergeDeep(target, ...sources) {\n    if (!sources.length) {\n      return target;\n    }\n    for (const source of sources) {\n      OrmUtils.merge(target, source);\n    }\n    return target;\n  }\n  /**\n   * Deep compare objects.\n   *\n   * @see http://stackoverflow.com/a/1144249\n   */\n  static deepCompare(...args) {\n    let i, l, leftChain, rightChain;\n    if (arguments.length < 1) {\n      return true; // Die silently? Don't know how to handle such case, please help...\n      // throw \"Need two or more arguments to compare\";\n    }\n\n    for (i = 1, l = arguments.length; i < l; i++) {\n      leftChain = []; // Todo: this can be cached\n      rightChain = [];\n      if (!this.compare2Objects(leftChain, rightChain, arguments[0], arguments[i])) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Gets deeper value of object.\n   */\n  static deepValue(obj, path) {\n    const segments = path.split(\".\");\n    for (let i = 0, len = segments.length; i < len; i++) {\n      obj = obj[segments[i]];\n    }\n    return obj;\n  }\n  static replaceEmptyObjectsWithBooleans(obj) {\n    for (let key in obj) {\n      if (obj[key] && typeof obj[key] === \"object\") {\n        if (Object.keys(obj[key]).length === 0) {\n          obj[key] = true;\n        } else {\n          this.replaceEmptyObjectsWithBooleans(obj[key]);\n        }\n      }\n    }\n  }\n  static propertyPathsToTruthyObject(paths) {\n    let obj = {};\n    for (let path of paths) {\n      const props = path.split(\".\");\n      if (!props.length) continue;\n      if (!obj[props[0]] || obj[props[0]] === true) {\n        obj[props[0]] = {};\n      }\n      let recursiveChild = obj[props[0]];\n      for (let [key, prop] of props.entries()) {\n        if (key === 0) continue;\n        if (recursiveChild[prop]) {\n          recursiveChild = recursiveChild[prop];\n        } else if (key === props.length - 1) {\n          recursiveChild[prop] = {};\n          recursiveChild = null;\n        } else {\n          recursiveChild[prop] = {};\n          recursiveChild = recursiveChild[prop];\n        }\n      }\n    }\n    this.replaceEmptyObjectsWithBooleans(obj);\n    return obj;\n  }\n  /**\n   * Check if two entity-id-maps are the same\n   */\n  static compareIds(firstId, secondId) {\n    if (firstId === undefined || firstId === null || secondId === undefined || secondId === null) return false;\n    // Optimized version for the common case\n    if ((typeof firstId.id === \"string\" && typeof secondId.id === \"string\" || typeof firstId.id === \"number\" && typeof secondId.id === \"number\") && Object.keys(firstId).length === 1 && Object.keys(secondId).length === 1) {\n      return firstId.id === secondId.id;\n    }\n    return OrmUtils.deepCompare(firstId, secondId);\n  }\n  /**\n   * Transforms given value into boolean value.\n   */\n  static toBoolean(value) {\n    if (typeof value === \"boolean\") return value;\n    if (typeof value === \"string\") return value === \"true\" || value === \"1\";\n    if (typeof value === \"number\") return value > 0;\n    return false;\n  }\n  /**\n   * Composes an object from the given array of keys and values.\n   */\n  static zipObject(keys, values) {\n    return keys.reduce((object, column, index) => {\n      object[column] = values[index];\n      return object;\n    }, {});\n  }\n  /**\n   * Compares two arrays.\n   */\n  static isArraysEqual(arr1, arr2) {\n    if (arr1.length !== arr2.length) return false;\n    return arr1.every(element => {\n      return arr2.indexOf(element) !== -1;\n    });\n  }\n  static areMutuallyExclusive(...lists) {\n    const haveSharedObjects = lists.some(list => {\n      const otherLists = lists.filter(otherList => otherList !== list);\n      return list.some(item => otherLists.some(otherList => otherList.includes(item)));\n    });\n    return !haveSharedObjects;\n  }\n  // -------------------------------------------------------------------------\n  // Private methods\n  // -------------------------------------------------------------------------\n  static compare2Objects(leftChain, rightChain, x, y) {\n    let p;\n    // remember that NaN === NaN returns false\n    // and isNaN(undefined) returns true\n    if (Number.isNaN(x) && Number.isNaN(y)) return true;\n    // Compare primitives and functions.\n    // Check if both arguments link to the same object.\n    // Especially useful on the step where we compare prototypes\n    if (x === y) return true;\n    // Unequal, but either is null or undefined (use case: jsonb comparison)\n    // PR #3776, todo: add tests\n    if (x === null || y === null || x === undefined || y === undefined) return false;\n    // Fix the buffer compare bug.\n    // See: https://github.com/typeorm/typeorm/issues/3654\n    if ((typeof x.equals === \"function\" || typeof x.equals === \"function\") && x.equals(y)) return true;\n    // Works in case when functions are created in constructor.\n    // Comparing dates is a common scenario. Another built-ins?\n    // We can even handle functions passed across iframes\n    if (typeof x === \"function\" && typeof y === \"function\" || x instanceof Date && y instanceof Date || x instanceof RegExp && y instanceof RegExp || typeof x === \"string\" && typeof y === \"string\" || typeof x === \"number\" && typeof y === \"number\") return x.toString() === y.toString();\n    // At last checking prototypes as good as we can\n    if (!(typeof x === \"object\" && typeof y === \"object\")) return false;\n    if (Object.prototype.isPrototypeOf.call(x, y) || Object.prototype.isPrototypeOf.call(y, x)) return false;\n    if (x.constructor !== y.constructor) return false;\n    if (x.prototype !== y.prototype) return false;\n    // Check for infinitive linking loops\n    if (leftChain.indexOf(x) > -1 || rightChain.indexOf(y) > -1) return false;\n    // Quick checking of one object being a subset of another.\n    // todo: cache the structure of arguments[0] for performance\n    for (p in y) {\n      if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {\n        return false;\n      } else if (typeof y[p] !== typeof x[p]) {\n        return false;\n      }\n    }\n    for (p in x) {\n      if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {\n        return false;\n      } else if (typeof y[p] !== typeof x[p]) {\n        return false;\n      }\n      switch (typeof x[p]) {\n        case \"object\":\n        case \"function\":\n          leftChain.push(x);\n          rightChain.push(y);\n          if (!this.compare2Objects(leftChain, rightChain, x[p], y[p])) {\n            return false;\n          }\n          leftChain.pop();\n          rightChain.pop();\n          break;\n        default:\n          if (x[p] !== y[p]) {\n            return false;\n          }\n          break;\n      }\n    }\n    return true;\n  }\n}","map":{"version":3,"names":["OrmUtils","chunk","array","size","Array","from","Math","ceil","length","_","i","slice","splitClassesAndStrings","classesAndStrings","filter","cls","str","groupBy","propertyCallback","reduce","groupedArray","value","key","grouped","find","id","items","push","uniq","criteriaOrProperty","uniqueArray","item","found","itemValue","uniqueItem","indexOf","isPlainObject","undefined","constructor","Object","mergeArrayKey","target","memo","has","get","Promise","isArray","set","merge","delete","mergeObjectKey","assign","source","Map","keys","mergeDeep","sources","deepCompare","args","l","leftChain","rightChain","arguments","compare2Objects","deepValue","obj","path","segments","split","len","replaceEmptyObjectsWithBooleans","propertyPathsToTruthyObject","paths","props","recursiveChild","prop","entries","compareIds","firstId","secondId","toBoolean","zipObject","values","object","column","index","isArraysEqual","arr1","arr2","every","element","areMutuallyExclusive","lists","haveSharedObjects","some","list","otherLists","otherList","includes","x","y","p","Number","isNaN","equals","Date","RegExp","toString","prototype","isPrototypeOf","call","hasOwnProperty","pop"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/util/OrmUtils.js"],"sourcesContent":["export class OrmUtils {\n    // -------------------------------------------------------------------------\n    // Public methods\n    // -------------------------------------------------------------------------\n    /**\n     * Chunks array into pieces.\n     */\n    static chunk(array, size) {\n        return Array.from(Array(Math.ceil(array.length / size)), (_, i) => {\n            return array.slice(i * size, i * size + size);\n        });\n    }\n    static splitClassesAndStrings(classesAndStrings) {\n        return [\n            classesAndStrings.filter((cls) => typeof cls !== \"string\"),\n            classesAndStrings.filter((str) => typeof str === \"string\"),\n        ];\n    }\n    static groupBy(array, propertyCallback) {\n        return array.reduce((groupedArray, value) => {\n            const key = propertyCallback(value);\n            let grouped = groupedArray.find((i) => i.id === key);\n            if (!grouped) {\n                grouped = { id: key, items: [] };\n                groupedArray.push(grouped);\n            }\n            grouped.items.push(value);\n            return groupedArray;\n        }, []);\n    }\n    static uniq(array, criteriaOrProperty) {\n        return array.reduce((uniqueArray, item) => {\n            let found = false;\n            if (typeof criteriaOrProperty === \"function\") {\n                const itemValue = criteriaOrProperty(item);\n                found = !!uniqueArray.find((uniqueItem) => criteriaOrProperty(uniqueItem) === itemValue);\n            }\n            else if (typeof criteriaOrProperty === \"string\") {\n                found = !!uniqueArray.find((uniqueItem) => uniqueItem[criteriaOrProperty] ===\n                    item[criteriaOrProperty]);\n            }\n            else {\n                found = uniqueArray.indexOf(item) !== -1;\n            }\n            if (!found)\n                uniqueArray.push(item);\n            return uniqueArray;\n        }, []);\n    }\n    // Checks if it's an object made by Object.create(null), {} or new Object()\n    static isPlainObject(item) {\n        if (item === null || item === undefined) {\n            return false;\n        }\n        return !item.constructor || item.constructor === Object;\n    }\n    static mergeArrayKey(target, key, value, memo) {\n        // Have we seen this before?  Prevent infinite recursion.\n        if (memo.has(value)) {\n            target[key] = memo.get(value);\n            return;\n        }\n        if (value instanceof Promise) {\n            // Skip promises entirely.\n            // This is a hold-over from the old code & is because we don't want to pull in\n            // the lazy fields.  Ideally we'd remove these promises via another function first\n            // but for now we have to do it here.\n            return;\n        }\n        if (!this.isPlainObject(value) && !Array.isArray(value)) {\n            target[key] = value;\n            return;\n        }\n        if (!target[key]) {\n            target[key] = Array.isArray(value) ? [] : {};\n        }\n        memo.set(value, target[key]);\n        this.merge(target[key], value, memo);\n        memo.delete(value);\n    }\n    static mergeObjectKey(target, key, value, memo) {\n        // Have we seen this before?  Prevent infinite recursion.\n        if (memo.has(value)) {\n            Object.assign(target, { [key]: memo.get(value) });\n            return;\n        }\n        if (value instanceof Promise) {\n            // Skip promises entirely.\n            // This is a hold-over from the old code & is because we don't want to pull in\n            // the lazy fields.  Ideally we'd remove these promises via another function first\n            // but for now we have to do it here.\n            return;\n        }\n        if (!this.isPlainObject(value) && !Array.isArray(value)) {\n            Object.assign(target, { [key]: value });\n            return;\n        }\n        if (!target[key]) {\n            Object.assign(target, { [key]: Array.isArray(value) ? [] : {} });\n        }\n        memo.set(value, target[key]);\n        this.merge(target[key], value, memo);\n        memo.delete(value);\n    }\n    static merge(target, source, memo = new Map()) {\n        if (this.isPlainObject(target) && this.isPlainObject(source)) {\n            for (const key of Object.keys(source)) {\n                if (key === \"__proto__\")\n                    continue;\n                this.mergeObjectKey(target, key, source[key], memo);\n            }\n        }\n        if (Array.isArray(target) && Array.isArray(source)) {\n            for (let key = 0; key < source.length; key++) {\n                this.mergeArrayKey(target, key, source[key], memo);\n            }\n        }\n    }\n    /**\n     * Deep Object.assign.\n     */\n    static mergeDeep(target, ...sources) {\n        if (!sources.length) {\n            return target;\n        }\n        for (const source of sources) {\n            OrmUtils.merge(target, source);\n        }\n        return target;\n    }\n    /**\n     * Deep compare objects.\n     *\n     * @see http://stackoverflow.com/a/1144249\n     */\n    static deepCompare(...args) {\n        let i, l, leftChain, rightChain;\n        if (arguments.length < 1) {\n            return true; // Die silently? Don't know how to handle such case, please help...\n            // throw \"Need two or more arguments to compare\";\n        }\n        for (i = 1, l = arguments.length; i < l; i++) {\n            leftChain = []; // Todo: this can be cached\n            rightChain = [];\n            if (!this.compare2Objects(leftChain, rightChain, arguments[0], arguments[i])) {\n                return false;\n            }\n        }\n        return true;\n    }\n    /**\n     * Gets deeper value of object.\n     */\n    static deepValue(obj, path) {\n        const segments = path.split(\".\");\n        for (let i = 0, len = segments.length; i < len; i++) {\n            obj = obj[segments[i]];\n        }\n        return obj;\n    }\n    static replaceEmptyObjectsWithBooleans(obj) {\n        for (let key in obj) {\n            if (obj[key] && typeof obj[key] === \"object\") {\n                if (Object.keys(obj[key]).length === 0) {\n                    obj[key] = true;\n                }\n                else {\n                    this.replaceEmptyObjectsWithBooleans(obj[key]);\n                }\n            }\n        }\n    }\n    static propertyPathsToTruthyObject(paths) {\n        let obj = {};\n        for (let path of paths) {\n            const props = path.split(\".\");\n            if (!props.length)\n                continue;\n            if (!obj[props[0]] || obj[props[0]] === true) {\n                obj[props[0]] = {};\n            }\n            let recursiveChild = obj[props[0]];\n            for (let [key, prop] of props.entries()) {\n                if (key === 0)\n                    continue;\n                if (recursiveChild[prop]) {\n                    recursiveChild = recursiveChild[prop];\n                }\n                else if (key === props.length - 1) {\n                    recursiveChild[prop] = {};\n                    recursiveChild = null;\n                }\n                else {\n                    recursiveChild[prop] = {};\n                    recursiveChild = recursiveChild[prop];\n                }\n            }\n        }\n        this.replaceEmptyObjectsWithBooleans(obj);\n        return obj;\n    }\n    /**\n     * Check if two entity-id-maps are the same\n     */\n    static compareIds(firstId, secondId) {\n        if (firstId === undefined ||\n            firstId === null ||\n            secondId === undefined ||\n            secondId === null)\n            return false;\n        // Optimized version for the common case\n        if (((typeof firstId.id === \"string\" &&\n            typeof secondId.id === \"string\") ||\n            (typeof firstId.id === \"number\" &&\n                typeof secondId.id === \"number\")) &&\n            Object.keys(firstId).length === 1 &&\n            Object.keys(secondId).length === 1) {\n            return firstId.id === secondId.id;\n        }\n        return OrmUtils.deepCompare(firstId, secondId);\n    }\n    /**\n     * Transforms given value into boolean value.\n     */\n    static toBoolean(value) {\n        if (typeof value === \"boolean\")\n            return value;\n        if (typeof value === \"string\")\n            return value === \"true\" || value === \"1\";\n        if (typeof value === \"number\")\n            return value > 0;\n        return false;\n    }\n    /**\n     * Composes an object from the given array of keys and values.\n     */\n    static zipObject(keys, values) {\n        return keys.reduce((object, column, index) => {\n            object[column] = values[index];\n            return object;\n        }, {});\n    }\n    /**\n     * Compares two arrays.\n     */\n    static isArraysEqual(arr1, arr2) {\n        if (arr1.length !== arr2.length)\n            return false;\n        return arr1.every((element) => {\n            return arr2.indexOf(element) !== -1;\n        });\n    }\n    static areMutuallyExclusive(...lists) {\n        const haveSharedObjects = lists.some((list) => {\n            const otherLists = lists.filter((otherList) => otherList !== list);\n            return list.some((item) => otherLists.some((otherList) => otherList.includes(item)));\n        });\n        return !haveSharedObjects;\n    }\n    // -------------------------------------------------------------------------\n    // Private methods\n    // -------------------------------------------------------------------------\n    static compare2Objects(leftChain, rightChain, x, y) {\n        let p;\n        // remember that NaN === NaN returns false\n        // and isNaN(undefined) returns true\n        if (Number.isNaN(x) && Number.isNaN(y))\n            return true;\n        // Compare primitives and functions.\n        // Check if both arguments link to the same object.\n        // Especially useful on the step where we compare prototypes\n        if (x === y)\n            return true;\n        // Unequal, but either is null or undefined (use case: jsonb comparison)\n        // PR #3776, todo: add tests\n        if (x === null || y === null || x === undefined || y === undefined)\n            return false;\n        // Fix the buffer compare bug.\n        // See: https://github.com/typeorm/typeorm/issues/3654\n        if ((typeof x.equals === \"function\" ||\n            typeof x.equals === \"function\") &&\n            x.equals(y))\n            return true;\n        // Works in case when functions are created in constructor.\n        // Comparing dates is a common scenario. Another built-ins?\n        // We can even handle functions passed across iframes\n        if ((typeof x === \"function\" && typeof y === \"function\") ||\n            (x instanceof Date && y instanceof Date) ||\n            (x instanceof RegExp && y instanceof RegExp) ||\n            (typeof x === \"string\" && typeof y === \"string\") ||\n            (typeof x === \"number\" && typeof y === \"number\"))\n            return x.toString() === y.toString();\n        // At last checking prototypes as good as we can\n        if (!(typeof x === \"object\" && typeof y === \"object\"))\n            return false;\n        if (Object.prototype.isPrototypeOf.call(x, y) ||\n            Object.prototype.isPrototypeOf.call(y, x))\n            return false;\n        if (x.constructor !== y.constructor)\n            return false;\n        if (x.prototype !== y.prototype)\n            return false;\n        // Check for infinitive linking loops\n        if (leftChain.indexOf(x) > -1 || rightChain.indexOf(y) > -1)\n            return false;\n        // Quick checking of one object being a subset of another.\n        // todo: cache the structure of arguments[0] for performance\n        for (p in y) {\n            if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {\n                return false;\n            }\n            else if (typeof y[p] !== typeof x[p]) {\n                return false;\n            }\n        }\n        for (p in x) {\n            if (y.hasOwnProperty(p) !== x.hasOwnProperty(p)) {\n                return false;\n            }\n            else if (typeof y[p] !== typeof x[p]) {\n                return false;\n            }\n            switch (typeof x[p]) {\n                case \"object\":\n                case \"function\":\n                    leftChain.push(x);\n                    rightChain.push(y);\n                    if (!this.compare2Objects(leftChain, rightChain, x[p], y[p])) {\n                        return false;\n                    }\n                    leftChain.pop();\n                    rightChain.pop();\n                    break;\n                default:\n                    if (x[p] !== y[p]) {\n                        return false;\n                    }\n                    break;\n            }\n        }\n        return true;\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}