{"ast":null,"code":"import { EntityMetadata } from \"../metadata/EntityMetadata\";\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\";\nimport { ForeignKeyMetadata } from \"../metadata/ForeignKeyMetadata\";\nimport { IndexMetadata } from \"../metadata/IndexMetadata\";\n/**\n * Creates EntityMetadata for junction tables of the closure entities.\n * Closure junction tables are tables generated by closure entities.\n */\nexport class ClosureJunctionEntityMetadataBuilder {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection) {\n    this.connection = connection;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Builds EntityMetadata for the closure junction of the given closure entity.\n   */\n  build(parentClosureEntityMetadata) {\n    // create entity metadata itself\n    const entityMetadata = new EntityMetadata({\n      parentClosureEntityMetadata: parentClosureEntityMetadata,\n      connection: this.connection,\n      args: {\n        target: \"\",\n        name: parentClosureEntityMetadata.treeOptions && parentClosureEntityMetadata.treeOptions.closureTableName ? parentClosureEntityMetadata.treeOptions.closureTableName : parentClosureEntityMetadata.tableNameWithoutPrefix,\n        type: \"closure-junction\"\n      }\n    });\n    entityMetadata.build();\n    // create ancestor and descendant columns for new closure junction table\n    parentClosureEntityMetadata.primaryColumns.forEach(primaryColumn => {\n      entityMetadata.ownColumns.push(new ColumnMetadata({\n        connection: this.connection,\n        entityMetadata: entityMetadata,\n        closureType: \"ancestor\",\n        referencedColumn: primaryColumn,\n        args: {\n          target: \"\",\n          mode: \"virtual\",\n          propertyName: parentClosureEntityMetadata.treeOptions && parentClosureEntityMetadata.treeOptions.ancestorColumnName ? parentClosureEntityMetadata.treeOptions.ancestorColumnName(primaryColumn) : primaryColumn.propertyName + \"_ancestor\",\n          options: {\n            primary: true,\n            length: primaryColumn.length,\n            type: primaryColumn.type\n          }\n        }\n      }));\n      entityMetadata.ownColumns.push(new ColumnMetadata({\n        connection: this.connection,\n        entityMetadata: entityMetadata,\n        closureType: \"descendant\",\n        referencedColumn: primaryColumn,\n        args: {\n          target: \"\",\n          mode: \"virtual\",\n          propertyName: parentClosureEntityMetadata.treeOptions && parentClosureEntityMetadata.treeOptions.descendantColumnName ? parentClosureEntityMetadata.treeOptions.descendantColumnName(primaryColumn) : primaryColumn.propertyName + \"_descendant\",\n          options: {\n            primary: true,\n            length: primaryColumn.length,\n            type: primaryColumn.type\n          }\n        }\n      }));\n    });\n    entityMetadata.ownIndices = [new IndexMetadata({\n      entityMetadata: entityMetadata,\n      columns: [entityMetadata.ownColumns[0]],\n      args: {\n        target: entityMetadata.target,\n        synchronize: true\n      }\n    }), new IndexMetadata({\n      entityMetadata: entityMetadata,\n      columns: [entityMetadata.ownColumns[1]],\n      args: {\n        target: entityMetadata.target,\n        synchronize: true\n      }\n    })];\n    // if tree level column was defined by a closure entity then add it to the junction columns as well\n    if (parentClosureEntityMetadata.treeLevelColumn) {\n      entityMetadata.ownColumns.push(new ColumnMetadata({\n        connection: this.connection,\n        entityMetadata: entityMetadata,\n        args: {\n          target: \"\",\n          mode: \"virtual\",\n          propertyName: \"level\",\n          options: {\n            type: this.connection.driver.mappedDataTypes.treeLevel\n          }\n        }\n      }));\n    }\n    // create junction table foreign keys\n    // Note: CASCADE is not applied to mssql because it does not support multi cascade paths\n    entityMetadata.foreignKeys = [new ForeignKeyMetadata({\n      entityMetadata: entityMetadata,\n      referencedEntityMetadata: parentClosureEntityMetadata,\n      columns: [entityMetadata.ownColumns[0]],\n      referencedColumns: parentClosureEntityMetadata.primaryColumns,\n      onDelete: this.connection.driver.options.type === \"mssql\" ? \"NO ACTION\" : \"CASCADE\"\n    }), new ForeignKeyMetadata({\n      entityMetadata: entityMetadata,\n      referencedEntityMetadata: parentClosureEntityMetadata,\n      columns: [entityMetadata.ownColumns[1]],\n      referencedColumns: parentClosureEntityMetadata.primaryColumns,\n      onDelete: this.connection.driver.options.type === \"mssql\" ? \"NO ACTION\" : \"CASCADE\"\n    })];\n    return entityMetadata;\n  }\n}","map":{"version":3,"names":["EntityMetadata","ColumnMetadata","ForeignKeyMetadata","IndexMetadata","ClosureJunctionEntityMetadataBuilder","constructor","connection","build","parentClosureEntityMetadata","entityMetadata","args","target","name","treeOptions","closureTableName","tableNameWithoutPrefix","type","primaryColumns","forEach","primaryColumn","ownColumns","push","closureType","referencedColumn","mode","propertyName","ancestorColumnName","options","primary","length","descendantColumnName","ownIndices","columns","synchronize","treeLevelColumn","driver","mappedDataTypes","treeLevel","foreignKeys","referencedEntityMetadata","referencedColumns","onDelete"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/metadata-builder/ClosureJunctionEntityMetadataBuilder.js"],"sourcesContent":["import { EntityMetadata } from \"../metadata/EntityMetadata\";\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\";\nimport { ForeignKeyMetadata } from \"../metadata/ForeignKeyMetadata\";\nimport { IndexMetadata } from \"../metadata/IndexMetadata\";\n/**\n * Creates EntityMetadata for junction tables of the closure entities.\n * Closure junction tables are tables generated by closure entities.\n */\nexport class ClosureJunctionEntityMetadataBuilder {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n    constructor(connection) {\n        this.connection = connection;\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Builds EntityMetadata for the closure junction of the given closure entity.\n     */\n    build(parentClosureEntityMetadata) {\n        // create entity metadata itself\n        const entityMetadata = new EntityMetadata({\n            parentClosureEntityMetadata: parentClosureEntityMetadata,\n            connection: this.connection,\n            args: {\n                target: \"\",\n                name: parentClosureEntityMetadata.treeOptions &&\n                    parentClosureEntityMetadata.treeOptions.closureTableName\n                    ? parentClosureEntityMetadata.treeOptions\n                        .closureTableName\n                    : parentClosureEntityMetadata.tableNameWithoutPrefix,\n                type: \"closure-junction\",\n            },\n        });\n        entityMetadata.build();\n        // create ancestor and descendant columns for new closure junction table\n        parentClosureEntityMetadata.primaryColumns.forEach((primaryColumn) => {\n            entityMetadata.ownColumns.push(new ColumnMetadata({\n                connection: this.connection,\n                entityMetadata: entityMetadata,\n                closureType: \"ancestor\",\n                referencedColumn: primaryColumn,\n                args: {\n                    target: \"\",\n                    mode: \"virtual\",\n                    propertyName: parentClosureEntityMetadata.treeOptions &&\n                        parentClosureEntityMetadata.treeOptions\n                            .ancestorColumnName\n                        ? parentClosureEntityMetadata.treeOptions.ancestorColumnName(primaryColumn)\n                        : primaryColumn.propertyName + \"_ancestor\",\n                    options: {\n                        primary: true,\n                        length: primaryColumn.length,\n                        type: primaryColumn.type,\n                    },\n                },\n            }));\n            entityMetadata.ownColumns.push(new ColumnMetadata({\n                connection: this.connection,\n                entityMetadata: entityMetadata,\n                closureType: \"descendant\",\n                referencedColumn: primaryColumn,\n                args: {\n                    target: \"\",\n                    mode: \"virtual\",\n                    propertyName: parentClosureEntityMetadata.treeOptions &&\n                        parentClosureEntityMetadata.treeOptions\n                            .descendantColumnName\n                        ? parentClosureEntityMetadata.treeOptions.descendantColumnName(primaryColumn)\n                        : primaryColumn.propertyName + \"_descendant\",\n                    options: {\n                        primary: true,\n                        length: primaryColumn.length,\n                        type: primaryColumn.type,\n                    },\n                },\n            }));\n        });\n        entityMetadata.ownIndices = [\n            new IndexMetadata({\n                entityMetadata: entityMetadata,\n                columns: [entityMetadata.ownColumns[0]],\n                args: {\n                    target: entityMetadata.target,\n                    synchronize: true,\n                },\n            }),\n            new IndexMetadata({\n                entityMetadata: entityMetadata,\n                columns: [entityMetadata.ownColumns[1]],\n                args: {\n                    target: entityMetadata.target,\n                    synchronize: true,\n                },\n            }),\n        ];\n        // if tree level column was defined by a closure entity then add it to the junction columns as well\n        if (parentClosureEntityMetadata.treeLevelColumn) {\n            entityMetadata.ownColumns.push(new ColumnMetadata({\n                connection: this.connection,\n                entityMetadata: entityMetadata,\n                args: {\n                    target: \"\",\n                    mode: \"virtual\",\n                    propertyName: \"level\",\n                    options: {\n                        type: this.connection.driver.mappedDataTypes\n                            .treeLevel,\n                    },\n                },\n            }));\n        }\n        // create junction table foreign keys\n        // Note: CASCADE is not applied to mssql because it does not support multi cascade paths\n        entityMetadata.foreignKeys = [\n            new ForeignKeyMetadata({\n                entityMetadata: entityMetadata,\n                referencedEntityMetadata: parentClosureEntityMetadata,\n                columns: [entityMetadata.ownColumns[0]],\n                referencedColumns: parentClosureEntityMetadata.primaryColumns,\n                onDelete: this.connection.driver.options.type === \"mssql\"\n                    ? \"NO ACTION\"\n                    : \"CASCADE\",\n            }),\n            new ForeignKeyMetadata({\n                entityMetadata: entityMetadata,\n                referencedEntityMetadata: parentClosureEntityMetadata,\n                columns: [entityMetadata.ownColumns[1]],\n                referencedColumns: parentClosureEntityMetadata.primaryColumns,\n                onDelete: this.connection.driver.options.type === \"mssql\"\n                    ? \"NO ACTION\"\n                    : \"CASCADE\",\n            }),\n        ];\n        return entityMetadata;\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}