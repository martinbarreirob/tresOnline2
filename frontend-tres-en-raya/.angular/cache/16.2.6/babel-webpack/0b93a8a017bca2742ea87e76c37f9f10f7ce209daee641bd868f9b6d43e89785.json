{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/practicas/Downloads/angular/tresOnline/frontend-tres-en-raya/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { DriverPackageNotInstalledError } from \"../../error/DriverPackageNotInstalledError\";\nimport { SpannerQueryRunner } from \"./SpannerQueryRunner\";\nimport { DateUtils } from \"../../util/DateUtils\";\nimport { PlatformTools } from \"../../platform/PlatformTools\";\nimport { RdbmsSchemaBuilder } from \"../../schema-builder/RdbmsSchemaBuilder\";\nimport { EntityMetadata } from \"../../metadata/EntityMetadata\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\nimport { ApplyValueTransformers } from \"../../util/ApplyValueTransformers\";\nimport { Table } from \"../../schema-builder/table/Table\";\nimport { View } from \"../../schema-builder/view/View\";\nimport { TableForeignKey } from \"../../schema-builder/table/TableForeignKey\";\n/**\n * Organizes communication with Spanner DBMS.\n */\nexport class SpannerDriver {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection) {\n    /**\n     * Indicates if replication is enabled.\n     */\n    this.isReplicated = false;\n    /**\n     * Indicates if tree tables are supported by this driver.\n     */\n    this.treeSupport = true;\n    /**\n     * Represent transaction support by this driver\n     */\n    this.transactionSupport = \"none\";\n    /**\n     * Gets list of supported column data types by a driver.\n     *\n     * @see https://cloud.google.com/spanner/docs/reference/standard-sql/data-types\n     */\n    this.supportedDataTypes = [\"bool\", \"int64\", \"float64\", \"numeric\", \"string\", \"json\", \"bytes\", \"date\", \"timestamp\", \"array\"];\n    /**\n     * Returns type of upsert supported by driver if any\n     */\n    this.supportedUpsertTypes = [];\n    /**\n     * Gets list of spatial column data types.\n     */\n    this.spatialTypes = [];\n    /**\n     * Gets list of column data types that support length by a driver.\n     */\n    this.withLengthColumnTypes = [\"string\", \"bytes\"];\n    /**\n     * Gets list of column data types that support length by a driver.\n     */\n    this.withWidthColumnTypes = [];\n    /**\n     * Gets list of column data types that support precision by a driver.\n     */\n    this.withPrecisionColumnTypes = [];\n    /**\n     * Gets list of column data types that supports scale by a driver.\n     */\n    this.withScaleColumnTypes = [];\n    /**\n     * ORM has special columns and we need to know what database column types should be for those columns.\n     * Column types are driver dependant.\n     */\n    this.mappedDataTypes = {\n      createDate: \"timestamp\",\n      createDateDefault: \"\",\n      updateDate: \"timestamp\",\n      updateDateDefault: \"\",\n      deleteDate: \"timestamp\",\n      deleteDateNullable: true,\n      version: \"int64\",\n      treeLevel: \"int64\",\n      migrationId: \"int64\",\n      migrationName: \"string\",\n      migrationTimestamp: \"int64\",\n      cacheId: \"string\",\n      cacheIdentifier: \"string\",\n      cacheTime: \"int64\",\n      cacheDuration: \"int64\",\n      cacheQuery: \"string\",\n      cacheResult: \"string\",\n      metadataType: \"string\",\n      metadataDatabase: \"string\",\n      metadataSchema: \"string\",\n      metadataTable: \"string\",\n      metadataName: \"string\",\n      metadataValue: \"string\"\n    };\n    /**\n     * Default values of length, precision and scale depends on column data type.\n     * Used in the cases when length/precision/scale is not specified by user.\n     */\n    this.dataTypeDefaults = {};\n    /**\n     * Max length allowed by MySQL for aliases.\n     * @see https://dev.mysql.com/doc/refman/5.5/en/identifiers.html\n     */\n    this.maxAliasLength = 63;\n    this.cteCapabilities = {\n      enabled: true\n    };\n    /**\n     * Supported returning types\n     */\n    this._isReturningSqlSupported = {\n      delete: false,\n      insert: false,\n      update: false\n    };\n    this.connection = connection;\n    this.options = connection.options;\n    this.isReplicated = this.options.replication ? true : false;\n    // load mysql package\n    this.loadDependencies();\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Performs connection to the database.\n   */\n  connect() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.instance = _this.spanner.instance(_this.options.instanceId);\n      _this.instanceDatabase = _this.instance.database(_this.options.databaseId);\n    })();\n  }\n  /**\n   * Makes any action after connection (e.g. create extensions in Postgres driver).\n   */\n  afterConnect() {\n    return Promise.resolve();\n  }\n  /**\n   * Closes connection with the database.\n   */\n  disconnect() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      _this2.instanceDatabase.close();\n    })();\n  }\n  /**\n   * Creates a schema builder used to build and sync a schema.\n   */\n  createSchemaBuilder() {\n    return new RdbmsSchemaBuilder(this.connection);\n  }\n  /**\n   * Creates a query runner used to execute database queries.\n   */\n  createQueryRunner(mode) {\n    return new SpannerQueryRunner(this, mode);\n  }\n  /**\n   * Replaces parameters in the given sql with special escaping character\n   * and an array of parameter names to be passed to a query.\n   */\n  escapeQueryWithParameters(sql, parameters, nativeParameters) {\n    const escapedParameters = Object.keys(nativeParameters).map(key => nativeParameters[key]);\n    if (!parameters || !Object.keys(parameters).length) return [sql, escapedParameters];\n    sql = sql.replace(/:(\\.\\.\\.)?([A-Za-z0-9_.]+)/g, (full, isArray, key) => {\n      if (!parameters.hasOwnProperty(key)) {\n        return full;\n      }\n      let value = parameters[key];\n      if (value === null) {\n        return full;\n      }\n      if (isArray) {\n        return value.map(v => {\n          escapedParameters.push(v);\n          return this.createParameter(key, escapedParameters.length - 1);\n        }).join(\", \");\n      }\n      if (value instanceof Function) {\n        return value();\n      }\n      escapedParameters.push(value);\n      return this.createParameter(key, escapedParameters.length - 1);\n    }); // todo: make replace only in value statements, otherwise problems\n    sql = sql.replace(/([ ]+)?=([ ]+)?:(\\.\\.\\.)?([A-Za-z0-9_.]+)/g, (full, emptySpaceBefore, emptySpaceAfter, isArray, key) => {\n      if (!parameters.hasOwnProperty(key)) {\n        return full;\n      }\n      let value = parameters[key];\n      if (value === null) {\n        return \" IS NULL\";\n      }\n      return full;\n    });\n    return [sql, escapedParameters];\n  }\n  /**\n   * Escapes a column name.\n   */\n  escape(columnName) {\n    return `\\`${columnName}\\``;\n  }\n  /**\n   * Build full table name with database name, schema name and table name.\n   * E.g. myDB.mySchema.myTable\n   */\n  buildTableName(tableName, schema, database) {\n    let tablePath = [tableName];\n    if (database) {\n      tablePath.unshift(database);\n    }\n    return tablePath.join(\".\");\n  }\n  /**\n   * Parse a target table name or other types and return a normalized table definition.\n   */\n  parseTableName(target) {\n    const driverDatabase = this.database;\n    const driverSchema = undefined;\n    if (target instanceof Table || target instanceof View) {\n      const parsed = this.parseTableName(target.name);\n      return {\n        database: target.database || parsed.database || driverDatabase,\n        schema: target.schema || parsed.schema || driverSchema,\n        tableName: parsed.tableName\n      };\n    }\n    if (target instanceof TableForeignKey) {\n      const parsed = this.parseTableName(target.referencedTableName);\n      return {\n        database: target.referencedDatabase || parsed.database || driverDatabase,\n        schema: target.referencedSchema || parsed.schema || driverSchema,\n        tableName: parsed.tableName\n      };\n    }\n    if (target instanceof EntityMetadata) {\n      // EntityMetadata tableName is never a path\n      return {\n        database: target.database || driverDatabase,\n        schema: target.schema || driverSchema,\n        tableName: target.tableName\n      };\n    }\n    const parts = target.split(\".\");\n    return {\n      database: (parts.length > 1 ? parts[0] : undefined) || driverDatabase,\n      schema: driverSchema,\n      tableName: parts.length > 1 ? parts[1] : parts[0]\n    };\n  }\n  /**\n   * Prepares given value to a value to be persisted, based on its column type and metadata.\n   */\n  preparePersistentValue(value, columnMetadata) {\n    if (columnMetadata.transformer) value = ApplyValueTransformers.transformTo(columnMetadata.transformer, value);\n    if (value === null || value === undefined) return value;\n    if (columnMetadata.type === \"numeric\") {\n      const lib = this.options.driver || PlatformTools.load(\"spanner\");\n      return lib.Spanner.numeric(value);\n    } else if (columnMetadata.type === \"date\") {\n      return DateUtils.mixedDateToDateString(value);\n    } else if (columnMetadata.type === \"json\") {\n      return value;\n    } else if (columnMetadata.type === \"timestamp\" || columnMetadata.type === Date) {\n      return DateUtils.mixedDateToDate(value);\n    }\n    return value;\n  }\n  /**\n   * Prepares given value to a value to be persisted, based on its column type or metadata.\n   */\n  prepareHydratedValue(value, columnMetadata) {\n    if (value === null || value === undefined) return columnMetadata.transformer ? ApplyValueTransformers.transformFrom(columnMetadata.transformer, value) : value;\n    if (columnMetadata.type === Boolean || columnMetadata.type === \"bool\") {\n      value = value ? true : false;\n    } else if (columnMetadata.type === \"timestamp\" || columnMetadata.type === Date) {\n      value = new Date(value);\n    } else if (columnMetadata.type === \"numeric\") {\n      value = value.value;\n    } else if (columnMetadata.type === \"date\") {\n      value = DateUtils.mixedDateToDateString(value);\n    } else if (columnMetadata.type === \"json\") {\n      value = typeof value === \"string\" ? JSON.parse(value) : value;\n    } else if (columnMetadata.type === Number) {\n      // convert to number if number\n      value = !isNaN(+value) ? parseInt(value) : value;\n    }\n    if (columnMetadata.transformer) value = ApplyValueTransformers.transformFrom(columnMetadata.transformer, value);\n    return value;\n  }\n  /**\n   * Creates a database type from a given column metadata.\n   */\n  normalizeType(column) {\n    if (column.type === Number) {\n      return \"int64\";\n    } else if (column.type === String || column.type === \"uuid\") {\n      return \"string\";\n    } else if (column.type === Date) {\n      return \"timestamp\";\n    } else if (column.type === Buffer) {\n      return \"bytes\";\n    } else if (column.type === Boolean) {\n      return \"bool\";\n    } else {\n      return column.type || \"\";\n    }\n  }\n  /**\n   * Normalizes \"default\" value of the column.\n   *\n   * Spanner does not support default values.\n   */\n  normalizeDefault(columnMetadata) {\n    return columnMetadata.default === \"\" ? `\"${columnMetadata.default}\"` : `${columnMetadata.default}`;\n  }\n  /**\n   * Normalizes \"isUnique\" value of the column.\n   */\n  normalizeIsUnique(column) {\n    return column.entityMetadata.indices.some(idx => idx.isUnique && idx.columns.length === 1 && idx.columns[0] === column);\n  }\n  /**\n   * Returns default column lengths, which is required on column creation.\n   */\n  getColumnLength(column) {\n    if (column.length) return column.length.toString();\n    if (column.generationStrategy === \"uuid\") return \"36\";\n    switch (column.type) {\n      case String:\n      case \"string\":\n      case \"bytes\":\n        return \"max\";\n      default:\n        return \"\";\n    }\n  }\n  /**\n   * Creates column type definition including length, precision and scale\n   */\n  createFullType(column) {\n    let type = column.type;\n    // used 'getColumnLength()' method, because Spanner requires column length for `string` and `bytes` data types\n    if (this.getColumnLength(column)) {\n      type += `(${this.getColumnLength(column)})`;\n    } else if (column.width) {\n      type += `(${column.width})`;\n    } else if (column.precision !== null && column.precision !== undefined && column.scale !== null && column.scale !== undefined) {\n      type += `(${column.precision},${column.scale})`;\n    } else if (column.precision !== null && column.precision !== undefined) {\n      type += `(${column.precision})`;\n    }\n    if (column.isArray) type = `array<${type}>`;\n    return type;\n  }\n  /**\n   * Obtains a new database connection to a master server.\n   * Used for replication.\n   * If replication is not setup then returns default connection's database connection.\n   */\n  obtainMasterConnection() {\n    return this.instanceDatabase;\n  }\n  /**\n   * Obtains a new database connection to a slave server.\n   * Used for replication.\n   * If replication is not setup then returns master (default) connection's database connection.\n   */\n  obtainSlaveConnection() {\n    return this.instanceDatabase;\n  }\n  /**\n   * Creates generated map of values generated or returned by database after INSERT query.\n   */\n  createGeneratedMap(metadata, insertResult, entityIndex) {\n    if (!insertResult) {\n      return undefined;\n    }\n    if (insertResult.insertId === undefined) {\n      return Object.keys(insertResult).reduce((map, key) => {\n        const column = metadata.findColumnWithDatabaseName(key);\n        if (column) {\n          OrmUtils.mergeDeep(map, column.createValueMap(insertResult[key]));\n          // OrmUtils.mergeDeep(map, column.createValueMap(this.prepareHydratedValue(insertResult[key], column))); // TODO: probably should be like there, but fails on enums, fix later\n        }\n\n        return map;\n      }, {});\n    }\n    const generatedMap = metadata.generatedColumns.reduce((map, generatedColumn) => {\n      let value;\n      if (generatedColumn.generationStrategy === \"increment\" && insertResult.insertId) {\n        // NOTE: When multiple rows is inserted by a single INSERT statement,\n        // `insertId` is the value generated for the first inserted row only.\n        value = insertResult.insertId + entityIndex;\n        // } else if (generatedColumn.generationStrategy === \"uuid\") {\n        //     console.log(\"getting db value:\", generatedColumn.databaseName);\n        //     value = generatedColumn.getEntityValue(uuidMap);\n      }\n\n      return OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));\n    }, {});\n    return Object.keys(generatedMap).length > 0 ? generatedMap : undefined;\n  }\n  /**\n   * Differentiate columns of this table and columns from the given column metadatas columns\n   * and returns only changed.\n   */\n  findChangedColumns(tableColumns, columnMetadatas) {\n    return columnMetadatas.filter(columnMetadata => {\n      const tableColumn = tableColumns.find(c => c.name === columnMetadata.databaseName);\n      if (!tableColumn) return false; // we don't need new columns, we only need exist and changed\n      const isColumnChanged = tableColumn.name !== columnMetadata.databaseName || tableColumn.type !== this.normalizeType(columnMetadata) || tableColumn.length !== this.getColumnLength(columnMetadata) || tableColumn.asExpression !== columnMetadata.asExpression || tableColumn.generatedType !== columnMetadata.generatedType || tableColumn.isPrimary !== columnMetadata.isPrimary || !this.compareNullableValues(columnMetadata, tableColumn) || tableColumn.isUnique !== this.normalizeIsUnique(columnMetadata);\n      // DEBUG SECTION\n      // if (isColumnChanged) {\n      //     console.log(\"table:\", columnMetadata.entityMetadata.tableName)\n      //     console.log(\n      //         \"name:\",\n      //         tableColumn.name,\n      //         columnMetadata.databaseName,\n      //     )\n      //     console.log(\n      //         \"type:\",\n      //         tableColumn.type,\n      //         this.normalizeType(columnMetadata),\n      //     )\n      //     console.log(\n      //         \"length:\",\n      //         tableColumn.length,\n      //         this.getColumnLength(columnMetadata),\n      //     )\n      //     console.log(\n      //         \"asExpression:\",\n      //         tableColumn.asExpression,\n      //         columnMetadata.asExpression,\n      //     )\n      //     console.log(\n      //         \"generatedType:\",\n      //         tableColumn.generatedType,\n      //         columnMetadata.generatedType,\n      //     )\n      //     console.log(\n      //         \"isPrimary:\",\n      //         tableColumn.isPrimary,\n      //         columnMetadata.isPrimary,\n      //     )\n      //     console.log(\n      //         \"isNullable:\",\n      //         tableColumn.isNullable,\n      //         columnMetadata.isNullable,\n      //     )\n      //     console.log(\n      //         \"isUnique:\",\n      //         tableColumn.isUnique,\n      //         this.normalizeIsUnique(columnMetadata),\n      //     )\n      //     console.log(\"==========================================\")\n      // }\n      return isColumnChanged;\n    });\n  }\n  /**\n   * Returns true if driver supports RETURNING / OUTPUT statement.\n   */\n  isReturningSqlSupported(returningType) {\n    return this._isReturningSqlSupported[returningType];\n  }\n  /**\n   * Returns true if driver supports uuid values generation on its own.\n   */\n  isUUIDGenerationSupported() {\n    return false;\n  }\n  /**\n   * Returns true if driver supports fulltext indices.\n   */\n  isFullTextColumnTypeSupported() {\n    return false;\n  }\n  /**\n   * Creates an escaped parameter.\n   */\n  createParameter(parameterName, index) {\n    return \"@param\" + index;\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Loads all driver dependencies.\n   */\n  loadDependencies() {\n    try {\n      const lib = this.options.driver || PlatformTools.load(\"spanner\");\n      this.spanner = new lib.Spanner({\n        projectId: this.options.projectId\n      });\n    } catch (e) {\n      console.error(e);\n      throw new DriverPackageNotInstalledError(\"Spanner\", \"@google-cloud/spanner\");\n    }\n  }\n  compareNullableValues(columnMetadata, tableColumn) {\n    // Spanner does not support NULL/NOT NULL expressions for generated columns\n    if (columnMetadata.generatedType) {\n      return true;\n    }\n    return columnMetadata.isNullable === tableColumn.isNullable;\n  }\n  /**\n   * Checks if \"DEFAULT\" values in the column metadata and in the database are equal.\n   */\n  compareDefaultValues(columnMetadataValue, databaseValue) {\n    if (typeof columnMetadataValue === \"string\" && typeof databaseValue === \"string\") {\n      // we need to cut out \"'\" because in mysql we can understand returned value is a string or a function\n      // as result compare cannot understand if default is really changed or not\n      columnMetadataValue = columnMetadataValue.replace(/^'+|'+$/g, \"\");\n      databaseValue = databaseValue.replace(/^'+|'+$/g, \"\");\n    }\n    return columnMetadataValue === databaseValue;\n  }\n  /**\n   * If parameter is a datetime function, e.g. \"CURRENT_TIMESTAMP\", normalizes it.\n   * Otherwise returns original input.\n   */\n  normalizeDatetimeFunction(value) {\n    if (!value) return value;\n    // check if input is datetime function\n    const isDatetimeFunction = value.toUpperCase().indexOf(\"CURRENT_TIMESTAMP\") !== -1 || value.toUpperCase().indexOf(\"NOW\") !== -1;\n    if (isDatetimeFunction) {\n      // extract precision, e.g. \"(3)\"\n      const precision = value.match(/\\(\\d+\\)/);\n      return precision ? `CURRENT_TIMESTAMP${precision[0]}` : \"CURRENT_TIMESTAMP\";\n    } else {\n      return value;\n    }\n  }\n  /**\n   * Escapes a given comment.\n   */\n  escapeComment(comment) {\n    if (!comment) return comment;\n    comment = comment.replace(/\\u0000/g, \"\"); // Null bytes aren't allowed in comments\n    return comment;\n  }\n}","map":{"version":3,"names":["DriverPackageNotInstalledError","SpannerQueryRunner","DateUtils","PlatformTools","RdbmsSchemaBuilder","EntityMetadata","OrmUtils","ApplyValueTransformers","Table","View","TableForeignKey","SpannerDriver","constructor","connection","isReplicated","treeSupport","transactionSupport","supportedDataTypes","supportedUpsertTypes","spatialTypes","withLengthColumnTypes","withWidthColumnTypes","withPrecisionColumnTypes","withScaleColumnTypes","mappedDataTypes","createDate","createDateDefault","updateDate","updateDateDefault","deleteDate","deleteDateNullable","version","treeLevel","migrationId","migrationName","migrationTimestamp","cacheId","cacheIdentifier","cacheTime","cacheDuration","cacheQuery","cacheResult","metadataType","metadataDatabase","metadataSchema","metadataTable","metadataName","metadataValue","dataTypeDefaults","maxAliasLength","cteCapabilities","enabled","_isReturningSqlSupported","delete","insert","update","options","replication","loadDependencies","connect","_this","_asyncToGenerator","instance","spanner","instanceId","instanceDatabase","database","databaseId","afterConnect","Promise","resolve","disconnect","_this2","close","createSchemaBuilder","createQueryRunner","mode","escapeQueryWithParameters","sql","parameters","nativeParameters","escapedParameters","Object","keys","map","key","length","replace","full","isArray","hasOwnProperty","value","v","push","createParameter","join","Function","emptySpaceBefore","emptySpaceAfter","escape","columnName","buildTableName","tableName","schema","tablePath","unshift","parseTableName","target","driverDatabase","driverSchema","undefined","parsed","name","referencedTableName","referencedDatabase","referencedSchema","parts","split","preparePersistentValue","columnMetadata","transformer","transformTo","type","lib","driver","load","Spanner","numeric","mixedDateToDateString","Date","mixedDateToDate","prepareHydratedValue","transformFrom","Boolean","JSON","parse","Number","isNaN","parseInt","normalizeType","column","String","Buffer","normalizeDefault","default","normalizeIsUnique","entityMetadata","indices","some","idx","isUnique","columns","getColumnLength","toString","generationStrategy","createFullType","width","precision","scale","obtainMasterConnection","obtainSlaveConnection","createGeneratedMap","metadata","insertResult","entityIndex","insertId","reduce","findColumnWithDatabaseName","mergeDeep","createValueMap","generatedMap","generatedColumns","generatedColumn","findChangedColumns","tableColumns","columnMetadatas","filter","tableColumn","find","c","databaseName","isColumnChanged","asExpression","generatedType","isPrimary","compareNullableValues","isReturningSqlSupported","returningType","isUUIDGenerationSupported","isFullTextColumnTypeSupported","parameterName","index","projectId","e","console","error","isNullable","compareDefaultValues","columnMetadataValue","databaseValue","normalizeDatetimeFunction","isDatetimeFunction","toUpperCase","indexOf","match","escapeComment","comment"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/driver/spanner/SpannerDriver.js"],"sourcesContent":["import { DriverPackageNotInstalledError } from \"../../error/DriverPackageNotInstalledError\";\nimport { SpannerQueryRunner } from \"./SpannerQueryRunner\";\nimport { DateUtils } from \"../../util/DateUtils\";\nimport { PlatformTools } from \"../../platform/PlatformTools\";\nimport { RdbmsSchemaBuilder } from \"../../schema-builder/RdbmsSchemaBuilder\";\nimport { EntityMetadata } from \"../../metadata/EntityMetadata\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\nimport { ApplyValueTransformers } from \"../../util/ApplyValueTransformers\";\nimport { Table } from \"../../schema-builder/table/Table\";\nimport { View } from \"../../schema-builder/view/View\";\nimport { TableForeignKey } from \"../../schema-builder/table/TableForeignKey\";\n/**\n * Organizes communication with Spanner DBMS.\n */\nexport class SpannerDriver {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n    constructor(connection) {\n        /**\n         * Indicates if replication is enabled.\n         */\n        this.isReplicated = false;\n        /**\n         * Indicates if tree tables are supported by this driver.\n         */\n        this.treeSupport = true;\n        /**\n         * Represent transaction support by this driver\n         */\n        this.transactionSupport = \"none\";\n        /**\n         * Gets list of supported column data types by a driver.\n         *\n         * @see https://cloud.google.com/spanner/docs/reference/standard-sql/data-types\n         */\n        this.supportedDataTypes = [\n            \"bool\",\n            \"int64\",\n            \"float64\",\n            \"numeric\",\n            \"string\",\n            \"json\",\n            \"bytes\",\n            \"date\",\n            \"timestamp\",\n            \"array\",\n        ];\n        /**\n         * Returns type of upsert supported by driver if any\n         */\n        this.supportedUpsertTypes = [];\n        /**\n         * Gets list of spatial column data types.\n         */\n        this.spatialTypes = [];\n        /**\n         * Gets list of column data types that support length by a driver.\n         */\n        this.withLengthColumnTypes = [\"string\", \"bytes\"];\n        /**\n         * Gets list of column data types that support length by a driver.\n         */\n        this.withWidthColumnTypes = [];\n        /**\n         * Gets list of column data types that support precision by a driver.\n         */\n        this.withPrecisionColumnTypes = [];\n        /**\n         * Gets list of column data types that supports scale by a driver.\n         */\n        this.withScaleColumnTypes = [];\n        /**\n         * ORM has special columns and we need to know what database column types should be for those columns.\n         * Column types are driver dependant.\n         */\n        this.mappedDataTypes = {\n            createDate: \"timestamp\",\n            createDateDefault: \"\",\n            updateDate: \"timestamp\",\n            updateDateDefault: \"\",\n            deleteDate: \"timestamp\",\n            deleteDateNullable: true,\n            version: \"int64\",\n            treeLevel: \"int64\",\n            migrationId: \"int64\",\n            migrationName: \"string\",\n            migrationTimestamp: \"int64\",\n            cacheId: \"string\",\n            cacheIdentifier: \"string\",\n            cacheTime: \"int64\",\n            cacheDuration: \"int64\",\n            cacheQuery: \"string\",\n            cacheResult: \"string\",\n            metadataType: \"string\",\n            metadataDatabase: \"string\",\n            metadataSchema: \"string\",\n            metadataTable: \"string\",\n            metadataName: \"string\",\n            metadataValue: \"string\",\n        };\n        /**\n         * Default values of length, precision and scale depends on column data type.\n         * Used in the cases when length/precision/scale is not specified by user.\n         */\n        this.dataTypeDefaults = {};\n        /**\n         * Max length allowed by MySQL for aliases.\n         * @see https://dev.mysql.com/doc/refman/5.5/en/identifiers.html\n         */\n        this.maxAliasLength = 63;\n        this.cteCapabilities = {\n            enabled: true,\n        };\n        /**\n         * Supported returning types\n         */\n        this._isReturningSqlSupported = {\n            delete: false,\n            insert: false,\n            update: false,\n        };\n        this.connection = connection;\n        this.options = connection.options;\n        this.isReplicated = this.options.replication ? true : false;\n        // load mysql package\n        this.loadDependencies();\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Performs connection to the database.\n     */\n    async connect() {\n        this.instance = this.spanner.instance(this.options.instanceId);\n        this.instanceDatabase = this.instance.database(this.options.databaseId);\n    }\n    /**\n     * Makes any action after connection (e.g. create extensions in Postgres driver).\n     */\n    afterConnect() {\n        return Promise.resolve();\n    }\n    /**\n     * Closes connection with the database.\n     */\n    async disconnect() {\n        this.instanceDatabase.close();\n    }\n    /**\n     * Creates a schema builder used to build and sync a schema.\n     */\n    createSchemaBuilder() {\n        return new RdbmsSchemaBuilder(this.connection);\n    }\n    /**\n     * Creates a query runner used to execute database queries.\n     */\n    createQueryRunner(mode) {\n        return new SpannerQueryRunner(this, mode);\n    }\n    /**\n     * Replaces parameters in the given sql with special escaping character\n     * and an array of parameter names to be passed to a query.\n     */\n    escapeQueryWithParameters(sql, parameters, nativeParameters) {\n        const escapedParameters = Object.keys(nativeParameters).map((key) => nativeParameters[key]);\n        if (!parameters || !Object.keys(parameters).length)\n            return [sql, escapedParameters];\n        sql = sql.replace(/:(\\.\\.\\.)?([A-Za-z0-9_.]+)/g, (full, isArray, key) => {\n            if (!parameters.hasOwnProperty(key)) {\n                return full;\n            }\n            let value = parameters[key];\n            if (value === null) {\n                return full;\n            }\n            if (isArray) {\n                return value\n                    .map((v) => {\n                    escapedParameters.push(v);\n                    return this.createParameter(key, escapedParameters.length - 1);\n                })\n                    .join(\", \");\n            }\n            if (value instanceof Function) {\n                return value();\n            }\n            escapedParameters.push(value);\n            return this.createParameter(key, escapedParameters.length - 1);\n        }); // todo: make replace only in value statements, otherwise problems\n        sql = sql.replace(/([ ]+)?=([ ]+)?:(\\.\\.\\.)?([A-Za-z0-9_.]+)/g, (full, emptySpaceBefore, emptySpaceAfter, isArray, key) => {\n            if (!parameters.hasOwnProperty(key)) {\n                return full;\n            }\n            let value = parameters[key];\n            if (value === null) {\n                return \" IS NULL\";\n            }\n            return full;\n        });\n        return [sql, escapedParameters];\n    }\n    /**\n     * Escapes a column name.\n     */\n    escape(columnName) {\n        return `\\`${columnName}\\``;\n    }\n    /**\n     * Build full table name with database name, schema name and table name.\n     * E.g. myDB.mySchema.myTable\n     */\n    buildTableName(tableName, schema, database) {\n        let tablePath = [tableName];\n        if (database) {\n            tablePath.unshift(database);\n        }\n        return tablePath.join(\".\");\n    }\n    /**\n     * Parse a target table name or other types and return a normalized table definition.\n     */\n    parseTableName(target) {\n        const driverDatabase = this.database;\n        const driverSchema = undefined;\n        if (target instanceof Table || target instanceof View) {\n            const parsed = this.parseTableName(target.name);\n            return {\n                database: target.database || parsed.database || driverDatabase,\n                schema: target.schema || parsed.schema || driverSchema,\n                tableName: parsed.tableName,\n            };\n        }\n        if (target instanceof TableForeignKey) {\n            const parsed = this.parseTableName(target.referencedTableName);\n            return {\n                database: target.referencedDatabase ||\n                    parsed.database ||\n                    driverDatabase,\n                schema: target.referencedSchema || parsed.schema || driverSchema,\n                tableName: parsed.tableName,\n            };\n        }\n        if (target instanceof EntityMetadata) {\n            // EntityMetadata tableName is never a path\n            return {\n                database: target.database || driverDatabase,\n                schema: target.schema || driverSchema,\n                tableName: target.tableName,\n            };\n        }\n        const parts = target.split(\".\");\n        return {\n            database: (parts.length > 1 ? parts[0] : undefined) || driverDatabase,\n            schema: driverSchema,\n            tableName: parts.length > 1 ? parts[1] : parts[0],\n        };\n    }\n    /**\n     * Prepares given value to a value to be persisted, based on its column type and metadata.\n     */\n    preparePersistentValue(value, columnMetadata) {\n        if (columnMetadata.transformer)\n            value = ApplyValueTransformers.transformTo(columnMetadata.transformer, value);\n        if (value === null || value === undefined)\n            return value;\n        if (columnMetadata.type === \"numeric\") {\n            const lib = this.options.driver || PlatformTools.load(\"spanner\");\n            return lib.Spanner.numeric(value);\n        }\n        else if (columnMetadata.type === \"date\") {\n            return DateUtils.mixedDateToDateString(value);\n        }\n        else if (columnMetadata.type === \"json\") {\n            return value;\n        }\n        else if (columnMetadata.type === \"timestamp\" ||\n            columnMetadata.type === Date) {\n            return DateUtils.mixedDateToDate(value);\n        }\n        return value;\n    }\n    /**\n     * Prepares given value to a value to be persisted, based on its column type or metadata.\n     */\n    prepareHydratedValue(value, columnMetadata) {\n        if (value === null || value === undefined)\n            return columnMetadata.transformer\n                ? ApplyValueTransformers.transformFrom(columnMetadata.transformer, value)\n                : value;\n        if (columnMetadata.type === Boolean || columnMetadata.type === \"bool\") {\n            value = value ? true : false;\n        }\n        else if (columnMetadata.type === \"timestamp\" ||\n            columnMetadata.type === Date) {\n            value = new Date(value);\n        }\n        else if (columnMetadata.type === \"numeric\") {\n            value = value.value;\n        }\n        else if (columnMetadata.type === \"date\") {\n            value = DateUtils.mixedDateToDateString(value);\n        }\n        else if (columnMetadata.type === \"json\") {\n            value = typeof value === \"string\" ? JSON.parse(value) : value;\n        }\n        else if (columnMetadata.type === Number) {\n            // convert to number if number\n            value = !isNaN(+value) ? parseInt(value) : value;\n        }\n        if (columnMetadata.transformer)\n            value = ApplyValueTransformers.transformFrom(columnMetadata.transformer, value);\n        return value;\n    }\n    /**\n     * Creates a database type from a given column metadata.\n     */\n    normalizeType(column) {\n        if (column.type === Number) {\n            return \"int64\";\n        }\n        else if (column.type === String || column.type === \"uuid\") {\n            return \"string\";\n        }\n        else if (column.type === Date) {\n            return \"timestamp\";\n        }\n        else if (column.type === Buffer) {\n            return \"bytes\";\n        }\n        else if (column.type === Boolean) {\n            return \"bool\";\n        }\n        else {\n            return column.type || \"\";\n        }\n    }\n    /**\n     * Normalizes \"default\" value of the column.\n     *\n     * Spanner does not support default values.\n     */\n    normalizeDefault(columnMetadata) {\n        return columnMetadata.default === \"\"\n            ? `\"${columnMetadata.default}\"`\n            : `${columnMetadata.default}`;\n    }\n    /**\n     * Normalizes \"isUnique\" value of the column.\n     */\n    normalizeIsUnique(column) {\n        return column.entityMetadata.indices.some((idx) => idx.isUnique &&\n            idx.columns.length === 1 &&\n            idx.columns[0] === column);\n    }\n    /**\n     * Returns default column lengths, which is required on column creation.\n     */\n    getColumnLength(column) {\n        if (column.length)\n            return column.length.toString();\n        if (column.generationStrategy === \"uuid\")\n            return \"36\";\n        switch (column.type) {\n            case String:\n            case \"string\":\n            case \"bytes\":\n                return \"max\";\n            default:\n                return \"\";\n        }\n    }\n    /**\n     * Creates column type definition including length, precision and scale\n     */\n    createFullType(column) {\n        let type = column.type;\n        // used 'getColumnLength()' method, because Spanner requires column length for `string` and `bytes` data types\n        if (this.getColumnLength(column)) {\n            type += `(${this.getColumnLength(column)})`;\n        }\n        else if (column.width) {\n            type += `(${column.width})`;\n        }\n        else if (column.precision !== null &&\n            column.precision !== undefined &&\n            column.scale !== null &&\n            column.scale !== undefined) {\n            type += `(${column.precision},${column.scale})`;\n        }\n        else if (column.precision !== null &&\n            column.precision !== undefined) {\n            type += `(${column.precision})`;\n        }\n        if (column.isArray)\n            type = `array<${type}>`;\n        return type;\n    }\n    /**\n     * Obtains a new database connection to a master server.\n     * Used for replication.\n     * If replication is not setup then returns default connection's database connection.\n     */\n    obtainMasterConnection() {\n        return this.instanceDatabase;\n    }\n    /**\n     * Obtains a new database connection to a slave server.\n     * Used for replication.\n     * If replication is not setup then returns master (default) connection's database connection.\n     */\n    obtainSlaveConnection() {\n        return this.instanceDatabase;\n    }\n    /**\n     * Creates generated map of values generated or returned by database after INSERT query.\n     */\n    createGeneratedMap(metadata, insertResult, entityIndex) {\n        if (!insertResult) {\n            return undefined;\n        }\n        if (insertResult.insertId === undefined) {\n            return Object.keys(insertResult).reduce((map, key) => {\n                const column = metadata.findColumnWithDatabaseName(key);\n                if (column) {\n                    OrmUtils.mergeDeep(map, column.createValueMap(insertResult[key]));\n                    // OrmUtils.mergeDeep(map, column.createValueMap(this.prepareHydratedValue(insertResult[key], column))); // TODO: probably should be like there, but fails on enums, fix later\n                }\n                return map;\n            }, {});\n        }\n        const generatedMap = metadata.generatedColumns.reduce((map, generatedColumn) => {\n            let value;\n            if (generatedColumn.generationStrategy === \"increment\" &&\n                insertResult.insertId) {\n                // NOTE: When multiple rows is inserted by a single INSERT statement,\n                // `insertId` is the value generated for the first inserted row only.\n                value = insertResult.insertId + entityIndex;\n                // } else if (generatedColumn.generationStrategy === \"uuid\") {\n                //     console.log(\"getting db value:\", generatedColumn.databaseName);\n                //     value = generatedColumn.getEntityValue(uuidMap);\n            }\n            return OrmUtils.mergeDeep(map, generatedColumn.createValueMap(value));\n        }, {});\n        return Object.keys(generatedMap).length > 0 ? generatedMap : undefined;\n    }\n    /**\n     * Differentiate columns of this table and columns from the given column metadatas columns\n     * and returns only changed.\n     */\n    findChangedColumns(tableColumns, columnMetadatas) {\n        return columnMetadatas.filter((columnMetadata) => {\n            const tableColumn = tableColumns.find((c) => c.name === columnMetadata.databaseName);\n            if (!tableColumn)\n                return false; // we don't need new columns, we only need exist and changed\n            const isColumnChanged = tableColumn.name !== columnMetadata.databaseName ||\n                tableColumn.type !== this.normalizeType(columnMetadata) ||\n                tableColumn.length !== this.getColumnLength(columnMetadata) ||\n                tableColumn.asExpression !== columnMetadata.asExpression ||\n                tableColumn.generatedType !== columnMetadata.generatedType ||\n                tableColumn.isPrimary !== columnMetadata.isPrimary ||\n                !this.compareNullableValues(columnMetadata, tableColumn) ||\n                tableColumn.isUnique !== this.normalizeIsUnique(columnMetadata);\n            // DEBUG SECTION\n            // if (isColumnChanged) {\n            //     console.log(\"table:\", columnMetadata.entityMetadata.tableName)\n            //     console.log(\n            //         \"name:\",\n            //         tableColumn.name,\n            //         columnMetadata.databaseName,\n            //     )\n            //     console.log(\n            //         \"type:\",\n            //         tableColumn.type,\n            //         this.normalizeType(columnMetadata),\n            //     )\n            //     console.log(\n            //         \"length:\",\n            //         tableColumn.length,\n            //         this.getColumnLength(columnMetadata),\n            //     )\n            //     console.log(\n            //         \"asExpression:\",\n            //         tableColumn.asExpression,\n            //         columnMetadata.asExpression,\n            //     )\n            //     console.log(\n            //         \"generatedType:\",\n            //         tableColumn.generatedType,\n            //         columnMetadata.generatedType,\n            //     )\n            //     console.log(\n            //         \"isPrimary:\",\n            //         tableColumn.isPrimary,\n            //         columnMetadata.isPrimary,\n            //     )\n            //     console.log(\n            //         \"isNullable:\",\n            //         tableColumn.isNullable,\n            //         columnMetadata.isNullable,\n            //     )\n            //     console.log(\n            //         \"isUnique:\",\n            //         tableColumn.isUnique,\n            //         this.normalizeIsUnique(columnMetadata),\n            //     )\n            //     console.log(\"==========================================\")\n            // }\n            return isColumnChanged;\n        });\n    }\n    /**\n     * Returns true if driver supports RETURNING / OUTPUT statement.\n     */\n    isReturningSqlSupported(returningType) {\n        return this._isReturningSqlSupported[returningType];\n    }\n    /**\n     * Returns true if driver supports uuid values generation on its own.\n     */\n    isUUIDGenerationSupported() {\n        return false;\n    }\n    /**\n     * Returns true if driver supports fulltext indices.\n     */\n    isFullTextColumnTypeSupported() {\n        return false;\n    }\n    /**\n     * Creates an escaped parameter.\n     */\n    createParameter(parameterName, index) {\n        return \"@param\" + index;\n    }\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Loads all driver dependencies.\n     */\n    loadDependencies() {\n        try {\n            const lib = this.options.driver || PlatformTools.load(\"spanner\");\n            this.spanner = new lib.Spanner({\n                projectId: this.options.projectId,\n            });\n        }\n        catch (e) {\n            console.error(e);\n            throw new DriverPackageNotInstalledError(\"Spanner\", \"@google-cloud/spanner\");\n        }\n    }\n    compareNullableValues(columnMetadata, tableColumn) {\n        // Spanner does not support NULL/NOT NULL expressions for generated columns\n        if (columnMetadata.generatedType) {\n            return true;\n        }\n        return columnMetadata.isNullable === tableColumn.isNullable;\n    }\n    /**\n     * Checks if \"DEFAULT\" values in the column metadata and in the database are equal.\n     */\n    compareDefaultValues(columnMetadataValue, databaseValue) {\n        if (typeof columnMetadataValue === \"string\" &&\n            typeof databaseValue === \"string\") {\n            // we need to cut out \"'\" because in mysql we can understand returned value is a string or a function\n            // as result compare cannot understand if default is really changed or not\n            columnMetadataValue = columnMetadataValue.replace(/^'+|'+$/g, \"\");\n            databaseValue = databaseValue.replace(/^'+|'+$/g, \"\");\n        }\n        return columnMetadataValue === databaseValue;\n    }\n    /**\n     * If parameter is a datetime function, e.g. \"CURRENT_TIMESTAMP\", normalizes it.\n     * Otherwise returns original input.\n     */\n    normalizeDatetimeFunction(value) {\n        if (!value)\n            return value;\n        // check if input is datetime function\n        const isDatetimeFunction = value.toUpperCase().indexOf(\"CURRENT_TIMESTAMP\") !== -1 ||\n            value.toUpperCase().indexOf(\"NOW\") !== -1;\n        if (isDatetimeFunction) {\n            // extract precision, e.g. \"(3)\"\n            const precision = value.match(/\\(\\d+\\)/);\n            return precision\n                ? `CURRENT_TIMESTAMP${precision[0]}`\n                : \"CURRENT_TIMESTAMP\";\n        }\n        else {\n            return value;\n        }\n    }\n    /**\n     * Escapes a given comment.\n     */\n    escapeComment(comment) {\n        if (!comment)\n            return comment;\n        comment = comment.replace(/\\u0000/g, \"\"); // Null bytes aren't allowed in comments\n        return comment;\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}