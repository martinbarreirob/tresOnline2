{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/practicas/Downloads/angular/tresOnline/frontend-tres-en-raya/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { CannotAttachTreeChildrenEntityError } from \"../../error/CannotAttachTreeChildrenEntityError\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\n/**\n * Executes subject operations for closure entities.\n */\nexport class ClosureSubjectExecutor {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(queryRunner) {\n    this.queryRunner = queryRunner;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Executes operations when subject is being inserted.\n   */\n  insert(subject) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      // create values to be inserted into the closure junction\n      const closureJunctionInsertMap = {};\n      subject.metadata.closureJunctionTable.ancestorColumns.forEach(column => {\n        closureJunctionInsertMap[column.databaseName] = subject.identifier;\n      });\n      subject.metadata.closureJunctionTable.descendantColumns.forEach(column => {\n        closureJunctionInsertMap[column.databaseName] = subject.identifier;\n      });\n      // insert values into the closure junction table\n      yield _this.queryRunner.manager.createQueryBuilder().insert().into(subject.metadata.closureJunctionTable.tablePath).values(closureJunctionInsertMap).updateEntity(false).callListeners(false).execute();\n      let parent = subject.metadata.treeParentRelation.getEntityValue(subject.entity); // if entity was attached via parent\n      if (!parent && subject.parentSubject && subject.parentSubject.entity)\n        // if entity was attached via children\n        parent = subject.parentSubject.insertedValueSet ? subject.parentSubject.insertedValueSet : subject.parentSubject.entity;\n      if (parent) {\n        const escape = alias => _this.queryRunner.connection.driver.escape(alias);\n        const tableName = _this.getTableName(subject.metadata.closureJunctionTable.tablePath);\n        const queryParams = [];\n        const ancestorColumnNames = subject.metadata.closureJunctionTable.ancestorColumns.map(column => {\n          return escape(column.databaseName);\n        });\n        const descendantColumnNames = subject.metadata.closureJunctionTable.descendantColumns.map(column => {\n          return escape(column.databaseName);\n        });\n        const childEntityIds1 = subject.metadata.primaryColumns.map(column => {\n          queryParams.push(column.getEntityValue(subject.insertedValueSet ? subject.insertedValueSet : subject.entity));\n          return _this.queryRunner.connection.driver.createParameter(\"child_entity_\" + column.databaseName, queryParams.length - 1);\n        });\n        const whereCondition = subject.metadata.closureJunctionTable.descendantColumns.map(column => {\n          const columnName = escape(column.databaseName);\n          const parentId = column.referencedColumn.getEntityValue(parent);\n          if (!parentId) throw new CannotAttachTreeChildrenEntityError(subject.metadata.name);\n          queryParams.push(parentId);\n          const parameterName = _this.queryRunner.connection.driver.createParameter(\"parent_entity_\" + column.referencedColumn.databaseName, queryParams.length - 1);\n          return `${columnName} = ${parameterName}`;\n        });\n        yield _this.queryRunner.query(`INSERT INTO ${tableName} (${[...ancestorColumnNames, ...descendantColumnNames].join(\", \")}) ` + `SELECT ${ancestorColumnNames.join(\", \")}, ${childEntityIds1.join(\", \")} FROM ${tableName} WHERE ${whereCondition.join(\" AND \")}`, queryParams);\n      }\n    })();\n  }\n  /**\n   * Executes operations when subject is being updated.\n   */\n  update(subject) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      let parent = subject.metadata.treeParentRelation.getEntityValue(subject.entity); // if entity was attached via parent\n      if (!parent && subject.parentSubject && subject.parentSubject.entity)\n        // if entity was attached via children\n        parent = subject.parentSubject.entity;\n      let entity = subject.databaseEntity; // if entity was attached via parent\n      if (!entity && parent)\n        // if entity was attached via children\n        entity = subject.metadata.treeChildrenRelation.getEntityValue(parent).find(child => {\n          return Object.entries(subject.identifier).every(([key, value]) => child[key] === value);\n        });\n      // Exit if the parent or the entity where never set\n      if (entity === undefined || parent === undefined) {\n        return;\n      }\n      const oldParent = subject.metadata.treeParentRelation.getEntityValue(entity);\n      const oldParentId = subject.metadata.getEntityIdMap(oldParent);\n      const parentId = subject.metadata.getEntityIdMap(parent);\n      // Exit if the new and old parents are the same\n      if (OrmUtils.compareIds(oldParentId, parentId)) {\n        return;\n      }\n      const escape = alias => _this2.queryRunner.connection.driver.escape(alias);\n      const closureTable = subject.metadata.closureJunctionTable;\n      const ancestorColumnNames = closureTable.ancestorColumns.map(column => {\n        return escape(column.databaseName);\n      });\n      const descendantColumnNames = closureTable.descendantColumns.map(column => {\n        return escape(column.databaseName);\n      });\n      // Delete logic\n      const createSubQuery = (qb, alias) => {\n        const subAlias = `sub${alias}`;\n        const subSelect = qb.createQueryBuilder().select(descendantColumnNames.join(\", \")).from(closureTable.tablePath, subAlias);\n        // Create where conditions e.g. (WHERE \"subdescendant\".\"id_ancestor\" = :value_id)\n        for (const column of closureTable.ancestorColumns) {\n          subSelect.andWhere(`${escape(subAlias)}.${escape(column.databaseName)} = :value_${column.referencedColumn.databaseName}`);\n        }\n        return qb.createQueryBuilder().select(descendantColumnNames.join(\", \")).from(`(${subSelect.getQuery()})`, alias).setParameters(subSelect.getParameters()).getQuery();\n      };\n      const parameters = {};\n      for (const column of subject.metadata.primaryColumns) {\n        parameters[`value_${column.databaseName}`] = entity[column.databaseName];\n      }\n      yield _this2.queryRunner.manager.createQueryBuilder().delete().from(closureTable.tablePath).where(qb => `(${descendantColumnNames.join(\", \")}) IN (${createSubQuery(qb, \"descendant\")})`).andWhere(qb => `(${ancestorColumnNames.join(\", \")}) NOT IN (${createSubQuery(qb, \"ancestor\")})`).setParameters(parameters).execute();\n      /**\n       * Only insert new parent if it exits\n       *\n       * This only happens if the entity doesn't become a root entity\n       */\n      if (parent) {\n        // Insert logic\n        const queryParams = [];\n        const tableName = _this2.getTableName(closureTable.tablePath);\n        const superAlias = escape(\"supertree\");\n        const subAlias = escape(\"subtree\");\n        const select = [...ancestorColumnNames.map(columnName => `${superAlias}.${columnName}`), ...descendantColumnNames.map(columnName => `${subAlias}.${columnName}`)];\n        const entityWhereCondition = subject.metadata.closureJunctionTable.ancestorColumns.map(column => {\n          const columnName = escape(column.databaseName);\n          const entityId = column.referencedColumn.getEntityValue(entity);\n          queryParams.push(entityId);\n          const parameterName = _this2.queryRunner.connection.driver.createParameter(\"entity_\" + column.referencedColumn.databaseName, queryParams.length - 1);\n          return `${subAlias}.${columnName} = ${parameterName}`;\n        });\n        const parentWhereCondition = subject.metadata.closureJunctionTable.descendantColumns.map(column => {\n          const columnName = escape(column.databaseName);\n          const parentId = column.referencedColumn.getEntityValue(parent);\n          if (!parentId) throw new CannotAttachTreeChildrenEntityError(subject.metadata.name);\n          queryParams.push(parentId);\n          const parameterName = _this2.queryRunner.connection.driver.createParameter(\"parent_entity_\" + column.referencedColumn.databaseName, queryParams.length - 1);\n          return `${superAlias}.${columnName} = ${parameterName}`;\n        });\n        yield _this2.queryRunner.query(`INSERT INTO ${tableName} (${[...ancestorColumnNames, ...descendantColumnNames].join(\", \")}) ` + `SELECT ${select.join(\", \")} ` + `FROM ${tableName} AS ${superAlias}, ${tableName} AS ${subAlias} ` + `WHERE ${[...entityWhereCondition, ...parentWhereCondition].join(\" AND \")}`, queryParams);\n      }\n    })();\n  }\n  /**\n   * Executes operations when subject is being removed.\n   */\n  remove(subjects) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      // Only mssql need to execute deletes for the juntion table as it doesn't support multi cascade paths.\n      if (!(_this3.queryRunner.connection.driver.options.type === \"mssql\")) {\n        return;\n      }\n      if (!Array.isArray(subjects)) subjects = [subjects];\n      const escape = alias => _this3.queryRunner.connection.driver.escape(alias);\n      const identifiers = subjects.map(subject => subject.identifier);\n      const closureTable = subjects[0].metadata.closureJunctionTable;\n      const generateWheres = columns => {\n        return columns.map(column => {\n          const data = identifiers.map(identifier => identifier[column.referencedColumn.databaseName]);\n          return `${escape(column.databaseName)} IN (${data.join(\", \")})`;\n        }).join(\" AND \");\n      };\n      const ancestorWhere = generateWheres(closureTable.ancestorColumns);\n      const descendantWhere = generateWheres(closureTable.descendantColumns);\n      yield _this3.queryRunner.manager.createQueryBuilder().delete().from(closureTable.tablePath).where(ancestorWhere).orWhere(descendantWhere).execute();\n    })();\n  }\n  /**\n   * Gets escaped table name with schema name if SqlServer or Postgres driver used with custom\n   * schema name, otherwise returns escaped table name.\n   */\n  getTableName(tablePath) {\n    return tablePath.split(\".\").map(i => {\n      // this condition need because in SQL Server driver when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string\n      return i === \"\" ? i : this.queryRunner.connection.driver.escape(i);\n    }).join(\".\");\n  }\n}","map":{"version":3,"names":["CannotAttachTreeChildrenEntityError","OrmUtils","ClosureSubjectExecutor","constructor","queryRunner","insert","subject","_this","_asyncToGenerator","closureJunctionInsertMap","metadata","closureJunctionTable","ancestorColumns","forEach","column","databaseName","identifier","descendantColumns","manager","createQueryBuilder","into","tablePath","values","updateEntity","callListeners","execute","parent","treeParentRelation","getEntityValue","entity","parentSubject","insertedValueSet","escape","alias","connection","driver","tableName","getTableName","queryParams","ancestorColumnNames","map","descendantColumnNames","childEntityIds1","primaryColumns","push","createParameter","length","whereCondition","columnName","parentId","referencedColumn","name","parameterName","query","join","update","_this2","databaseEntity","treeChildrenRelation","find","child","Object","entries","every","key","value","undefined","oldParent","oldParentId","getEntityIdMap","compareIds","closureTable","createSubQuery","qb","subAlias","subSelect","select","from","andWhere","getQuery","setParameters","getParameters","parameters","delete","where","superAlias","entityWhereCondition","entityId","parentWhereCondition","remove","subjects","_this3","options","type","Array","isArray","identifiers","generateWheres","columns","data","ancestorWhere","descendantWhere","orWhere","split","i"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/persistence/tree/ClosureSubjectExecutor.js"],"sourcesContent":["import { CannotAttachTreeChildrenEntityError } from \"../../error/CannotAttachTreeChildrenEntityError\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\n/**\n * Executes subject operations for closure entities.\n */\nexport class ClosureSubjectExecutor {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n    constructor(queryRunner) {\n        this.queryRunner = queryRunner;\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Executes operations when subject is being inserted.\n     */\n    async insert(subject) {\n        // create values to be inserted into the closure junction\n        const closureJunctionInsertMap = {};\n        subject.metadata.closureJunctionTable.ancestorColumns.forEach((column) => {\n            closureJunctionInsertMap[column.databaseName] =\n                subject.identifier;\n        });\n        subject.metadata.closureJunctionTable.descendantColumns.forEach((column) => {\n            closureJunctionInsertMap[column.databaseName] =\n                subject.identifier;\n        });\n        // insert values into the closure junction table\n        await this.queryRunner.manager\n            .createQueryBuilder()\n            .insert()\n            .into(subject.metadata.closureJunctionTable.tablePath)\n            .values(closureJunctionInsertMap)\n            .updateEntity(false)\n            .callListeners(false)\n            .execute();\n        let parent = subject.metadata.treeParentRelation.getEntityValue(subject.entity); // if entity was attached via parent\n        if (!parent && subject.parentSubject && subject.parentSubject.entity)\n            // if entity was attached via children\n            parent = subject.parentSubject.insertedValueSet\n                ? subject.parentSubject.insertedValueSet\n                : subject.parentSubject.entity;\n        if (parent) {\n            const escape = (alias) => this.queryRunner.connection.driver.escape(alias);\n            const tableName = this.getTableName(subject.metadata.closureJunctionTable.tablePath);\n            const queryParams = [];\n            const ancestorColumnNames = subject.metadata.closureJunctionTable.ancestorColumns.map((column) => {\n                return escape(column.databaseName);\n            });\n            const descendantColumnNames = subject.metadata.closureJunctionTable.descendantColumns.map((column) => {\n                return escape(column.databaseName);\n            });\n            const childEntityIds1 = subject.metadata.primaryColumns.map((column) => {\n                queryParams.push(column.getEntityValue(subject.insertedValueSet\n                    ? subject.insertedValueSet\n                    : subject.entity));\n                return this.queryRunner.connection.driver.createParameter(\"child_entity_\" + column.databaseName, queryParams.length - 1);\n            });\n            const whereCondition = subject.metadata.closureJunctionTable.descendantColumns.map((column) => {\n                const columnName = escape(column.databaseName);\n                const parentId = column.referencedColumn.getEntityValue(parent);\n                if (!parentId)\n                    throw new CannotAttachTreeChildrenEntityError(subject.metadata.name);\n                queryParams.push(parentId);\n                const parameterName = this.queryRunner.connection.driver.createParameter(\"parent_entity_\" +\n                    column.referencedColumn.databaseName, queryParams.length - 1);\n                return `${columnName} = ${parameterName}`;\n            });\n            await this.queryRunner.query(`INSERT INTO ${tableName} (${[\n                ...ancestorColumnNames,\n                ...descendantColumnNames,\n            ].join(\", \")}) ` +\n                `SELECT ${ancestorColumnNames.join(\", \")}, ${childEntityIds1.join(\", \")} FROM ${tableName} WHERE ${whereCondition.join(\" AND \")}`, queryParams);\n        }\n    }\n    /**\n     * Executes operations when subject is being updated.\n     */\n    async update(subject) {\n        let parent = subject.metadata.treeParentRelation.getEntityValue(subject.entity); // if entity was attached via parent\n        if (!parent && subject.parentSubject && subject.parentSubject.entity)\n            // if entity was attached via children\n            parent = subject.parentSubject.entity;\n        let entity = subject.databaseEntity; // if entity was attached via parent\n        if (!entity && parent)\n            // if entity was attached via children\n            entity = subject.metadata\n                .treeChildrenRelation.getEntityValue(parent)\n                .find((child) => {\n                return Object.entries(subject.identifier).every(([key, value]) => child[key] === value);\n            });\n        // Exit if the parent or the entity where never set\n        if (entity === undefined || parent === undefined) {\n            return;\n        }\n        const oldParent = subject.metadata.treeParentRelation.getEntityValue(entity);\n        const oldParentId = subject.metadata.getEntityIdMap(oldParent);\n        const parentId = subject.metadata.getEntityIdMap(parent);\n        // Exit if the new and old parents are the same\n        if (OrmUtils.compareIds(oldParentId, parentId)) {\n            return;\n        }\n        const escape = (alias) => this.queryRunner.connection.driver.escape(alias);\n        const closureTable = subject.metadata.closureJunctionTable;\n        const ancestorColumnNames = closureTable.ancestorColumns.map((column) => {\n            return escape(column.databaseName);\n        });\n        const descendantColumnNames = closureTable.descendantColumns.map((column) => {\n            return escape(column.databaseName);\n        });\n        // Delete logic\n        const createSubQuery = (qb, alias) => {\n            const subAlias = `sub${alias}`;\n            const subSelect = qb\n                .createQueryBuilder()\n                .select(descendantColumnNames.join(\", \"))\n                .from(closureTable.tablePath, subAlias);\n            // Create where conditions e.g. (WHERE \"subdescendant\".\"id_ancestor\" = :value_id)\n            for (const column of closureTable.ancestorColumns) {\n                subSelect.andWhere(`${escape(subAlias)}.${escape(column.databaseName)} = :value_${column.referencedColumn.databaseName}`);\n            }\n            return qb\n                .createQueryBuilder()\n                .select(descendantColumnNames.join(\", \"))\n                .from(`(${subSelect.getQuery()})`, alias)\n                .setParameters(subSelect.getParameters())\n                .getQuery();\n        };\n        const parameters = {};\n        for (const column of subject.metadata.primaryColumns) {\n            parameters[`value_${column.databaseName}`] =\n                entity[column.databaseName];\n        }\n        await this.queryRunner.manager\n            .createQueryBuilder()\n            .delete()\n            .from(closureTable.tablePath)\n            .where((qb) => `(${descendantColumnNames.join(\", \")}) IN (${createSubQuery(qb, \"descendant\")})`)\n            .andWhere((qb) => `(${ancestorColumnNames.join(\", \")}) NOT IN (${createSubQuery(qb, \"ancestor\")})`)\n            .setParameters(parameters)\n            .execute();\n        /**\n         * Only insert new parent if it exits\n         *\n         * This only happens if the entity doesn't become a root entity\n         */\n        if (parent) {\n            // Insert logic\n            const queryParams = [];\n            const tableName = this.getTableName(closureTable.tablePath);\n            const superAlias = escape(\"supertree\");\n            const subAlias = escape(\"subtree\");\n            const select = [\n                ...ancestorColumnNames.map((columnName) => `${superAlias}.${columnName}`),\n                ...descendantColumnNames.map((columnName) => `${subAlias}.${columnName}`),\n            ];\n            const entityWhereCondition = subject.metadata.closureJunctionTable.ancestorColumns.map((column) => {\n                const columnName = escape(column.databaseName);\n                const entityId = column.referencedColumn.getEntityValue(entity);\n                queryParams.push(entityId);\n                const parameterName = this.queryRunner.connection.driver.createParameter(\"entity_\" +\n                    column.referencedColumn.databaseName, queryParams.length - 1);\n                return `${subAlias}.${columnName} = ${parameterName}`;\n            });\n            const parentWhereCondition = subject.metadata.closureJunctionTable.descendantColumns.map((column) => {\n                const columnName = escape(column.databaseName);\n                const parentId = column.referencedColumn.getEntityValue(parent);\n                if (!parentId)\n                    throw new CannotAttachTreeChildrenEntityError(subject.metadata.name);\n                queryParams.push(parentId);\n                const parameterName = this.queryRunner.connection.driver.createParameter(\"parent_entity_\" +\n                    column.referencedColumn.databaseName, queryParams.length - 1);\n                return `${superAlias}.${columnName} = ${parameterName}`;\n            });\n            await this.queryRunner.query(`INSERT INTO ${tableName} (${[\n                ...ancestorColumnNames,\n                ...descendantColumnNames,\n            ].join(\", \")}) ` +\n                `SELECT ${select.join(\", \")} ` +\n                `FROM ${tableName} AS ${superAlias}, ${tableName} AS ${subAlias} ` +\n                `WHERE ${[\n                    ...entityWhereCondition,\n                    ...parentWhereCondition,\n                ].join(\" AND \")}`, queryParams);\n        }\n    }\n    /**\n     * Executes operations when subject is being removed.\n     */\n    async remove(subjects) {\n        // Only mssql need to execute deletes for the juntion table as it doesn't support multi cascade paths.\n        if (!(this.queryRunner.connection.driver.options.type === \"mssql\")) {\n            return;\n        }\n        if (!Array.isArray(subjects))\n            subjects = [subjects];\n        const escape = (alias) => this.queryRunner.connection.driver.escape(alias);\n        const identifiers = subjects.map((subject) => subject.identifier);\n        const closureTable = subjects[0].metadata.closureJunctionTable;\n        const generateWheres = (columns) => {\n            return columns\n                .map((column) => {\n                const data = identifiers.map((identifier) => identifier[column.referencedColumn.databaseName]);\n                return `${escape(column.databaseName)} IN (${data.join(\", \")})`;\n            })\n                .join(\" AND \");\n        };\n        const ancestorWhere = generateWheres(closureTable.ancestorColumns);\n        const descendantWhere = generateWheres(closureTable.descendantColumns);\n        await this.queryRunner.manager\n            .createQueryBuilder()\n            .delete()\n            .from(closureTable.tablePath)\n            .where(ancestorWhere)\n            .orWhere(descendantWhere)\n            .execute();\n    }\n    /**\n     * Gets escaped table name with schema name if SqlServer or Postgres driver used with custom\n     * schema name, otherwise returns escaped table name.\n     */\n    getTableName(tablePath) {\n        return tablePath\n            .split(\".\")\n            .map((i) => {\n            // this condition need because in SQL Server driver when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string\n            return i === \"\"\n                ? i\n                : this.queryRunner.connection.driver.escape(i);\n        })\n            .join(\".\");\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}