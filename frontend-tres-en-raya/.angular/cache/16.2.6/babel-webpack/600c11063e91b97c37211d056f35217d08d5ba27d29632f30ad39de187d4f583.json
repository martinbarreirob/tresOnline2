{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/practicas/Downloads/angular/tresOnline/frontend-tres-en-raya/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { TypeORMError } from \"../error\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\n/**\n * Allows to work with entity relations and perform specific operations with those relations.\n *\n * todo: add transactions everywhere\n */\nexport class RelationUpdater {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(queryBuilder, expressionMap) {\n    this.queryBuilder = queryBuilder;\n    this.expressionMap = expressionMap;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Performs set or add operation on a relation.\n   */\n  update(value) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const relation = _this.expressionMap.relationMetadata;\n      if (relation.isManyToOne || relation.isOneToOneOwner) {\n        const updateSet = relation.joinColumns.reduce((updateSet, joinColumn) => {\n          const relationValue = ObjectUtils.isObject(value) ? joinColumn.referencedColumn.getEntityValue(value) : value;\n          joinColumn.setEntityValue(updateSet, relationValue);\n          return updateSet;\n        }, {});\n        if (!_this.expressionMap.of || Array.isArray(_this.expressionMap.of) && !_this.expressionMap.of.length) return;\n        yield _this.queryBuilder.createQueryBuilder().update(relation.entityMetadata.target).set(updateSet).whereInIds(_this.expressionMap.of).execute();\n      } else if ((relation.isOneToOneNotOwner || relation.isOneToMany) && value === null) {\n        // we handle null a bit different way\n        const updateSet = {};\n        relation.inverseRelation.joinColumns.forEach(column => {\n          updateSet[column.propertyName] = null;\n        });\n        const ofs = Array.isArray(_this.expressionMap.of) ? _this.expressionMap.of : [_this.expressionMap.of];\n        const parameters = {};\n        const conditions = [];\n        ofs.forEach((of, ofIndex) => {\n          relation.inverseRelation.joinColumns.map((column, columnIndex) => {\n            const parameterName = \"joinColumn_\" + ofIndex + \"_\" + columnIndex;\n            parameters[parameterName] = ObjectUtils.isObject(of) ? column.referencedColumn.getEntityValue(of) : of;\n            conditions.push(`${column.propertyPath} = :${parameterName}`);\n          });\n        });\n        const condition = conditions.map(str => \"(\" + str + \")\").join(\" OR \");\n        if (!condition) return;\n        yield _this.queryBuilder.createQueryBuilder().update(relation.inverseEntityMetadata.target).set(updateSet).where(condition).setParameters(parameters).execute();\n      } else if (relation.isOneToOneNotOwner || relation.isOneToMany) {\n        if (Array.isArray(_this.expressionMap.of)) throw new TypeORMError(`You cannot update relations of multiple entities with the same related object. Provide a single entity into .of method.`);\n        const of = _this.expressionMap.of;\n        const updateSet = relation.inverseRelation.joinColumns.reduce((updateSet, joinColumn) => {\n          const relationValue = ObjectUtils.isObject(of) ? joinColumn.referencedColumn.getEntityValue(of) : of;\n          joinColumn.setEntityValue(updateSet, relationValue);\n          return updateSet;\n        }, {});\n        if (!value || Array.isArray(value) && !value.length) return;\n        yield _this.queryBuilder.createQueryBuilder().update(relation.inverseEntityMetadata.target).set(updateSet).whereInIds(value).execute();\n      } else {\n        // many to many\n        const junctionMetadata = relation.junctionEntityMetadata;\n        const ofs = Array.isArray(_this.expressionMap.of) ? _this.expressionMap.of : [_this.expressionMap.of];\n        const values = Array.isArray(value) ? value : [value];\n        const firstColumnValues = relation.isManyToManyOwner ? ofs : values;\n        const secondColumnValues = relation.isManyToManyOwner ? values : ofs;\n        const bulkInserted = [];\n        firstColumnValues.forEach(firstColumnVal => {\n          secondColumnValues.forEach(secondColumnVal => {\n            const inserted = {};\n            junctionMetadata.ownerColumns.forEach(column => {\n              inserted[column.databaseName] = ObjectUtils.isObject(firstColumnVal) ? column.referencedColumn.getEntityValue(firstColumnVal) : firstColumnVal;\n            });\n            junctionMetadata.inverseColumns.forEach(column => {\n              inserted[column.databaseName] = ObjectUtils.isObject(secondColumnVal) ? column.referencedColumn.getEntityValue(secondColumnVal) : secondColumnVal;\n            });\n            bulkInserted.push(inserted);\n          });\n        });\n        if (!bulkInserted.length) return;\n        if (_this.queryBuilder.connection.driver.options.type === \"oracle\" || _this.queryBuilder.connection.driver.options.type === \"sap\") {\n          yield Promise.all(bulkInserted.map(value => {\n            return _this.queryBuilder.createQueryBuilder().insert().into(junctionMetadata.tableName).values(value).execute();\n          }));\n        } else {\n          yield _this.queryBuilder.createQueryBuilder().insert().into(junctionMetadata.tableName).values(bulkInserted).execute();\n        }\n      }\n    })();\n  }\n}","map":{"version":3,"names":["TypeORMError","ObjectUtils","RelationUpdater","constructor","queryBuilder","expressionMap","update","value","_this","_asyncToGenerator","relation","relationMetadata","isManyToOne","isOneToOneOwner","updateSet","joinColumns","reduce","joinColumn","relationValue","isObject","referencedColumn","getEntityValue","setEntityValue","of","Array","isArray","length","createQueryBuilder","entityMetadata","target","set","whereInIds","execute","isOneToOneNotOwner","isOneToMany","inverseRelation","forEach","column","propertyName","ofs","parameters","conditions","ofIndex","map","columnIndex","parameterName","push","propertyPath","condition","str","join","inverseEntityMetadata","where","setParameters","junctionMetadata","junctionEntityMetadata","values","firstColumnValues","isManyToManyOwner","secondColumnValues","bulkInserted","firstColumnVal","secondColumnVal","inserted","ownerColumns","databaseName","inverseColumns","connection","driver","options","type","Promise","all","insert","into","tableName"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/query-builder/RelationUpdater.js"],"sourcesContent":["import { TypeORMError } from \"../error\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\n/**\n * Allows to work with entity relations and perform specific operations with those relations.\n *\n * todo: add transactions everywhere\n */\nexport class RelationUpdater {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n    constructor(queryBuilder, expressionMap) {\n        this.queryBuilder = queryBuilder;\n        this.expressionMap = expressionMap;\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Performs set or add operation on a relation.\n     */\n    async update(value) {\n        const relation = this.expressionMap.relationMetadata;\n        if (relation.isManyToOne || relation.isOneToOneOwner) {\n            const updateSet = relation.joinColumns.reduce((updateSet, joinColumn) => {\n                const relationValue = ObjectUtils.isObject(value)\n                    ? joinColumn.referencedColumn.getEntityValue(value)\n                    : value;\n                joinColumn.setEntityValue(updateSet, relationValue);\n                return updateSet;\n            }, {});\n            if (!this.expressionMap.of ||\n                (Array.isArray(this.expressionMap.of) &&\n                    !this.expressionMap.of.length))\n                return;\n            await this.queryBuilder\n                .createQueryBuilder()\n                .update(relation.entityMetadata.target)\n                .set(updateSet)\n                .whereInIds(this.expressionMap.of)\n                .execute();\n        }\n        else if ((relation.isOneToOneNotOwner || relation.isOneToMany) &&\n            value === null) {\n            // we handle null a bit different way\n            const updateSet = {};\n            relation.inverseRelation.joinColumns.forEach((column) => {\n                updateSet[column.propertyName] = null;\n            });\n            const ofs = Array.isArray(this.expressionMap.of)\n                ? this.expressionMap.of\n                : [this.expressionMap.of];\n            const parameters = {};\n            const conditions = [];\n            ofs.forEach((of, ofIndex) => {\n                relation.inverseRelation.joinColumns.map((column, columnIndex) => {\n                    const parameterName = \"joinColumn_\" + ofIndex + \"_\" + columnIndex;\n                    parameters[parameterName] = ObjectUtils.isObject(of)\n                        ? column.referencedColumn.getEntityValue(of)\n                        : of;\n                    conditions.push(`${column.propertyPath} = :${parameterName}`);\n                });\n            });\n            const condition = conditions\n                .map((str) => \"(\" + str + \")\")\n                .join(\" OR \");\n            if (!condition)\n                return;\n            await this.queryBuilder\n                .createQueryBuilder()\n                .update(relation.inverseEntityMetadata.target)\n                .set(updateSet)\n                .where(condition)\n                .setParameters(parameters)\n                .execute();\n        }\n        else if (relation.isOneToOneNotOwner || relation.isOneToMany) {\n            if (Array.isArray(this.expressionMap.of))\n                throw new TypeORMError(`You cannot update relations of multiple entities with the same related object. Provide a single entity into .of method.`);\n            const of = this.expressionMap.of;\n            const updateSet = relation.inverseRelation.joinColumns.reduce((updateSet, joinColumn) => {\n                const relationValue = ObjectUtils.isObject(of)\n                    ? joinColumn.referencedColumn.getEntityValue(of)\n                    : of;\n                joinColumn.setEntityValue(updateSet, relationValue);\n                return updateSet;\n            }, {});\n            if (!value || (Array.isArray(value) && !value.length))\n                return;\n            await this.queryBuilder\n                .createQueryBuilder()\n                .update(relation.inverseEntityMetadata.target)\n                .set(updateSet)\n                .whereInIds(value)\n                .execute();\n        }\n        else {\n            // many to many\n            const junctionMetadata = relation.junctionEntityMetadata;\n            const ofs = Array.isArray(this.expressionMap.of)\n                ? this.expressionMap.of\n                : [this.expressionMap.of];\n            const values = Array.isArray(value) ? value : [value];\n            const firstColumnValues = relation.isManyToManyOwner ? ofs : values;\n            const secondColumnValues = relation.isManyToManyOwner ? values : ofs;\n            const bulkInserted = [];\n            firstColumnValues.forEach((firstColumnVal) => {\n                secondColumnValues.forEach((secondColumnVal) => {\n                    const inserted = {};\n                    junctionMetadata.ownerColumns.forEach((column) => {\n                        inserted[column.databaseName] = ObjectUtils.isObject(firstColumnVal)\n                            ? column.referencedColumn.getEntityValue(firstColumnVal)\n                            : firstColumnVal;\n                    });\n                    junctionMetadata.inverseColumns.forEach((column) => {\n                        inserted[column.databaseName] = ObjectUtils.isObject(secondColumnVal)\n                            ? column.referencedColumn.getEntityValue(secondColumnVal)\n                            : secondColumnVal;\n                    });\n                    bulkInserted.push(inserted);\n                });\n            });\n            if (!bulkInserted.length)\n                return;\n            if (this.queryBuilder.connection.driver.options.type === \"oracle\" ||\n                this.queryBuilder.connection.driver.options.type === \"sap\") {\n                await Promise.all(bulkInserted.map((value) => {\n                    return this.queryBuilder\n                        .createQueryBuilder()\n                        .insert()\n                        .into(junctionMetadata.tableName)\n                        .values(value)\n                        .execute();\n                }));\n            }\n            else {\n                await this.queryBuilder\n                    .createQueryBuilder()\n                    .insert()\n                    .into(junctionMetadata.tableName)\n                    .values(bulkInserted)\n                    .execute();\n            }\n        }\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}