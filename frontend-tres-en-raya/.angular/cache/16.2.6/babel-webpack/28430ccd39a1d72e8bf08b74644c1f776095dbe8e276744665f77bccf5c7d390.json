{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/practicas/Downloads/angular/tresOnline/frontend-tres-en-raya/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nexport class RelationCountLoader {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection, queryRunner, relationCountAttributes) {\n    this.connection = connection;\n    this.queryRunner = queryRunner;\n    this.relationCountAttributes = relationCountAttributes;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  load(rawEntities) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const onlyUnique = (value, index, self) => {\n        return self.indexOf(value) === index;\n      };\n      const promises = _this.relationCountAttributes.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (relationCountAttr) {\n          if (relationCountAttr.relation.isOneToMany) {\n            // example: Post and Category\n            // loadRelationCountAndMap(\"post.categoryCount\", \"post.categories\")\n            // we expect it to load array of post ids\n            // todo(dima): fix issues wit multiple primary keys and remove joinColumns[0]\n            const relation = relationCountAttr.relation; // \"category.posts\"\n            const inverseRelation = relation.inverseRelation; // \"post.category\"\n            const referenceColumnName = inverseRelation.joinColumns[0].referencedColumn.propertyName; // post id\n            const inverseSideTable = relation.inverseEntityMetadata.target; // Post\n            const inverseSideTableName = relation.inverseEntityMetadata.tableName; // post\n            const inverseSideTableAlias = relationCountAttr.alias || inverseSideTableName; // if condition (custom query builder factory) is set then relationIdAttr.alias defined\n            const inverseSidePropertyName = inverseRelation.propertyName; // \"category\" from \"post.category\"\n            let referenceColumnValues = rawEntities.map(rawEntity => rawEntity[relationCountAttr.parentAlias + \"_\" + referenceColumnName]).filter(value => !!value);\n            referenceColumnValues = referenceColumnValues.filter(onlyUnique);\n            // ensure we won't perform redundant queries for joined data which was not found in selection\n            // example: if post.category was not found in db then no need to execute query for category.imageIds\n            if (referenceColumnValues.length === 0) return {\n              relationCountAttribute: relationCountAttr,\n              results: []\n            };\n            // generate query:\n            // SELECT category.post as parentId, COUNT(*) AS cnt FROM category category WHERE category.post IN (1, 2) GROUP BY category.post\n            const qb = _this.connection.createQueryBuilder(_this.queryRunner);\n            qb.select(inverseSideTableAlias + \".\" + inverseSidePropertyName, \"parentId\").addSelect(\"COUNT(*)\", \"cnt\").from(inverseSideTable, inverseSideTableAlias).where(inverseSideTableAlias + \".\" + inverseSidePropertyName + \" IN (:...ids)\").addGroupBy(inverseSideTableAlias + \".\" + inverseSidePropertyName).setParameter(\"ids\", referenceColumnValues);\n            // apply condition (custom query builder factory)\n            if (relationCountAttr.queryBuilderFactory) relationCountAttr.queryBuilderFactory(qb);\n            return {\n              relationCountAttribute: relationCountAttr,\n              results: yield qb.getRawMany()\n            };\n          } else {\n            // example: Post and Category\n            // owner side: loadRelationIdAndMap(\"post.categoryIds\", \"post.categories\")\n            // inverse side: loadRelationIdAndMap(\"category.postIds\", \"category.posts\")\n            // we expect it to load array of post ids\n            let joinTableColumnName;\n            let inverseJoinColumnName;\n            let firstJunctionColumn;\n            let secondJunctionColumn;\n            if (relationCountAttr.relation.isOwning) {\n              // todo fix joinColumns[0] and inverseJoinColumns[0].\n              joinTableColumnName = relationCountAttr.relation.joinColumns[0].referencedColumn.databaseName;\n              inverseJoinColumnName = relationCountAttr.relation.inverseJoinColumns[0].referencedColumn.databaseName;\n              firstJunctionColumn = relationCountAttr.relation.junctionEntityMetadata.columns[0];\n              secondJunctionColumn = relationCountAttr.relation.junctionEntityMetadata.columns[1];\n            } else {\n              joinTableColumnName = relationCountAttr.relation.inverseRelation.inverseJoinColumns[0].referencedColumn.databaseName;\n              inverseJoinColumnName = relationCountAttr.relation.inverseRelation.joinColumns[0].referencedColumn.databaseName;\n              firstJunctionColumn = relationCountAttr.relation.junctionEntityMetadata.columns[1];\n              secondJunctionColumn = relationCountAttr.relation.junctionEntityMetadata.columns[0];\n            }\n            let referenceColumnValues = rawEntities.map(rawEntity => rawEntity[relationCountAttr.parentAlias + \"_\" + joinTableColumnName]).filter(value => !!value);\n            referenceColumnValues = referenceColumnValues.filter(onlyUnique);\n            // ensure we won't perform redundant queries for joined data which was not found in selection\n            // example: if post.category was not found in db then no need to execute query for category.imageIds\n            if (referenceColumnValues.length === 0) return {\n              relationCountAttribute: relationCountAttr,\n              results: []\n            };\n            const junctionAlias = relationCountAttr.junctionAlias;\n            const inverseSideTableName = relationCountAttr.joinInverseSideMetadata.tableName;\n            const inverseSideTableAlias = relationCountAttr.alias || inverseSideTableName;\n            const junctionTableName = relationCountAttr.relation.junctionEntityMetadata.tableName;\n            const condition = junctionAlias + \".\" + firstJunctionColumn.propertyName + \" IN (\" + referenceColumnValues.map(vals => isNaN(vals) ? \"'\" + vals + \"'\" : vals) + \")\" + \" AND \" + junctionAlias + \".\" + secondJunctionColumn.propertyName + \" = \" + inverseSideTableAlias + \".\" + inverseJoinColumnName;\n            const qb = _this.connection.createQueryBuilder(_this.queryRunner);\n            qb.select(junctionAlias + \".\" + firstJunctionColumn.propertyName, \"parentId\").addSelect(\"COUNT(\" + qb.escape(inverseSideTableAlias) + \".\" + qb.escape(inverseJoinColumnName) + \")\", \"cnt\").from(inverseSideTableName, inverseSideTableAlias).innerJoin(junctionTableName, junctionAlias, condition).addGroupBy(junctionAlias + \".\" + firstJunctionColumn.propertyName);\n            // apply condition (custom query builder factory)\n            if (relationCountAttr.queryBuilderFactory) relationCountAttr.queryBuilderFactory(qb);\n            return {\n              relationCountAttribute: relationCountAttr,\n              results: yield qb.getRawMany()\n            };\n          }\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n      return Promise.all(promises);\n    })();\n  }\n}","map":{"version":3,"names":["RelationCountLoader","constructor","connection","queryRunner","relationCountAttributes","load","rawEntities","_this","_asyncToGenerator","onlyUnique","value","index","self","indexOf","promises","map","_ref","relationCountAttr","relation","isOneToMany","inverseRelation","referenceColumnName","joinColumns","referencedColumn","propertyName","inverseSideTable","inverseEntityMetadata","target","inverseSideTableName","tableName","inverseSideTableAlias","alias","inverseSidePropertyName","referenceColumnValues","rawEntity","parentAlias","filter","length","relationCountAttribute","results","qb","createQueryBuilder","select","addSelect","from","where","addGroupBy","setParameter","queryBuilderFactory","getRawMany","joinTableColumnName","inverseJoinColumnName","firstJunctionColumn","secondJunctionColumn","isOwning","databaseName","inverseJoinColumns","junctionEntityMetadata","columns","junctionAlias","joinInverseSideMetadata","junctionTableName","condition","vals","isNaN","escape","innerJoin","_x","apply","arguments","Promise","all"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/query-builder/relation-count/RelationCountLoader.js"],"sourcesContent":["export class RelationCountLoader {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n    constructor(connection, queryRunner, relationCountAttributes) {\n        this.connection = connection;\n        this.queryRunner = queryRunner;\n        this.relationCountAttributes = relationCountAttributes;\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    async load(rawEntities) {\n        const onlyUnique = (value, index, self) => {\n            return self.indexOf(value) === index;\n        };\n        const promises = this.relationCountAttributes.map(async (relationCountAttr) => {\n            if (relationCountAttr.relation.isOneToMany) {\n                // example: Post and Category\n                // loadRelationCountAndMap(\"post.categoryCount\", \"post.categories\")\n                // we expect it to load array of post ids\n                // todo(dima): fix issues wit multiple primary keys and remove joinColumns[0]\n                const relation = relationCountAttr.relation; // \"category.posts\"\n                const inverseRelation = relation.inverseRelation; // \"post.category\"\n                const referenceColumnName = inverseRelation.joinColumns[0].referencedColumn\n                    .propertyName; // post id\n                const inverseSideTable = relation.inverseEntityMetadata.target; // Post\n                const inverseSideTableName = relation.inverseEntityMetadata.tableName; // post\n                const inverseSideTableAlias = relationCountAttr.alias || inverseSideTableName; // if condition (custom query builder factory) is set then relationIdAttr.alias defined\n                const inverseSidePropertyName = inverseRelation.propertyName; // \"category\" from \"post.category\"\n                let referenceColumnValues = rawEntities\n                    .map((rawEntity) => rawEntity[relationCountAttr.parentAlias +\n                    \"_\" +\n                    referenceColumnName])\n                    .filter((value) => !!value);\n                referenceColumnValues =\n                    referenceColumnValues.filter(onlyUnique);\n                // ensure we won't perform redundant queries for joined data which was not found in selection\n                // example: if post.category was not found in db then no need to execute query for category.imageIds\n                if (referenceColumnValues.length === 0)\n                    return {\n                        relationCountAttribute: relationCountAttr,\n                        results: [],\n                    };\n                // generate query:\n                // SELECT category.post as parentId, COUNT(*) AS cnt FROM category category WHERE category.post IN (1, 2) GROUP BY category.post\n                const qb = this.connection.createQueryBuilder(this.queryRunner);\n                qb.select(inverseSideTableAlias + \".\" + inverseSidePropertyName, \"parentId\")\n                    .addSelect(\"COUNT(*)\", \"cnt\")\n                    .from(inverseSideTable, inverseSideTableAlias)\n                    .where(inverseSideTableAlias +\n                    \".\" +\n                    inverseSidePropertyName +\n                    \" IN (:...ids)\")\n                    .addGroupBy(inverseSideTableAlias +\n                    \".\" +\n                    inverseSidePropertyName)\n                    .setParameter(\"ids\", referenceColumnValues);\n                // apply condition (custom query builder factory)\n                if (relationCountAttr.queryBuilderFactory)\n                    relationCountAttr.queryBuilderFactory(qb);\n                return {\n                    relationCountAttribute: relationCountAttr,\n                    results: await qb.getRawMany(),\n                };\n            }\n            else {\n                // example: Post and Category\n                // owner side: loadRelationIdAndMap(\"post.categoryIds\", \"post.categories\")\n                // inverse side: loadRelationIdAndMap(\"category.postIds\", \"category.posts\")\n                // we expect it to load array of post ids\n                let joinTableColumnName;\n                let inverseJoinColumnName;\n                let firstJunctionColumn;\n                let secondJunctionColumn;\n                if (relationCountAttr.relation.isOwning) {\n                    // todo fix joinColumns[0] and inverseJoinColumns[0].\n                    joinTableColumnName =\n                        relationCountAttr.relation.joinColumns[0]\n                            .referencedColumn.databaseName;\n                    inverseJoinColumnName =\n                        relationCountAttr.relation.inverseJoinColumns[0]\n                            .referencedColumn.databaseName;\n                    firstJunctionColumn =\n                        relationCountAttr.relation.junctionEntityMetadata\n                            .columns[0];\n                    secondJunctionColumn =\n                        relationCountAttr.relation.junctionEntityMetadata\n                            .columns[1];\n                }\n                else {\n                    joinTableColumnName =\n                        relationCountAttr.relation.inverseRelation\n                            .inverseJoinColumns[0].referencedColumn\n                            .databaseName;\n                    inverseJoinColumnName =\n                        relationCountAttr.relation.inverseRelation\n                            .joinColumns[0].referencedColumn.databaseName;\n                    firstJunctionColumn =\n                        relationCountAttr.relation.junctionEntityMetadata\n                            .columns[1];\n                    secondJunctionColumn =\n                        relationCountAttr.relation.junctionEntityMetadata\n                            .columns[0];\n                }\n                let referenceColumnValues = rawEntities\n                    .map((rawEntity) => rawEntity[relationCountAttr.parentAlias +\n                    \"_\" +\n                    joinTableColumnName])\n                    .filter((value) => !!value);\n                referenceColumnValues =\n                    referenceColumnValues.filter(onlyUnique);\n                // ensure we won't perform redundant queries for joined data which was not found in selection\n                // example: if post.category was not found in db then no need to execute query for category.imageIds\n                if (referenceColumnValues.length === 0)\n                    return {\n                        relationCountAttribute: relationCountAttr,\n                        results: [],\n                    };\n                const junctionAlias = relationCountAttr.junctionAlias;\n                const inverseSideTableName = relationCountAttr.joinInverseSideMetadata.tableName;\n                const inverseSideTableAlias = relationCountAttr.alias || inverseSideTableName;\n                const junctionTableName = relationCountAttr.relation.junctionEntityMetadata\n                    .tableName;\n                const condition = junctionAlias +\n                    \".\" +\n                    firstJunctionColumn.propertyName +\n                    \" IN (\" +\n                    referenceColumnValues.map((vals) => isNaN(vals) ? \"'\" + vals + \"'\" : vals) +\n                    \")\" +\n                    \" AND \" +\n                    junctionAlias +\n                    \".\" +\n                    secondJunctionColumn.propertyName +\n                    \" = \" +\n                    inverseSideTableAlias +\n                    \".\" +\n                    inverseJoinColumnName;\n                const qb = this.connection.createQueryBuilder(this.queryRunner);\n                qb.select(junctionAlias + \".\" + firstJunctionColumn.propertyName, \"parentId\")\n                    .addSelect(\"COUNT(\" +\n                    qb.escape(inverseSideTableAlias) +\n                    \".\" +\n                    qb.escape(inverseJoinColumnName) +\n                    \")\", \"cnt\")\n                    .from(inverseSideTableName, inverseSideTableAlias)\n                    .innerJoin(junctionTableName, junctionAlias, condition)\n                    .addGroupBy(junctionAlias +\n                    \".\" +\n                    firstJunctionColumn.propertyName);\n                // apply condition (custom query builder factory)\n                if (relationCountAttr.queryBuilderFactory)\n                    relationCountAttr.queryBuilderFactory(qb);\n                return {\n                    relationCountAttribute: relationCountAttr,\n                    results: await qb.getRawMany(),\n                };\n            }\n        });\n        return Promise.all(promises);\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}