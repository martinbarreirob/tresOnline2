{"ast":null,"code":"import { Subject } from \"../Subject\";\nimport { ObjectUtils } from \"../../util/ObjectUtils\";\n/**\n * Finds all cascade operations of the given subject and cascade operations of the found cascaded subjects,\n * e.g. builds a cascade tree and creates a subjects for them.\n */\nexport class CascadesSubjectBuilder {\n  // ---------------------------------------------------------------------\n  // Constructor\n  // ---------------------------------------------------------------------\n  constructor(allSubjects) {\n    this.allSubjects = allSubjects;\n  }\n  // ---------------------------------------------------------------------\n  // Public Methods\n  // ---------------------------------------------------------------------\n  /**\n   * Builds a cascade subjects tree and pushes them in into the given array of subjects.\n   */\n  build(subject, operationType) {\n    subject.metadata.extractRelationValuesFromEntity(subject.entity, subject.metadata.relations) // todo: we can create EntityMetadata.cascadeRelations\n    .forEach(([relation, relationEntity, relationEntityMetadata]) => {\n      // we need only defined values and insert, update, soft-remove or recover cascades of the relation should be set\n      if (relationEntity === undefined || relationEntity === null || !relation.isCascadeInsert && !relation.isCascadeUpdate && !relation.isCascadeSoftRemove && !relation.isCascadeRecover) return;\n      // if relation entity is just a relation id set (for example post.tag = 1)\n      // then we don't really need to check cascades since there is no object to insert or update\n      if (!ObjectUtils.isObject(relationEntity)) return;\n      // if we already has this entity in list of operated subjects then skip it to avoid recursion\n      const alreadyExistRelationEntitySubject = this.findByPersistEntityLike(relationEntityMetadata.target, relationEntity);\n      if (alreadyExistRelationEntitySubject) {\n        if (alreadyExistRelationEntitySubject.canBeInserted === false)\n          // if its not marked for insertion yet\n          alreadyExistRelationEntitySubject.canBeInserted = relation.isCascadeInsert === true && operationType === \"save\";\n        if (alreadyExistRelationEntitySubject.canBeUpdated === false)\n          // if its not marked for update yet\n          alreadyExistRelationEntitySubject.canBeUpdated = relation.isCascadeUpdate === true && operationType === \"save\";\n        if (alreadyExistRelationEntitySubject.canBeSoftRemoved === false)\n          // if its not marked for removal yet\n          alreadyExistRelationEntitySubject.canBeSoftRemoved = relation.isCascadeSoftRemove === true && operationType === \"soft-remove\";\n        if (alreadyExistRelationEntitySubject.canBeRecovered === false)\n          // if its not marked for recovery yet\n          alreadyExistRelationEntitySubject.canBeRecovered = relation.isCascadeRecover === true && operationType === \"recover\";\n        return;\n      }\n      // mark subject with what we can do with it\n      // and add to the array of subjects to load only if there is no same entity there already\n      const relationEntitySubject = new Subject({\n        metadata: relationEntityMetadata,\n        parentSubject: subject,\n        entity: relationEntity,\n        canBeInserted: relation.isCascadeInsert === true && operationType === \"save\",\n        canBeUpdated: relation.isCascadeUpdate === true && operationType === \"save\",\n        canBeSoftRemoved: relation.isCascadeSoftRemove === true && operationType === \"soft-remove\",\n        canBeRecovered: relation.isCascadeRecover === true && operationType === \"recover\"\n      });\n      this.allSubjects.push(relationEntitySubject);\n      // go recursively and find other entities we need to insert/update\n      this.build(relationEntitySubject, operationType);\n    });\n  }\n  // ---------------------------------------------------------------------\n  // Protected Methods\n  // ---------------------------------------------------------------------\n  /**\n   * Finds subject where entity like given subject's entity.\n   * Comparison made by entity id.\n   */\n  findByPersistEntityLike(entityTarget, entity) {\n    return this.allSubjects.find(subject => {\n      if (!subject.entity) return false;\n      if (subject.entity === entity) return true;\n      return subject.metadata.target === entityTarget && subject.metadata.compareEntities(subject.entityWithFulfilledIds, entity);\n    });\n  }\n}","map":{"version":3,"names":["Subject","ObjectUtils","CascadesSubjectBuilder","constructor","allSubjects","build","subject","operationType","metadata","extractRelationValuesFromEntity","entity","relations","forEach","relation","relationEntity","relationEntityMetadata","undefined","isCascadeInsert","isCascadeUpdate","isCascadeSoftRemove","isCascadeRecover","isObject","alreadyExistRelationEntitySubject","findByPersistEntityLike","target","canBeInserted","canBeUpdated","canBeSoftRemoved","canBeRecovered","relationEntitySubject","parentSubject","push","entityTarget","find","compareEntities","entityWithFulfilledIds"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/persistence/subject-builder/CascadesSubjectBuilder.js"],"sourcesContent":["import { Subject } from \"../Subject\";\nimport { ObjectUtils } from \"../../util/ObjectUtils\";\n/**\n * Finds all cascade operations of the given subject and cascade operations of the found cascaded subjects,\n * e.g. builds a cascade tree and creates a subjects for them.\n */\nexport class CascadesSubjectBuilder {\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n    constructor(allSubjects) {\n        this.allSubjects = allSubjects;\n    }\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n    /**\n     * Builds a cascade subjects tree and pushes them in into the given array of subjects.\n     */\n    build(subject, operationType) {\n        subject.metadata\n            .extractRelationValuesFromEntity(subject.entity, subject.metadata.relations) // todo: we can create EntityMetadata.cascadeRelations\n            .forEach(([relation, relationEntity, relationEntityMetadata]) => {\n            // we need only defined values and insert, update, soft-remove or recover cascades of the relation should be set\n            if (relationEntity === undefined ||\n                relationEntity === null ||\n                (!relation.isCascadeInsert &&\n                    !relation.isCascadeUpdate &&\n                    !relation.isCascadeSoftRemove &&\n                    !relation.isCascadeRecover))\n                return;\n            // if relation entity is just a relation id set (for example post.tag = 1)\n            // then we don't really need to check cascades since there is no object to insert or update\n            if (!ObjectUtils.isObject(relationEntity))\n                return;\n            // if we already has this entity in list of operated subjects then skip it to avoid recursion\n            const alreadyExistRelationEntitySubject = this.findByPersistEntityLike(relationEntityMetadata.target, relationEntity);\n            if (alreadyExistRelationEntitySubject) {\n                if (alreadyExistRelationEntitySubject.canBeInserted ===\n                    false)\n                    // if its not marked for insertion yet\n                    alreadyExistRelationEntitySubject.canBeInserted =\n                        relation.isCascadeInsert === true &&\n                            operationType === \"save\";\n                if (alreadyExistRelationEntitySubject.canBeUpdated === false)\n                    // if its not marked for update yet\n                    alreadyExistRelationEntitySubject.canBeUpdated =\n                        relation.isCascadeUpdate === true &&\n                            operationType === \"save\";\n                if (alreadyExistRelationEntitySubject.canBeSoftRemoved ===\n                    false)\n                    // if its not marked for removal yet\n                    alreadyExistRelationEntitySubject.canBeSoftRemoved =\n                        relation.isCascadeSoftRemove === true &&\n                            operationType === \"soft-remove\";\n                if (alreadyExistRelationEntitySubject.canBeRecovered ===\n                    false)\n                    // if its not marked for recovery yet\n                    alreadyExistRelationEntitySubject.canBeRecovered =\n                        relation.isCascadeRecover === true &&\n                            operationType === \"recover\";\n                return;\n            }\n            // mark subject with what we can do with it\n            // and add to the array of subjects to load only if there is no same entity there already\n            const relationEntitySubject = new Subject({\n                metadata: relationEntityMetadata,\n                parentSubject: subject,\n                entity: relationEntity,\n                canBeInserted: relation.isCascadeInsert === true &&\n                    operationType === \"save\",\n                canBeUpdated: relation.isCascadeUpdate === true &&\n                    operationType === \"save\",\n                canBeSoftRemoved: relation.isCascadeSoftRemove === true &&\n                    operationType === \"soft-remove\",\n                canBeRecovered: relation.isCascadeRecover === true &&\n                    operationType === \"recover\",\n            });\n            this.allSubjects.push(relationEntitySubject);\n            // go recursively and find other entities we need to insert/update\n            this.build(relationEntitySubject, operationType);\n        });\n    }\n    // ---------------------------------------------------------------------\n    // Protected Methods\n    // ---------------------------------------------------------------------\n    /**\n     * Finds subject where entity like given subject's entity.\n     * Comparison made by entity id.\n     */\n    findByPersistEntityLike(entityTarget, entity) {\n        return this.allSubjects.find((subject) => {\n            if (!subject.entity)\n                return false;\n            if (subject.entity === entity)\n                return true;\n            return (subject.metadata.target === entityTarget &&\n                subject.metadata.compareEntities(subject.entityWithFulfilledIds, entity));\n        });\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}