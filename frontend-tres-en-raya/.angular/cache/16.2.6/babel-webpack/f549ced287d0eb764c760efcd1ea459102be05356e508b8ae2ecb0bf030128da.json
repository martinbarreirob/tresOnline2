{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/practicas/Downloads/angular/tresOnline/frontend-tres-en-raya/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { Table } from \"../schema-builder/table/Table\";\nimport { Migration } from \"./Migration\";\nimport { MssqlParameter } from \"../driver/sqlserver/MssqlParameter\";\nimport { ForbiddenTransactionModeOverrideError, TypeORMError } from \"../error\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\n/**\n * Executes migrations: runs pending and reverts previously executed migrations.\n */\nexport class MigrationExecutor {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection, queryRunner) {\n    this.connection = connection;\n    this.queryRunner = queryRunner;\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n    /**\n     * Indicates how migrations should be run in transactions.\n     *   all: all migrations are run in a single transaction\n     *   none: all migrations are run without a transaction\n     *   each: each migration is run in a separate transaction\n     */\n    this.transaction = \"all\";\n    const {\n      schema\n    } = this.connection.driver.options;\n    const database = this.connection.driver.database;\n    this.migrationsDatabase = database;\n    this.migrationsSchema = schema;\n    this.migrationsTableName = connection.options.migrationsTableName || \"migrations\";\n    this.migrationsTable = this.connection.driver.buildTableName(this.migrationsTableName, schema, database);\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Tries to execute a single migration given.\n   */\n  executeMigration(migration) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      return _this.withQueryRunner( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (queryRunner) {\n          yield _this.createMigrationsTableIfNotExist(queryRunner);\n          // create typeorm_metadata table if it's not created yet\n          const schemaBuilder = _this.connection.driver.createSchemaBuilder();\n          if (InstanceChecker.isRdbmsSchemaBuilder(schemaBuilder)) {\n            yield schemaBuilder.createMetadataTableIfNecessary(queryRunner);\n          }\n          yield queryRunner.beforeMigration();\n          yield migration.instance.up(queryRunner);\n          yield queryRunner.afterMigration();\n          yield _this.insertExecutedMigration(queryRunner, migration);\n          return migration;\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n    })();\n  }\n  /**\n   * Returns an array of all migrations.\n   */\n  getAllMigrations() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      return Promise.resolve(_this2.getMigrations());\n    })();\n  }\n  /**\n   * Returns an array of all executed migrations.\n   */\n  getExecutedMigrations() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      return _this3.withQueryRunner( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (queryRunner) {\n          yield _this3.createMigrationsTableIfNotExist(queryRunner);\n          return yield _this3.loadExecutedMigrations(queryRunner);\n        });\n        return function (_x2) {\n          return _ref2.apply(this, arguments);\n        };\n      }());\n    })();\n  }\n  /**\n   * Returns an array of all pending migrations.\n   */\n  getPendingMigrations() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const allMigrations = yield _this4.getAllMigrations();\n      const executedMigrations = yield _this4.getExecutedMigrations();\n      return allMigrations.filter(migration => !executedMigrations.find(executedMigration => executedMigration.name === migration.name));\n    })();\n  }\n  /**\n   * Inserts an executed migration.\n   */\n  insertMigration(migration) {\n    return this.withQueryRunner(q => this.insertExecutedMigration(q, migration));\n  }\n  /**\n   * Deletes an executed migration.\n   */\n  deleteMigration(migration) {\n    return this.withQueryRunner(q => this.deleteExecutedMigration(q, migration));\n  }\n  /**\n   * Lists all migrations and whether they have been executed or not\n   * returns true if there are unapplied migrations\n   */\n  showMigrations() {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      let hasUnappliedMigrations = false;\n      const queryRunner = _this5.queryRunner || _this5.connection.createQueryRunner();\n      // create migrations table if its not created yet\n      yield _this5.createMigrationsTableIfNotExist(queryRunner);\n      // get all migrations that are executed and saved in the database\n      const executedMigrations = yield _this5.loadExecutedMigrations(queryRunner);\n      // get all user's migrations in the source code\n      const allMigrations = _this5.getMigrations();\n      for (const migration of allMigrations) {\n        const executedMigration = executedMigrations.find(executedMigration => executedMigration.name === migration.name);\n        if (executedMigration) {\n          _this5.connection.logger.logSchemaBuild(`[X] ${executedMigration.id} ${migration.name}`);\n        } else {\n          hasUnappliedMigrations = true;\n          _this5.connection.logger.logSchemaBuild(`[ ] ${migration.name}`);\n        }\n      }\n      // if query runner was created by us then release it\n      if (!_this5.queryRunner) {\n        yield queryRunner.release();\n      }\n      return hasUnappliedMigrations;\n    })();\n  }\n  /**\n   * Executes all pending migrations. Pending migrations are migrations that are not yet executed,\n   * thus not saved in the database.\n   */\n  executePendingMigrations() {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const queryRunner = _this6.queryRunner || _this6.connection.createQueryRunner();\n      // create migrations table if it's not created yet\n      yield _this6.createMigrationsTableIfNotExist(queryRunner);\n      // create the typeorm_metadata table if it's not created yet\n      const schemaBuilder = _this6.connection.driver.createSchemaBuilder();\n      if (InstanceChecker.isRdbmsSchemaBuilder(schemaBuilder)) {\n        yield schemaBuilder.createMetadataTableIfNecessary(queryRunner);\n      }\n      // get all migrations that are executed and saved in the database\n      const executedMigrations = yield _this6.loadExecutedMigrations(queryRunner);\n      // get the time when last migration was executed\n      let lastTimeExecutedMigration = _this6.getLatestTimestampMigration(executedMigrations);\n      // get all user's migrations in the source code\n      const allMigrations = _this6.getMigrations();\n      // variable to store all migrations we did successfully\n      const successMigrations = [];\n      // find all migrations that needs to be executed\n      const pendingMigrations = allMigrations.filter(migration => {\n        // check if we already have executed migration\n        const executedMigration = executedMigrations.find(executedMigration => executedMigration.name === migration.name);\n        if (executedMigration) return false;\n        // migration is new and not executed. now check if its timestamp is correct\n        // if (lastTimeExecutedMigration && migration.timestamp < lastTimeExecutedMigration.timestamp)\n        //     throw new TypeORMError(`New migration found: ${migration.name}, however this migration's timestamp is not valid. Migration's timestamp should not be older then migrations already executed in the database.`);\n        // every check is passed means that migration was not run yet and we need to run it\n        return true;\n      });\n      // if no migrations are pending then nothing to do here\n      if (!pendingMigrations.length) {\n        _this6.connection.logger.logSchemaBuild(`No migrations are pending`);\n        // if query runner was created by us then release it\n        if (!_this6.queryRunner) yield queryRunner.release();\n        return [];\n      }\n      // log information about migration execution\n      _this6.connection.logger.logSchemaBuild(`${executedMigrations.length} migrations are already loaded in the database.`);\n      _this6.connection.logger.logSchemaBuild(`${allMigrations.length} migrations were found in the source code.`);\n      if (lastTimeExecutedMigration) _this6.connection.logger.logSchemaBuild(`${lastTimeExecutedMigration.name} is the last executed migration. It was executed on ${new Date(lastTimeExecutedMigration.timestamp).toString()}.`);\n      _this6.connection.logger.logSchemaBuild(`${pendingMigrations.length} migrations are new migrations must be executed.`);\n      if (_this6.transaction === \"all\") {\n        // If we desire to run all migrations in a single transaction\n        // but there is a migration that explicitly overrides the transaction mode\n        // then we have to fail since we cannot properly resolve that intent\n        // In theory we could support overrides that are set to `true`,\n        // however to keep the interface more rigid, we fail those too\n        const migrationsOverridingTransactionMode = pendingMigrations.filter(migration => {\n          var _a;\n          return !(((_a = migration.instance) === null || _a === void 0 ? void 0 : _a.transaction) === undefined);\n        });\n        if (migrationsOverridingTransactionMode.length > 0) {\n          const error = new ForbiddenTransactionModeOverrideError(migrationsOverridingTransactionMode);\n          _this6.connection.logger.logMigration(`Migrations failed, error: ${error.message}`);\n          throw error;\n        }\n      }\n      // Set the per-migration defaults for the transaction mode\n      // so that we have one centralized place that controls this behavior\n      // When transaction mode is `each` the default is to run in a transaction\n      // When transaction mode is `none` the default is to not run in a transaction\n      // When transaction mode is `all` the default is to not run in a transaction\n      // since all the migrations are already running in one single transaction\n      const txModeDefault = {\n        each: true,\n        none: false,\n        all: false\n      }[_this6.transaction];\n      for (const migration of pendingMigrations) {\n        if (migration.instance) {\n          const instanceTx = migration.instance.transaction;\n          if (instanceTx === undefined) {\n            migration.transaction = txModeDefault;\n          } else {\n            migration.transaction = instanceTx;\n          }\n        }\n      }\n      // start transaction if its not started yet\n      let transactionStartedByUs = false;\n      if (_this6.transaction === \"all\" && !queryRunner.isTransactionActive) {\n        yield queryRunner.beforeMigration();\n        yield queryRunner.startTransaction();\n        transactionStartedByUs = true;\n      }\n      // run all pending migrations in a sequence\n      try {\n        for (const migration of pendingMigrations) {\n          if (_this6.fake) {\n            // directly insert migration record into the database if it is fake\n            yield _this6.insertExecutedMigration(queryRunner, migration);\n            // nothing else needs to be done, continue to next migration\n            continue;\n          }\n          if (migration.transaction && !queryRunner.isTransactionActive) {\n            yield queryRunner.beforeMigration();\n            yield queryRunner.startTransaction();\n            transactionStartedByUs = true;\n          }\n          yield migration.instance.up(queryRunner).catch(error => {\n            // informative log about migration failure\n            _this6.connection.logger.logMigration(`Migration \"${migration.name}\" failed, error: ${error === null || error === void 0 ? void 0 : error.message}`);\n            throw error;\n          }).then( /*#__PURE__*/_asyncToGenerator(function* () {\n            // now when migration is executed we need to insert record about it into the database\n            yield _this6.insertExecutedMigration(queryRunner, migration);\n            // commit transaction if we started it\n            if (migration.transaction && transactionStartedByUs) {\n              yield queryRunner.commitTransaction();\n              yield queryRunner.afterMigration();\n            }\n          })).then(() => {\n            // informative log about migration success\n            successMigrations.push(migration);\n            _this6.connection.logger.logSchemaBuild(`Migration ${migration.name} has been ${_this6.fake ? \"(fake)\" : \"\"} executed successfully.`);\n          });\n        }\n        // commit transaction if we started it\n        if (_this6.transaction === \"all\" && transactionStartedByUs) {\n          yield queryRunner.commitTransaction();\n          yield queryRunner.afterMigration();\n        }\n      } catch (err) {\n        // rollback transaction if we started it\n        if (transactionStartedByUs) {\n          try {\n            // we throw original error even if rollback thrown an error\n            yield queryRunner.rollbackTransaction();\n          } catch (rollbackError) {}\n        }\n        throw err;\n      } finally {\n        // if query runner was created by us then release it\n        if (!_this6.queryRunner) yield queryRunner.release();\n      }\n      return successMigrations;\n    })();\n  }\n  /**\n   * Reverts last migration that were run.\n   */\n  undoLastMigration() {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const queryRunner = _this7.queryRunner || _this7.connection.createQueryRunner();\n      // create migrations table if it's not created yet\n      yield _this7.createMigrationsTableIfNotExist(queryRunner);\n      // create typeorm_metadata table if it's not created yet\n      const schemaBuilder = _this7.connection.driver.createSchemaBuilder();\n      if (InstanceChecker.isRdbmsSchemaBuilder(schemaBuilder)) {\n        yield schemaBuilder.createMetadataTableIfNecessary(queryRunner);\n      }\n      // get all migrations that are executed and saved in the database\n      const executedMigrations = yield _this7.loadExecutedMigrations(queryRunner);\n      // get the time when last migration was executed\n      let lastTimeExecutedMigration = _this7.getLatestExecutedMigration(executedMigrations);\n      // if no migrations found in the database then nothing to revert\n      if (!lastTimeExecutedMigration) {\n        _this7.connection.logger.logSchemaBuild(`No migrations were found in the database. Nothing to revert!`);\n        return;\n      }\n      // get all user's migrations in the source code\n      const allMigrations = _this7.getMigrations();\n      // find the instance of the migration we need to remove\n      const migrationToRevert = allMigrations.find(migration => migration.name === lastTimeExecutedMigration.name);\n      // if no migrations found in the database then nothing to revert\n      if (!migrationToRevert) throw new TypeORMError(`No migration ${lastTimeExecutedMigration.name} was found in the source code. Make sure you have this migration in your codebase and its included in the connection options.`);\n      // log information about migration execution\n      _this7.connection.logger.logSchemaBuild(`${executedMigrations.length} migrations are already loaded in the database.`);\n      _this7.connection.logger.logSchemaBuild(`${lastTimeExecutedMigration.name} is the last executed migration. It was executed on ${new Date(lastTimeExecutedMigration.timestamp).toString()}.`);\n      _this7.connection.logger.logSchemaBuild(`Now reverting it...`);\n      // start transaction if its not started yet\n      let transactionStartedByUs = false;\n      if (_this7.transaction !== \"none\" && !queryRunner.isTransactionActive) {\n        yield queryRunner.startTransaction();\n        transactionStartedByUs = true;\n      }\n      try {\n        if (!_this7.fake) {\n          yield queryRunner.beforeMigration();\n          yield migrationToRevert.instance.down(queryRunner);\n          yield queryRunner.afterMigration();\n        }\n        yield _this7.deleteExecutedMigration(queryRunner, migrationToRevert);\n        _this7.connection.logger.logSchemaBuild(`Migration ${migrationToRevert.name} has been ${_this7.fake ? \"(fake)\" : \"\"} reverted successfully.`);\n        // commit transaction if we started it\n        if (transactionStartedByUs) yield queryRunner.commitTransaction();\n      } catch (err) {\n        // rollback transaction if we started it\n        if (transactionStartedByUs) {\n          try {\n            // we throw original error even if rollback thrown an error\n            yield queryRunner.rollbackTransaction();\n          } catch (rollbackError) {}\n        }\n        throw err;\n      } finally {\n        // if query runner was created by us then release it\n        if (!_this7.queryRunner) yield queryRunner.release();\n      }\n    })();\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Creates table \"migrations\" that will store information about executed migrations.\n   */\n  createMigrationsTableIfNotExist(queryRunner) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      // If driver is mongo no need to create\n      if (_this8.connection.driver.options.type === \"mongodb\") {\n        return;\n      }\n      const tableExist = yield queryRunner.hasTable(_this8.migrationsTable); // todo: table name should be configurable\n      if (!tableExist) {\n        yield queryRunner.createTable(new Table({\n          database: _this8.migrationsDatabase,\n          schema: _this8.migrationsSchema,\n          name: _this8.migrationsTable,\n          columns: [{\n            name: \"id\",\n            type: _this8.connection.driver.normalizeType({\n              type: _this8.connection.driver.mappedDataTypes.migrationId\n            }),\n            isGenerated: true,\n            generationStrategy: \"increment\",\n            isPrimary: true,\n            isNullable: false\n          }, {\n            name: \"timestamp\",\n            type: _this8.connection.driver.normalizeType({\n              type: _this8.connection.driver.mappedDataTypes.migrationTimestamp\n            }),\n            isPrimary: false,\n            isNullable: false\n          }, {\n            name: \"name\",\n            type: _this8.connection.driver.normalizeType({\n              type: _this8.connection.driver.mappedDataTypes.migrationName\n            }),\n            isNullable: false\n          }]\n        }));\n      }\n    })();\n  }\n  /**\n   * Loads all migrations that were executed and saved into the database (sorts by id).\n   */\n  loadExecutedMigrations(queryRunner) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      if (_this9.connection.driver.options.type === \"mongodb\") {\n        const mongoRunner = queryRunner;\n        return mongoRunner.cursor(_this9.migrationsTableName, {}).sort({\n          _id: -1\n        }).toArray();\n      } else {\n        const migrationsRaw = yield _this9.connection.manager.createQueryBuilder(queryRunner).select().orderBy(_this9.connection.driver.escape(\"id\"), \"DESC\").from(_this9.migrationsTable, _this9.migrationsTableName).getRawMany();\n        return migrationsRaw.map(migrationRaw => {\n          return new Migration(parseInt(migrationRaw[\"id\"]), parseInt(migrationRaw[\"timestamp\"]), migrationRaw[\"name\"]);\n        });\n      }\n    })();\n  }\n  /**\n   * Gets all migrations that setup for this connection.\n   */\n  getMigrations() {\n    const migrations = this.connection.migrations.map(migration => {\n      const migrationClassName = migration.name || migration.constructor.name;\n      const migrationTimestamp = parseInt(migrationClassName.substr(-13), 10);\n      if (!migrationTimestamp || isNaN(migrationTimestamp)) {\n        throw new TypeORMError(`${migrationClassName} migration name is wrong. Migration class name should have a JavaScript timestamp appended.`);\n      }\n      return new Migration(undefined, migrationTimestamp, migrationClassName, migration);\n    });\n    this.checkForDuplicateMigrations(migrations);\n    // sort them by timestamp\n    return migrations.sort((a, b) => a.timestamp - b.timestamp);\n  }\n  checkForDuplicateMigrations(migrations) {\n    const migrationNames = migrations.map(migration => migration.name);\n    const duplicates = Array.from(new Set(migrationNames.filter((migrationName, index) => migrationNames.indexOf(migrationName) < index)));\n    if (duplicates.length > 0) {\n      throw Error(`Duplicate migrations: ${duplicates.join(\", \")}`);\n    }\n  }\n  /**\n   * Finds the latest migration (sorts by timestamp) in the given array of migrations.\n   */\n  getLatestTimestampMigration(migrations) {\n    const sortedMigrations = migrations.map(migration => migration).sort((a, b) => (a.timestamp - b.timestamp) * -1);\n    return sortedMigrations.length > 0 ? sortedMigrations[0] : undefined;\n  }\n  /**\n   * Finds the latest migration in the given array of migrations.\n   * PRE: Migration array must be sorted by descending id.\n   */\n  getLatestExecutedMigration(sortedMigrations) {\n    return sortedMigrations.length > 0 ? sortedMigrations[0] : undefined;\n  }\n  /**\n   * Inserts new executed migration's data into migrations table.\n   */\n  insertExecutedMigration(queryRunner, migration) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      const values = {};\n      if (_this10.connection.driver.options.type === \"mssql\") {\n        values[\"timestamp\"] = new MssqlParameter(migration.timestamp, _this10.connection.driver.normalizeType({\n          type: _this10.connection.driver.mappedDataTypes.migrationTimestamp\n        }));\n        values[\"name\"] = new MssqlParameter(migration.name, _this10.connection.driver.normalizeType({\n          type: _this10.connection.driver.mappedDataTypes.migrationName\n        }));\n      } else {\n        values[\"timestamp\"] = migration.timestamp;\n        values[\"name\"] = migration.name;\n      }\n      if (_this10.connection.driver.options.type === \"mongodb\") {\n        const mongoRunner = queryRunner;\n        yield mongoRunner.databaseConnection.db(_this10.connection.driver.database).collection(_this10.migrationsTableName).insertOne(values);\n      } else {\n        const qb = queryRunner.manager.createQueryBuilder();\n        yield qb.insert().into(_this10.migrationsTable).values(values).execute();\n      }\n    })();\n  }\n  /**\n   * Delete previously executed migration's data from the migrations table.\n   */\n  deleteExecutedMigration(queryRunner, migration) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      const conditions = {};\n      if (_this11.connection.driver.options.type === \"mssql\") {\n        conditions[\"timestamp\"] = new MssqlParameter(migration.timestamp, _this11.connection.driver.normalizeType({\n          type: _this11.connection.driver.mappedDataTypes.migrationTimestamp\n        }));\n        conditions[\"name\"] = new MssqlParameter(migration.name, _this11.connection.driver.normalizeType({\n          type: _this11.connection.driver.mappedDataTypes.migrationName\n        }));\n      } else {\n        conditions[\"timestamp\"] = migration.timestamp;\n        conditions[\"name\"] = migration.name;\n      }\n      if (_this11.connection.driver.options.type === \"mongodb\") {\n        const mongoRunner = queryRunner;\n        yield mongoRunner.databaseConnection.db(_this11.connection.driver.database).collection(_this11.migrationsTableName).deleteOne(conditions);\n      } else {\n        const qb = queryRunner.manager.createQueryBuilder();\n        yield qb.delete().from(_this11.migrationsTable).where(`${qb.escape(\"timestamp\")} = :timestamp`).andWhere(`${qb.escape(\"name\")} = :name`).setParameters(conditions).execute();\n      }\n    })();\n  }\n  withQueryRunner(callback) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      const queryRunner = _this12.queryRunner || _this12.connection.createQueryRunner();\n      try {\n        return yield callback(queryRunner);\n      } finally {\n        if (!_this12.queryRunner) {\n          yield queryRunner.release();\n        }\n      }\n    })();\n  }\n}","map":{"version":3,"names":["Table","Migration","MssqlParameter","ForbiddenTransactionModeOverrideError","TypeORMError","InstanceChecker","MigrationExecutor","constructor","connection","queryRunner","transaction","schema","driver","options","database","migrationsDatabase","migrationsSchema","migrationsTableName","migrationsTable","buildTableName","executeMigration","migration","_this","_asyncToGenerator","withQueryRunner","_ref","createMigrationsTableIfNotExist","schemaBuilder","createSchemaBuilder","isRdbmsSchemaBuilder","createMetadataTableIfNecessary","beforeMigration","instance","up","afterMigration","insertExecutedMigration","_x","apply","arguments","getAllMigrations","_this2","Promise","resolve","getMigrations","getExecutedMigrations","_this3","_ref2","loadExecutedMigrations","_x2","getPendingMigrations","_this4","allMigrations","executedMigrations","filter","find","executedMigration","name","insertMigration","q","deleteMigration","deleteExecutedMigration","showMigrations","_this5","hasUnappliedMigrations","createQueryRunner","logger","logSchemaBuild","id","release","executePendingMigrations","_this6","lastTimeExecutedMigration","getLatestTimestampMigration","successMigrations","pendingMigrations","length","Date","timestamp","toString","migrationsOverridingTransactionMode","_a","undefined","error","logMigration","message","txModeDefault","each","none","all","instanceTx","transactionStartedByUs","isTransactionActive","startTransaction","fake","catch","then","commitTransaction","push","err","rollbackTransaction","rollbackError","undoLastMigration","_this7","getLatestExecutedMigration","migrationToRevert","down","_this8","type","tableExist","hasTable","createTable","columns","normalizeType","mappedDataTypes","migrationId","isGenerated","generationStrategy","isPrimary","isNullable","migrationTimestamp","migrationName","_this9","mongoRunner","cursor","sort","_id","toArray","migrationsRaw","manager","createQueryBuilder","select","orderBy","escape","from","getRawMany","map","migrationRaw","parseInt","migrations","migrationClassName","substr","isNaN","checkForDuplicateMigrations","a","b","migrationNames","duplicates","Array","Set","index","indexOf","Error","join","sortedMigrations","_this10","values","databaseConnection","db","collection","insertOne","qb","insert","into","execute","_this11","conditions","deleteOne","delete","where","andWhere","setParameters","callback","_this12"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/migration/MigrationExecutor.js"],"sourcesContent":["import { Table } from \"../schema-builder/table/Table\";\nimport { Migration } from \"./Migration\";\nimport { MssqlParameter } from \"../driver/sqlserver/MssqlParameter\";\nimport { ForbiddenTransactionModeOverrideError, TypeORMError } from \"../error\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\n/**\n * Executes migrations: runs pending and reverts previously executed migrations.\n */\nexport class MigrationExecutor {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n    constructor(connection, queryRunner) {\n        this.connection = connection;\n        this.queryRunner = queryRunner;\n        // -------------------------------------------------------------------------\n        // Public Properties\n        // -------------------------------------------------------------------------\n        /**\n         * Indicates how migrations should be run in transactions.\n         *   all: all migrations are run in a single transaction\n         *   none: all migrations are run without a transaction\n         *   each: each migration is run in a separate transaction\n         */\n        this.transaction = \"all\";\n        const { schema } = this.connection.driver.options;\n        const database = this.connection.driver.database;\n        this.migrationsDatabase = database;\n        this.migrationsSchema = schema;\n        this.migrationsTableName =\n            connection.options.migrationsTableName || \"migrations\";\n        this.migrationsTable = this.connection.driver.buildTableName(this.migrationsTableName, schema, database);\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Tries to execute a single migration given.\n     */\n    async executeMigration(migration) {\n        return this.withQueryRunner(async (queryRunner) => {\n            await this.createMigrationsTableIfNotExist(queryRunner);\n            // create typeorm_metadata table if it's not created yet\n            const schemaBuilder = this.connection.driver.createSchemaBuilder();\n            if (InstanceChecker.isRdbmsSchemaBuilder(schemaBuilder)) {\n                await schemaBuilder.createMetadataTableIfNecessary(queryRunner);\n            }\n            await queryRunner.beforeMigration();\n            await migration.instance.up(queryRunner);\n            await queryRunner.afterMigration();\n            await this.insertExecutedMigration(queryRunner, migration);\n            return migration;\n        });\n    }\n    /**\n     * Returns an array of all migrations.\n     */\n    async getAllMigrations() {\n        return Promise.resolve(this.getMigrations());\n    }\n    /**\n     * Returns an array of all executed migrations.\n     */\n    async getExecutedMigrations() {\n        return this.withQueryRunner(async (queryRunner) => {\n            await this.createMigrationsTableIfNotExist(queryRunner);\n            return await this.loadExecutedMigrations(queryRunner);\n        });\n    }\n    /**\n     * Returns an array of all pending migrations.\n     */\n    async getPendingMigrations() {\n        const allMigrations = await this.getAllMigrations();\n        const executedMigrations = await this.getExecutedMigrations();\n        return allMigrations.filter((migration) => !executedMigrations.find((executedMigration) => executedMigration.name === migration.name));\n    }\n    /**\n     * Inserts an executed migration.\n     */\n    insertMigration(migration) {\n        return this.withQueryRunner((q) => this.insertExecutedMigration(q, migration));\n    }\n    /**\n     * Deletes an executed migration.\n     */\n    deleteMigration(migration) {\n        return this.withQueryRunner((q) => this.deleteExecutedMigration(q, migration));\n    }\n    /**\n     * Lists all migrations and whether they have been executed or not\n     * returns true if there are unapplied migrations\n     */\n    async showMigrations() {\n        let hasUnappliedMigrations = false;\n        const queryRunner = this.queryRunner || this.connection.createQueryRunner();\n        // create migrations table if its not created yet\n        await this.createMigrationsTableIfNotExist(queryRunner);\n        // get all migrations that are executed and saved in the database\n        const executedMigrations = await this.loadExecutedMigrations(queryRunner);\n        // get all user's migrations in the source code\n        const allMigrations = this.getMigrations();\n        for (const migration of allMigrations) {\n            const executedMigration = executedMigrations.find((executedMigration) => executedMigration.name === migration.name);\n            if (executedMigration) {\n                this.connection.logger.logSchemaBuild(`[X] ${executedMigration.id} ${migration.name}`);\n            }\n            else {\n                hasUnappliedMigrations = true;\n                this.connection.logger.logSchemaBuild(`[ ] ${migration.name}`);\n            }\n        }\n        // if query runner was created by us then release it\n        if (!this.queryRunner) {\n            await queryRunner.release();\n        }\n        return hasUnappliedMigrations;\n    }\n    /**\n     * Executes all pending migrations. Pending migrations are migrations that are not yet executed,\n     * thus not saved in the database.\n     */\n    async executePendingMigrations() {\n        const queryRunner = this.queryRunner || this.connection.createQueryRunner();\n        // create migrations table if it's not created yet\n        await this.createMigrationsTableIfNotExist(queryRunner);\n        // create the typeorm_metadata table if it's not created yet\n        const schemaBuilder = this.connection.driver.createSchemaBuilder();\n        if (InstanceChecker.isRdbmsSchemaBuilder(schemaBuilder)) {\n            await schemaBuilder.createMetadataTableIfNecessary(queryRunner);\n        }\n        // get all migrations that are executed and saved in the database\n        const executedMigrations = await this.loadExecutedMigrations(queryRunner);\n        // get the time when last migration was executed\n        let lastTimeExecutedMigration = this.getLatestTimestampMigration(executedMigrations);\n        // get all user's migrations in the source code\n        const allMigrations = this.getMigrations();\n        // variable to store all migrations we did successfully\n        const successMigrations = [];\n        // find all migrations that needs to be executed\n        const pendingMigrations = allMigrations.filter((migration) => {\n            // check if we already have executed migration\n            const executedMigration = executedMigrations.find((executedMigration) => executedMigration.name === migration.name);\n            if (executedMigration)\n                return false;\n            // migration is new and not executed. now check if its timestamp is correct\n            // if (lastTimeExecutedMigration && migration.timestamp < lastTimeExecutedMigration.timestamp)\n            //     throw new TypeORMError(`New migration found: ${migration.name}, however this migration's timestamp is not valid. Migration's timestamp should not be older then migrations already executed in the database.`);\n            // every check is passed means that migration was not run yet and we need to run it\n            return true;\n        });\n        // if no migrations are pending then nothing to do here\n        if (!pendingMigrations.length) {\n            this.connection.logger.logSchemaBuild(`No migrations are pending`);\n            // if query runner was created by us then release it\n            if (!this.queryRunner)\n                await queryRunner.release();\n            return [];\n        }\n        // log information about migration execution\n        this.connection.logger.logSchemaBuild(`${executedMigrations.length} migrations are already loaded in the database.`);\n        this.connection.logger.logSchemaBuild(`${allMigrations.length} migrations were found in the source code.`);\n        if (lastTimeExecutedMigration)\n            this.connection.logger.logSchemaBuild(`${lastTimeExecutedMigration.name} is the last executed migration. It was executed on ${new Date(lastTimeExecutedMigration.timestamp).toString()}.`);\n        this.connection.logger.logSchemaBuild(`${pendingMigrations.length} migrations are new migrations must be executed.`);\n        if (this.transaction === \"all\") {\n            // If we desire to run all migrations in a single transaction\n            // but there is a migration that explicitly overrides the transaction mode\n            // then we have to fail since we cannot properly resolve that intent\n            // In theory we could support overrides that are set to `true`,\n            // however to keep the interface more rigid, we fail those too\n            const migrationsOverridingTransactionMode = pendingMigrations.filter((migration) => { var _a; return !(((_a = migration.instance) === null || _a === void 0 ? void 0 : _a.transaction) === undefined); });\n            if (migrationsOverridingTransactionMode.length > 0) {\n                const error = new ForbiddenTransactionModeOverrideError(migrationsOverridingTransactionMode);\n                this.connection.logger.logMigration(`Migrations failed, error: ${error.message}`);\n                throw error;\n            }\n        }\n        // Set the per-migration defaults for the transaction mode\n        // so that we have one centralized place that controls this behavior\n        // When transaction mode is `each` the default is to run in a transaction\n        // When transaction mode is `none` the default is to not run in a transaction\n        // When transaction mode is `all` the default is to not run in a transaction\n        // since all the migrations are already running in one single transaction\n        const txModeDefault = {\n            each: true,\n            none: false,\n            all: false,\n        }[this.transaction];\n        for (const migration of pendingMigrations) {\n            if (migration.instance) {\n                const instanceTx = migration.instance.transaction;\n                if (instanceTx === undefined) {\n                    migration.transaction = txModeDefault;\n                }\n                else {\n                    migration.transaction = instanceTx;\n                }\n            }\n        }\n        // start transaction if its not started yet\n        let transactionStartedByUs = false;\n        if (this.transaction === \"all\" && !queryRunner.isTransactionActive) {\n            await queryRunner.beforeMigration();\n            await queryRunner.startTransaction();\n            transactionStartedByUs = true;\n        }\n        // run all pending migrations in a sequence\n        try {\n            for (const migration of pendingMigrations) {\n                if (this.fake) {\n                    // directly insert migration record into the database if it is fake\n                    await this.insertExecutedMigration(queryRunner, migration);\n                    // nothing else needs to be done, continue to next migration\n                    continue;\n                }\n                if (migration.transaction && !queryRunner.isTransactionActive) {\n                    await queryRunner.beforeMigration();\n                    await queryRunner.startTransaction();\n                    transactionStartedByUs = true;\n                }\n                await migration\n                    .instance.up(queryRunner)\n                    .catch((error) => {\n                    // informative log about migration failure\n                    this.connection.logger.logMigration(`Migration \"${migration.name}\" failed, error: ${error === null || error === void 0 ? void 0 : error.message}`);\n                    throw error;\n                })\n                    .then(async () => {\n                    // now when migration is executed we need to insert record about it into the database\n                    await this.insertExecutedMigration(queryRunner, migration);\n                    // commit transaction if we started it\n                    if (migration.transaction && transactionStartedByUs) {\n                        await queryRunner.commitTransaction();\n                        await queryRunner.afterMigration();\n                    }\n                })\n                    .then(() => {\n                    // informative log about migration success\n                    successMigrations.push(migration);\n                    this.connection.logger.logSchemaBuild(`Migration ${migration.name} has been ${this.fake ? \"(fake)\" : \"\"} executed successfully.`);\n                });\n            }\n            // commit transaction if we started it\n            if (this.transaction === \"all\" && transactionStartedByUs) {\n                await queryRunner.commitTransaction();\n                await queryRunner.afterMigration();\n            }\n        }\n        catch (err) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    // we throw original error even if rollback thrown an error\n                    await queryRunner.rollbackTransaction();\n                }\n                catch (rollbackError) { }\n            }\n            throw err;\n        }\n        finally {\n            // if query runner was created by us then release it\n            if (!this.queryRunner)\n                await queryRunner.release();\n        }\n        return successMigrations;\n    }\n    /**\n     * Reverts last migration that were run.\n     */\n    async undoLastMigration() {\n        const queryRunner = this.queryRunner || this.connection.createQueryRunner();\n        // create migrations table if it's not created yet\n        await this.createMigrationsTableIfNotExist(queryRunner);\n        // create typeorm_metadata table if it's not created yet\n        const schemaBuilder = this.connection.driver.createSchemaBuilder();\n        if (InstanceChecker.isRdbmsSchemaBuilder(schemaBuilder)) {\n            await schemaBuilder.createMetadataTableIfNecessary(queryRunner);\n        }\n        // get all migrations that are executed and saved in the database\n        const executedMigrations = await this.loadExecutedMigrations(queryRunner);\n        // get the time when last migration was executed\n        let lastTimeExecutedMigration = this.getLatestExecutedMigration(executedMigrations);\n        // if no migrations found in the database then nothing to revert\n        if (!lastTimeExecutedMigration) {\n            this.connection.logger.logSchemaBuild(`No migrations were found in the database. Nothing to revert!`);\n            return;\n        }\n        // get all user's migrations in the source code\n        const allMigrations = this.getMigrations();\n        // find the instance of the migration we need to remove\n        const migrationToRevert = allMigrations.find((migration) => migration.name === lastTimeExecutedMigration.name);\n        // if no migrations found in the database then nothing to revert\n        if (!migrationToRevert)\n            throw new TypeORMError(`No migration ${lastTimeExecutedMigration.name} was found in the source code. Make sure you have this migration in your codebase and its included in the connection options.`);\n        // log information about migration execution\n        this.connection.logger.logSchemaBuild(`${executedMigrations.length} migrations are already loaded in the database.`);\n        this.connection.logger.logSchemaBuild(`${lastTimeExecutedMigration.name} is the last executed migration. It was executed on ${new Date(lastTimeExecutedMigration.timestamp).toString()}.`);\n        this.connection.logger.logSchemaBuild(`Now reverting it...`);\n        // start transaction if its not started yet\n        let transactionStartedByUs = false;\n        if (this.transaction !== \"none\" && !queryRunner.isTransactionActive) {\n            await queryRunner.startTransaction();\n            transactionStartedByUs = true;\n        }\n        try {\n            if (!this.fake) {\n                await queryRunner.beforeMigration();\n                await migrationToRevert.instance.down(queryRunner);\n                await queryRunner.afterMigration();\n            }\n            await this.deleteExecutedMigration(queryRunner, migrationToRevert);\n            this.connection.logger.logSchemaBuild(`Migration ${migrationToRevert.name} has been ${this.fake ? \"(fake)\" : \"\"} reverted successfully.`);\n            // commit transaction if we started it\n            if (transactionStartedByUs)\n                await queryRunner.commitTransaction();\n        }\n        catch (err) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    // we throw original error even if rollback thrown an error\n                    await queryRunner.rollbackTransaction();\n                }\n                catch (rollbackError) { }\n            }\n            throw err;\n        }\n        finally {\n            // if query runner was created by us then release it\n            if (!this.queryRunner)\n                await queryRunner.release();\n        }\n    }\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Creates table \"migrations\" that will store information about executed migrations.\n     */\n    async createMigrationsTableIfNotExist(queryRunner) {\n        // If driver is mongo no need to create\n        if (this.connection.driver.options.type === \"mongodb\") {\n            return;\n        }\n        const tableExist = await queryRunner.hasTable(this.migrationsTable); // todo: table name should be configurable\n        if (!tableExist) {\n            await queryRunner.createTable(new Table({\n                database: this.migrationsDatabase,\n                schema: this.migrationsSchema,\n                name: this.migrationsTable,\n                columns: [\n                    {\n                        name: \"id\",\n                        type: this.connection.driver.normalizeType({\n                            type: this.connection.driver.mappedDataTypes\n                                .migrationId,\n                        }),\n                        isGenerated: true,\n                        generationStrategy: \"increment\",\n                        isPrimary: true,\n                        isNullable: false,\n                    },\n                    {\n                        name: \"timestamp\",\n                        type: this.connection.driver.normalizeType({\n                            type: this.connection.driver.mappedDataTypes\n                                .migrationTimestamp,\n                        }),\n                        isPrimary: false,\n                        isNullable: false,\n                    },\n                    {\n                        name: \"name\",\n                        type: this.connection.driver.normalizeType({\n                            type: this.connection.driver.mappedDataTypes\n                                .migrationName,\n                        }),\n                        isNullable: false,\n                    },\n                ],\n            }));\n        }\n    }\n    /**\n     * Loads all migrations that were executed and saved into the database (sorts by id).\n     */\n    async loadExecutedMigrations(queryRunner) {\n        if (this.connection.driver.options.type === \"mongodb\") {\n            const mongoRunner = queryRunner;\n            return mongoRunner\n                .cursor(this.migrationsTableName, {})\n                .sort({ _id: -1 })\n                .toArray();\n        }\n        else {\n            const migrationsRaw = await this.connection.manager\n                .createQueryBuilder(queryRunner)\n                .select()\n                .orderBy(this.connection.driver.escape(\"id\"), \"DESC\")\n                .from(this.migrationsTable, this.migrationsTableName)\n                .getRawMany();\n            return migrationsRaw.map((migrationRaw) => {\n                return new Migration(parseInt(migrationRaw[\"id\"]), parseInt(migrationRaw[\"timestamp\"]), migrationRaw[\"name\"]);\n            });\n        }\n    }\n    /**\n     * Gets all migrations that setup for this connection.\n     */\n    getMigrations() {\n        const migrations = this.connection.migrations.map((migration) => {\n            const migrationClassName = migration.name || migration.constructor.name;\n            const migrationTimestamp = parseInt(migrationClassName.substr(-13), 10);\n            if (!migrationTimestamp || isNaN(migrationTimestamp)) {\n                throw new TypeORMError(`${migrationClassName} migration name is wrong. Migration class name should have a JavaScript timestamp appended.`);\n            }\n            return new Migration(undefined, migrationTimestamp, migrationClassName, migration);\n        });\n        this.checkForDuplicateMigrations(migrations);\n        // sort them by timestamp\n        return migrations.sort((a, b) => a.timestamp - b.timestamp);\n    }\n    checkForDuplicateMigrations(migrations) {\n        const migrationNames = migrations.map((migration) => migration.name);\n        const duplicates = Array.from(new Set(migrationNames.filter((migrationName, index) => migrationNames.indexOf(migrationName) < index)));\n        if (duplicates.length > 0) {\n            throw Error(`Duplicate migrations: ${duplicates.join(\", \")}`);\n        }\n    }\n    /**\n     * Finds the latest migration (sorts by timestamp) in the given array of migrations.\n     */\n    getLatestTimestampMigration(migrations) {\n        const sortedMigrations = migrations\n            .map((migration) => migration)\n            .sort((a, b) => (a.timestamp - b.timestamp) * -1);\n        return sortedMigrations.length > 0 ? sortedMigrations[0] : undefined;\n    }\n    /**\n     * Finds the latest migration in the given array of migrations.\n     * PRE: Migration array must be sorted by descending id.\n     */\n    getLatestExecutedMigration(sortedMigrations) {\n        return sortedMigrations.length > 0 ? sortedMigrations[0] : undefined;\n    }\n    /**\n     * Inserts new executed migration's data into migrations table.\n     */\n    async insertExecutedMigration(queryRunner, migration) {\n        const values = {};\n        if (this.connection.driver.options.type === \"mssql\") {\n            values[\"timestamp\"] = new MssqlParameter(migration.timestamp, this.connection.driver.normalizeType({\n                type: this.connection.driver.mappedDataTypes\n                    .migrationTimestamp,\n            }));\n            values[\"name\"] = new MssqlParameter(migration.name, this.connection.driver.normalizeType({\n                type: this.connection.driver.mappedDataTypes.migrationName,\n            }));\n        }\n        else {\n            values[\"timestamp\"] = migration.timestamp;\n            values[\"name\"] = migration.name;\n        }\n        if (this.connection.driver.options.type === \"mongodb\") {\n            const mongoRunner = queryRunner;\n            await mongoRunner.databaseConnection\n                .db(this.connection.driver.database)\n                .collection(this.migrationsTableName)\n                .insertOne(values);\n        }\n        else {\n            const qb = queryRunner.manager.createQueryBuilder();\n            await qb\n                .insert()\n                .into(this.migrationsTable)\n                .values(values)\n                .execute();\n        }\n    }\n    /**\n     * Delete previously executed migration's data from the migrations table.\n     */\n    async deleteExecutedMigration(queryRunner, migration) {\n        const conditions = {};\n        if (this.connection.driver.options.type === \"mssql\") {\n            conditions[\"timestamp\"] = new MssqlParameter(migration.timestamp, this.connection.driver.normalizeType({\n                type: this.connection.driver.mappedDataTypes\n                    .migrationTimestamp,\n            }));\n            conditions[\"name\"] = new MssqlParameter(migration.name, this.connection.driver.normalizeType({\n                type: this.connection.driver.mappedDataTypes.migrationName,\n            }));\n        }\n        else {\n            conditions[\"timestamp\"] = migration.timestamp;\n            conditions[\"name\"] = migration.name;\n        }\n        if (this.connection.driver.options.type === \"mongodb\") {\n            const mongoRunner = queryRunner;\n            await mongoRunner.databaseConnection\n                .db(this.connection.driver.database)\n                .collection(this.migrationsTableName)\n                .deleteOne(conditions);\n        }\n        else {\n            const qb = queryRunner.manager.createQueryBuilder();\n            await qb\n                .delete()\n                .from(this.migrationsTable)\n                .where(`${qb.escape(\"timestamp\")} = :timestamp`)\n                .andWhere(`${qb.escape(\"name\")} = :name`)\n                .setParameters(conditions)\n                .execute();\n        }\n    }\n    async withQueryRunner(callback) {\n        const queryRunner = this.queryRunner || this.connection.createQueryRunner();\n        try {\n            return await callback(queryRunner);\n        }\n        finally {\n            if (!this.queryRunner) {\n                await queryRunner.release();\n            }\n        }\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}