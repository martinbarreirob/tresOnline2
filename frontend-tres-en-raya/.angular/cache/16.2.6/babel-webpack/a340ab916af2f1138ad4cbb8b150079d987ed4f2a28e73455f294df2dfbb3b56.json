{"ast":null,"code":"import { FindRelationsNotFoundError } from \"../error\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\nimport { EntityPropertyNotFoundError } from \"../error\";\n/**\n * Utilities to work with FindOptions.\n */\nexport class FindOptionsUtils {\n  // -------------------------------------------------------------------------\n  // Public Static Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Checks if given object is really instance of FindOneOptions interface.\n   */\n  static isFindOneOptions(obj) {\n    const possibleOptions = obj;\n    return possibleOptions && (Array.isArray(possibleOptions.select) || Array.isArray(possibleOptions.relations) || typeof possibleOptions.select === \"object\" || typeof possibleOptions.relations === \"object\" || typeof possibleOptions.where === \"object\" ||\n    // typeof possibleOptions.where === \"string\" ||\n    typeof possibleOptions.join === \"object\" || typeof possibleOptions.order === \"object\" || typeof possibleOptions.cache === \"object\" || typeof possibleOptions.cache === \"boolean\" || typeof possibleOptions.cache === \"number\" || typeof possibleOptions.comment === \"string\" || typeof possibleOptions.lock === \"object\" || typeof possibleOptions.loadRelationIds === \"object\" || typeof possibleOptions.loadRelationIds === \"boolean\" || typeof possibleOptions.loadEagerRelations === \"boolean\" || typeof possibleOptions.withDeleted === \"boolean\" || typeof possibleOptions.relationLoadStrategy === \"string\" || typeof possibleOptions.transaction === \"boolean\");\n  }\n  /**\n   * Checks if given object is really instance of FindManyOptions interface.\n   */\n  static isFindManyOptions(obj) {\n    const possibleOptions = obj;\n    return possibleOptions && (this.isFindOneOptions(possibleOptions) || typeof possibleOptions.skip === \"number\" || typeof possibleOptions.take === \"number\" || typeof possibleOptions.skip === \"string\" || typeof possibleOptions.take === \"string\");\n  }\n  /**\n   * Checks if given object is really instance of FindOptions interface.\n   */\n  static extractFindManyOptionsAlias(object) {\n    if (this.isFindManyOptions(object) && object.join) return object.join.alias;\n    return undefined;\n  }\n  /**\n   * Applies give find many options to the given query builder.\n   static applyFindManyOptionsOrConditionsToQueryBuilder<T>(qb: SelectQueryBuilder<T>, options: FindManyOptions<T>|Partial<T>|undefined): SelectQueryBuilder<T> {\n      if (this.isFindManyOptions(options))\n          return this.applyOptionsToQueryBuilder(qb, options);\n       if (options)\n          return qb.where(options);\n       return qb;\n  }*/\n  /**\n   * Applies give find options to the given query builder.\n   static applyOptionsToQueryBuilder<T>(qb: SelectQueryBuilder<T>, options: FindOneOptions<T>|FindManyOptions<T>|undefined): SelectQueryBuilder<T> {\n       // if options are not set then simply return query builder. This is made for simplicity of usage.\n      if (!options || (!this.isFindOneOptions(options) && !this.isFindManyOptions(options)))\n          return qb;\n       if (options.transaction === true) {\n          qb.expressionMap.useTransaction = true;\n      }\n       if (!qb.expressionMap.mainAlias || !qb.expressionMap.mainAlias.hasMetadata)\n          return qb;\n       const metadata = qb.expressionMap.mainAlias!.metadata;\n       // apply all options from FindOptions\n      if (options.comment) {\n          qb.comment(options.comment);\n      }\n       if (options.withDeleted) {\n          qb.withDeleted();\n      }\n       if (options.select) {\n          qb.select([]);\n          options.select.forEach(select => {\n              if (!metadata.hasColumnWithPropertyPath(`${select}`))\n                  throw new TypeORMError(`${select} column was not found in the ${metadata.name} entity.`);\n               const columns = metadata.findColumnsWithPropertyPath(`${select}`);\n               for (const column of columns) {\n                  qb.addSelect(qb.alias + \".\" + column.propertyPath);\n              }\n          });\n      }\n       if (options.relations) {\n          // Copy because `applyRelationsRecursively` modifies it\n          const allRelations = [...options.relations];\n          this.applyRelationsRecursively(qb, allRelations, qb.expressionMap.mainAlias!.name, qb.expressionMap.mainAlias!.metadata, \"\");\n          // recursive removes found relations from allRelations array\n          // if there are relations left in this array it means those relations were not found in the entity structure\n          // so, we give an exception about not found relations\n          if (allRelations.length > 0)\n              throw new FindRelationsNotFoundError(allRelations);\n      }\n       if (options.join) {\n          if (options.join.leftJoin)\n              Object.keys(options.join.leftJoin).forEach(key => {\n                  qb.leftJoin(options.join!.leftJoin![key], key);\n              });\n           if (options.join.innerJoin)\n              Object.keys(options.join.innerJoin).forEach(key => {\n                  qb.innerJoin(options.join!.innerJoin![key], key);\n              });\n           if (options.join.leftJoinAndSelect)\n              Object.keys(options.join.leftJoinAndSelect).forEach(key => {\n                  qb.leftJoinAndSelect(options.join!.leftJoinAndSelect![key], key);\n              });\n           if (options.join.innerJoinAndSelect)\n              Object.keys(options.join.innerJoinAndSelect).forEach(key => {\n                  qb.innerJoinAndSelect(options.join!.innerJoinAndSelect![key], key);\n              });\n      }\n       if (options.cache) {\n          if (options.cache instanceof Object) {\n              const cache = options.cache as { id: any, milliseconds: number };\n              qb.cache(cache.id, cache.milliseconds);\n          } else {\n              qb.cache(options.cache);\n          }\n      }\n       if (options.lock) {\n          if (options.lock.mode === \"optimistic\") {\n              qb.setLock(options.lock.mode, options.lock.version);\n          } else if (\n              options.lock.mode === \"pessimistic_read\" ||\n              options.lock.mode === \"pessimistic_write\" ||\n              options.lock.mode === \"dirty_read\" ||\n              options.lock.mode === \"pessimistic_partial_write\" ||\n              options.lock.mode === \"pessimistic_write_or_fail\" ||\n              options.lock.mode === \"for_no_key_update\" ||\n              options.lock.mode === \"for_key_share\"\n          ) {\n              const tableNames = options.lock.tables ? options.lock.tables.map((table) => {\n                  const tableAlias = qb.expressionMap.aliases.find((alias) => {\n                      return alias.metadata.tableNameWithoutPrefix === table;\n                  });\n                  if (!tableAlias) {\n                      throw new TypeORMError(`\"${table}\" is not part of this query`);\n                  }\n                  return qb.escape(tableAlias.name);\n              }) : undefined;\n              qb.setLock(options.lock.mode, undefined, tableNames);\n          }\n      }\n       if (options.loadRelationIds === true) {\n          qb.loadAllRelationIds();\n       } else if (options.loadRelationIds instanceof Object) {\n          qb.loadAllRelationIds(options.loadRelationIds as any);\n      }\n       if (options.where)\n          qb.where(options.where);\n       if ((options as FindManyOptions<T>).skip)\n          qb.skip((options as FindManyOptions<T>).skip!);\n       if ((options as FindManyOptions<T>).take)\n          qb.take((options as FindManyOptions<T>).take!);\n       if (options.order)\n          Object.keys(options.order).forEach(key => {\n              const order = ((options as FindOneOptions<T>).order as any)[key as any];\n               if (!metadata.findColumnWithPropertyPath(key))\n                  throw new Error(`${key} column was not found in the ${metadata.name} entity.`);\n               switch (order) {\n                  case 1:\n                      qb.addOrderBy(qb.alias + \".\" + key, \"ASC\");\n                      break;\n                  case -1:\n                      qb.addOrderBy(qb.alias + \".\" + key, \"DESC\");\n                      break;\n                  case \"ASC\":\n                      qb.addOrderBy(qb.alias + \".\" + key, \"ASC\");\n                      break;\n                  case \"DESC\":\n                      qb.addOrderBy(qb.alias + \".\" + key, \"DESC\");\n                      break;\n              }\n          });\n       return qb;\n  }*/\n  static applyOptionsToTreeQueryBuilder(qb, options) {\n    if (options === null || options === void 0 ? void 0 : options.relations) {\n      // Copy because `applyRelationsRecursively` modifies it\n      const allRelations = [...options.relations];\n      FindOptionsUtils.applyRelationsRecursively(qb, allRelations, qb.expressionMap.mainAlias.name, qb.expressionMap.mainAlias.metadata, \"\");\n      // recursive removes found relations from allRelations array\n      // if there are relations left in this array it means those relations were not found in the entity structure\n      // so, we give an exception about not found relations\n      if (allRelations.length > 0) throw new FindRelationsNotFoundError(allRelations);\n    }\n    return qb;\n  }\n  // -------------------------------------------------------------------------\n  // Protected Static Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Adds joins for all relations and sub-relations of the given relations provided in the find options.\n   */\n  static applyRelationsRecursively(qb, allRelations, alias, metadata, prefix) {\n    // find all relations that match given prefix\n    let matchedBaseRelations = [];\n    if (prefix) {\n      const regexp = new RegExp(\"^\" + prefix.replace(\".\", \"\\\\.\") + \"\\\\.\");\n      matchedBaseRelations = allRelations.filter(relation => relation.match(regexp)).map(relation => metadata.findRelationWithPropertyPath(relation.replace(regexp, \"\"))).filter(entity => entity);\n    } else {\n      matchedBaseRelations = allRelations.map(relation => metadata.findRelationWithPropertyPath(relation)).filter(entity => entity);\n    }\n    // go through all matched relations and add join for them\n    matchedBaseRelations.forEach(relation => {\n      // generate a relation alias\n      let relationAlias = DriverUtils.buildAlias(qb.connection.driver, {\n        joiner: \"__\"\n      }, alias, relation.propertyPath);\n      // add a join for the found relation\n      const selection = alias + \".\" + relation.propertyPath;\n      if (qb.expressionMap.relationLoadStrategy === \"query\") {\n        qb.concatRelationMetadata(relation);\n      } else {\n        qb.leftJoinAndSelect(selection, relationAlias);\n      }\n      // remove added relations from the allRelations array, this is needed to find all not found relations at the end\n      allRelations.splice(allRelations.indexOf(prefix ? prefix + \".\" + relation.propertyPath : relation.propertyPath), 1);\n      // try to find sub-relations\n      let relationMetadata;\n      let relationName;\n      if (qb.expressionMap.relationLoadStrategy === \"query\") {\n        relationMetadata = relation.inverseEntityMetadata;\n        relationName = relationAlias;\n      } else {\n        const join = qb.expressionMap.joinAttributes.find(join => join.entityOrProperty === selection);\n        relationMetadata = join.metadata;\n        relationName = join.alias.name;\n      }\n      if (!relationName || !relationMetadata) {\n        throw new EntityPropertyNotFoundError(relation.propertyPath, metadata);\n      }\n      this.applyRelationsRecursively(qb, allRelations, relationName, relationMetadata, prefix ? prefix + \".\" + relation.propertyPath : relation.propertyPath);\n      // join the eager relations of the found relation\n      // Only supported for \"join\" relationLoadStrategy\n      if (qb.expressionMap.relationLoadStrategy === \"join\") {\n        const relMetadata = metadata.relations.find(metadata => metadata.propertyName === relation.propertyPath);\n        if (relMetadata) {\n          this.joinEagerRelations(qb, relationAlias, relMetadata.inverseEntityMetadata);\n        }\n      }\n    });\n  }\n  static joinEagerRelations(qb, alias, metadata) {\n    metadata.eagerRelations.forEach(relation => {\n      // generate a relation alias\n      let relationAlias = DriverUtils.buildAlias(qb.connection.driver, {\n        joiner: \"__\"\n      }, alias, relation.propertyPath);\n      // add a join for the relation\n      // Checking whether the relation wasn't joined yet.\n      let addJoin = true;\n      // TODO: Review this validation\n      for (const join of qb.expressionMap.joinAttributes) {\n        if (join.condition !== undefined || join.mapToProperty !== undefined || join.isMappingMany !== undefined || join.direction !== \"LEFT\" || join.entityOrProperty !== `${alias}.${relation.propertyPath}`) {\n          continue;\n        }\n        addJoin = false;\n        relationAlias = join.alias.name;\n        break;\n      }\n      const joinAlreadyAdded = Boolean(qb.expressionMap.joinAttributes.find(joinAttribute => joinAttribute.alias.name === relationAlias));\n      if (addJoin && !joinAlreadyAdded) {\n        qb.leftJoin(alias + \".\" + relation.propertyPath, relationAlias);\n      }\n      // Checking whether the relation wasn't selected yet.\n      // This check shall be after the join check to detect relationAlias.\n      let addSelect = true;\n      for (const select of qb.expressionMap.selects) {\n        if (select.aliasName !== undefined || select.virtual !== undefined || select.selection !== relationAlias) {\n          continue;\n        }\n        addSelect = false;\n        break;\n      }\n      if (addSelect) {\n        qb.addSelect(relationAlias);\n      }\n      // (recursive) join the eager relations\n      this.joinEagerRelations(qb, relationAlias, relation.inverseEntityMetadata);\n    });\n  }\n}","map":{"version":3,"names":["FindRelationsNotFoundError","DriverUtils","EntityPropertyNotFoundError","FindOptionsUtils","isFindOneOptions","obj","possibleOptions","Array","isArray","select","relations","where","join","order","cache","comment","lock","loadRelationIds","loadEagerRelations","withDeleted","relationLoadStrategy","transaction","isFindManyOptions","skip","take","extractFindManyOptionsAlias","object","alias","undefined","applyOptionsToTreeQueryBuilder","qb","options","allRelations","applyRelationsRecursively","expressionMap","mainAlias","name","metadata","length","prefix","matchedBaseRelations","regexp","RegExp","replace","filter","relation","match","map","findRelationWithPropertyPath","entity","forEach","relationAlias","buildAlias","connection","driver","joiner","propertyPath","selection","concatRelationMetadata","leftJoinAndSelect","splice","indexOf","relationMetadata","relationName","inverseEntityMetadata","joinAttributes","find","entityOrProperty","relMetadata","propertyName","joinEagerRelations","eagerRelations","addJoin","condition","mapToProperty","isMappingMany","direction","joinAlreadyAdded","Boolean","joinAttribute","leftJoin","addSelect","selects","aliasName","virtual"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/find-options/FindOptionsUtils.js"],"sourcesContent":["import { FindRelationsNotFoundError } from \"../error\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\nimport { EntityPropertyNotFoundError } from \"../error\";\n/**\n * Utilities to work with FindOptions.\n */\nexport class FindOptionsUtils {\n    // -------------------------------------------------------------------------\n    // Public Static Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Checks if given object is really instance of FindOneOptions interface.\n     */\n    static isFindOneOptions(obj) {\n        const possibleOptions = obj;\n        return (possibleOptions &&\n            (Array.isArray(possibleOptions.select) ||\n                Array.isArray(possibleOptions.relations) ||\n                typeof possibleOptions.select === \"object\" ||\n                typeof possibleOptions.relations === \"object\" ||\n                typeof possibleOptions.where === \"object\" ||\n                // typeof possibleOptions.where === \"string\" ||\n                typeof possibleOptions.join === \"object\" ||\n                typeof possibleOptions.order === \"object\" ||\n                typeof possibleOptions.cache === \"object\" ||\n                typeof possibleOptions.cache === \"boolean\" ||\n                typeof possibleOptions.cache === \"number\" ||\n                typeof possibleOptions.comment === \"string\" ||\n                typeof possibleOptions.lock === \"object\" ||\n                typeof possibleOptions.loadRelationIds === \"object\" ||\n                typeof possibleOptions.loadRelationIds === \"boolean\" ||\n                typeof possibleOptions.loadEagerRelations === \"boolean\" ||\n                typeof possibleOptions.withDeleted === \"boolean\" ||\n                typeof possibleOptions.relationLoadStrategy === \"string\" ||\n                typeof possibleOptions.transaction === \"boolean\"));\n    }\n    /**\n     * Checks if given object is really instance of FindManyOptions interface.\n     */\n    static isFindManyOptions(obj) {\n        const possibleOptions = obj;\n        return (possibleOptions &&\n            (this.isFindOneOptions(possibleOptions) ||\n                typeof possibleOptions.skip ===\n                    \"number\" ||\n                typeof possibleOptions.take ===\n                    \"number\" ||\n                typeof possibleOptions.skip ===\n                    \"string\" ||\n                typeof possibleOptions.take ===\n                    \"string\"));\n    }\n    /**\n     * Checks if given object is really instance of FindOptions interface.\n     */\n    static extractFindManyOptionsAlias(object) {\n        if (this.isFindManyOptions(object) && object.join)\n            return object.join.alias;\n        return undefined;\n    }\n    /**\n     * Applies give find many options to the given query builder.\n\n    static applyFindManyOptionsOrConditionsToQueryBuilder<T>(qb: SelectQueryBuilder<T>, options: FindManyOptions<T>|Partial<T>|undefined): SelectQueryBuilder<T> {\n        if (this.isFindManyOptions(options))\n            return this.applyOptionsToQueryBuilder(qb, options);\n\n        if (options)\n            return qb.where(options);\n\n        return qb;\n    }*/\n    /**\n     * Applies give find options to the given query builder.\n\n    static applyOptionsToQueryBuilder<T>(qb: SelectQueryBuilder<T>, options: FindOneOptions<T>|FindManyOptions<T>|undefined): SelectQueryBuilder<T> {\n\n        // if options are not set then simply return query builder. This is made for simplicity of usage.\n        if (!options || (!this.isFindOneOptions(options) && !this.isFindManyOptions(options)))\n            return qb;\n\n        if (options.transaction === true) {\n            qb.expressionMap.useTransaction = true;\n        }\n\n        if (!qb.expressionMap.mainAlias || !qb.expressionMap.mainAlias.hasMetadata)\n            return qb;\n\n        const metadata = qb.expressionMap.mainAlias!.metadata;\n\n        // apply all options from FindOptions\n        if (options.comment) {\n            qb.comment(options.comment);\n        }\n\n        if (options.withDeleted) {\n            qb.withDeleted();\n        }\n\n        if (options.select) {\n            qb.select([]);\n            options.select.forEach(select => {\n                if (!metadata.hasColumnWithPropertyPath(`${select}`))\n                    throw new TypeORMError(`${select} column was not found in the ${metadata.name} entity.`);\n\n                const columns = metadata.findColumnsWithPropertyPath(`${select}`);\n\n                for (const column of columns) {\n                    qb.addSelect(qb.alias + \".\" + column.propertyPath);\n                }\n            });\n        }\n\n        if (options.relations) {\n            // Copy because `applyRelationsRecursively` modifies it\n            const allRelations = [...options.relations];\n            this.applyRelationsRecursively(qb, allRelations, qb.expressionMap.mainAlias!.name, qb.expressionMap.mainAlias!.metadata, \"\");\n            // recursive removes found relations from allRelations array\n            // if there are relations left in this array it means those relations were not found in the entity structure\n            // so, we give an exception about not found relations\n            if (allRelations.length > 0)\n                throw new FindRelationsNotFoundError(allRelations);\n        }\n\n        if (options.join) {\n            if (options.join.leftJoin)\n                Object.keys(options.join.leftJoin).forEach(key => {\n                    qb.leftJoin(options.join!.leftJoin![key], key);\n                });\n\n            if (options.join.innerJoin)\n                Object.keys(options.join.innerJoin).forEach(key => {\n                    qb.innerJoin(options.join!.innerJoin![key], key);\n                });\n\n            if (options.join.leftJoinAndSelect)\n                Object.keys(options.join.leftJoinAndSelect).forEach(key => {\n                    qb.leftJoinAndSelect(options.join!.leftJoinAndSelect![key], key);\n                });\n\n            if (options.join.innerJoinAndSelect)\n                Object.keys(options.join.innerJoinAndSelect).forEach(key => {\n                    qb.innerJoinAndSelect(options.join!.innerJoinAndSelect![key], key);\n                });\n        }\n\n        if (options.cache) {\n            if (options.cache instanceof Object) {\n                const cache = options.cache as { id: any, milliseconds: number };\n                qb.cache(cache.id, cache.milliseconds);\n            } else {\n                qb.cache(options.cache);\n            }\n        }\n\n        if (options.lock) {\n            if (options.lock.mode === \"optimistic\") {\n                qb.setLock(options.lock.mode, options.lock.version);\n            } else if (\n                options.lock.mode === \"pessimistic_read\" ||\n                options.lock.mode === \"pessimistic_write\" ||\n                options.lock.mode === \"dirty_read\" ||\n                options.lock.mode === \"pessimistic_partial_write\" ||\n                options.lock.mode === \"pessimistic_write_or_fail\" ||\n                options.lock.mode === \"for_no_key_update\" ||\n                options.lock.mode === \"for_key_share\"\n            ) {\n                const tableNames = options.lock.tables ? options.lock.tables.map((table) => {\n                    const tableAlias = qb.expressionMap.aliases.find((alias) => {\n                        return alias.metadata.tableNameWithoutPrefix === table;\n                    });\n                    if (!tableAlias) {\n                        throw new TypeORMError(`\"${table}\" is not part of this query`);\n                    }\n                    return qb.escape(tableAlias.name);\n                }) : undefined;\n                qb.setLock(options.lock.mode, undefined, tableNames);\n            }\n        }\n\n        if (options.loadRelationIds === true) {\n            qb.loadAllRelationIds();\n\n        } else if (options.loadRelationIds instanceof Object) {\n            qb.loadAllRelationIds(options.loadRelationIds as any);\n        }\n\n        if (options.where)\n            qb.where(options.where);\n\n        if ((options as FindManyOptions<T>).skip)\n            qb.skip((options as FindManyOptions<T>).skip!);\n\n        if ((options as FindManyOptions<T>).take)\n            qb.take((options as FindManyOptions<T>).take!);\n\n        if (options.order)\n            Object.keys(options.order).forEach(key => {\n                const order = ((options as FindOneOptions<T>).order as any)[key as any];\n\n                if (!metadata.findColumnWithPropertyPath(key))\n                    throw new Error(`${key} column was not found in the ${metadata.name} entity.`);\n\n                switch (order) {\n                    case 1:\n                        qb.addOrderBy(qb.alias + \".\" + key, \"ASC\");\n                        break;\n                    case -1:\n                        qb.addOrderBy(qb.alias + \".\" + key, \"DESC\");\n                        break;\n                    case \"ASC\":\n                        qb.addOrderBy(qb.alias + \".\" + key, \"ASC\");\n                        break;\n                    case \"DESC\":\n                        qb.addOrderBy(qb.alias + \".\" + key, \"DESC\");\n                        break;\n                }\n            });\n\n        return qb;\n    }*/\n    static applyOptionsToTreeQueryBuilder(qb, options) {\n        if (options === null || options === void 0 ? void 0 : options.relations) {\n            // Copy because `applyRelationsRecursively` modifies it\n            const allRelations = [...options.relations];\n            FindOptionsUtils.applyRelationsRecursively(qb, allRelations, qb.expressionMap.mainAlias.name, qb.expressionMap.mainAlias.metadata, \"\");\n            // recursive removes found relations from allRelations array\n            // if there are relations left in this array it means those relations were not found in the entity structure\n            // so, we give an exception about not found relations\n            if (allRelations.length > 0)\n                throw new FindRelationsNotFoundError(allRelations);\n        }\n        return qb;\n    }\n    // -------------------------------------------------------------------------\n    // Protected Static Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Adds joins for all relations and sub-relations of the given relations provided in the find options.\n     */\n    static applyRelationsRecursively(qb, allRelations, alias, metadata, prefix) {\n        // find all relations that match given prefix\n        let matchedBaseRelations = [];\n        if (prefix) {\n            const regexp = new RegExp(\"^\" + prefix.replace(\".\", \"\\\\.\") + \"\\\\.\");\n            matchedBaseRelations = allRelations\n                .filter((relation) => relation.match(regexp))\n                .map((relation) => metadata.findRelationWithPropertyPath(relation.replace(regexp, \"\")))\n                .filter((entity) => entity);\n        }\n        else {\n            matchedBaseRelations = allRelations\n                .map((relation) => metadata.findRelationWithPropertyPath(relation))\n                .filter((entity) => entity);\n        }\n        // go through all matched relations and add join for them\n        matchedBaseRelations.forEach((relation) => {\n            // generate a relation alias\n            let relationAlias = DriverUtils.buildAlias(qb.connection.driver, { joiner: \"__\" }, alias, relation.propertyPath);\n            // add a join for the found relation\n            const selection = alias + \".\" + relation.propertyPath;\n            if (qb.expressionMap.relationLoadStrategy === \"query\") {\n                qb.concatRelationMetadata(relation);\n            }\n            else {\n                qb.leftJoinAndSelect(selection, relationAlias);\n            }\n            // remove added relations from the allRelations array, this is needed to find all not found relations at the end\n            allRelations.splice(allRelations.indexOf(prefix\n                ? prefix + \".\" + relation.propertyPath\n                : relation.propertyPath), 1);\n            // try to find sub-relations\n            let relationMetadata;\n            let relationName;\n            if (qb.expressionMap.relationLoadStrategy === \"query\") {\n                relationMetadata = relation.inverseEntityMetadata;\n                relationName = relationAlias;\n            }\n            else {\n                const join = qb.expressionMap.joinAttributes.find((join) => join.entityOrProperty === selection);\n                relationMetadata = join.metadata;\n                relationName = join.alias.name;\n            }\n            if (!relationName || !relationMetadata) {\n                throw new EntityPropertyNotFoundError(relation.propertyPath, metadata);\n            }\n            this.applyRelationsRecursively(qb, allRelations, relationName, relationMetadata, prefix\n                ? prefix + \".\" + relation.propertyPath\n                : relation.propertyPath);\n            // join the eager relations of the found relation\n            // Only supported for \"join\" relationLoadStrategy\n            if (qb.expressionMap.relationLoadStrategy === \"join\") {\n                const relMetadata = metadata.relations.find((metadata) => metadata.propertyName === relation.propertyPath);\n                if (relMetadata) {\n                    this.joinEagerRelations(qb, relationAlias, relMetadata.inverseEntityMetadata);\n                }\n            }\n        });\n    }\n    static joinEagerRelations(qb, alias, metadata) {\n        metadata.eagerRelations.forEach((relation) => {\n            // generate a relation alias\n            let relationAlias = DriverUtils.buildAlias(qb.connection.driver, { joiner: \"__\" }, alias, relation.propertyPath);\n            // add a join for the relation\n            // Checking whether the relation wasn't joined yet.\n            let addJoin = true;\n            // TODO: Review this validation\n            for (const join of qb.expressionMap.joinAttributes) {\n                if (join.condition !== undefined ||\n                    join.mapToProperty !== undefined ||\n                    join.isMappingMany !== undefined ||\n                    join.direction !== \"LEFT\" ||\n                    join.entityOrProperty !==\n                        `${alias}.${relation.propertyPath}`) {\n                    continue;\n                }\n                addJoin = false;\n                relationAlias = join.alias.name;\n                break;\n            }\n            const joinAlreadyAdded = Boolean(qb.expressionMap.joinAttributes.find((joinAttribute) => joinAttribute.alias.name === relationAlias));\n            if (addJoin && !joinAlreadyAdded) {\n                qb.leftJoin(alias + \".\" + relation.propertyPath, relationAlias);\n            }\n            // Checking whether the relation wasn't selected yet.\n            // This check shall be after the join check to detect relationAlias.\n            let addSelect = true;\n            for (const select of qb.expressionMap.selects) {\n                if (select.aliasName !== undefined ||\n                    select.virtual !== undefined ||\n                    select.selection !== relationAlias) {\n                    continue;\n                }\n                addSelect = false;\n                break;\n            }\n            if (addSelect) {\n                qb.addSelect(relationAlias);\n            }\n            // (recursive) join the eager relations\n            this.joinEagerRelations(qb, relationAlias, relation.inverseEntityMetadata);\n        });\n    }\n}\n\n"],"mappings":"AAAA,SAASA,0BAA0B,QAAQ,UAAU;AACrD,SAASC,WAAW,QAAQ,uBAAuB;AACnD,SAASC,2BAA2B,QAAQ,UAAU;AACtD;AACA;AACA;AACA,OAAO,MAAMC,gBAAgB,CAAC;EAC1B;EACA;EACA;EACA;AACJ;AACA;EACI,OAAOC,gBAAgBA,CAACC,GAAG,EAAE;IACzB,MAAMC,eAAe,GAAGD,GAAG;IAC3B,OAAQC,eAAe,KAClBC,KAAK,CAACC,OAAO,CAACF,eAAe,CAACG,MAAM,CAAC,IAClCF,KAAK,CAACC,OAAO,CAACF,eAAe,CAACI,SAAS,CAAC,IACxC,OAAOJ,eAAe,CAACG,MAAM,KAAK,QAAQ,IAC1C,OAAOH,eAAe,CAACI,SAAS,KAAK,QAAQ,IAC7C,OAAOJ,eAAe,CAACK,KAAK,KAAK,QAAQ;IACzC;IACA,OAAOL,eAAe,CAACM,IAAI,KAAK,QAAQ,IACxC,OAAON,eAAe,CAACO,KAAK,KAAK,QAAQ,IACzC,OAAOP,eAAe,CAACQ,KAAK,KAAK,QAAQ,IACzC,OAAOR,eAAe,CAACQ,KAAK,KAAK,SAAS,IAC1C,OAAOR,eAAe,CAACQ,KAAK,KAAK,QAAQ,IACzC,OAAOR,eAAe,CAACS,OAAO,KAAK,QAAQ,IAC3C,OAAOT,eAAe,CAACU,IAAI,KAAK,QAAQ,IACxC,OAAOV,eAAe,CAACW,eAAe,KAAK,QAAQ,IACnD,OAAOX,eAAe,CAACW,eAAe,KAAK,SAAS,IACpD,OAAOX,eAAe,CAACY,kBAAkB,KAAK,SAAS,IACvD,OAAOZ,eAAe,CAACa,WAAW,KAAK,SAAS,IAChD,OAAOb,eAAe,CAACc,oBAAoB,KAAK,QAAQ,IACxD,OAAOd,eAAe,CAACe,WAAW,KAAK,SAAS,CAAC;EAC7D;EACA;AACJ;AACA;EACI,OAAOC,iBAAiBA,CAACjB,GAAG,EAAE;IAC1B,MAAMC,eAAe,GAAGD,GAAG;IAC3B,OAAQC,eAAe,KAClB,IAAI,CAACF,gBAAgB,CAACE,eAAe,CAAC,IACnC,OAAOA,eAAe,CAACiB,IAAI,KACvB,QAAQ,IACZ,OAAOjB,eAAe,CAACkB,IAAI,KACvB,QAAQ,IACZ,OAAOlB,eAAe,CAACiB,IAAI,KACvB,QAAQ,IACZ,OAAOjB,eAAe,CAACkB,IAAI,KACvB,QAAQ,CAAC;EACzB;EACA;AACJ;AACA;EACI,OAAOC,2BAA2BA,CAACC,MAAM,EAAE;IACvC,IAAI,IAAI,CAACJ,iBAAiB,CAACI,MAAM,CAAC,IAAIA,MAAM,CAACd,IAAI,EAC7C,OAAOc,MAAM,CAACd,IAAI,CAACe,KAAK;IAC5B,OAAOC,SAAS;EACpB;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EAII;AACJ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;EA2BI,OAAOC,8BAA8BA,CAACC,EAAE,EAAEC,OAAO,EAAE;IAC/C,IAAIA,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACrB,SAAS,EAAE;MACrE;MACA,MAAMsB,YAAY,GAAG,CAAC,GAAGD,OAAO,CAACrB,SAAS,CAAC;MAC3CP,gBAAgB,CAAC8B,yBAAyB,CAACH,EAAE,EAAEE,YAAY,EAAEF,EAAE,CAACI,aAAa,CAACC,SAA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"},"metadata":{},"sourceType":"module","externalDependencies":[]}