{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/practicas/Downloads/angular/tresOnline/frontend-tres-en-raya/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { BroadcasterResult } from \"./BroadcasterResult\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\n/**\n * Broadcaster provides a helper methods to broadcast events to the subscribers.\n */\nexport class Broadcaster {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(queryRunner) {\n    this.queryRunner = queryRunner;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  broadcast(event, ...args) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const result = new BroadcasterResult();\n      const broadcastFunction = _this[`broadcast${event}Event`];\n      if (typeof broadcastFunction === \"function\") {\n        ;\n        broadcastFunction.call(_this, result, ...args);\n      }\n      yield result.wait();\n    })();\n  }\n  /**\n   * Broadcasts \"BEFORE_INSERT\" event.\n   * Before insert event is executed before entity is being inserted to the database for the first time.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n  broadcastBeforeInsertEvent(result, metadata, entity) {\n    if (entity && metadata.beforeInsertListeners.length) {\n      metadata.beforeInsertListeners.forEach(listener => {\n        if (listener.isAllowed(entity)) {\n          const executionResult = listener.execute(entity);\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeInsert) {\n          const executionResult = subscriber.beforeInsert({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager,\n            entity: entity,\n            metadata: metadata\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"BEFORE_UPDATE\" event.\n   * Before update event is executed before entity is being updated in the database.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n  broadcastBeforeUpdateEvent(result, metadata, entity, databaseEntity, updatedColumns, updatedRelations) {\n    // todo: send relations too?\n    if (entity && metadata.beforeUpdateListeners.length) {\n      metadata.beforeUpdateListeners.forEach(listener => {\n        if (listener.isAllowed(entity)) {\n          const executionResult = listener.execute(entity);\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeUpdate) {\n          const executionResult = subscriber.beforeUpdate({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager,\n            entity: entity,\n            metadata: metadata,\n            databaseEntity: databaseEntity,\n            updatedColumns: updatedColumns || [],\n            updatedRelations: updatedRelations || []\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"BEFORE_REMOVE\" event.\n   * Before remove event is executed before entity is being removed from the database.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n  broadcastBeforeRemoveEvent(result, metadata, entity, databaseEntity, identifier) {\n    if (entity && metadata.beforeRemoveListeners.length) {\n      metadata.beforeRemoveListeners.forEach(listener => {\n        if (listener.isAllowed(entity)) {\n          const executionResult = listener.execute(entity);\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeRemove) {\n          const executionResult = subscriber.beforeRemove({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager,\n            entity: entity,\n            metadata: metadata,\n            databaseEntity: databaseEntity,\n            entityId: metadata.getEntityIdMixedMap(databaseEntity !== null && databaseEntity !== void 0 ? databaseEntity : identifier)\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"BEFORE_SOFT_REMOVE\" event.\n   * Before soft remove event is executed before entity is being soft removed from the database.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n  broadcastBeforeSoftRemoveEvent(result, metadata, entity, databaseEntity, identifier) {\n    if (entity && metadata.beforeSoftRemoveListeners.length) {\n      metadata.beforeSoftRemoveListeners.forEach(listener => {\n        if (listener.isAllowed(entity)) {\n          const executionResult = listener.execute(entity);\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeSoftRemove) {\n          const executionResult = subscriber.beforeSoftRemove({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager,\n            entity: entity,\n            metadata: metadata,\n            databaseEntity: databaseEntity,\n            entityId: metadata.getEntityIdMixedMap(databaseEntity !== null && databaseEntity !== void 0 ? databaseEntity : identifier)\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"BEFORE_RECOVER\" event.\n   * Before recover event is executed before entity is being recovered in the database.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n  broadcastBeforeRecoverEvent(result, metadata, entity, databaseEntity, identifier) {\n    if (entity && metadata.beforeRecoverListeners.length) {\n      metadata.beforeRecoverListeners.forEach(listener => {\n        if (listener.isAllowed(entity)) {\n          const executionResult = listener.execute(entity);\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.beforeRecover) {\n          const executionResult = subscriber.beforeRecover({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager,\n            entity: entity,\n            metadata: metadata,\n            databaseEntity: databaseEntity,\n            entityId: metadata.getEntityIdMixedMap(databaseEntity !== null && databaseEntity !== void 0 ? databaseEntity : identifier)\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"AFTER_INSERT\" event.\n   * After insert event is executed after entity is being persisted to the database for the first time.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n  broadcastAfterInsertEvent(result, metadata, entity) {\n    if (entity && metadata.afterInsertListeners.length) {\n      metadata.afterInsertListeners.forEach(listener => {\n        if (listener.isAllowed(entity)) {\n          const executionResult = listener.execute(entity);\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterInsert) {\n          const executionResult = subscriber.afterInsert({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager,\n            entity: entity,\n            metadata: metadata\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"BEFORE_TRANSACTION_START\" event.\n   */\n  broadcastBeforeTransactionStartEvent(result) {\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (subscriber.beforeTransactionStart) {\n          const executionResult = subscriber.beforeTransactionStart({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"AFTER_TRANSACTION_START\" event.\n   */\n  broadcastAfterTransactionStartEvent(result) {\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (subscriber.afterTransactionStart) {\n          const executionResult = subscriber.afterTransactionStart({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"BEFORE_TRANSACTION_COMMIT\" event.\n   */\n  broadcastBeforeTransactionCommitEvent(result) {\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (subscriber.beforeTransactionCommit) {\n          const executionResult = subscriber.beforeTransactionCommit({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"AFTER_TRANSACTION_COMMIT\" event.\n   */\n  broadcastAfterTransactionCommitEvent(result) {\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (subscriber.afterTransactionCommit) {\n          const executionResult = subscriber.afterTransactionCommit({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"BEFORE_TRANSACTION_ROLLBACK\" event.\n   */\n  broadcastBeforeTransactionRollbackEvent(result) {\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (subscriber.beforeTransactionRollback) {\n          const executionResult = subscriber.beforeTransactionRollback({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"AFTER_TRANSACTION_ROLLBACK\" event.\n   */\n  broadcastAfterTransactionRollbackEvent(result) {\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (subscriber.afterTransactionRollback) {\n          const executionResult = subscriber.afterTransactionRollback({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"AFTER_UPDATE\" event.\n   * After update event is executed after entity is being updated in the database.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n  broadcastAfterUpdateEvent(result, metadata, entity, databaseEntity, updatedColumns, updatedRelations) {\n    if (entity && metadata.afterUpdateListeners.length) {\n      metadata.afterUpdateListeners.forEach(listener => {\n        if (listener.isAllowed(entity)) {\n          const executionResult = listener.execute(entity);\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterUpdate) {\n          const executionResult = subscriber.afterUpdate({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager,\n            entity: entity,\n            metadata: metadata,\n            databaseEntity: databaseEntity,\n            updatedColumns: updatedColumns || [],\n            updatedRelations: updatedRelations || []\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"AFTER_REMOVE\" event.\n   * After remove event is executed after entity is being removed from the database.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n  broadcastAfterRemoveEvent(result, metadata, entity, databaseEntity, identifier) {\n    if (entity && metadata.afterRemoveListeners.length) {\n      metadata.afterRemoveListeners.forEach(listener => {\n        if (listener.isAllowed(entity)) {\n          const executionResult = listener.execute(entity);\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterRemove) {\n          const executionResult = subscriber.afterRemove({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager,\n            entity: entity,\n            metadata: metadata,\n            databaseEntity: databaseEntity,\n            entityId: metadata.getEntityIdMixedMap(databaseEntity !== null && databaseEntity !== void 0 ? databaseEntity : identifier)\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"AFTER_SOFT_REMOVE\" event.\n   * After soft remove event is executed after entity is being soft removed from the database.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n  broadcastAfterSoftRemoveEvent(result, metadata, entity, databaseEntity, identifier) {\n    if (entity && metadata.afterSoftRemoveListeners.length) {\n      metadata.afterSoftRemoveListeners.forEach(listener => {\n        if (listener.isAllowed(entity)) {\n          const executionResult = listener.execute(entity);\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterSoftRemove) {\n          const executionResult = subscriber.afterSoftRemove({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager,\n            entity: entity,\n            metadata: metadata,\n            databaseEntity: databaseEntity,\n            entityId: metadata.getEntityIdMixedMap(databaseEntity !== null && databaseEntity !== void 0 ? databaseEntity : identifier)\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * Broadcasts \"AFTER_RECOVER\" event.\n   * After recover event is executed after entity is being recovered in the database.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n  broadcastAfterRecoverEvent(result, metadata, entity, databaseEntity, identifier) {\n    if (entity && metadata.afterRecoverListeners.length) {\n      metadata.afterRecoverListeners.forEach(listener => {\n        if (listener.isAllowed(entity)) {\n          const executionResult = listener.execute(entity);\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n    if (this.queryRunner.connection.subscribers.length) {\n      this.queryRunner.connection.subscribers.forEach(subscriber => {\n        if (this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterRecover) {\n          const executionResult = subscriber.afterRecover({\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager,\n            entity: entity,\n            metadata: metadata,\n            databaseEntity: databaseEntity,\n            entityId: metadata.getEntityIdMixedMap(databaseEntity !== null && databaseEntity !== void 0 ? databaseEntity : identifier)\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        }\n      });\n    }\n  }\n  /**\n   * @deprecated Use `broadcastLoadForAllEvent`\n   */\n  broadcastLoadEventsForAll(result, metadata, entities) {\n    return this.broadcastLoadEvent(result, metadata, entities);\n  }\n  /**\n   * Broadcasts \"AFTER_LOAD\" event for all given entities, and their sub-entities.\n   * After load event is executed after entity has been loaded from the database.\n   * All subscribers and entity listeners who listened to this event will be executed at this point.\n   * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n   *\n   * Note: this method has a performance-optimized code organization, do not change code structure.\n   */\n  broadcastLoadEvent(result, metadata, entities) {\n    // Calculate which subscribers are fitting for the given entity type\n    const fittingSubscribers = this.queryRunner.connection.subscribers.filter(subscriber => this.isAllowedSubscriber(subscriber, metadata.target) && subscriber.afterLoad);\n    if (metadata.relations.length || metadata.afterLoadListeners.length || fittingSubscribers.length) {\n      // todo: check why need this?\n      const nonPromiseEntities = entities.filter(entity => !(entity instanceof Promise));\n      // collect load events for all children entities that were loaded with the main entity\n      if (metadata.relations.length) {\n        metadata.relations.forEach(relation => {\n          nonPromiseEntities.forEach(entity => {\n            // in lazy relations we cannot simply access to entity property because it will cause a getter and a database query\n            if (relation.isLazy && !entity.hasOwnProperty(relation.propertyName)) return;\n            const value = relation.getEntityValue(entity);\n            if (ObjectUtils.isObject(value)) this.broadcastLoadEvent(result, relation.inverseEntityMetadata, Array.isArray(value) ? value : [value]);\n          });\n        });\n      }\n      if (metadata.afterLoadListeners.length) {\n        metadata.afterLoadListeners.forEach(listener => {\n          nonPromiseEntities.forEach(entity => {\n            if (listener.isAllowed(entity)) {\n              const executionResult = listener.execute(entity);\n              if (executionResult instanceof Promise) result.promises.push(executionResult);\n              result.count++;\n            }\n          });\n        });\n      }\n      fittingSubscribers.forEach(subscriber => {\n        nonPromiseEntities.forEach(entity => {\n          const executionResult = subscriber.afterLoad(entity, {\n            entity,\n            metadata,\n            connection: this.queryRunner.connection,\n            queryRunner: this.queryRunner,\n            manager: this.queryRunner.manager\n          });\n          if (executionResult instanceof Promise) result.promises.push(executionResult);\n          result.count++;\n        });\n      });\n    }\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Checks if subscriber's methods can be executed by checking if its don't listen to the particular entity,\n   * or listens our entity.\n   */\n  isAllowedSubscriber(subscriber, target) {\n    return !subscriber.listenTo || !subscriber.listenTo() || subscriber.listenTo() === Object || subscriber.listenTo() === target || subscriber.listenTo().isPrototypeOf(target);\n  }\n}","map":{"version":3,"names":["BroadcasterResult","ObjectUtils","Broadcaster","constructor","queryRunner","broadcast","event","args","_this","_asyncToGenerator","result","broadcastFunction","call","wait","broadcastBeforeInsertEvent","metadata","entity","beforeInsertListeners","length","forEach","listener","isAllowed","executionResult","execute","Promise","promises","push","count","connection","subscribers","subscriber","isAllowedSubscriber","target","beforeInsert","manager","broadcastBeforeUpdateEvent","databaseEntity","updatedColumns","updatedRelations","beforeUpdateListeners","beforeUpdate","broadcastBeforeRemoveEvent","identifier","beforeRemoveListeners","beforeRemove","entityId","getEntityIdMixedMap","broadcastBeforeSoftRemoveEvent","beforeSoftRemoveListeners","beforeSoftRemove","broadcastBeforeRecoverEvent","beforeRecoverListeners","beforeRecover","broadcastAfterInsertEvent","afterInsertListeners","afterInsert","broadcastBeforeTransactionStartEvent","beforeTransactionStart","broadcastAfterTransactionStartEvent","afterTransactionStart","broadcastBeforeTransactionCommitEvent","beforeTransactionCommit","broadcastAfterTransactionCommitEvent","afterTransactionCommit","broadcastBeforeTransactionRollbackEvent","beforeTransactionRollback","broadcastAfterTransactionRollbackEvent","afterTransactionRollback","broadcastAfterUpdateEvent","afterUpdateListeners","afterUpdate","broadcastAfterRemoveEvent","afterRemoveListeners","afterRemove","broadcastAfterSoftRemoveEvent","afterSoftRemoveListeners","afterSoftRemove","broadcastAfterRecoverEvent","afterRecoverListeners","afterRecover","broadcastLoadEventsForAll","entities","broadcastLoadEvent","fittingSubscribers","filter","afterLoad","relations","afterLoadListeners","nonPromiseEntities","relation","isLazy","hasOwnProperty","propertyName","value","getEntityValue","isObject","inverseEntityMetadata","Array","isArray","listenTo","Object","isPrototypeOf"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/subscriber/Broadcaster.js"],"sourcesContent":["import { BroadcasterResult } from \"./BroadcasterResult\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\n/**\n * Broadcaster provides a helper methods to broadcast events to the subscribers.\n */\nexport class Broadcaster {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n    constructor(queryRunner) {\n        this.queryRunner = queryRunner;\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    async broadcast(event, ...args) {\n        const result = new BroadcasterResult();\n        const broadcastFunction = this[`broadcast${event}Event`];\n        if (typeof broadcastFunction === \"function\") {\n            ;\n            broadcastFunction.call(this, result, ...args);\n        }\n        await result.wait();\n    }\n    /**\n     * Broadcasts \"BEFORE_INSERT\" event.\n     * Before insert event is executed before entity is being inserted to the database for the first time.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastBeforeInsertEvent(result, metadata, entity) {\n        if (entity && metadata.beforeInsertListeners.length) {\n            metadata.beforeInsertListeners.forEach((listener) => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity);\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (this.isAllowedSubscriber(subscriber, metadata.target) &&\n                    subscriber.beforeInsert) {\n                    const executionResult = subscriber.beforeInsert({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n    /**\n     * Broadcasts \"BEFORE_UPDATE\" event.\n     * Before update event is executed before entity is being updated in the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastBeforeUpdateEvent(result, metadata, entity, databaseEntity, updatedColumns, updatedRelations) {\n        // todo: send relations too?\n        if (entity && metadata.beforeUpdateListeners.length) {\n            metadata.beforeUpdateListeners.forEach((listener) => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity);\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (this.isAllowedSubscriber(subscriber, metadata.target) &&\n                    subscriber.beforeUpdate) {\n                    const executionResult = subscriber.beforeUpdate({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                        databaseEntity: databaseEntity,\n                        updatedColumns: updatedColumns || [],\n                        updatedRelations: updatedRelations || [],\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n    /**\n     * Broadcasts \"BEFORE_REMOVE\" event.\n     * Before remove event is executed before entity is being removed from the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastBeforeRemoveEvent(result, metadata, entity, databaseEntity, identifier) {\n        if (entity && metadata.beforeRemoveListeners.length) {\n            metadata.beforeRemoveListeners.forEach((listener) => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity);\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (this.isAllowedSubscriber(subscriber, metadata.target) &&\n                    subscriber.beforeRemove) {\n                    const executionResult = subscriber.beforeRemove({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                        databaseEntity: databaseEntity,\n                        entityId: metadata.getEntityIdMixedMap(databaseEntity !== null && databaseEntity !== void 0 ? databaseEntity : identifier),\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n    /**\n     * Broadcasts \"BEFORE_SOFT_REMOVE\" event.\n     * Before soft remove event is executed before entity is being soft removed from the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastBeforeSoftRemoveEvent(result, metadata, entity, databaseEntity, identifier) {\n        if (entity && metadata.beforeSoftRemoveListeners.length) {\n            metadata.beforeSoftRemoveListeners.forEach((listener) => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity);\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (this.isAllowedSubscriber(subscriber, metadata.target) &&\n                    subscriber.beforeSoftRemove) {\n                    const executionResult = subscriber.beforeSoftRemove({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                        databaseEntity: databaseEntity,\n                        entityId: metadata.getEntityIdMixedMap(databaseEntity !== null && databaseEntity !== void 0 ? databaseEntity : identifier),\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n    /**\n     * Broadcasts \"BEFORE_RECOVER\" event.\n     * Before recover event is executed before entity is being recovered in the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastBeforeRecoverEvent(result, metadata, entity, databaseEntity, identifier) {\n        if (entity && metadata.beforeRecoverListeners.length) {\n            metadata.beforeRecoverListeners.forEach((listener) => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity);\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (this.isAllowedSubscriber(subscriber, metadata.target) &&\n                    subscriber.beforeRecover) {\n                    const executionResult = subscriber.beforeRecover({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                        databaseEntity: databaseEntity,\n                        entityId: metadata.getEntityIdMixedMap(databaseEntity !== null && databaseEntity !== void 0 ? databaseEntity : identifier),\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n    /**\n     * Broadcasts \"AFTER_INSERT\" event.\n     * After insert event is executed after entity is being persisted to the database for the first time.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastAfterInsertEvent(result, metadata, entity) {\n        if (entity && metadata.afterInsertListeners.length) {\n            metadata.afterInsertListeners.forEach((listener) => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity);\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (this.isAllowedSubscriber(subscriber, metadata.target) &&\n                    subscriber.afterInsert) {\n                    const executionResult = subscriber.afterInsert({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n    /**\n     * Broadcasts \"BEFORE_TRANSACTION_START\" event.\n     */\n    broadcastBeforeTransactionStartEvent(result) {\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (subscriber.beforeTransactionStart) {\n                    const executionResult = subscriber.beforeTransactionStart({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n    /**\n     * Broadcasts \"AFTER_TRANSACTION_START\" event.\n     */\n    broadcastAfterTransactionStartEvent(result) {\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (subscriber.afterTransactionStart) {\n                    const executionResult = subscriber.afterTransactionStart({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n    /**\n     * Broadcasts \"BEFORE_TRANSACTION_COMMIT\" event.\n     */\n    broadcastBeforeTransactionCommitEvent(result) {\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (subscriber.beforeTransactionCommit) {\n                    const executionResult = subscriber.beforeTransactionCommit({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n    /**\n     * Broadcasts \"AFTER_TRANSACTION_COMMIT\" event.\n     */\n    broadcastAfterTransactionCommitEvent(result) {\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (subscriber.afterTransactionCommit) {\n                    const executionResult = subscriber.afterTransactionCommit({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n    /**\n     * Broadcasts \"BEFORE_TRANSACTION_ROLLBACK\" event.\n     */\n    broadcastBeforeTransactionRollbackEvent(result) {\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (subscriber.beforeTransactionRollback) {\n                    const executionResult = subscriber.beforeTransactionRollback({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n    /**\n     * Broadcasts \"AFTER_TRANSACTION_ROLLBACK\" event.\n     */\n    broadcastAfterTransactionRollbackEvent(result) {\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (subscriber.afterTransactionRollback) {\n                    const executionResult = subscriber.afterTransactionRollback({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n    /**\n     * Broadcasts \"AFTER_UPDATE\" event.\n     * After update event is executed after entity is being updated in the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastAfterUpdateEvent(result, metadata, entity, databaseEntity, updatedColumns, updatedRelations) {\n        if (entity && metadata.afterUpdateListeners.length) {\n            metadata.afterUpdateListeners.forEach((listener) => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity);\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (this.isAllowedSubscriber(subscriber, metadata.target) &&\n                    subscriber.afterUpdate) {\n                    const executionResult = subscriber.afterUpdate({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                        databaseEntity: databaseEntity,\n                        updatedColumns: updatedColumns || [],\n                        updatedRelations: updatedRelations || [],\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n    /**\n     * Broadcasts \"AFTER_REMOVE\" event.\n     * After remove event is executed after entity is being removed from the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastAfterRemoveEvent(result, metadata, entity, databaseEntity, identifier) {\n        if (entity && metadata.afterRemoveListeners.length) {\n            metadata.afterRemoveListeners.forEach((listener) => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity);\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (this.isAllowedSubscriber(subscriber, metadata.target) &&\n                    subscriber.afterRemove) {\n                    const executionResult = subscriber.afterRemove({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                        databaseEntity: databaseEntity,\n                        entityId: metadata.getEntityIdMixedMap(databaseEntity !== null && databaseEntity !== void 0 ? databaseEntity : identifier),\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n    /**\n     * Broadcasts \"AFTER_SOFT_REMOVE\" event.\n     * After soft remove event is executed after entity is being soft removed from the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastAfterSoftRemoveEvent(result, metadata, entity, databaseEntity, identifier) {\n        if (entity && metadata.afterSoftRemoveListeners.length) {\n            metadata.afterSoftRemoveListeners.forEach((listener) => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity);\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (this.isAllowedSubscriber(subscriber, metadata.target) &&\n                    subscriber.afterSoftRemove) {\n                    const executionResult = subscriber.afterSoftRemove({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                        databaseEntity: databaseEntity,\n                        entityId: metadata.getEntityIdMixedMap(databaseEntity !== null && databaseEntity !== void 0 ? databaseEntity : identifier),\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n    /**\n     * Broadcasts \"AFTER_RECOVER\" event.\n     * After recover event is executed after entity is being recovered in the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastAfterRecoverEvent(result, metadata, entity, databaseEntity, identifier) {\n        if (entity && metadata.afterRecoverListeners.length) {\n            metadata.afterRecoverListeners.forEach((listener) => {\n                if (listener.isAllowed(entity)) {\n                    const executionResult = listener.execute(entity);\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n        if (this.queryRunner.connection.subscribers.length) {\n            this.queryRunner.connection.subscribers.forEach((subscriber) => {\n                if (this.isAllowedSubscriber(subscriber, metadata.target) &&\n                    subscriber.afterRecover) {\n                    const executionResult = subscriber.afterRecover({\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                        entity: entity,\n                        metadata: metadata,\n                        databaseEntity: databaseEntity,\n                        entityId: metadata.getEntityIdMixedMap(databaseEntity !== null && databaseEntity !== void 0 ? databaseEntity : identifier),\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                }\n            });\n        }\n    }\n    /**\n     * @deprecated Use `broadcastLoadForAllEvent`\n     */\n    broadcastLoadEventsForAll(result, metadata, entities) {\n        return this.broadcastLoadEvent(result, metadata, entities);\n    }\n    /**\n     * Broadcasts \"AFTER_LOAD\" event for all given entities, and their sub-entities.\n     * After load event is executed after entity has been loaded from the database.\n     * All subscribers and entity listeners who listened to this event will be executed at this point.\n     * Subscribers and entity listeners can return promises, it will wait until they are resolved.\n     *\n     * Note: this method has a performance-optimized code organization, do not change code structure.\n     */\n    broadcastLoadEvent(result, metadata, entities) {\n        // Calculate which subscribers are fitting for the given entity type\n        const fittingSubscribers = this.queryRunner.connection.subscribers.filter((subscriber) => this.isAllowedSubscriber(subscriber, metadata.target) &&\n            subscriber.afterLoad);\n        if (metadata.relations.length ||\n            metadata.afterLoadListeners.length ||\n            fittingSubscribers.length) {\n            // todo: check why need this?\n            const nonPromiseEntities = entities.filter((entity) => !(entity instanceof Promise));\n            // collect load events for all children entities that were loaded with the main entity\n            if (metadata.relations.length) {\n                metadata.relations.forEach((relation) => {\n                    nonPromiseEntities.forEach((entity) => {\n                        // in lazy relations we cannot simply access to entity property because it will cause a getter and a database query\n                        if (relation.isLazy &&\n                            !entity.hasOwnProperty(relation.propertyName))\n                            return;\n                        const value = relation.getEntityValue(entity);\n                        if (ObjectUtils.isObject(value))\n                            this.broadcastLoadEvent(result, relation.inverseEntityMetadata, Array.isArray(value) ? value : [value]);\n                    });\n                });\n            }\n            if (metadata.afterLoadListeners.length) {\n                metadata.afterLoadListeners.forEach((listener) => {\n                    nonPromiseEntities.forEach((entity) => {\n                        if (listener.isAllowed(entity)) {\n                            const executionResult = listener.execute(entity);\n                            if (executionResult instanceof Promise)\n                                result.promises.push(executionResult);\n                            result.count++;\n                        }\n                    });\n                });\n            }\n            fittingSubscribers.forEach((subscriber) => {\n                nonPromiseEntities.forEach((entity) => {\n                    const executionResult = subscriber.afterLoad(entity, {\n                        entity,\n                        metadata,\n                        connection: this.queryRunner.connection,\n                        queryRunner: this.queryRunner,\n                        manager: this.queryRunner.manager,\n                    });\n                    if (executionResult instanceof Promise)\n                        result.promises.push(executionResult);\n                    result.count++;\n                });\n            });\n        }\n    }\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Checks if subscriber's methods can be executed by checking if its don't listen to the particular entity,\n     * or listens our entity.\n     */\n    isAllowedSubscriber(subscriber, target) {\n        return (!subscriber.listenTo ||\n            !subscriber.listenTo() ||\n            subscriber.listenTo() === Object ||\n            subscriber.listenTo() === target ||\n            subscriber.listenTo().isPrototypeOf(target));\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}