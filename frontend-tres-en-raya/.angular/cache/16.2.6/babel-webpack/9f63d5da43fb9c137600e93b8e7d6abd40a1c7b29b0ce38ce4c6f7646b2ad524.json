{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/practicas/Downloads/angular/tresOnline/frontend-tres-en-raya/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { EntityNotFoundError } from \"../error/EntityNotFoundError\";\nimport { QueryRunnerProviderAlreadyReleasedError } from \"../error/QueryRunnerProviderAlreadyReleasedError\";\nimport { NoNeedToReleaseEntityManagerError } from \"../error/NoNeedToReleaseEntityManagerError\";\nimport { MongoRepository } from \"../repository/MongoRepository\";\nimport { TreeRepository } from \"../repository/TreeRepository\";\nimport { Repository } from \"../repository/Repository\";\nimport { FindOptionsUtils } from \"../find-options/FindOptionsUtils\";\nimport { PlainObjectToNewEntityTransformer } from \"../query-builder/transformer/PlainObjectToNewEntityTransformer\";\nimport { PlainObjectToDatabaseEntityTransformer } from \"../query-builder/transformer/PlainObjectToDatabaseEntityTransformer\";\nimport { CustomRepositoryCannotInheritRepositoryError, CustomRepositoryNotFoundError, TreeRepositoryNotSupportedError, TypeORMError } from \"../error\";\nimport { AbstractRepository } from \"../repository/AbstractRepository\";\nimport { EntityPersistExecutor } from \"../persistence/EntityPersistExecutor\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\nimport { getMetadataArgsStorage } from \"../globals\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\n/**\n * Entity manager supposed to work with any entity, automatically find its repository and call its methods,\n * whatever entity type are you passing.\n */\nexport class EntityManager {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection, queryRunner) {\n    this[\"@instanceof\"] = Symbol.for(\"EntityManager\");\n    // -------------------------------------------------------------------------\n    // Protected Properties\n    // -------------------------------------------------------------------------\n    /**\n     * Once created and then reused by repositories.\n     * Created as a future replacement for the #repositories to provide a bit more perf optimization.\n     */\n    this.repositories = new Map();\n    /**\n     * Once created and then reused by repositories.\n     */\n    this.treeRepositories = [];\n    /**\n     * Plain to object transformer used in create and merge operations.\n     */\n    this.plainObjectToEntityTransformer = new PlainObjectToNewEntityTransformer();\n    this.connection = connection;\n    if (queryRunner) {\n      this.queryRunner = queryRunner;\n      // dynamic: this.queryRunner = manager;\n      ObjectUtils.assign(this.queryRunner, {\n        manager: this\n      });\n    }\n  }\n  /**\n   * Wraps given function execution (and all operations made there) in a transaction.\n   * All database operations must be executed using provided entity manager.\n   */\n  transaction(isolationOrRunInTransaction, runInTransactionParam) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const isolation = typeof isolationOrRunInTransaction === \"string\" ? isolationOrRunInTransaction : undefined;\n      const runInTransaction = typeof isolationOrRunInTransaction === \"function\" ? isolationOrRunInTransaction : runInTransactionParam;\n      if (!runInTransaction) {\n        throw new TypeORMError(`Transaction method requires callback in second parameter if isolation level is supplied.`);\n      }\n      if (_this.queryRunner && _this.queryRunner.isReleased) throw new QueryRunnerProviderAlreadyReleasedError();\n      // if query runner is already defined in this class, it means this entity manager was already created for a single connection\n      // if its not defined we create a new query runner - single connection where we'll execute all our operations\n      const queryRunner = _this.queryRunner || _this.connection.createQueryRunner();\n      try {\n        yield queryRunner.startTransaction(isolation);\n        const result = yield runInTransaction(queryRunner.manager);\n        yield queryRunner.commitTransaction();\n        return result;\n      } catch (err) {\n        try {\n          // we throw original error even if rollback thrown an error\n          yield queryRunner.rollbackTransaction();\n        } catch (rollbackError) {}\n        throw err;\n      } finally {\n        if (!_this.queryRunner)\n          // if we used a new query runner provider then release it\n          yield queryRunner.release();\n      }\n    })();\n  }\n  /**\n   * Executes raw SQL query and returns raw database results.\n   */\n  query(query, parameters) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      return _this2.connection.query(query, parameters, _this2.queryRunner);\n    })();\n  }\n  /**\n   * Creates a new query builder that can be used to build a SQL query.\n   */\n  createQueryBuilder(entityClass, alias, queryRunner) {\n    if (alias) {\n      return this.connection.createQueryBuilder(entityClass, alias, queryRunner || this.queryRunner);\n    } else {\n      return this.connection.createQueryBuilder(entityClass || queryRunner || this.queryRunner);\n    }\n  }\n  /**\n   * Checks if entity has an id by its Function type or schema name.\n   */\n  hasId(targetOrEntity, maybeEntity) {\n    const target = arguments.length === 2 ? targetOrEntity : targetOrEntity.constructor;\n    const entity = arguments.length === 2 ? maybeEntity : targetOrEntity;\n    const metadata = this.connection.getMetadata(target);\n    return metadata.hasId(entity);\n  }\n  /**\n   * Gets entity mixed id.\n   */\n  getId(targetOrEntity, maybeEntity) {\n    const target = arguments.length === 2 ? targetOrEntity : targetOrEntity.constructor;\n    const entity = arguments.length === 2 ? maybeEntity : targetOrEntity;\n    const metadata = this.connection.getMetadata(target);\n    return metadata.getEntityIdMixedMap(entity);\n  }\n  /**\n   * Creates a new entity instance or instances.\n   * Can copy properties from the given object into new entities.\n   */\n  create(entityClass, plainObjectOrObjects) {\n    const metadata = this.connection.getMetadata(entityClass);\n    if (!plainObjectOrObjects) return metadata.create(this.queryRunner);\n    if (Array.isArray(plainObjectOrObjects)) return plainObjectOrObjects.map(plainEntityLike => this.create(entityClass, plainEntityLike));\n    const mergeIntoEntity = metadata.create(this.queryRunner);\n    this.plainObjectToEntityTransformer.transform(mergeIntoEntity, plainObjectOrObjects, metadata, true);\n    return mergeIntoEntity;\n  }\n  /**\n   * Merges two entities into one new entity.\n   */\n  merge(entityClass, mergeIntoEntity, ...entityLikes) {\n    // todo: throw exception if entity manager is released\n    const metadata = this.connection.getMetadata(entityClass);\n    entityLikes.forEach(object => this.plainObjectToEntityTransformer.transform(mergeIntoEntity, object, metadata));\n    return mergeIntoEntity;\n  }\n  /**\n   * Creates a new entity from the given plain javascript object. If entity already exist in the database, then\n   * it loads it (and everything related to it), replaces all values with the new ones from the given object\n   * and returns this new entity. This new entity is actually a loaded from the db entity with all properties\n   * replaced from the new object.\n   */\n  preload(entityClass, entityLike) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const metadata = _this3.connection.getMetadata(entityClass);\n      const plainObjectToDatabaseEntityTransformer = new PlainObjectToDatabaseEntityTransformer(_this3.connection.manager);\n      const transformedEntity = yield plainObjectToDatabaseEntityTransformer.transform(entityLike, metadata);\n      if (transformedEntity) return _this3.merge(entityClass, transformedEntity, entityLike);\n      return undefined;\n    })();\n  }\n  /**\n   * Saves a given entity in the database.\n   */\n  save(targetOrEntity, maybeEntityOrOptions, maybeOptions) {\n    // normalize mixed parameters\n    let target = arguments.length > 1 && (typeof targetOrEntity === \"function\" || InstanceChecker.isEntitySchema(targetOrEntity) || typeof targetOrEntity === \"string\") ? targetOrEntity : undefined;\n    const entity = target ? maybeEntityOrOptions : targetOrEntity;\n    const options = target ? maybeOptions : maybeEntityOrOptions;\n    if (InstanceChecker.isEntitySchema(target)) target = target.options.name;\n    // if user passed empty array of entities then we don't need to do anything\n    if (Array.isArray(entity) && entity.length === 0) return Promise.resolve(entity);\n    // execute save operation\n    return new EntityPersistExecutor(this.connection, this.queryRunner, \"save\", target, entity, options).execute().then(() => entity);\n  }\n  /**\n   * Removes a given entity from the database.\n   */\n  remove(targetOrEntity, maybeEntityOrOptions, maybeOptions) {\n    // normalize mixed parameters\n    const target = arguments.length > 1 && (typeof targetOrEntity === \"function\" || InstanceChecker.isEntitySchema(targetOrEntity) || typeof targetOrEntity === \"string\") ? targetOrEntity : undefined;\n    const entity = target ? maybeEntityOrOptions : targetOrEntity;\n    const options = target ? maybeOptions : maybeEntityOrOptions;\n    // if user passed empty array of entities then we don't need to do anything\n    if (Array.isArray(entity) && entity.length === 0) return Promise.resolve(entity);\n    // execute save operation\n    return new EntityPersistExecutor(this.connection, this.queryRunner, \"remove\", target, entity, options).execute().then(() => entity);\n  }\n  /**\n   * Records the delete date of one or many given entities.\n   */\n  softRemove(targetOrEntity, maybeEntityOrOptions, maybeOptions) {\n    // normalize mixed parameters\n    let target = arguments.length > 1 && (typeof targetOrEntity === \"function\" || InstanceChecker.isEntitySchema(targetOrEntity) || typeof targetOrEntity === \"string\") ? targetOrEntity : undefined;\n    const entity = target ? maybeEntityOrOptions : targetOrEntity;\n    const options = target ? maybeOptions : maybeEntityOrOptions;\n    if (InstanceChecker.isEntitySchema(target)) target = target.options.name;\n    // if user passed empty array of entities then we don't need to do anything\n    if (Array.isArray(entity) && entity.length === 0) return Promise.resolve(entity);\n    // execute soft-remove operation\n    return new EntityPersistExecutor(this.connection, this.queryRunner, \"soft-remove\", target, entity, options).execute().then(() => entity);\n  }\n  /**\n   * Recovers one or many given entities.\n   */\n  recover(targetOrEntity, maybeEntityOrOptions, maybeOptions) {\n    // normalize mixed parameters\n    let target = arguments.length > 1 && (typeof targetOrEntity === \"function\" || InstanceChecker.isEntitySchema(targetOrEntity) || typeof targetOrEntity === \"string\") ? targetOrEntity : undefined;\n    const entity = target ? maybeEntityOrOptions : targetOrEntity;\n    const options = target ? maybeOptions : maybeEntityOrOptions;\n    if (InstanceChecker.isEntitySchema(target)) target = target.options.name;\n    // if user passed empty array of entities then we don't need to do anything\n    if (Array.isArray(entity) && entity.length === 0) return Promise.resolve(entity);\n    // execute recover operation\n    return new EntityPersistExecutor(this.connection, this.queryRunner, \"recover\", target, entity, options).execute().then(() => entity);\n  }\n  /**\n   * Inserts a given entity into the database.\n   * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n   * Executes fast and efficient INSERT query.\n   * Does not check if entity exist in the database, so query will fail if duplicate entity is being inserted.\n   * You can execute bulk inserts using this method.\n   */\n  insert(target, entity) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      return _this4.createQueryBuilder().insert().into(target).values(entity).execute();\n    })();\n  }\n  upsert(target, entityOrEntities, conflictPathsOrOptions) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const metadata = _this5.connection.getMetadata(target);\n      let options;\n      if (Array.isArray(conflictPathsOrOptions)) {\n        options = {\n          conflictPaths: conflictPathsOrOptions\n        };\n      } else {\n        options = conflictPathsOrOptions;\n      }\n      let entities;\n      if (!Array.isArray(entityOrEntities)) {\n        entities = [entityOrEntities];\n      } else {\n        entities = entityOrEntities;\n      }\n      const conflictColumns = metadata.mapPropertyPathsToColumns(Array.isArray(options.conflictPaths) ? options.conflictPaths : Object.keys(options.conflictPaths));\n      const overwriteColumns = metadata.columns.filter(col => !conflictColumns.includes(col) && entities.some(entity => typeof col.getEntityValue(entity) !== \"undefined\"));\n      return _this5.createQueryBuilder().insert().into(target).values(entities).orUpdate([...conflictColumns, ...overwriteColumns].map(col => col.databaseName), conflictColumns.map(col => col.databaseName), {\n        skipUpdateIfNoValuesChanged: options.skipUpdateIfNoValuesChanged,\n        indexPredicate: options.indexPredicate,\n        upsertType: options.upsertType || _this5.connection.driver.supportedUpsertTypes[0]\n      }).execute();\n    })();\n  }\n  /**\n   * Updates entity partially. Entity can be found by a given condition(s).\n   * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n   * Executes fast and efficient UPDATE query.\n   * Does not check if entity exist in the database.\n   * Condition(s) cannot be empty.\n   */\n  update(target, criteria, partialEntity) {\n    // if user passed empty criteria or empty list of criterias, then throw an error\n    if (criteria === undefined || criteria === null || criteria === \"\" || Array.isArray(criteria) && criteria.length === 0) {\n      return Promise.reject(new TypeORMError(`Empty criteria(s) are not allowed for the update method.`));\n    }\n    if (typeof criteria === \"string\" || typeof criteria === \"number\" || criteria instanceof Date || Array.isArray(criteria)) {\n      return this.createQueryBuilder().update(target).set(partialEntity).whereInIds(criteria).execute();\n    } else {\n      return this.createQueryBuilder().update(target).set(partialEntity).where(criteria).execute();\n    }\n  }\n  /**\n   * Deletes entities by a given condition(s).\n   * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n   * Executes fast and efficient DELETE query.\n   * Does not check if entity exist in the database.\n   * Condition(s) cannot be empty.\n   */\n  delete(targetOrEntity, criteria) {\n    // if user passed empty criteria or empty list of criterias, then throw an error\n    if (criteria === undefined || criteria === null || criteria === \"\" || Array.isArray(criteria) && criteria.length === 0) {\n      return Promise.reject(new TypeORMError(`Empty criteria(s) are not allowed for the delete method.`));\n    }\n    if (typeof criteria === \"string\" || typeof criteria === \"number\" || criteria instanceof Date || Array.isArray(criteria)) {\n      return this.createQueryBuilder().delete().from(targetOrEntity).whereInIds(criteria).execute();\n    } else {\n      return this.createQueryBuilder().delete().from(targetOrEntity).where(criteria).execute();\n    }\n  }\n  /**\n   * Records the delete date of entities by a given condition(s).\n   * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n   * Executes fast and efficient DELETE query.\n   * Does not check if entity exist in the database.\n   * Condition(s) cannot be empty.\n   */\n  softDelete(targetOrEntity, criteria) {\n    // if user passed empty criteria or empty list of criterias, then throw an error\n    if (criteria === undefined || criteria === null || criteria === \"\" || Array.isArray(criteria) && criteria.length === 0) {\n      return Promise.reject(new TypeORMError(`Empty criteria(s) are not allowed for the delete method.`));\n    }\n    if (typeof criteria === \"string\" || typeof criteria === \"number\" || criteria instanceof Date || Array.isArray(criteria)) {\n      return this.createQueryBuilder().softDelete().from(targetOrEntity).whereInIds(criteria).execute();\n    } else {\n      return this.createQueryBuilder().softDelete().from(targetOrEntity).where(criteria).execute();\n    }\n  }\n  /**\n   * Restores entities by a given condition(s).\n   * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n   * Executes fast and efficient DELETE query.\n   * Does not check if entity exist in the database.\n   * Condition(s) cannot be empty.\n   */\n  restore(targetOrEntity, criteria) {\n    // if user passed empty criteria or empty list of criterias, then throw an error\n    if (criteria === undefined || criteria === null || criteria === \"\" || Array.isArray(criteria) && criteria.length === 0) {\n      return Promise.reject(new TypeORMError(`Empty criteria(s) are not allowed for the delete method.`));\n    }\n    if (typeof criteria === \"string\" || typeof criteria === \"number\" || criteria instanceof Date || Array.isArray(criteria)) {\n      return this.createQueryBuilder().restore().from(targetOrEntity).whereInIds(criteria).execute();\n    } else {\n      return this.createQueryBuilder().restore().from(targetOrEntity).where(criteria).execute();\n    }\n  }\n  /**\n   * Checks whether any entity exists with the given condition\n   */\n  exists(entityClass, options) {\n    const metadata = this.connection.getMetadata(entityClass);\n    return this.createQueryBuilder(entityClass, FindOptionsUtils.extractFindManyOptionsAlias(options) || metadata.name).setFindOptions(options || {}).getExists();\n  }\n  /**\n   * Counts entities that match given options.\n   * Useful for pagination.\n   */\n  count(entityClass, options) {\n    const metadata = this.connection.getMetadata(entityClass);\n    return this.createQueryBuilder(entityClass, FindOptionsUtils.extractFindManyOptionsAlias(options) || metadata.name).setFindOptions(options || {}).getCount();\n  }\n  /**\n   * Counts entities that match given conditions.\n   * Useful for pagination.\n   */\n  countBy(entityClass, where) {\n    const metadata = this.connection.getMetadata(entityClass);\n    return this.createQueryBuilder(entityClass, metadata.name).setFindOptions({\n      where\n    }).getCount();\n  }\n  /**\n   * Return the SUM of a column\n   */\n  sum(entityClass, columnName, where) {\n    return this.callAggregateFun(entityClass, \"SUM\", columnName, where);\n  }\n  /**\n   * Return the AVG of a column\n   */\n  average(entityClass, columnName, where) {\n    return this.callAggregateFun(entityClass, \"AVG\", columnName, where);\n  }\n  /**\n   * Return the MIN of a column\n   */\n  minimum(entityClass, columnName, where) {\n    return this.callAggregateFun(entityClass, \"MIN\", columnName, where);\n  }\n  /**\n   * Return the MAX of a column\n   */\n  maximum(entityClass, columnName, where) {\n    return this.callAggregateFun(entityClass, \"MAX\", columnName, where);\n  }\n  callAggregateFun(entityClass, fnName, columnName, where = {}) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const metadata = _this6.connection.getMetadata(entityClass);\n      const result = yield _this6.createQueryBuilder(entityClass, metadata.name).setFindOptions({\n        where\n      }).select(`${fnName}(${_this6.connection.driver.escape(String(columnName))})`, fnName).getRawOne();\n      return result[fnName] === null ? null : parseFloat(result[fnName]);\n    })();\n  }\n  /**\n   * Finds entities that match given find options.\n   */\n  find(entityClass, options) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      const metadata = _this7.connection.getMetadata(entityClass);\n      return _this7.createQueryBuilder(entityClass, FindOptionsUtils.extractFindManyOptionsAlias(options) || metadata.name).setFindOptions(options || {}).getMany();\n    })();\n  }\n  /**\n   * Finds entities that match given find options.\n   */\n  findBy(entityClass, where) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const metadata = _this8.connection.getMetadata(entityClass);\n      return _this8.createQueryBuilder(entityClass, metadata.name).setFindOptions({\n        where: where\n      }).getMany();\n    })();\n  }\n  /**\n   * Finds entities that match given find options.\n   * Also counts all entities that match given conditions,\n   * but ignores pagination settings (from and take options).\n   */\n  findAndCount(entityClass, options) {\n    const metadata = this.connection.getMetadata(entityClass);\n    return this.createQueryBuilder(entityClass, FindOptionsUtils.extractFindManyOptionsAlias(options) || metadata.name).setFindOptions(options || {}).getManyAndCount();\n  }\n  /**\n   * Finds entities that match given WHERE conditions.\n   * Also counts all entities that match given conditions,\n   * but ignores pagination settings (from and take options).\n   */\n  findAndCountBy(entityClass, where) {\n    const metadata = this.connection.getMetadata(entityClass);\n    return this.createQueryBuilder(entityClass, metadata.name).setFindOptions({\n      where\n    }).getManyAndCount();\n  }\n  /**\n   * Finds entities with ids.\n   * Optionally find options or conditions can be applied.\n   *\n   * @deprecated use `findBy` method instead in conjunction with `In` operator, for example:\n   *\n   * .findBy({\n   *     id: In([1, 2, 3])\n   * })\n   */\n  findByIds(entityClass, ids) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      // if no ids passed, no need to execute a query - just return an empty array of values\n      if (!ids.length) return Promise.resolve([]);\n      const metadata = _this9.connection.getMetadata(entityClass);\n      return _this9.createQueryBuilder(entityClass, metadata.name).andWhereInIds(ids).getMany();\n    })();\n  }\n  /**\n   * Finds first entity by a given find options.\n   * If entity was not found in the database - returns null.\n   */\n  findOne(entityClass, options) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      const metadata = _this10.connection.getMetadata(entityClass);\n      // prepare alias for built query\n      let alias = metadata.name;\n      if (options && options.join) {\n        alias = options.join.alias;\n      }\n      if (!options.where) {\n        throw new Error(`You must provide selection conditions in order to find a single row.`);\n      }\n      // create query builder and apply find options\n      return _this10.createQueryBuilder(entityClass, alias).setFindOptions({\n        ...options,\n        take: 1\n      }).getOne();\n    })();\n  }\n  /**\n   * Finds first entity that matches given where condition.\n   * If entity was not found in the database - returns null.\n   */\n  findOneBy(entityClass, where) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      const metadata = _this11.connection.getMetadata(entityClass);\n      // create query builder and apply find options\n      return _this11.createQueryBuilder(entityClass, metadata.name).setFindOptions({\n        where,\n        take: 1\n      }).getOne();\n    })();\n  }\n  /**\n   * Finds first entity that matches given id.\n   * If entity was not found in the database - returns null.\n   *\n   * @deprecated use `findOneBy` method instead in conjunction with `In` operator, for example:\n   *\n   * .findOneBy({\n   *     id: 1 // where \"id\" is your primary column name\n   * })\n   */\n  findOneById(entityClass, id) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      const metadata = _this12.connection.getMetadata(entityClass);\n      // create query builder and apply find options\n      return _this12.createQueryBuilder(entityClass, metadata.name).setFindOptions({\n        take: 1\n      }).whereInIds(metadata.ensureEntityIdMap(id)).getOne();\n    })();\n  }\n  /**\n   * Finds first entity by a given find options.\n   * If entity was not found in the database - rejects with error.\n   */\n  findOneOrFail(entityClass, options) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      return _this13.findOne(entityClass, options).then(value => {\n        if (value === null) {\n          return Promise.reject(new EntityNotFoundError(entityClass, options));\n        }\n        return Promise.resolve(value);\n      });\n    })();\n  }\n  /**\n   * Finds first entity that matches given where condition.\n   * If entity was not found in the database - rejects with error.\n   */\n  findOneByOrFail(entityClass, where) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      return _this14.findOneBy(entityClass, where).then(value => {\n        if (value === null) {\n          return Promise.reject(new EntityNotFoundError(entityClass, where));\n        }\n        return Promise.resolve(value);\n      });\n    })();\n  }\n  /**\n   * Clears all the data from the given table (truncates/drops it).\n   *\n   * Note: this method uses TRUNCATE and may not work as you expect in transactions on some platforms.\n   * @see https://stackoverflow.com/a/5972738/925151\n   */\n  clear(entityClass) {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      const metadata = _this15.connection.getMetadata(entityClass);\n      const queryRunner = _this15.queryRunner || _this15.connection.createQueryRunner();\n      try {\n        return yield queryRunner.clearTable(metadata.tablePath); // await is needed here because we are using finally\n      } finally {\n        if (!_this15.queryRunner) yield queryRunner.release();\n      }\n    })();\n  }\n  /**\n   * Increments some column by provided value of the entities matched given conditions.\n   */\n  increment(entityClass, conditions, propertyPath, value) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      const metadata = _this16.connection.getMetadata(entityClass);\n      const column = metadata.findColumnWithPropertyPath(propertyPath);\n      if (!column) throw new TypeORMError(`Column ${propertyPath} was not found in ${metadata.targetName} entity.`);\n      if (isNaN(Number(value))) throw new TypeORMError(`Value \"${value}\" is not a number.`);\n      // convert possible embeded path \"social.likes\" into object { social: { like: () => value } }\n      const values = propertyPath.split(\".\").reduceRight((value, key) => ({\n        [key]: value\n      }), () => _this16.connection.driver.escape(column.databaseName) + \" + \" + value);\n      return _this16.createQueryBuilder(entityClass, \"entity\").update(entityClass).set(values).where(conditions).execute();\n    })();\n  }\n  /**\n   * Decrements some column by provided value of the entities matched given conditions.\n   */\n  decrement(entityClass, conditions, propertyPath, value) {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      const metadata = _this17.connection.getMetadata(entityClass);\n      const column = metadata.findColumnWithPropertyPath(propertyPath);\n      if (!column) throw new TypeORMError(`Column ${propertyPath} was not found in ${metadata.targetName} entity.`);\n      if (isNaN(Number(value))) throw new TypeORMError(`Value \"${value}\" is not a number.`);\n      // convert possible embeded path \"social.likes\" into object { social: { like: () => value } }\n      const values = propertyPath.split(\".\").reduceRight((value, key) => ({\n        [key]: value\n      }), () => _this17.connection.driver.escape(column.databaseName) + \" - \" + value);\n      return _this17.createQueryBuilder(entityClass, \"entity\").update(entityClass).set(values).where(conditions).execute();\n    })();\n  }\n  /**\n   * Gets repository for the given entity class or name.\n   * If single database connection mode is used, then repository is obtained from the\n   * repository aggregator, where each repository is individually created for this entity manager.\n   * When single database connection is not used, repository is being obtained from the connection.\n   */\n  getRepository(target) {\n    // find already created repository instance and return it if found\n    const repoFromMap = this.repositories.get(target);\n    if (repoFromMap) return repoFromMap;\n    // if repository was not found then create it, store its instance and return it\n    if (this.connection.driver.options.type === \"mongodb\") {\n      const newRepository = new MongoRepository(target, this, this.queryRunner);\n      this.repositories.set(target, newRepository);\n      return newRepository;\n    } else {\n      const newRepository = new Repository(target, this, this.queryRunner);\n      this.repositories.set(target, newRepository);\n      return newRepository;\n    }\n  }\n  /**\n   * Gets tree repository for the given entity class or name.\n   * If single database connection mode is used, then repository is obtained from the\n   * repository aggregator, where each repository is individually created for this entity manager.\n   * When single database connection is not used, repository is being obtained from the connection.\n   */\n  getTreeRepository(target) {\n    // tree tables aren't supported by some drivers (mongodb)\n    if (this.connection.driver.treeSupport === false) throw new TreeRepositoryNotSupportedError(this.connection.driver);\n    // find already created repository instance and return it if found\n    const repository = this.treeRepositories.find(repository => repository.target === target);\n    if (repository) return repository;\n    // check if repository is real tree repository\n    const newRepository = new TreeRepository(target, this, this.queryRunner);\n    this.treeRepositories.push(newRepository);\n    return newRepository;\n  }\n  /**\n   * Gets mongodb repository for the given entity class.\n   */\n  getMongoRepository(target) {\n    return this.connection.getMongoRepository(target);\n  }\n  /**\n   * Creates a new repository instance out of a given Repository and\n   * sets current EntityManager instance to it. Used to work with custom repositories\n   * in transactions.\n   */\n  withRepository(repository) {\n    const repositoryConstructor = repository.constructor;\n    const {\n      target,\n      manager,\n      queryRunner,\n      ...otherRepositoryProperties\n    } = repository;\n    return Object.assign(new repositoryConstructor(repository.target, this), {\n      ...otherRepositoryProperties\n    });\n  }\n  /**\n   * Gets custom entity repository marked with @EntityRepository decorator.\n   *\n   * @deprecated use Repository.extend to create custom repositories\n   */\n  getCustomRepository(customRepository) {\n    const entityRepositoryMetadataArgs = getMetadataArgsStorage().entityRepositories.find(repository => {\n      return repository.target === (typeof customRepository === \"function\" ? customRepository : customRepository.constructor);\n    });\n    if (!entityRepositoryMetadataArgs) throw new CustomRepositoryNotFoundError(customRepository);\n    const entityMetadata = entityRepositoryMetadataArgs.entity ? this.connection.getMetadata(entityRepositoryMetadataArgs.entity) : undefined;\n    const entityRepositoryInstance = new entityRepositoryMetadataArgs.target(this, entityMetadata);\n    // NOTE: dynamic access to protected properties. We need this to prevent unwanted properties in those classes to be exposed,\n    // however we need these properties for internal work of the class\n    if (entityRepositoryInstance instanceof AbstractRepository) {\n      if (!entityRepositoryInstance[\"manager\"]) entityRepositoryInstance[\"manager\"] = this;\n    } else {\n      if (!entityMetadata) throw new CustomRepositoryCannotInheritRepositoryError(customRepository);\n      entityRepositoryInstance[\"manager\"] = this;\n      entityRepositoryInstance[\"metadata\"] = entityMetadata;\n    }\n    return entityRepositoryInstance;\n  }\n  /**\n   * Releases all resources used by entity manager.\n   * This is used when entity manager is created with a single query runner,\n   * and this single query runner needs to be released after job with entity manager is done.\n   */\n  release() {\n    var _this18 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this18.queryRunner) throw new NoNeedToReleaseEntityManagerError();\n      return _this18.queryRunner.release();\n    })();\n  }\n}","map":{"version":3,"names":["EntityNotFoundError","QueryRunnerProviderAlreadyReleasedError","NoNeedToReleaseEntityManagerError","MongoRepository","TreeRepository","Repository","FindOptionsUtils","PlainObjectToNewEntityTransformer","PlainObjectToDatabaseEntityTransformer","CustomRepositoryCannotInheritRepositoryError","CustomRepositoryNotFoundError","TreeRepositoryNotSupportedError","TypeORMError","AbstractRepository","EntityPersistExecutor","ObjectUtils","getMetadataArgsStorage","InstanceChecker","EntityManager","constructor","connection","queryRunner","Symbol","for","repositories","Map","treeRepositories","plainObjectToEntityTransformer","assign","manager","transaction","isolationOrRunInTransaction","runInTransactionParam","_this","_asyncToGenerator","isolation","undefined","runInTransaction","isReleased","createQueryRunner","startTransaction","result","commitTransaction","err","rollbackTransaction","rollbackError","release","query","parameters","_this2","createQueryBuilder","entityClass","alias","hasId","targetOrEntity","maybeEntity","target","arguments","length","entity","metadata","getMetadata","getId","getEntityIdMixedMap","create","plainObjectOrObjects","Array","isArray","map","plainEntityLike","mergeIntoEntity","transform","merge","entityLikes","forEach","object","preload","entityLike","_this3","plainObjectToDatabaseEntityTransformer","transformedEntity","save","maybeEntityOrOptions","maybeOptions","isEntitySchema","options","name","Promise","resolve","execute","then","remove","softRemove","recover","insert","_this4","into","values","upsert","entityOrEntities","conflictPathsOrOptions","_this5","conflictPaths","entities","conflictColumns","mapPropertyPathsToColumns","Object","keys","overwriteColumns","columns","filter","col","includes","some","getEntityValue","orUpdate","databaseName","skipUpdateIfNoValuesChanged","indexPredicate","upsertType","driver","supportedUpsertTypes","update","criteria","partialEntity","reject","Date","set","whereInIds","where","delete","from","softDelete","restore","exists","extractFindManyOptionsAlias","setFindOptions","getExists","count","getCount","countBy","sum","columnName","callAggregateFun","average","minimum","maximum","fnName","_this6","select","escape","String","getRawOne","parseFloat","find","_this7","getMany","findBy","_this8","findAndCount","getManyAndCount","findAndCountBy","findByIds","ids","_this9","andWhereInIds","findOne","_this10","join","Error","take","getOne","findOneBy","_this11","findOneById","id","_this12","ensureEntityIdMap","findOneOrFail","_this13","value","findOneByOrFail","_this14","clear","_this15","clearTable","tablePath","increment","conditions","propertyPath","_this16","column","findColumnWithPropertyPath","targetName","isNaN","Number","split","reduceRight","key","decrement","_this17","getRepository","repoFromMap","get","type","newRepository","getTreeRepository","treeSupport","repository","push","getMongoRepository","withRepository","repositoryConstructor","otherRepositoryProperties","getCustomRepository","customRepository","entityRepositoryMetadataArgs","entityRepositories","entityMetadata","entityRepositoryInstance","_this18"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/entity-manager/EntityManager.js"],"sourcesContent":["import { EntityNotFoundError } from \"../error/EntityNotFoundError\";\nimport { QueryRunnerProviderAlreadyReleasedError } from \"../error/QueryRunnerProviderAlreadyReleasedError\";\nimport { NoNeedToReleaseEntityManagerError } from \"../error/NoNeedToReleaseEntityManagerError\";\nimport { MongoRepository } from \"../repository/MongoRepository\";\nimport { TreeRepository } from \"../repository/TreeRepository\";\nimport { Repository } from \"../repository/Repository\";\nimport { FindOptionsUtils } from \"../find-options/FindOptionsUtils\";\nimport { PlainObjectToNewEntityTransformer } from \"../query-builder/transformer/PlainObjectToNewEntityTransformer\";\nimport { PlainObjectToDatabaseEntityTransformer } from \"../query-builder/transformer/PlainObjectToDatabaseEntityTransformer\";\nimport { CustomRepositoryCannotInheritRepositoryError, CustomRepositoryNotFoundError, TreeRepositoryNotSupportedError, TypeORMError, } from \"../error\";\nimport { AbstractRepository } from \"../repository/AbstractRepository\";\nimport { EntityPersistExecutor } from \"../persistence/EntityPersistExecutor\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\nimport { getMetadataArgsStorage } from \"../globals\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\n/**\n * Entity manager supposed to work with any entity, automatically find its repository and call its methods,\n * whatever entity type are you passing.\n */\nexport class EntityManager {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n    constructor(connection, queryRunner) {\n        this[\"@instanceof\"] = Symbol.for(\"EntityManager\");\n        // -------------------------------------------------------------------------\n        // Protected Properties\n        // -------------------------------------------------------------------------\n        /**\n         * Once created and then reused by repositories.\n         * Created as a future replacement for the #repositories to provide a bit more perf optimization.\n         */\n        this.repositories = new Map();\n        /**\n         * Once created and then reused by repositories.\n         */\n        this.treeRepositories = [];\n        /**\n         * Plain to object transformer used in create and merge operations.\n         */\n        this.plainObjectToEntityTransformer = new PlainObjectToNewEntityTransformer();\n        this.connection = connection;\n        if (queryRunner) {\n            this.queryRunner = queryRunner;\n            // dynamic: this.queryRunner = manager;\n            ObjectUtils.assign(this.queryRunner, { manager: this });\n        }\n    }\n    /**\n     * Wraps given function execution (and all operations made there) in a transaction.\n     * All database operations must be executed using provided entity manager.\n     */\n    async transaction(isolationOrRunInTransaction, runInTransactionParam) {\n        const isolation = typeof isolationOrRunInTransaction === \"string\"\n            ? isolationOrRunInTransaction\n            : undefined;\n        const runInTransaction = typeof isolationOrRunInTransaction === \"function\"\n            ? isolationOrRunInTransaction\n            : runInTransactionParam;\n        if (!runInTransaction) {\n            throw new TypeORMError(`Transaction method requires callback in second parameter if isolation level is supplied.`);\n        }\n        if (this.queryRunner && this.queryRunner.isReleased)\n            throw new QueryRunnerProviderAlreadyReleasedError();\n        // if query runner is already defined in this class, it means this entity manager was already created for a single connection\n        // if its not defined we create a new query runner - single connection where we'll execute all our operations\n        const queryRunner = this.queryRunner || this.connection.createQueryRunner();\n        try {\n            await queryRunner.startTransaction(isolation);\n            const result = await runInTransaction(queryRunner.manager);\n            await queryRunner.commitTransaction();\n            return result;\n        }\n        catch (err) {\n            try {\n                // we throw original error even if rollback thrown an error\n                await queryRunner.rollbackTransaction();\n            }\n            catch (rollbackError) { }\n            throw err;\n        }\n        finally {\n            if (!this.queryRunner)\n                // if we used a new query runner provider then release it\n                await queryRunner.release();\n        }\n    }\n    /**\n     * Executes raw SQL query and returns raw database results.\n     */\n    async query(query, parameters) {\n        return this.connection.query(query, parameters, this.queryRunner);\n    }\n    /**\n     * Creates a new query builder that can be used to build a SQL query.\n     */\n    createQueryBuilder(entityClass, alias, queryRunner) {\n        if (alias) {\n            return this.connection.createQueryBuilder(entityClass, alias, queryRunner || this.queryRunner);\n        }\n        else {\n            return this.connection.createQueryBuilder(entityClass ||\n                queryRunner ||\n                this.queryRunner);\n        }\n    }\n    /**\n     * Checks if entity has an id by its Function type or schema name.\n     */\n    hasId(targetOrEntity, maybeEntity) {\n        const target = arguments.length === 2 ? targetOrEntity : targetOrEntity.constructor;\n        const entity = arguments.length === 2 ? maybeEntity : targetOrEntity;\n        const metadata = this.connection.getMetadata(target);\n        return metadata.hasId(entity);\n    }\n    /**\n     * Gets entity mixed id.\n     */\n    getId(targetOrEntity, maybeEntity) {\n        const target = arguments.length === 2 ? targetOrEntity : targetOrEntity.constructor;\n        const entity = arguments.length === 2 ? maybeEntity : targetOrEntity;\n        const metadata = this.connection.getMetadata(target);\n        return metadata.getEntityIdMixedMap(entity);\n    }\n    /**\n     * Creates a new entity instance or instances.\n     * Can copy properties from the given object into new entities.\n     */\n    create(entityClass, plainObjectOrObjects) {\n        const metadata = this.connection.getMetadata(entityClass);\n        if (!plainObjectOrObjects)\n            return metadata.create(this.queryRunner);\n        if (Array.isArray(plainObjectOrObjects))\n            return plainObjectOrObjects.map((plainEntityLike) => this.create(entityClass, plainEntityLike));\n        const mergeIntoEntity = metadata.create(this.queryRunner);\n        this.plainObjectToEntityTransformer.transform(mergeIntoEntity, plainObjectOrObjects, metadata, true);\n        return mergeIntoEntity;\n    }\n    /**\n     * Merges two entities into one new entity.\n     */\n    merge(entityClass, mergeIntoEntity, ...entityLikes) {\n        // todo: throw exception if entity manager is released\n        const metadata = this.connection.getMetadata(entityClass);\n        entityLikes.forEach((object) => this.plainObjectToEntityTransformer.transform(mergeIntoEntity, object, metadata));\n        return mergeIntoEntity;\n    }\n    /**\n     * Creates a new entity from the given plain javascript object. If entity already exist in the database, then\n     * it loads it (and everything related to it), replaces all values with the new ones from the given object\n     * and returns this new entity. This new entity is actually a loaded from the db entity with all properties\n     * replaced from the new object.\n     */\n    async preload(entityClass, entityLike) {\n        const metadata = this.connection.getMetadata(entityClass);\n        const plainObjectToDatabaseEntityTransformer = new PlainObjectToDatabaseEntityTransformer(this.connection.manager);\n        const transformedEntity = await plainObjectToDatabaseEntityTransformer.transform(entityLike, metadata);\n        if (transformedEntity)\n            return this.merge(entityClass, transformedEntity, entityLike);\n        return undefined;\n    }\n    /**\n     * Saves a given entity in the database.\n     */\n    save(targetOrEntity, maybeEntityOrOptions, maybeOptions) {\n        // normalize mixed parameters\n        let target = arguments.length > 1 &&\n            (typeof targetOrEntity === \"function\" ||\n                InstanceChecker.isEntitySchema(targetOrEntity) ||\n                typeof targetOrEntity === \"string\")\n            ? targetOrEntity\n            : undefined;\n        const entity = target\n            ? maybeEntityOrOptions\n            : targetOrEntity;\n        const options = target\n            ? maybeOptions\n            : maybeEntityOrOptions;\n        if (InstanceChecker.isEntitySchema(target))\n            target = target.options.name;\n        // if user passed empty array of entities then we don't need to do anything\n        if (Array.isArray(entity) && entity.length === 0)\n            return Promise.resolve(entity);\n        // execute save operation\n        return new EntityPersistExecutor(this.connection, this.queryRunner, \"save\", target, entity, options)\n            .execute()\n            .then(() => entity);\n    }\n    /**\n     * Removes a given entity from the database.\n     */\n    remove(targetOrEntity, maybeEntityOrOptions, maybeOptions) {\n        // normalize mixed parameters\n        const target = arguments.length > 1 &&\n            (typeof targetOrEntity === \"function\" ||\n                InstanceChecker.isEntitySchema(targetOrEntity) ||\n                typeof targetOrEntity === \"string\")\n            ? targetOrEntity\n            : undefined;\n        const entity = target\n            ? maybeEntityOrOptions\n            : targetOrEntity;\n        const options = target\n            ? maybeOptions\n            : maybeEntityOrOptions;\n        // if user passed empty array of entities then we don't need to do anything\n        if (Array.isArray(entity) && entity.length === 0)\n            return Promise.resolve(entity);\n        // execute save operation\n        return new EntityPersistExecutor(this.connection, this.queryRunner, \"remove\", target, entity, options)\n            .execute()\n            .then(() => entity);\n    }\n    /**\n     * Records the delete date of one or many given entities.\n     */\n    softRemove(targetOrEntity, maybeEntityOrOptions, maybeOptions) {\n        // normalize mixed parameters\n        let target = arguments.length > 1 &&\n            (typeof targetOrEntity === \"function\" ||\n                InstanceChecker.isEntitySchema(targetOrEntity) ||\n                typeof targetOrEntity === \"string\")\n            ? targetOrEntity\n            : undefined;\n        const entity = target\n            ? maybeEntityOrOptions\n            : targetOrEntity;\n        const options = target\n            ? maybeOptions\n            : maybeEntityOrOptions;\n        if (InstanceChecker.isEntitySchema(target))\n            target = target.options.name;\n        // if user passed empty array of entities then we don't need to do anything\n        if (Array.isArray(entity) && entity.length === 0)\n            return Promise.resolve(entity);\n        // execute soft-remove operation\n        return new EntityPersistExecutor(this.connection, this.queryRunner, \"soft-remove\", target, entity, options)\n            .execute()\n            .then(() => entity);\n    }\n    /**\n     * Recovers one or many given entities.\n     */\n    recover(targetOrEntity, maybeEntityOrOptions, maybeOptions) {\n        // normalize mixed parameters\n        let target = arguments.length > 1 &&\n            (typeof targetOrEntity === \"function\" ||\n                InstanceChecker.isEntitySchema(targetOrEntity) ||\n                typeof targetOrEntity === \"string\")\n            ? targetOrEntity\n            : undefined;\n        const entity = target\n            ? maybeEntityOrOptions\n            : targetOrEntity;\n        const options = target\n            ? maybeOptions\n            : maybeEntityOrOptions;\n        if (InstanceChecker.isEntitySchema(target))\n            target = target.options.name;\n        // if user passed empty array of entities then we don't need to do anything\n        if (Array.isArray(entity) && entity.length === 0)\n            return Promise.resolve(entity);\n        // execute recover operation\n        return new EntityPersistExecutor(this.connection, this.queryRunner, \"recover\", target, entity, options)\n            .execute()\n            .then(() => entity);\n    }\n    /**\n     * Inserts a given entity into the database.\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient INSERT query.\n     * Does not check if entity exist in the database, so query will fail if duplicate entity is being inserted.\n     * You can execute bulk inserts using this method.\n     */\n    async insert(target, entity) {\n        return this.createQueryBuilder()\n            .insert()\n            .into(target)\n            .values(entity)\n            .execute();\n    }\n    async upsert(target, entityOrEntities, conflictPathsOrOptions) {\n        const metadata = this.connection.getMetadata(target);\n        let options;\n        if (Array.isArray(conflictPathsOrOptions)) {\n            options = {\n                conflictPaths: conflictPathsOrOptions,\n            };\n        }\n        else {\n            options = conflictPathsOrOptions;\n        }\n        let entities;\n        if (!Array.isArray(entityOrEntities)) {\n            entities = [entityOrEntities];\n        }\n        else {\n            entities = entityOrEntities;\n        }\n        const conflictColumns = metadata.mapPropertyPathsToColumns(Array.isArray(options.conflictPaths)\n            ? options.conflictPaths\n            : Object.keys(options.conflictPaths));\n        const overwriteColumns = metadata.columns.filter((col) => !conflictColumns.includes(col) &&\n            entities.some((entity) => typeof col.getEntityValue(entity) !== \"undefined\"));\n        return this.createQueryBuilder()\n            .insert()\n            .into(target)\n            .values(entities)\n            .orUpdate([...conflictColumns, ...overwriteColumns].map((col) => col.databaseName), conflictColumns.map((col) => col.databaseName), {\n            skipUpdateIfNoValuesChanged: options.skipUpdateIfNoValuesChanged,\n            indexPredicate: options.indexPredicate,\n            upsertType: options.upsertType ||\n                this.connection.driver.supportedUpsertTypes[0],\n        })\n            .execute();\n    }\n    /**\n     * Updates entity partially. Entity can be found by a given condition(s).\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient UPDATE query.\n     * Does not check if entity exist in the database.\n     * Condition(s) cannot be empty.\n     */\n    update(target, criteria, partialEntity) {\n        // if user passed empty criteria or empty list of criterias, then throw an error\n        if (criteria === undefined ||\n            criteria === null ||\n            criteria === \"\" ||\n            (Array.isArray(criteria) && criteria.length === 0)) {\n            return Promise.reject(new TypeORMError(`Empty criteria(s) are not allowed for the update method.`));\n        }\n        if (typeof criteria === \"string\" ||\n            typeof criteria === \"number\" ||\n            criteria instanceof Date ||\n            Array.isArray(criteria)) {\n            return this.createQueryBuilder()\n                .update(target)\n                .set(partialEntity)\n                .whereInIds(criteria)\n                .execute();\n        }\n        else {\n            return this.createQueryBuilder()\n                .update(target)\n                .set(partialEntity)\n                .where(criteria)\n                .execute();\n        }\n    }\n    /**\n     * Deletes entities by a given condition(s).\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient DELETE query.\n     * Does not check if entity exist in the database.\n     * Condition(s) cannot be empty.\n     */\n    delete(targetOrEntity, criteria) {\n        // if user passed empty criteria or empty list of criterias, then throw an error\n        if (criteria === undefined ||\n            criteria === null ||\n            criteria === \"\" ||\n            (Array.isArray(criteria) && criteria.length === 0)) {\n            return Promise.reject(new TypeORMError(`Empty criteria(s) are not allowed for the delete method.`));\n        }\n        if (typeof criteria === \"string\" ||\n            typeof criteria === \"number\" ||\n            criteria instanceof Date ||\n            Array.isArray(criteria)) {\n            return this.createQueryBuilder()\n                .delete()\n                .from(targetOrEntity)\n                .whereInIds(criteria)\n                .execute();\n        }\n        else {\n            return this.createQueryBuilder()\n                .delete()\n                .from(targetOrEntity)\n                .where(criteria)\n                .execute();\n        }\n    }\n    /**\n     * Records the delete date of entities by a given condition(s).\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient DELETE query.\n     * Does not check if entity exist in the database.\n     * Condition(s) cannot be empty.\n     */\n    softDelete(targetOrEntity, criteria) {\n        // if user passed empty criteria or empty list of criterias, then throw an error\n        if (criteria === undefined ||\n            criteria === null ||\n            criteria === \"\" ||\n            (Array.isArray(criteria) && criteria.length === 0)) {\n            return Promise.reject(new TypeORMError(`Empty criteria(s) are not allowed for the delete method.`));\n        }\n        if (typeof criteria === \"string\" ||\n            typeof criteria === \"number\" ||\n            criteria instanceof Date ||\n            Array.isArray(criteria)) {\n            return this.createQueryBuilder()\n                .softDelete()\n                .from(targetOrEntity)\n                .whereInIds(criteria)\n                .execute();\n        }\n        else {\n            return this.createQueryBuilder()\n                .softDelete()\n                .from(targetOrEntity)\n                .where(criteria)\n                .execute();\n        }\n    }\n    /**\n     * Restores entities by a given condition(s).\n     * Unlike save method executes a primitive operation without cascades, relations and other operations included.\n     * Executes fast and efficient DELETE query.\n     * Does not check if entity exist in the database.\n     * Condition(s) cannot be empty.\n     */\n    restore(targetOrEntity, criteria) {\n        // if user passed empty criteria or empty list of criterias, then throw an error\n        if (criteria === undefined ||\n            criteria === null ||\n            criteria === \"\" ||\n            (Array.isArray(criteria) && criteria.length === 0)) {\n            return Promise.reject(new TypeORMError(`Empty criteria(s) are not allowed for the delete method.`));\n        }\n        if (typeof criteria === \"string\" ||\n            typeof criteria === \"number\" ||\n            criteria instanceof Date ||\n            Array.isArray(criteria)) {\n            return this.createQueryBuilder()\n                .restore()\n                .from(targetOrEntity)\n                .whereInIds(criteria)\n                .execute();\n        }\n        else {\n            return this.createQueryBuilder()\n                .restore()\n                .from(targetOrEntity)\n                .where(criteria)\n                .execute();\n        }\n    }\n    /**\n     * Checks whether any entity exists with the given condition\n     */\n    exists(entityClass, options) {\n        const metadata = this.connection.getMetadata(entityClass);\n        return this.createQueryBuilder(entityClass, FindOptionsUtils.extractFindManyOptionsAlias(options) ||\n            metadata.name)\n            .setFindOptions(options || {})\n            .getExists();\n    }\n    /**\n     * Counts entities that match given options.\n     * Useful for pagination.\n     */\n    count(entityClass, options) {\n        const metadata = this.connection.getMetadata(entityClass);\n        return this.createQueryBuilder(entityClass, FindOptionsUtils.extractFindManyOptionsAlias(options) ||\n            metadata.name)\n            .setFindOptions(options || {})\n            .getCount();\n    }\n    /**\n     * Counts entities that match given conditions.\n     * Useful for pagination.\n     */\n    countBy(entityClass, where) {\n        const metadata = this.connection.getMetadata(entityClass);\n        return this.createQueryBuilder(entityClass, metadata.name)\n            .setFindOptions({ where })\n            .getCount();\n    }\n    /**\n     * Return the SUM of a column\n     */\n    sum(entityClass, columnName, where) {\n        return this.callAggregateFun(entityClass, \"SUM\", columnName, where);\n    }\n    /**\n     * Return the AVG of a column\n     */\n    average(entityClass, columnName, where) {\n        return this.callAggregateFun(entityClass, \"AVG\", columnName, where);\n    }\n    /**\n     * Return the MIN of a column\n     */\n    minimum(entityClass, columnName, where) {\n        return this.callAggregateFun(entityClass, \"MIN\", columnName, where);\n    }\n    /**\n     * Return the MAX of a column\n     */\n    maximum(entityClass, columnName, where) {\n        return this.callAggregateFun(entityClass, \"MAX\", columnName, where);\n    }\n    async callAggregateFun(entityClass, fnName, columnName, where = {}) {\n        const metadata = this.connection.getMetadata(entityClass);\n        const result = await this.createQueryBuilder(entityClass, metadata.name)\n            .setFindOptions({ where })\n            .select(`${fnName}(${this.connection.driver.escape(String(columnName))})`, fnName)\n            .getRawOne();\n        return result[fnName] === null ? null : parseFloat(result[fnName]);\n    }\n    /**\n     * Finds entities that match given find options.\n     */\n    async find(entityClass, options) {\n        const metadata = this.connection.getMetadata(entityClass);\n        return this.createQueryBuilder(entityClass, FindOptionsUtils.extractFindManyOptionsAlias(options) ||\n            metadata.name)\n            .setFindOptions(options || {})\n            .getMany();\n    }\n    /**\n     * Finds entities that match given find options.\n     */\n    async findBy(entityClass, where) {\n        const metadata = this.connection.getMetadata(entityClass);\n        return this.createQueryBuilder(entityClass, metadata.name)\n            .setFindOptions({ where: where })\n            .getMany();\n    }\n    /**\n     * Finds entities that match given find options.\n     * Also counts all entities that match given conditions,\n     * but ignores pagination settings (from and take options).\n     */\n    findAndCount(entityClass, options) {\n        const metadata = this.connection.getMetadata(entityClass);\n        return this.createQueryBuilder(entityClass, FindOptionsUtils.extractFindManyOptionsAlias(options) ||\n            metadata.name)\n            .setFindOptions(options || {})\n            .getManyAndCount();\n    }\n    /**\n     * Finds entities that match given WHERE conditions.\n     * Also counts all entities that match given conditions,\n     * but ignores pagination settings (from and take options).\n     */\n    findAndCountBy(entityClass, where) {\n        const metadata = this.connection.getMetadata(entityClass);\n        return this.createQueryBuilder(entityClass, metadata.name)\n            .setFindOptions({ where })\n            .getManyAndCount();\n    }\n    /**\n     * Finds entities with ids.\n     * Optionally find options or conditions can be applied.\n     *\n     * @deprecated use `findBy` method instead in conjunction with `In` operator, for example:\n     *\n     * .findBy({\n     *     id: In([1, 2, 3])\n     * })\n     */\n    async findByIds(entityClass, ids) {\n        // if no ids passed, no need to execute a query - just return an empty array of values\n        if (!ids.length)\n            return Promise.resolve([]);\n        const metadata = this.connection.getMetadata(entityClass);\n        return this.createQueryBuilder(entityClass, metadata.name)\n            .andWhereInIds(ids)\n            .getMany();\n    }\n    /**\n     * Finds first entity by a given find options.\n     * If entity was not found in the database - returns null.\n     */\n    async findOne(entityClass, options) {\n        const metadata = this.connection.getMetadata(entityClass);\n        // prepare alias for built query\n        let alias = metadata.name;\n        if (options && options.join) {\n            alias = options.join.alias;\n        }\n        if (!options.where) {\n            throw new Error(`You must provide selection conditions in order to find a single row.`);\n        }\n        // create query builder and apply find options\n        return this.createQueryBuilder(entityClass, alias)\n            .setFindOptions({\n            ...options,\n            take: 1,\n        })\n            .getOne();\n    }\n    /**\n     * Finds first entity that matches given where condition.\n     * If entity was not found in the database - returns null.\n     */\n    async findOneBy(entityClass, where) {\n        const metadata = this.connection.getMetadata(entityClass);\n        // create query builder and apply find options\n        return this.createQueryBuilder(entityClass, metadata.name)\n            .setFindOptions({\n            where,\n            take: 1,\n        })\n            .getOne();\n    }\n    /**\n     * Finds first entity that matches given id.\n     * If entity was not found in the database - returns null.\n     *\n     * @deprecated use `findOneBy` method instead in conjunction with `In` operator, for example:\n     *\n     * .findOneBy({\n     *     id: 1 // where \"id\" is your primary column name\n     * })\n     */\n    async findOneById(entityClass, id) {\n        const metadata = this.connection.getMetadata(entityClass);\n        // create query builder and apply find options\n        return this.createQueryBuilder(entityClass, metadata.name)\n            .setFindOptions({\n            take: 1,\n        })\n            .whereInIds(metadata.ensureEntityIdMap(id))\n            .getOne();\n    }\n    /**\n     * Finds first entity by a given find options.\n     * If entity was not found in the database - rejects with error.\n     */\n    async findOneOrFail(entityClass, options) {\n        return this.findOne(entityClass, options).then((value) => {\n            if (value === null) {\n                return Promise.reject(new EntityNotFoundError(entityClass, options));\n            }\n            return Promise.resolve(value);\n        });\n    }\n    /**\n     * Finds first entity that matches given where condition.\n     * If entity was not found in the database - rejects with error.\n     */\n    async findOneByOrFail(entityClass, where) {\n        return this.findOneBy(entityClass, where).then((value) => {\n            if (value === null) {\n                return Promise.reject(new EntityNotFoundError(entityClass, where));\n            }\n            return Promise.resolve(value);\n        });\n    }\n    /**\n     * Clears all the data from the given table (truncates/drops it).\n     *\n     * Note: this method uses TRUNCATE and may not work as you expect in transactions on some platforms.\n     * @see https://stackoverflow.com/a/5972738/925151\n     */\n    async clear(entityClass) {\n        const metadata = this.connection.getMetadata(entityClass);\n        const queryRunner = this.queryRunner || this.connection.createQueryRunner();\n        try {\n            return await queryRunner.clearTable(metadata.tablePath); // await is needed here because we are using finally\n        }\n        finally {\n            if (!this.queryRunner)\n                await queryRunner.release();\n        }\n    }\n    /**\n     * Increments some column by provided value of the entities matched given conditions.\n     */\n    async increment(entityClass, conditions, propertyPath, value) {\n        const metadata = this.connection.getMetadata(entityClass);\n        const column = metadata.findColumnWithPropertyPath(propertyPath);\n        if (!column)\n            throw new TypeORMError(`Column ${propertyPath} was not found in ${metadata.targetName} entity.`);\n        if (isNaN(Number(value)))\n            throw new TypeORMError(`Value \"${value}\" is not a number.`);\n        // convert possible embeded path \"social.likes\" into object { social: { like: () => value } }\n        const values = propertyPath\n            .split(\".\")\n            .reduceRight((value, key) => ({ [key]: value }), () => this.connection.driver.escape(column.databaseName) +\n            \" + \" +\n            value);\n        return this.createQueryBuilder(entityClass, \"entity\")\n            .update(entityClass)\n            .set(values)\n            .where(conditions)\n            .execute();\n    }\n    /**\n     * Decrements some column by provided value of the entities matched given conditions.\n     */\n    async decrement(entityClass, conditions, propertyPath, value) {\n        const metadata = this.connection.getMetadata(entityClass);\n        const column = metadata.findColumnWithPropertyPath(propertyPath);\n        if (!column)\n            throw new TypeORMError(`Column ${propertyPath} was not found in ${metadata.targetName} entity.`);\n        if (isNaN(Number(value)))\n            throw new TypeORMError(`Value \"${value}\" is not a number.`);\n        // convert possible embeded path \"social.likes\" into object { social: { like: () => value } }\n        const values = propertyPath\n            .split(\".\")\n            .reduceRight((value, key) => ({ [key]: value }), () => this.connection.driver.escape(column.databaseName) +\n            \" - \" +\n            value);\n        return this.createQueryBuilder(entityClass, \"entity\")\n            .update(entityClass)\n            .set(values)\n            .where(conditions)\n            .execute();\n    }\n    /**\n     * Gets repository for the given entity class or name.\n     * If single database connection mode is used, then repository is obtained from the\n     * repository aggregator, where each repository is individually created for this entity manager.\n     * When single database connection is not used, repository is being obtained from the connection.\n     */\n    getRepository(target) {\n        // find already created repository instance and return it if found\n        const repoFromMap = this.repositories.get(target);\n        if (repoFromMap)\n            return repoFromMap;\n        // if repository was not found then create it, store its instance and return it\n        if (this.connection.driver.options.type === \"mongodb\") {\n            const newRepository = new MongoRepository(target, this, this.queryRunner);\n            this.repositories.set(target, newRepository);\n            return newRepository;\n        }\n        else {\n            const newRepository = new Repository(target, this, this.queryRunner);\n            this.repositories.set(target, newRepository);\n            return newRepository;\n        }\n    }\n    /**\n     * Gets tree repository for the given entity class or name.\n     * If single database connection mode is used, then repository is obtained from the\n     * repository aggregator, where each repository is individually created for this entity manager.\n     * When single database connection is not used, repository is being obtained from the connection.\n     */\n    getTreeRepository(target) {\n        // tree tables aren't supported by some drivers (mongodb)\n        if (this.connection.driver.treeSupport === false)\n            throw new TreeRepositoryNotSupportedError(this.connection.driver);\n        // find already created repository instance and return it if found\n        const repository = this.treeRepositories.find((repository) => repository.target === target);\n        if (repository)\n            return repository;\n        // check if repository is real tree repository\n        const newRepository = new TreeRepository(target, this, this.queryRunner);\n        this.treeRepositories.push(newRepository);\n        return newRepository;\n    }\n    /**\n     * Gets mongodb repository for the given entity class.\n     */\n    getMongoRepository(target) {\n        return this.connection.getMongoRepository(target);\n    }\n    /**\n     * Creates a new repository instance out of a given Repository and\n     * sets current EntityManager instance to it. Used to work with custom repositories\n     * in transactions.\n     */\n    withRepository(repository) {\n        const repositoryConstructor = repository.constructor;\n        const { target, manager, queryRunner, ...otherRepositoryProperties } = repository;\n        return Object.assign(new repositoryConstructor(repository.target, this), {\n            ...otherRepositoryProperties,\n        });\n    }\n    /**\n     * Gets custom entity repository marked with @EntityRepository decorator.\n     *\n     * @deprecated use Repository.extend to create custom repositories\n     */\n    getCustomRepository(customRepository) {\n        const entityRepositoryMetadataArgs = getMetadataArgsStorage().entityRepositories.find((repository) => {\n            return (repository.target ===\n                (typeof customRepository === \"function\"\n                    ? customRepository\n                    : customRepository.constructor));\n        });\n        if (!entityRepositoryMetadataArgs)\n            throw new CustomRepositoryNotFoundError(customRepository);\n        const entityMetadata = entityRepositoryMetadataArgs.entity\n            ? this.connection.getMetadata(entityRepositoryMetadataArgs.entity)\n            : undefined;\n        const entityRepositoryInstance = new entityRepositoryMetadataArgs.target(this, entityMetadata);\n        // NOTE: dynamic access to protected properties. We need this to prevent unwanted properties in those classes to be exposed,\n        // however we need these properties for internal work of the class\n        if (entityRepositoryInstance instanceof AbstractRepository) {\n            if (!entityRepositoryInstance[\"manager\"])\n                entityRepositoryInstance[\"manager\"] = this;\n        }\n        else {\n            if (!entityMetadata)\n                throw new CustomRepositoryCannotInheritRepositoryError(customRepository);\n            entityRepositoryInstance[\"manager\"] = this;\n            entityRepositoryInstance[\"metadata\"] = entityMetadata;\n        }\n        return entityRepositoryInstance;\n    }\n    /**\n     * Releases all resources used by entity manager.\n     * This is used when entity manager is created with a single query runner,\n     * and this single query runner needs to be released after job with entity manager is done.\n     */\n    async release() {\n        if (!this.queryRunner)\n            throw new NoNeedToReleaseEntityManagerError();\n        return this.queryRunner.release();\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}