{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/practicas/Downloads/angular/tresOnline/frontend-tres-en-raya/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { TypeORMError } from \"../error\";\n/**\n * Updates entity with returning results in the entity insert and update operations.\n */\nexport class ReturningResultsEntityUpdator {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(queryRunner, expressionMap) {\n    this.queryRunner = queryRunner;\n    this.expressionMap = expressionMap;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Updates entities with a special columns after updation query execution.\n   */\n  update(updateResult, entities) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const metadata = _this.expressionMap.mainAlias.metadata;\n      yield Promise.all(entities.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (entity, entityIndex) {\n          // if database supports returning/output statement then we already should have updating values in the raw data returned by insert query\n          if (_this.queryRunner.connection.driver.isReturningSqlSupported(\"update\")) {\n            if (_this.queryRunner.connection.driver.options.type === \"oracle\" && Array.isArray(updateResult.raw) && _this.expressionMap.extraReturningColumns.length > 0) {\n              updateResult.raw = updateResult.raw.reduce((newRaw, rawItem, rawItemIndex) => {\n                newRaw[_this.expressionMap.extraReturningColumns[rawItemIndex].databaseName] = rawItem[0];\n                return newRaw;\n              }, {});\n            }\n            const result = Array.isArray(updateResult.raw) ? updateResult.raw[entityIndex] : updateResult.raw;\n            const returningColumns = _this.queryRunner.connection.driver.createGeneratedMap(metadata, result);\n            if (returningColumns) {\n              _this.queryRunner.manager.merge(metadata.target, entity, returningColumns);\n              updateResult.generatedMaps.push(returningColumns);\n            }\n          } else {\n            // for driver which do not support returning/output statement we need to perform separate query and load what we need\n            const updationColumns = _this.expressionMap.extraReturningColumns;\n            if (updationColumns.length > 0) {\n              // get entity id by which we will get needed data\n              const entityId = _this.expressionMap.mainAlias.metadata.getEntityIdMap(entity);\n              if (!entityId) throw new TypeORMError(`Cannot update entity because entity id is not set in the entity.`);\n              // execute query to get needed data\n              const loadedReturningColumns = yield _this.queryRunner.manager.createQueryBuilder().select(metadata.primaryColumns.map(column => metadata.targetName + \".\" + column.propertyPath)).addSelect(updationColumns.map(column => metadata.targetName + \".\" + column.propertyPath)).from(metadata.target, metadata.targetName).where(entityId).withDeleted().setOption(\"create-pojo\") // use POJO because created object can contain default values, e.g. property = null and those properties might be overridden by merge process\n              .getOne();\n              if (loadedReturningColumns) {\n                _this.queryRunner.manager.merge(metadata.target, entity, loadedReturningColumns);\n                updateResult.generatedMaps.push(loadedReturningColumns);\n              }\n            }\n          }\n        });\n        return function (_x, _x2) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n    })();\n  }\n  /**\n   * Updates entities with a special columns after insertion query execution.\n   */\n  insert(insertResult, entities) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const metadata = _this2.expressionMap.mainAlias.metadata;\n      let insertionColumns = metadata.getInsertionReturningColumns();\n      // to prevent extra select SQL execution for databases not supporting RETURNING\n      // in the case if we have generated column and it's value returned by underlying driver\n      // we remove this column from the insertionColumns list\n      const needToCheckGenerated = _this2.queryRunner.connection.driver.isReturningSqlSupported(\"insert\");\n      insertionColumns = insertionColumns.filter(column => {\n        if (!column.isGenerated) return true;\n        return needToCheckGenerated === true;\n      });\n      const generatedMaps = entities.map((entity, entityIndex) => {\n        if (_this2.queryRunner.connection.driver.options.type === \"oracle\" && Array.isArray(insertResult.raw) && _this2.expressionMap.extraReturningColumns.length > 0) {\n          insertResult.raw = insertResult.raw.reduce((newRaw, rawItem, rawItemIndex) => {\n            newRaw[_this2.expressionMap.extraReturningColumns[rawItemIndex].databaseName] = rawItem[0];\n            return newRaw;\n          }, {});\n        }\n        // get all values generated by a database for us\n        const result = Array.isArray(insertResult.raw) ? insertResult.raw[entityIndex] : insertResult.raw;\n        const generatedMap = _this2.queryRunner.connection.driver.createGeneratedMap(metadata, result, entityIndex, entities.length) || {};\n        if (entityIndex in _this2.expressionMap.locallyGenerated) {\n          _this2.queryRunner.manager.merge(metadata.target, generatedMap, _this2.expressionMap.locallyGenerated[entityIndex]);\n        }\n        _this2.queryRunner.manager.merge(metadata.target, entity, generatedMap);\n        return generatedMap;\n      });\n      // for postgres and mssql we use returning/output statement to get values of inserted default and generated values\n      // for other drivers we have to re-select this data from the database\n      if (insertionColumns.length > 0 && !_this2.queryRunner.connection.driver.isReturningSqlSupported(\"insert\")) {\n        const entityIds = entities.map(entity => {\n          const entityId = metadata.getEntityIdMap(entity);\n          // We have to check for an empty `entityId` - if we don't, the query against the database\n          // effectively drops the `where` clause entirely and the first record will be returned -\n          // not what we want at all.\n          if (!entityId) throw new TypeORMError(`Cannot update entity because entity id is not set in the entity.`);\n          return entityId;\n        });\n        // to select just inserted entities we need a criteria to select by.\n        // for newly inserted entities in drivers which do not support returning statement\n        // row identifier can only be an increment column\n        // (since its the only thing that can be generated by those databases)\n        // or (and) other primary key which is defined by a user and inserted value has it\n        const returningResult = yield _this2.queryRunner.manager.createQueryBuilder().select(metadata.primaryColumns.map(column => metadata.targetName + \".\" + column.propertyPath)).addSelect(insertionColumns.map(column => metadata.targetName + \".\" + column.propertyPath)).from(metadata.target, metadata.targetName).where(entityIds).setOption(\"create-pojo\") // use POJO because created object can contain default values, e.g. property = null and those properties might be overridden by merge process\n        .getMany();\n        entities.forEach((entity, entityIndex) => {\n          _this2.queryRunner.manager.merge(metadata.target, generatedMaps[entityIndex], returningResult[entityIndex]);\n          _this2.queryRunner.manager.merge(metadata.target, entity, returningResult[entityIndex]);\n        });\n      }\n      entities.forEach((entity, entityIndex) => {\n        const entityId = metadata.getEntityIdMap(entity);\n        insertResult.identifiers.push(entityId);\n        insertResult.generatedMaps.push(generatedMaps[entityIndex]);\n      });\n    })();\n  }\n  /**\n   * Columns we need to be returned from the database when we update entity.\n   */\n  getUpdationReturningColumns() {\n    return this.expressionMap.mainAlias.metadata.columns.filter(column => {\n      return column.isUpdateDate || column.isVersion;\n    });\n  }\n  /**\n   * Columns we need to be returned from the database when we soft delete and restore entity.\n   */\n  getSoftDeletionReturningColumns() {\n    return this.expressionMap.mainAlias.metadata.columns.filter(column => {\n      return column.isUpdateDate || column.isVersion || column.isDeleteDate;\n    });\n  }\n}","map":{"version":3,"names":["TypeORMError","ReturningResultsEntityUpdator","constructor","queryRunner","expressionMap","update","updateResult","entities","_this","_asyncToGenerator","metadata","mainAlias","Promise","all","map","_ref","entity","entityIndex","connection","driver","isReturningSqlSupported","options","type","Array","isArray","raw","extraReturningColumns","length","reduce","newRaw","rawItem","rawItemIndex","databaseName","result","returningColumns","createGeneratedMap","manager","merge","target","generatedMaps","push","updationColumns","entityId","getEntityIdMap","loadedReturningColumns","createQueryBuilder","select","primaryColumns","column","targetName","propertyPath","addSelect","from","where","withDeleted","setOption","getOne","_x","_x2","apply","arguments","insert","insertResult","_this2","insertionColumns","getInsertionReturningColumns","needToCheckGenerated","filter","isGenerated","generatedMap","locallyGenerated","entityIds","returningResult","getMany","forEach","identifiers","getUpdationReturningColumns","columns","isUpdateDate","isVersion","getSoftDeletionReturningColumns","isDeleteDate"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/query-builder/ReturningResultsEntityUpdator.js"],"sourcesContent":["import { TypeORMError } from \"../error\";\n/**\n * Updates entity with returning results in the entity insert and update operations.\n */\nexport class ReturningResultsEntityUpdator {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n    constructor(queryRunner, expressionMap) {\n        this.queryRunner = queryRunner;\n        this.expressionMap = expressionMap;\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Updates entities with a special columns after updation query execution.\n     */\n    async update(updateResult, entities) {\n        const metadata = this.expressionMap.mainAlias.metadata;\n        await Promise.all(entities.map(async (entity, entityIndex) => {\n            // if database supports returning/output statement then we already should have updating values in the raw data returned by insert query\n            if (this.queryRunner.connection.driver.isReturningSqlSupported(\"update\")) {\n                if (this.queryRunner.connection.driver.options.type ===\n                    \"oracle\" &&\n                    Array.isArray(updateResult.raw) &&\n                    this.expressionMap.extraReturningColumns.length > 0) {\n                    updateResult.raw = updateResult.raw.reduce((newRaw, rawItem, rawItemIndex) => {\n                        newRaw[this.expressionMap.extraReturningColumns[rawItemIndex].databaseName] = rawItem[0];\n                        return newRaw;\n                    }, {});\n                }\n                const result = Array.isArray(updateResult.raw)\n                    ? updateResult.raw[entityIndex]\n                    : updateResult.raw;\n                const returningColumns = this.queryRunner.connection.driver.createGeneratedMap(metadata, result);\n                if (returningColumns) {\n                    this.queryRunner.manager.merge(metadata.target, entity, returningColumns);\n                    updateResult.generatedMaps.push(returningColumns);\n                }\n            }\n            else {\n                // for driver which do not support returning/output statement we need to perform separate query and load what we need\n                const updationColumns = this.expressionMap.extraReturningColumns;\n                if (updationColumns.length > 0) {\n                    // get entity id by which we will get needed data\n                    const entityId = this.expressionMap.mainAlias.metadata.getEntityIdMap(entity);\n                    if (!entityId)\n                        throw new TypeORMError(`Cannot update entity because entity id is not set in the entity.`);\n                    // execute query to get needed data\n                    const loadedReturningColumns = (await this.queryRunner.manager\n                        .createQueryBuilder()\n                        .select(metadata.primaryColumns.map((column) => metadata.targetName +\n                        \".\" +\n                        column.propertyPath))\n                        .addSelect(updationColumns.map((column) => metadata.targetName +\n                        \".\" +\n                        column.propertyPath))\n                        .from(metadata.target, metadata.targetName)\n                        .where(entityId)\n                        .withDeleted()\n                        .setOption(\"create-pojo\") // use POJO because created object can contain default values, e.g. property = null and those properties might be overridden by merge process\n                        .getOne());\n                    if (loadedReturningColumns) {\n                        this.queryRunner.manager.merge(metadata.target, entity, loadedReturningColumns);\n                        updateResult.generatedMaps.push(loadedReturningColumns);\n                    }\n                }\n            }\n        }));\n    }\n    /**\n     * Updates entities with a special columns after insertion query execution.\n     */\n    async insert(insertResult, entities) {\n        const metadata = this.expressionMap.mainAlias.metadata;\n        let insertionColumns = metadata.getInsertionReturningColumns();\n        // to prevent extra select SQL execution for databases not supporting RETURNING\n        // in the case if we have generated column and it's value returned by underlying driver\n        // we remove this column from the insertionColumns list\n        const needToCheckGenerated = this.queryRunner.connection.driver.isReturningSqlSupported(\"insert\");\n        insertionColumns = insertionColumns.filter((column) => {\n            if (!column.isGenerated)\n                return true;\n            return needToCheckGenerated === true;\n        });\n        const generatedMaps = entities.map((entity, entityIndex) => {\n            if (this.queryRunner.connection.driver.options.type === \"oracle\" &&\n                Array.isArray(insertResult.raw) &&\n                this.expressionMap.extraReturningColumns.length > 0) {\n                insertResult.raw = insertResult.raw.reduce((newRaw, rawItem, rawItemIndex) => {\n                    newRaw[this.expressionMap.extraReturningColumns[rawItemIndex].databaseName] = rawItem[0];\n                    return newRaw;\n                }, {});\n            }\n            // get all values generated by a database for us\n            const result = Array.isArray(insertResult.raw)\n                ? insertResult.raw[entityIndex]\n                : insertResult.raw;\n            const generatedMap = this.queryRunner.connection.driver.createGeneratedMap(metadata, result, entityIndex, entities.length) || {};\n            if (entityIndex in this.expressionMap.locallyGenerated) {\n                this.queryRunner.manager.merge(metadata.target, generatedMap, this.expressionMap.locallyGenerated[entityIndex]);\n            }\n            this.queryRunner.manager.merge(metadata.target, entity, generatedMap);\n            return generatedMap;\n        });\n        // for postgres and mssql we use returning/output statement to get values of inserted default and generated values\n        // for other drivers we have to re-select this data from the database\n        if (insertionColumns.length > 0 &&\n            !this.queryRunner.connection.driver.isReturningSqlSupported(\"insert\")) {\n            const entityIds = entities.map((entity) => {\n                const entityId = metadata.getEntityIdMap(entity);\n                // We have to check for an empty `entityId` - if we don't, the query against the database\n                // effectively drops the `where` clause entirely and the first record will be returned -\n                // not what we want at all.\n                if (!entityId)\n                    throw new TypeORMError(`Cannot update entity because entity id is not set in the entity.`);\n                return entityId;\n            });\n            // to select just inserted entities we need a criteria to select by.\n            // for newly inserted entities in drivers which do not support returning statement\n            // row identifier can only be an increment column\n            // (since its the only thing that can be generated by those databases)\n            // or (and) other primary key which is defined by a user and inserted value has it\n            const returningResult = await this.queryRunner.manager\n                .createQueryBuilder()\n                .select(metadata.primaryColumns.map((column) => metadata.targetName + \".\" + column.propertyPath))\n                .addSelect(insertionColumns.map((column) => metadata.targetName + \".\" + column.propertyPath))\n                .from(metadata.target, metadata.targetName)\n                .where(entityIds)\n                .setOption(\"create-pojo\") // use POJO because created object can contain default values, e.g. property = null and those properties might be overridden by merge process\n                .getMany();\n            entities.forEach((entity, entityIndex) => {\n                this.queryRunner.manager.merge(metadata.target, generatedMaps[entityIndex], returningResult[entityIndex]);\n                this.queryRunner.manager.merge(metadata.target, entity, returningResult[entityIndex]);\n            });\n        }\n        entities.forEach((entity, entityIndex) => {\n            const entityId = metadata.getEntityIdMap(entity);\n            insertResult.identifiers.push(entityId);\n            insertResult.generatedMaps.push(generatedMaps[entityIndex]);\n        });\n    }\n    /**\n     * Columns we need to be returned from the database when we update entity.\n     */\n    getUpdationReturningColumns() {\n        return this.expressionMap.mainAlias.metadata.columns.filter((column) => {\n            return column.isUpdateDate || column.isVersion;\n        });\n    }\n    /**\n     * Columns we need to be returned from the database when we soft delete and restore entity.\n     */\n    getSoftDeletionReturningColumns() {\n        return this.expressionMap.mainAlias.metadata.columns.filter((column) => {\n            return (column.isUpdateDate ||\n                column.isVersion ||\n                column.isDeleteDate);\n        });\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}