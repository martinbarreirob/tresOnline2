{"ast":null,"code":"import { ColumnTypeUndefinedError } from \"../../error\";\nimport { getMetadataArgsStorage } from \"../../globals\";\n/**\n * VirtualColumn decorator is used to mark a specific class property as a Virtual column.\n */\nexport function VirtualColumn(typeOrOptions, options) {\n  return function (object, propertyName) {\n    // normalize parameters\n    let type;\n    if (typeof typeOrOptions === \"string\") {\n      type = typeOrOptions;\n    } else {\n      options = typeOrOptions;\n      type = options.type;\n    }\n    if (!(options === null || options === void 0 ? void 0 : options.query)) {\n      throw new Error(\"Column options must be defined for calculated columns.\");\n    }\n    // if type is not given explicitly then try to guess it\n    const reflectMetadataType = Reflect && Reflect.getMetadata ? Reflect.getMetadata(\"design:type\", object, propertyName) : undefined;\n    if (!type && reflectMetadataType)\n      // if type is not given explicitly then try to guess it\n      type = reflectMetadataType;\n    // check if there is no type in column options then set type from first function argument, or guessed one\n    if (type) options.type = type;\n    // specify HSTORE type if column is HSTORE\n    if (options.type === \"hstore\" && !options.hstoreType) options.hstoreType = reflectMetadataType === Object ? \"object\" : \"string\";\n    // if we still don't have a type then we need to give error to user that type is required\n    if (!options.type) throw new ColumnTypeUndefinedError(object, propertyName);\n    getMetadataArgsStorage().columns.push({\n      target: object.constructor,\n      propertyName: propertyName,\n      mode: \"virtual-property\",\n      options: options || {}\n    });\n  };\n}","map":{"version":3,"names":["ColumnTypeUndefinedError","getMetadataArgsStorage","VirtualColumn","typeOrOptions","options","object","propertyName","type","query","Error","reflectMetadataType","Reflect","getMetadata","undefined","hstoreType","Object","columns","push","target","constructor","mode"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/decorator/columns/VirtualColumn.js"],"sourcesContent":["import { ColumnTypeUndefinedError } from \"../../error\";\nimport { getMetadataArgsStorage } from \"../../globals\";\n/**\n * VirtualColumn decorator is used to mark a specific class property as a Virtual column.\n */\nexport function VirtualColumn(typeOrOptions, options) {\n    return function (object, propertyName) {\n        // normalize parameters\n        let type;\n        if (typeof typeOrOptions === \"string\") {\n            type = typeOrOptions;\n        }\n        else {\n            options = typeOrOptions;\n            type = options.type;\n        }\n        if (!(options === null || options === void 0 ? void 0 : options.query)) {\n            throw new Error(\"Column options must be defined for calculated columns.\");\n        }\n        // if type is not given explicitly then try to guess it\n        const reflectMetadataType = Reflect && Reflect.getMetadata\n            ? Reflect.getMetadata(\"design:type\", object, propertyName)\n            : undefined;\n        if (!type && reflectMetadataType)\n            // if type is not given explicitly then try to guess it\n            type = reflectMetadataType;\n        // check if there is no type in column options then set type from first function argument, or guessed one\n        if (type)\n            options.type = type;\n        // specify HSTORE type if column is HSTORE\n        if (options.type === \"hstore\" && !options.hstoreType)\n            options.hstoreType =\n                reflectMetadataType === Object ? \"object\" : \"string\";\n        // if we still don't have a type then we need to give error to user that type is required\n        if (!options.type)\n            throw new ColumnTypeUndefinedError(object, propertyName);\n        getMetadataArgsStorage().columns.push({\n            target: object.constructor,\n            propertyName: propertyName,\n            mode: \"virtual-property\",\n            options: options || {},\n        });\n    };\n}\n\n"],"mappings":"AAAA,SAASA,wBAAwB,QAAQ,aAAa;AACtD,SAASC,sBAAsB,QAAQ,eAAe;AACtD;AACA;AACA;AACA,OAAO,SAASC,aAAaA,CAACC,aAAa,EAAEC,OAAO,EAAE;EAClD,OAAO,UAAUC,MAAM,EAAEC,YAAY,EAAE;IACnC;IACA,IAAIC,IAAI;IACR,IAAI,OAAOJ,aAAa,KAAK,QAAQ,EAAE;MACnCI,IAAI,GAAGJ,aAAa;IACxB,CAAC,MACI;MACDC,OAAO,GAAGD,aAAa;MACvBI,IAAI,GAAGH,OAAO,CAACG,IAAI;IACvB;IACA,IAAI,EAAEH,OAAO,KAAK,IAAI,IAAIA,OAAO,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,OAAO,CAACI,KAAK,CAAC,EAAE;MACpE,MAAM,IAAIC,KAAK,CAAC,wDAAwD,CAAC;IAC7E;IACA;IACA,MAAMC,mBAAmB,GAAGC,OAAO,IAAIA,OAAO,CAACC,WAAW,GACpDD,OAAO,CAACC,WAAW,CAAC,aAAa,EAAEP,MAAM,EAAEC,YAAY,CAAC,GACxDO,SAAS;IACf,IAAI,CAACN,IAAI,IAAIG,mBAAmB;MAC5B;MACAH,IAAI,GAAGG,mBAAmB;IAC9B;IACA,IAAIH,IAAI,EACJH,OAAO,CAACG,IAAI,GAAGA,IAAI;IACvB;IACA,IAAIH,OAAO,CAACG,IAAI,KAAK,QAAQ,IAAI,CAACH,OAAO,CAACU,UAAU,EAChDV,OAAO,CAACU,UAAU,GACdJ,mBAAmB,KAAKK,MAAM,GAAG,QAAQ,GAAG,QAAQ;IAC5D;IACA,IAAI,CAACX,OAAO,CAACG,IAAI,EACb,MAAM,IAAIP,wBAAwB,CAACK,MAAM,EAAEC,YAAY,CAAC;IAC5DL,sBAAsB,CAAC,CAAC,CAACe,OAAO,CAACC,IAAI,CAAC;MAClCC,MAAM,EAAEb,MAAM,CAACc,WAAW;MAC1Bb,YAAY,EAAEA,YAAY;MAC1Bc,IAAI,EAAE,kBAAkB;MACxBhB,OAAO,EAAEA,OAAO,IAAI,CAAC;IACzB,CAAC,CAAC;EACN,CAAC;AACL"},"metadata":{},"sourceType":"module","externalDependencies":[]}