{"ast":null,"code":"import { CannotCreateEntityIdMapError } from \"../error/CannotCreateEntityIdMapError\";\nimport { OrmUtils } from \"../util/OrmUtils\";\nimport { EntityPropertyNotFoundError } from \"../error/EntityPropertyNotFoundError\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\nimport { shorten } from \"../util/StringUtils\";\n/**\n * Contains all entity metadata.\n */\nexport class EntityMetadata {\n  // ---------------------------------------------------------------------\n  // Constructor\n  // ---------------------------------------------------------------------\n  constructor(options) {\n    this[\"@instanceof\"] = Symbol.for(\"EntityMetadata\");\n    /**\n     * Children entity metadatas. Used in inheritance patterns.\n     */\n    this.childEntityMetadatas = [];\n    /**\n     * All \"inheritance tree\" from a target entity.\n     * For example for target Post < ContentModel < Unit it will be an array of [Post, ContentModel, Unit].\n     * It also contains child entities for single table inheritance.\n     */\n    this.inheritanceTree = [];\n    /**\n     * Table type. Tables can be closure, junction, etc.\n     */\n    this.tableType = \"regular\";\n    /**\n     * Enables Sqlite \"WITHOUT ROWID\" modifier for the \"CREATE TABLE\" statement\n     */\n    this.withoutRowid = false;\n    /**\n     * Indicates if schema will be synchronized for this entity or not.\n     */\n    this.synchronize = true;\n    /**\n     * Checks if there any non-nullable column exist in this entity.\n     */\n    this.hasNonNullableRelations = false;\n    /**\n     * Indicates if this entity metadata of a junction table, or not.\n     * Junction table is a table created by many-to-many relationship.\n     *\n     * Its also possible to understand if entity is junction via tableType.\n     */\n    this.isJunction = false;\n    /**\n     * Indicates if the entity should be instantiated using the constructor\n     * or via allocating a new object via `Object.create()`.\n     */\n    this.isAlwaysUsingConstructor = true;\n    /**\n     * Checks if this table is a junction table of the closure table.\n     * This type is for tables that contain junction metadata of the closure tables.\n     */\n    this.isClosureJunction = false;\n    /**\n     * Checks if entity's table has multiple primary columns.\n     */\n    this.hasMultiplePrimaryKeys = false;\n    /**\n     * Indicates if this entity metadata has uuid generated columns.\n     */\n    this.hasUUIDGeneratedColumns = false;\n    /**\n     * Entity's column metadatas defined by user.\n     */\n    this.ownColumns = [];\n    /**\n     * Columns of the entity, including columns that are coming from the embeddeds of this entity.\n     */\n    this.columns = [];\n    /**\n     * Ancestor columns used only in closure junction tables.\n     */\n    this.ancestorColumns = [];\n    /**\n     * Descendant columns used only in closure junction tables.\n     */\n    this.descendantColumns = [];\n    /**\n     * All columns except for virtual columns.\n     */\n    this.nonVirtualColumns = [];\n    /**\n     * In the case if this entity metadata is junction table's entity metadata,\n     * this will contain all referenced columns of owner entity.\n     */\n    this.ownerColumns = [];\n    /**\n     * In the case if this entity metadata is junction table's entity metadata,\n     * this will contain all referenced columns of inverse entity.\n     */\n    this.inverseColumns = [];\n    /**\n     * Gets the column with generated flag.\n     */\n    this.generatedColumns = [];\n    /**\n     * Gets the primary columns.\n     */\n    this.primaryColumns = [];\n    /**\n     * Entity's relation metadatas.\n     */\n    this.ownRelations = [];\n    /**\n     * Relations of the entity, including relations that are coming from the embeddeds of this entity.\n     */\n    this.relations = [];\n    /**\n     * List of eager relations this metadata has.\n     */\n    this.eagerRelations = [];\n    /**\n     * List of eager relations this metadata has.\n     */\n    this.lazyRelations = [];\n    /**\n     * Gets only one-to-one relations of the entity.\n     */\n    this.oneToOneRelations = [];\n    /**\n     * Gets only owner one-to-one relations of the entity.\n     */\n    this.ownerOneToOneRelations = [];\n    /**\n     * Gets only one-to-many relations of the entity.\n     */\n    this.oneToManyRelations = [];\n    /**\n     * Gets only many-to-one relations of the entity.\n     */\n    this.manyToOneRelations = [];\n    /**\n     * Gets only many-to-many relations of the entity.\n     */\n    this.manyToManyRelations = [];\n    /**\n     * Gets only owner many-to-many relations of the entity.\n     */\n    this.ownerManyToManyRelations = [];\n    /**\n     * Gets only owner one-to-one and many-to-one relations.\n     */\n    this.relationsWithJoinColumns = [];\n    /**\n     * Entity's relation id metadatas.\n     */\n    this.relationIds = [];\n    /**\n     * Entity's relation id metadatas.\n     */\n    this.relationCounts = [];\n    /**\n     * Entity's foreign key metadatas.\n     */\n    this.foreignKeys = [];\n    /**\n     * Entity's embedded metadatas.\n     */\n    this.embeddeds = [];\n    /**\n     * All embeddeds - embeddeds from this entity metadata and from all child embeddeds, etc.\n     */\n    this.allEmbeddeds = [];\n    /**\n     * Entity's own indices.\n     */\n    this.ownIndices = [];\n    /**\n     * Entity's index metadatas.\n     */\n    this.indices = [];\n    /**\n     * Entity's unique metadatas.\n     */\n    this.uniques = [];\n    /**\n     * Entity's own uniques.\n     */\n    this.ownUniques = [];\n    /**\n     * Entity's check metadatas.\n     */\n    this.checks = [];\n    /**\n     * Entity's exclusion metadatas.\n     */\n    this.exclusions = [];\n    /**\n     * Entity's own listener metadatas.\n     */\n    this.ownListeners = [];\n    /**\n     * Entity listener metadatas.\n     */\n    this.listeners = [];\n    /**\n     * Listener metadatas with \"AFTER LOAD\" type.\n     */\n    this.afterLoadListeners = [];\n    /**\n     * Listener metadatas with \"AFTER INSERT\" type.\n     */\n    this.beforeInsertListeners = [];\n    /**\n     * Listener metadatas with \"AFTER INSERT\" type.\n     */\n    this.afterInsertListeners = [];\n    /**\n     * Listener metadatas with \"AFTER UPDATE\" type.\n     */\n    this.beforeUpdateListeners = [];\n    /**\n     * Listener metadatas with \"AFTER UPDATE\" type.\n     */\n    this.afterUpdateListeners = [];\n    /**\n     * Listener metadatas with \"AFTER REMOVE\" type.\n     */\n    this.beforeRemoveListeners = [];\n    /**\n     * Listener metadatas with \"BEFORE SOFT REMOVE\" type.\n     */\n    this.beforeSoftRemoveListeners = [];\n    /**\n     * Listener metadatas with \"BEFORE RECOVER\" type.\n     */\n    this.beforeRecoverListeners = [];\n    /**\n     * Listener metadatas with \"AFTER REMOVE\" type.\n     */\n    this.afterRemoveListeners = [];\n    /**\n     * Listener metadatas with \"AFTER SOFT REMOVE\" type.\n     */\n    this.afterSoftRemoveListeners = [];\n    /**\n     * Listener metadatas with \"AFTER RECOVER\" type.\n     */\n    this.afterRecoverListeners = [];\n    this.connection = options.connection;\n    this.inheritanceTree = options.inheritanceTree || [];\n    this.inheritancePattern = options.inheritancePattern;\n    this.treeType = options.tableTree ? options.tableTree.type : undefined;\n    this.treeOptions = options.tableTree ? options.tableTree.options : undefined;\n    this.parentClosureEntityMetadata = options.parentClosureEntityMetadata;\n    this.tableMetadataArgs = options.args;\n    this.target = this.tableMetadataArgs.target;\n    this.tableType = this.tableMetadataArgs.type;\n    this.expression = this.tableMetadataArgs.expression;\n    this.withoutRowid = this.tableMetadataArgs.withoutRowid;\n    this.dependsOn = this.tableMetadataArgs.dependsOn;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Creates a new entity.\n   */\n  create(queryRunner, options) {\n    const pojo = options && options.pojo === true ? true : false;\n    // if target is set to a function (e.g. class) that can be created then create it\n    let ret;\n    if (typeof this.target === \"function\" && !pojo) {\n      if (!(options === null || options === void 0 ? void 0 : options.fromDeserializer) || this.isAlwaysUsingConstructor) {\n        ret = new this.target();\n      } else {\n        ret = Object.create(this.target.prototype);\n      }\n    } else {\n      // otherwise simply return a new empty object\n      ret = {};\n    }\n    // add \"typename\" property\n    if (this.connection.options.typename) {\n      ret[this.connection.options.typename] = this.targetName;\n    }\n    this.lazyRelations.forEach(relation => this.connection.relationLoader.enableLazyLoad(relation, ret, queryRunner));\n    return ret;\n  }\n  /**\n   * Checks if given entity has an id.\n   */\n  hasId(entity) {\n    if (!entity) return false;\n    return this.primaryColumns.every(primaryColumn => {\n      const value = primaryColumn.getEntityValue(entity);\n      return value !== null && value !== undefined && value !== \"\";\n    });\n  }\n  /**\n   * Checks if given entity / object contains ALL primary keys entity must have.\n   * Returns true if it contains all of them, false if at least one of them is not defined.\n   */\n  hasAllPrimaryKeys(entity) {\n    return this.primaryColumns.every(primaryColumn => {\n      const value = primaryColumn.getEntityValue(entity);\n      return value !== null && value !== undefined;\n    });\n  }\n  /**\n   * Ensures that given object is an entity id map.\n   * If given id is an object then it means its already id map.\n   * If given id isn't an object then it means its a value of the id column\n   * and it creates a new id map with this value and name of the primary column.\n   */\n  ensureEntityIdMap(id) {\n    if (ObjectUtils.isObject(id)) return id;\n    if (this.hasMultiplePrimaryKeys) throw new CannotCreateEntityIdMapError(this, id);\n    return this.primaryColumns[0].createValueMap(id);\n  }\n  /**\n   * Gets primary keys of the entity and returns them in a literal object.\n   * For example, for Post{ id: 1, title: \"hello\" } where id is primary it will return { id: 1 }\n   * For multiple primary keys it returns multiple keys in object.\n   * For primary keys inside embeds it returns complex object literal with keys in them.\n   */\n  getEntityIdMap(entity) {\n    if (!entity) return undefined;\n    return EntityMetadata.getValueMap(entity, this.primaryColumns, {\n      skipNulls: true\n    });\n  }\n  /**\n   * Creates a \"mixed id map\".\n   * If entity has multiple primary keys (ids) then it will return just regular id map, like what getEntityIdMap returns.\n   * But if entity has a single primary key then it will return just value of the id column of the entity, just value.\n   * This is called mixed id map.\n   */\n  getEntityIdMixedMap(entity) {\n    if (!entity) return entity;\n    const idMap = this.getEntityIdMap(entity);\n    if (this.hasMultiplePrimaryKeys) {\n      return idMap;\n    } else if (idMap) {\n      return this.primaryColumns[0].getEntityValue(idMap); // todo: what about parent primary column?\n    }\n\n    return idMap;\n  }\n  /**\n   * Compares two different entities by their ids.\n   * Returns true if they match, false otherwise.\n   */\n  compareEntities(firstEntity, secondEntity) {\n    const firstEntityIdMap = this.getEntityIdMap(firstEntity);\n    if (!firstEntityIdMap) return false;\n    const secondEntityIdMap = this.getEntityIdMap(secondEntity);\n    if (!secondEntityIdMap) return false;\n    return OrmUtils.compareIds(firstEntityIdMap, secondEntityIdMap);\n  }\n  /**\n   * Finds column with a given property name.\n   */\n  findColumnWithPropertyName(propertyName) {\n    return this.columns.find(column => column.propertyName === propertyName);\n  }\n  /**\n   * Finds column with a given database name.\n   */\n  findColumnWithDatabaseName(databaseName) {\n    return this.columns.find(column => column.databaseName === databaseName);\n  }\n  /**\n   * Checks if there is a column or relationship with a given property path.\n   */\n  hasColumnWithPropertyPath(propertyPath) {\n    const hasColumn = this.columns.some(column => column.propertyPath === propertyPath);\n    return hasColumn || this.hasRelationWithPropertyPath(propertyPath);\n  }\n  /**\n   * Finds column with a given property path.\n   */\n  findColumnWithPropertyPath(propertyPath) {\n    const column = this.columns.find(column => column.propertyPath === propertyPath);\n    if (column) return column;\n    // in the case if column with property path was not found, try to find a relation with such property path\n    // if we find relation and it has a single join column then its the column user was seeking\n    const relation = this.relations.find(relation => relation.propertyPath === propertyPath);\n    if (relation && relation.joinColumns.length === 1) return relation.joinColumns[0];\n    return undefined;\n  }\n  /**\n   * Finds column with a given property path.\n   * Does not search in relation unlike findColumnWithPropertyPath.\n   */\n  findColumnWithPropertyPathStrict(propertyPath) {\n    return this.columns.find(column => column.propertyPath === propertyPath);\n  }\n  /**\n   * Finds columns with a given property path.\n   * Property path can match a relation, and relations can contain multiple columns.\n   */\n  findColumnsWithPropertyPath(propertyPath) {\n    const column = this.columns.find(column => column.propertyPath === propertyPath);\n    if (column) return [column];\n    // in the case if column with property path was not found, try to find a relation with such property path\n    // if we find relation and it has a single join column then its the column user was seeking\n    const relation = this.findRelationWithPropertyPath(propertyPath);\n    if (relation && relation.joinColumns) return relation.joinColumns;\n    return [];\n  }\n  /**\n   * Checks if there is a relation with the given property path.\n   */\n  hasRelationWithPropertyPath(propertyPath) {\n    return this.relations.some(relation => relation.propertyPath === propertyPath);\n  }\n  /**\n   * Finds relation with the given property path.\n   */\n  findRelationWithPropertyPath(propertyPath) {\n    return this.relations.find(relation => relation.propertyPath === propertyPath);\n  }\n  /**\n   * Checks if there is an embedded with a given property path.\n   */\n  hasEmbeddedWithPropertyPath(propertyPath) {\n    return this.allEmbeddeds.some(embedded => embedded.propertyPath === propertyPath);\n  }\n  /**\n   * Finds embedded with a given property path.\n   */\n  findEmbeddedWithPropertyPath(propertyPath) {\n    return this.allEmbeddeds.find(embedded => embedded.propertyPath === propertyPath);\n  }\n  /**\n   * Returns an array of databaseNames mapped from provided propertyPaths\n   */\n  mapPropertyPathsToColumns(propertyPaths) {\n    return propertyPaths.map(propertyPath => {\n      const column = this.findColumnWithPropertyPath(propertyPath);\n      if (column == null) {\n        throw new EntityPropertyNotFoundError(propertyPath, this);\n      }\n      return column;\n    });\n  }\n  /**\n   * Iterates through entity and finds and extracts all values from relations in the entity.\n   * If relation value is an array its being flattened.\n   */\n  extractRelationValuesFromEntity(entity, relations) {\n    const relationsAndValues = [];\n    relations.forEach(relation => {\n      const value = relation.getEntityValue(entity);\n      if (Array.isArray(value)) {\n        value.forEach(subValue => relationsAndValues.push([relation, subValue, EntityMetadata.getInverseEntityMetadata(subValue, relation)]));\n      } else if (value) {\n        relationsAndValues.push([relation, value, EntityMetadata.getInverseEntityMetadata(value, relation)]);\n      }\n    });\n    return relationsAndValues;\n  }\n  /**\n   * In the case of SingleTableInheritance, find the correct metadata\n   * for a given value.\n   *\n   * @param value The value to find the metadata for.\n   * @returns The found metadata for the entity or the base metadata if no matching metadata\n   *          was found in the whole inheritance tree.\n   */\n  findInheritanceMetadata(value) {\n    // Check for single table inheritance and find the correct metadata in that case.\n    // Goal is to use the correct discriminator as we could have a repository\n    // for an (abstract) base class and thus the target would not match.\n    if (this.inheritancePattern === \"STI\" && this.childEntityMetadatas.length > 0) {\n      // There could be a column on the base class that can manually be set to override the type.\n      let manuallySetDiscriminatorValue;\n      if (this.discriminatorColumn) {\n        manuallySetDiscriminatorValue = value[this.discriminatorColumn.propertyName];\n      }\n      return this.childEntityMetadatas.find(meta => manuallySetDiscriminatorValue === meta.discriminatorValue || value.constructor === meta.target) || this;\n    }\n    return this;\n  }\n  // -------------------------------------------------------------------------\n  // Private Static Methods\n  // -------------------------------------------------------------------------\n  static getInverseEntityMetadata(value, relation) {\n    return relation.inverseEntityMetadata.findInheritanceMetadata(value);\n  }\n  // -------------------------------------------------------------------------\n  // Public Static Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Creates a property paths for a given entity.\n   *\n   * @deprecated\n   */\n  static createPropertyPath(metadata, entity, prefix = \"\") {\n    const paths = [];\n    Object.keys(entity).forEach(key => {\n      // check for function is needed in the cases when createPropertyPath used on values contain a function as a value\n      // example: .update().set({ name: () => `SUBSTR('', 1, 2)` })\n      const parentPath = prefix ? prefix + \".\" + key : key;\n      if (metadata.hasEmbeddedWithPropertyPath(parentPath)) {\n        const subPaths = this.createPropertyPath(metadata, entity[key], parentPath);\n        paths.push(...subPaths);\n      } else {\n        const path = prefix ? prefix + \".\" + key : key;\n        paths.push(path);\n      }\n    });\n    return paths;\n  }\n  /**\n   * Finds difference between two entity id maps.\n   * Returns items that exist in the first array and absent in the second array.\n   */\n  static difference(firstIdMaps, secondIdMaps) {\n    return firstIdMaps.filter(firstIdMap => {\n      return !secondIdMaps.find(secondIdMap => OrmUtils.compareIds(firstIdMap, secondIdMap));\n    });\n  }\n  /**\n   * Creates value map from the given values and columns.\n   * Examples of usages are primary columns map and join columns map.\n   */\n  static getValueMap(entity, columns, options) {\n    return columns.reduce((map, column) => {\n      const value = column.getEntityValueMap(entity, options);\n      // make sure that none of the values of the columns are not missing\n      if (map === undefined || value === null || value === undefined) return undefined;\n      return OrmUtils.mergeDeep(map, value);\n    }, {});\n  }\n  // ---------------------------------------------------------------------\n  // Public Builder Methods\n  // ---------------------------------------------------------------------\n  build() {\n    var _a;\n    const namingStrategy = this.connection.namingStrategy;\n    const entityPrefix = this.connection.options.entityPrefix;\n    const entitySkipConstructor = this.connection.options.entitySkipConstructor;\n    this.engine = this.tableMetadataArgs.engine;\n    this.database = this.tableMetadataArgs.type === \"entity-child\" && this.parentEntityMetadata ? this.parentEntityMetadata.database : this.tableMetadataArgs.database;\n    if (this.tableMetadataArgs.schema) {\n      this.schema = this.tableMetadataArgs.schema;\n    } else if (this.tableMetadataArgs.type === \"entity-child\" && this.parentEntityMetadata) {\n      this.schema = this.parentEntityMetadata.schema;\n    } else if ((_a = this.connection.options) === null || _a === void 0 ? void 0 : _a.hasOwnProperty(\"schema\")) {\n      this.schema = this.connection.options.schema;\n    }\n    this.givenTableName = this.tableMetadataArgs.type === \"entity-child\" && this.parentEntityMetadata ? this.parentEntityMetadata.givenTableName : this.tableMetadataArgs.name;\n    this.synchronize = this.tableMetadataArgs.synchronize === false ? false : true;\n    this.targetName = typeof this.tableMetadataArgs.target === \"function\" ? this.tableMetadataArgs.target.name : this.tableMetadataArgs.target;\n    if (this.tableMetadataArgs.type === \"closure-junction\") {\n      this.tableNameWithoutPrefix = namingStrategy.closureJunctionTableName(this.givenTableName);\n    } else if (this.tableMetadataArgs.type === \"entity-child\" && this.parentEntityMetadata) {\n      this.tableNameWithoutPrefix = namingStrategy.tableName(this.parentEntityMetadata.targetName, this.parentEntityMetadata.givenTableName);\n    } else {\n      this.tableNameWithoutPrefix = namingStrategy.tableName(this.targetName, this.givenTableName);\n      if (this.tableMetadataArgs.type === \"junction\" && this.connection.driver.maxAliasLength && this.connection.driver.maxAliasLength > 0 && this.tableNameWithoutPrefix.length > this.connection.driver.maxAliasLength) {\n        // note: we are not using DriverUtils.buildAlias here because we would like to avoid\n        // hashed table names. However, current algorithm also isn't perfect, but we cannot\n        // change it, since it's a big breaking change. Planned to 0.4.0\n        this.tableNameWithoutPrefix = shorten(this.tableNameWithoutPrefix, {\n          separator: \"_\",\n          segmentLength: 3\n        });\n      }\n    }\n    this.tableName = entityPrefix ? namingStrategy.prefixTableName(entityPrefix, this.tableNameWithoutPrefix) : this.tableNameWithoutPrefix;\n    this.target = this.target ? this.target : this.tableName;\n    this.name = this.targetName ? this.targetName : this.tableName;\n    this.expression = this.tableMetadataArgs.expression;\n    this.withoutRowid = this.tableMetadataArgs.withoutRowid === true ? true : false;\n    this.tablePath = this.connection.driver.buildTableName(this.tableName, this.schema, this.database);\n    this.orderBy = typeof this.tableMetadataArgs.orderBy === \"function\" ? this.tableMetadataArgs.orderBy(this.propertiesMap) : this.tableMetadataArgs.orderBy; // todo: is propertiesMap available here? Looks like its not\n    if (entitySkipConstructor !== undefined) {\n      this.isAlwaysUsingConstructor = !entitySkipConstructor;\n    }\n    this.isJunction = this.tableMetadataArgs.type === \"closure-junction\" || this.tableMetadataArgs.type === \"junction\";\n    this.isClosureJunction = this.tableMetadataArgs.type === \"closure-junction\";\n  }\n  /**\n   * Registers a new column in the entity and recomputes all depend properties.\n   */\n  registerColumn(column) {\n    if (this.ownColumns.indexOf(column) !== -1) return;\n    this.ownColumns.push(column);\n    this.columns = this.embeddeds.reduce((columns, embedded) => columns.concat(embedded.columnsFromTree), this.ownColumns);\n    this.primaryColumns = this.columns.filter(column => column.isPrimary);\n    this.hasMultiplePrimaryKeys = this.primaryColumns.length > 1;\n    this.hasUUIDGeneratedColumns = this.columns.filter(column => column.isGenerated || column.generationStrategy === \"uuid\").length > 0;\n    this.propertiesMap = this.createPropertiesMap();\n    if (this.childEntityMetadatas) this.childEntityMetadatas.forEach(entityMetadata => entityMetadata.registerColumn(column));\n  }\n  /**\n   * Creates a special object - all columns and relations of the object (plus columns and relations from embeds)\n   * in a special format - { propertyName: propertyName }.\n   *\n   * example: Post{ id: number, name: string, counterEmbed: { count: number }, category: Category }.\n   * This method will create following object:\n   * { id: \"id\", counterEmbed: { count: \"counterEmbed.count\" }, category: \"category\" }\n   */\n  createPropertiesMap() {\n    const map = {};\n    this.columns.forEach(column => OrmUtils.mergeDeep(map, column.createValueMap(column.propertyPath)));\n    this.relations.forEach(relation => OrmUtils.mergeDeep(map, relation.createValueMap(relation.propertyPath)));\n    return map;\n  }\n  /**\n   * Checks if entity has any column which rely on returning data,\n   * e.g. columns with auto generated value, DEFAULT values considered as dependant of returning data.\n   * For example, if we need to have RETURNING after INSERT (or we need returned id for DBs not supporting RETURNING),\n   * it means we cannot execute bulk inserts in some cases.\n   */\n  getInsertionReturningColumns() {\n    return this.columns.filter(column => {\n      return column.default !== undefined || column.isGenerated || column.isCreateDate || column.isUpdateDate || column.isDeleteDate || column.isVersion;\n    });\n  }\n}","map":{"version":3,"names":["CannotCreateEntityIdMapError","OrmUtils","EntityPropertyNotFoundError","ObjectUtils","shorten","EntityMetadata","constructor","options","Symbol","for","childEntityMetadatas","inheritanceTree","tableType","withoutRowid","synchronize","hasNonNullableRelations","isJunction","isAlwaysUsingConstructor","isClosureJunction","hasMultiplePrimaryKeys","hasUUIDGeneratedColumns","ownColumns","columns","ancestorColumns","descendantColumns","nonVirtualColumns","ownerColumns","inverseColumns","generatedColumns","primaryColumns","ownRelations","relations","eagerRelations","lazyRelations","oneToOneRelations","ownerOneToOneRelations","oneToManyRelations","manyToOneRelations","manyToManyRelations","ownerManyToManyRelations","relationsWithJoinColumns","relationIds","relationCounts","foreignKeys","embeddeds","allEmbeddeds","ownIndices","indices","uniques","ownUniques","checks","exclusions","ownListeners","listeners","afterLoadListeners","beforeInsertListeners","afterInsertListeners","beforeUpdateListeners","afterUpdateListeners","beforeRemoveListeners","beforeSoftRemoveListeners","beforeRecoverListeners","afterRemoveListeners","afterSoftRemoveListeners","afterRecoverListeners","connection","inheritancePattern","treeType","tableTree","type","undefined","treeOptions","parentClosureEntityMetadata","tableMetadataArgs","args","target","expression","dependsOn","create","queryRunner","pojo","ret","fromDeserializer","Object","prototype","typename","targetName","forEach","relation","relationLoader","enableLazyLoad","hasId","entity","every","primaryColumn","value","getEntityValue","hasAllPrimaryKeys","ensureEntityIdMap","id","isObject","createValueMap","getEntityIdMap","getValueMap","skipNulls","getEntityIdMixedMap","idMap","compareEntities","firstEntity","secondEntity","firstEntityIdMap","secondEntityIdMap","compareIds","findColumnWithPropertyName","propertyName","find","column","findColumnWithDatabaseName","databaseName","hasColumnWithPropertyPath","propertyPath","hasColumn","some","hasRelationWithPropertyPath","findColumnWithPropertyPath","joinColumns","length","findColumnWithPropertyPathStrict","findColumnsWithPropertyPath","findRelationWithPropertyPath","hasEmbeddedWithPropertyPath","embedded","findEmbeddedWithPropertyPath","mapPropertyPathsToColumns","propertyPaths","map","extractRelationValuesFromEntity","relationsAndValues","Array","isArray","subValue","push","getInverseEntityMetadata","findInheritanceMetadata","manuallySetDiscriminatorValue","discriminatorColumn","meta","discriminatorValue","inverseEntityMetadata","createPropertyPath","metadata","prefix","paths","keys","key","parentPath","subPaths","path","difference","firstIdMaps","secondIdMaps","filter","firstIdMap","secondIdMap","reduce","getEntityValueMap","mergeDeep","build","_a","namingStrategy","entityPrefix","entitySkipConstructor","engine","database","parentEntityMetadata","schema","hasOwnProperty","givenTableName","name","tableNameWithoutPrefix","closureJunctionTableName","tableName","driver","maxAliasLength","separator","segmentLength","prefixTableName","tablePath","buildTableName","orderBy","propertiesMap","registerColumn","indexOf","concat","columnsFromTree","isPrimary","isGenerated","generationStrategy","createPropertiesMap","entityMetadata","getInsertionReturningColumns","default","isCreateDate","isUpdateDate","isDeleteDate","isVersion"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/metadata/EntityMetadata.js"],"sourcesContent":["import { CannotCreateEntityIdMapError } from \"../error/CannotCreateEntityIdMapError\";\nimport { OrmUtils } from \"../util/OrmUtils\";\nimport { EntityPropertyNotFoundError } from \"../error/EntityPropertyNotFoundError\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\nimport { shorten } from \"../util/StringUtils\";\n/**\n * Contains all entity metadata.\n */\nexport class EntityMetadata {\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n    constructor(options) {\n        this[\"@instanceof\"] = Symbol.for(\"EntityMetadata\");\n        /**\n         * Children entity metadatas. Used in inheritance patterns.\n         */\n        this.childEntityMetadatas = [];\n        /**\n         * All \"inheritance tree\" from a target entity.\n         * For example for target Post < ContentModel < Unit it will be an array of [Post, ContentModel, Unit].\n         * It also contains child entities for single table inheritance.\n         */\n        this.inheritanceTree = [];\n        /**\n         * Table type. Tables can be closure, junction, etc.\n         */\n        this.tableType = \"regular\";\n        /**\n         * Enables Sqlite \"WITHOUT ROWID\" modifier for the \"CREATE TABLE\" statement\n         */\n        this.withoutRowid = false;\n        /**\n         * Indicates if schema will be synchronized for this entity or not.\n         */\n        this.synchronize = true;\n        /**\n         * Checks if there any non-nullable column exist in this entity.\n         */\n        this.hasNonNullableRelations = false;\n        /**\n         * Indicates if this entity metadata of a junction table, or not.\n         * Junction table is a table created by many-to-many relationship.\n         *\n         * Its also possible to understand if entity is junction via tableType.\n         */\n        this.isJunction = false;\n        /**\n         * Indicates if the entity should be instantiated using the constructor\n         * or via allocating a new object via `Object.create()`.\n         */\n        this.isAlwaysUsingConstructor = true;\n        /**\n         * Checks if this table is a junction table of the closure table.\n         * This type is for tables that contain junction metadata of the closure tables.\n         */\n        this.isClosureJunction = false;\n        /**\n         * Checks if entity's table has multiple primary columns.\n         */\n        this.hasMultiplePrimaryKeys = false;\n        /**\n         * Indicates if this entity metadata has uuid generated columns.\n         */\n        this.hasUUIDGeneratedColumns = false;\n        /**\n         * Entity's column metadatas defined by user.\n         */\n        this.ownColumns = [];\n        /**\n         * Columns of the entity, including columns that are coming from the embeddeds of this entity.\n         */\n        this.columns = [];\n        /**\n         * Ancestor columns used only in closure junction tables.\n         */\n        this.ancestorColumns = [];\n        /**\n         * Descendant columns used only in closure junction tables.\n         */\n        this.descendantColumns = [];\n        /**\n         * All columns except for virtual columns.\n         */\n        this.nonVirtualColumns = [];\n        /**\n         * In the case if this entity metadata is junction table's entity metadata,\n         * this will contain all referenced columns of owner entity.\n         */\n        this.ownerColumns = [];\n        /**\n         * In the case if this entity metadata is junction table's entity metadata,\n         * this will contain all referenced columns of inverse entity.\n         */\n        this.inverseColumns = [];\n        /**\n         * Gets the column with generated flag.\n         */\n        this.generatedColumns = [];\n        /**\n         * Gets the primary columns.\n         */\n        this.primaryColumns = [];\n        /**\n         * Entity's relation metadatas.\n         */\n        this.ownRelations = [];\n        /**\n         * Relations of the entity, including relations that are coming from the embeddeds of this entity.\n         */\n        this.relations = [];\n        /**\n         * List of eager relations this metadata has.\n         */\n        this.eagerRelations = [];\n        /**\n         * List of eager relations this metadata has.\n         */\n        this.lazyRelations = [];\n        /**\n         * Gets only one-to-one relations of the entity.\n         */\n        this.oneToOneRelations = [];\n        /**\n         * Gets only owner one-to-one relations of the entity.\n         */\n        this.ownerOneToOneRelations = [];\n        /**\n         * Gets only one-to-many relations of the entity.\n         */\n        this.oneToManyRelations = [];\n        /**\n         * Gets only many-to-one relations of the entity.\n         */\n        this.manyToOneRelations = [];\n        /**\n         * Gets only many-to-many relations of the entity.\n         */\n        this.manyToManyRelations = [];\n        /**\n         * Gets only owner many-to-many relations of the entity.\n         */\n        this.ownerManyToManyRelations = [];\n        /**\n         * Gets only owner one-to-one and many-to-one relations.\n         */\n        this.relationsWithJoinColumns = [];\n        /**\n         * Entity's relation id metadatas.\n         */\n        this.relationIds = [];\n        /**\n         * Entity's relation id metadatas.\n         */\n        this.relationCounts = [];\n        /**\n         * Entity's foreign key metadatas.\n         */\n        this.foreignKeys = [];\n        /**\n         * Entity's embedded metadatas.\n         */\n        this.embeddeds = [];\n        /**\n         * All embeddeds - embeddeds from this entity metadata and from all child embeddeds, etc.\n         */\n        this.allEmbeddeds = [];\n        /**\n         * Entity's own indices.\n         */\n        this.ownIndices = [];\n        /**\n         * Entity's index metadatas.\n         */\n        this.indices = [];\n        /**\n         * Entity's unique metadatas.\n         */\n        this.uniques = [];\n        /**\n         * Entity's own uniques.\n         */\n        this.ownUniques = [];\n        /**\n         * Entity's check metadatas.\n         */\n        this.checks = [];\n        /**\n         * Entity's exclusion metadatas.\n         */\n        this.exclusions = [];\n        /**\n         * Entity's own listener metadatas.\n         */\n        this.ownListeners = [];\n        /**\n         * Entity listener metadatas.\n         */\n        this.listeners = [];\n        /**\n         * Listener metadatas with \"AFTER LOAD\" type.\n         */\n        this.afterLoadListeners = [];\n        /**\n         * Listener metadatas with \"AFTER INSERT\" type.\n         */\n        this.beforeInsertListeners = [];\n        /**\n         * Listener metadatas with \"AFTER INSERT\" type.\n         */\n        this.afterInsertListeners = [];\n        /**\n         * Listener metadatas with \"AFTER UPDATE\" type.\n         */\n        this.beforeUpdateListeners = [];\n        /**\n         * Listener metadatas with \"AFTER UPDATE\" type.\n         */\n        this.afterUpdateListeners = [];\n        /**\n         * Listener metadatas with \"AFTER REMOVE\" type.\n         */\n        this.beforeRemoveListeners = [];\n        /**\n         * Listener metadatas with \"BEFORE SOFT REMOVE\" type.\n         */\n        this.beforeSoftRemoveListeners = [];\n        /**\n         * Listener metadatas with \"BEFORE RECOVER\" type.\n         */\n        this.beforeRecoverListeners = [];\n        /**\n         * Listener metadatas with \"AFTER REMOVE\" type.\n         */\n        this.afterRemoveListeners = [];\n        /**\n         * Listener metadatas with \"AFTER SOFT REMOVE\" type.\n         */\n        this.afterSoftRemoveListeners = [];\n        /**\n         * Listener metadatas with \"AFTER RECOVER\" type.\n         */\n        this.afterRecoverListeners = [];\n        this.connection = options.connection;\n        this.inheritanceTree = options.inheritanceTree || [];\n        this.inheritancePattern = options.inheritancePattern;\n        this.treeType = options.tableTree ? options.tableTree.type : undefined;\n        this.treeOptions = options.tableTree\n            ? options.tableTree.options\n            : undefined;\n        this.parentClosureEntityMetadata = options.parentClosureEntityMetadata;\n        this.tableMetadataArgs = options.args;\n        this.target = this.tableMetadataArgs.target;\n        this.tableType = this.tableMetadataArgs.type;\n        this.expression = this.tableMetadataArgs.expression;\n        this.withoutRowid = this.tableMetadataArgs.withoutRowid;\n        this.dependsOn = this.tableMetadataArgs.dependsOn;\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Creates a new entity.\n     */\n    create(queryRunner, options) {\n        const pojo = options && options.pojo === true ? true : false;\n        // if target is set to a function (e.g. class) that can be created then create it\n        let ret;\n        if (typeof this.target === \"function\" && !pojo) {\n            if (!(options === null || options === void 0 ? void 0 : options.fromDeserializer) || this.isAlwaysUsingConstructor) {\n                ret = new this.target();\n            }\n            else {\n                ret = Object.create(this.target.prototype);\n            }\n        }\n        else {\n            // otherwise simply return a new empty object\n            ret = {};\n        }\n        // add \"typename\" property\n        if (this.connection.options.typename) {\n            ret[this.connection.options.typename] = this.targetName;\n        }\n        this.lazyRelations.forEach((relation) => this.connection.relationLoader.enableLazyLoad(relation, ret, queryRunner));\n        return ret;\n    }\n    /**\n     * Checks if given entity has an id.\n     */\n    hasId(entity) {\n        if (!entity)\n            return false;\n        return this.primaryColumns.every((primaryColumn) => {\n            const value = primaryColumn.getEntityValue(entity);\n            return value !== null && value !== undefined && value !== \"\";\n        });\n    }\n    /**\n     * Checks if given entity / object contains ALL primary keys entity must have.\n     * Returns true if it contains all of them, false if at least one of them is not defined.\n     */\n    hasAllPrimaryKeys(entity) {\n        return this.primaryColumns.every((primaryColumn) => {\n            const value = primaryColumn.getEntityValue(entity);\n            return value !== null && value !== undefined;\n        });\n    }\n    /**\n     * Ensures that given object is an entity id map.\n     * If given id is an object then it means its already id map.\n     * If given id isn't an object then it means its a value of the id column\n     * and it creates a new id map with this value and name of the primary column.\n     */\n    ensureEntityIdMap(id) {\n        if (ObjectUtils.isObject(id))\n            return id;\n        if (this.hasMultiplePrimaryKeys)\n            throw new CannotCreateEntityIdMapError(this, id);\n        return this.primaryColumns[0].createValueMap(id);\n    }\n    /**\n     * Gets primary keys of the entity and returns them in a literal object.\n     * For example, for Post{ id: 1, title: \"hello\" } where id is primary it will return { id: 1 }\n     * For multiple primary keys it returns multiple keys in object.\n     * For primary keys inside embeds it returns complex object literal with keys in them.\n     */\n    getEntityIdMap(entity) {\n        if (!entity)\n            return undefined;\n        return EntityMetadata.getValueMap(entity, this.primaryColumns, {\n            skipNulls: true,\n        });\n    }\n    /**\n     * Creates a \"mixed id map\".\n     * If entity has multiple primary keys (ids) then it will return just regular id map, like what getEntityIdMap returns.\n     * But if entity has a single primary key then it will return just value of the id column of the entity, just value.\n     * This is called mixed id map.\n     */\n    getEntityIdMixedMap(entity) {\n        if (!entity)\n            return entity;\n        const idMap = this.getEntityIdMap(entity);\n        if (this.hasMultiplePrimaryKeys) {\n            return idMap;\n        }\n        else if (idMap) {\n            return this.primaryColumns[0].getEntityValue(idMap); // todo: what about parent primary column?\n        }\n        return idMap;\n    }\n    /**\n     * Compares two different entities by their ids.\n     * Returns true if they match, false otherwise.\n     */\n    compareEntities(firstEntity, secondEntity) {\n        const firstEntityIdMap = this.getEntityIdMap(firstEntity);\n        if (!firstEntityIdMap)\n            return false;\n        const secondEntityIdMap = this.getEntityIdMap(secondEntity);\n        if (!secondEntityIdMap)\n            return false;\n        return OrmUtils.compareIds(firstEntityIdMap, secondEntityIdMap);\n    }\n    /**\n     * Finds column with a given property name.\n     */\n    findColumnWithPropertyName(propertyName) {\n        return this.columns.find((column) => column.propertyName === propertyName);\n    }\n    /**\n     * Finds column with a given database name.\n     */\n    findColumnWithDatabaseName(databaseName) {\n        return this.columns.find((column) => column.databaseName === databaseName);\n    }\n    /**\n     * Checks if there is a column or relationship with a given property path.\n     */\n    hasColumnWithPropertyPath(propertyPath) {\n        const hasColumn = this.columns.some((column) => column.propertyPath === propertyPath);\n        return hasColumn || this.hasRelationWithPropertyPath(propertyPath);\n    }\n    /**\n     * Finds column with a given property path.\n     */\n    findColumnWithPropertyPath(propertyPath) {\n        const column = this.columns.find((column) => column.propertyPath === propertyPath);\n        if (column)\n            return column;\n        // in the case if column with property path was not found, try to find a relation with such property path\n        // if we find relation and it has a single join column then its the column user was seeking\n        const relation = this.relations.find((relation) => relation.propertyPath === propertyPath);\n        if (relation && relation.joinColumns.length === 1)\n            return relation.joinColumns[0];\n        return undefined;\n    }\n    /**\n     * Finds column with a given property path.\n     * Does not search in relation unlike findColumnWithPropertyPath.\n     */\n    findColumnWithPropertyPathStrict(propertyPath) {\n        return this.columns.find((column) => column.propertyPath === propertyPath);\n    }\n    /**\n     * Finds columns with a given property path.\n     * Property path can match a relation, and relations can contain multiple columns.\n     */\n    findColumnsWithPropertyPath(propertyPath) {\n        const column = this.columns.find((column) => column.propertyPath === propertyPath);\n        if (column)\n            return [column];\n        // in the case if column with property path was not found, try to find a relation with such property path\n        // if we find relation and it has a single join column then its the column user was seeking\n        const relation = this.findRelationWithPropertyPath(propertyPath);\n        if (relation && relation.joinColumns)\n            return relation.joinColumns;\n        return [];\n    }\n    /**\n     * Checks if there is a relation with the given property path.\n     */\n    hasRelationWithPropertyPath(propertyPath) {\n        return this.relations.some((relation) => relation.propertyPath === propertyPath);\n    }\n    /**\n     * Finds relation with the given property path.\n     */\n    findRelationWithPropertyPath(propertyPath) {\n        return this.relations.find((relation) => relation.propertyPath === propertyPath);\n    }\n    /**\n     * Checks if there is an embedded with a given property path.\n     */\n    hasEmbeddedWithPropertyPath(propertyPath) {\n        return this.allEmbeddeds.some((embedded) => embedded.propertyPath === propertyPath);\n    }\n    /**\n     * Finds embedded with a given property path.\n     */\n    findEmbeddedWithPropertyPath(propertyPath) {\n        return this.allEmbeddeds.find((embedded) => embedded.propertyPath === propertyPath);\n    }\n    /**\n     * Returns an array of databaseNames mapped from provided propertyPaths\n     */\n    mapPropertyPathsToColumns(propertyPaths) {\n        return propertyPaths.map((propertyPath) => {\n            const column = this.findColumnWithPropertyPath(propertyPath);\n            if (column == null) {\n                throw new EntityPropertyNotFoundError(propertyPath, this);\n            }\n            return column;\n        });\n    }\n    /**\n     * Iterates through entity and finds and extracts all values from relations in the entity.\n     * If relation value is an array its being flattened.\n     */\n    extractRelationValuesFromEntity(entity, relations) {\n        const relationsAndValues = [];\n        relations.forEach((relation) => {\n            const value = relation.getEntityValue(entity);\n            if (Array.isArray(value)) {\n                value.forEach((subValue) => relationsAndValues.push([\n                    relation,\n                    subValue,\n                    EntityMetadata.getInverseEntityMetadata(subValue, relation),\n                ]));\n            }\n            else if (value) {\n                relationsAndValues.push([\n                    relation,\n                    value,\n                    EntityMetadata.getInverseEntityMetadata(value, relation),\n                ]);\n            }\n        });\n        return relationsAndValues;\n    }\n    /**\n     * In the case of SingleTableInheritance, find the correct metadata\n     * for a given value.\n     *\n     * @param value The value to find the metadata for.\n     * @returns The found metadata for the entity or the base metadata if no matching metadata\n     *          was found in the whole inheritance tree.\n     */\n    findInheritanceMetadata(value) {\n        // Check for single table inheritance and find the correct metadata in that case.\n        // Goal is to use the correct discriminator as we could have a repository\n        // for an (abstract) base class and thus the target would not match.\n        if (this.inheritancePattern === \"STI\" &&\n            this.childEntityMetadatas.length > 0) {\n            // There could be a column on the base class that can manually be set to override the type.\n            let manuallySetDiscriminatorValue;\n            if (this.discriminatorColumn) {\n                manuallySetDiscriminatorValue =\n                    value[this.discriminatorColumn.propertyName];\n            }\n            return (this.childEntityMetadatas.find((meta) => manuallySetDiscriminatorValue ===\n                meta.discriminatorValue ||\n                value.constructor === meta.target) || this);\n        }\n        return this;\n    }\n    // -------------------------------------------------------------------------\n    // Private Static Methods\n    // -------------------------------------------------------------------------\n    static getInverseEntityMetadata(value, relation) {\n        return relation.inverseEntityMetadata.findInheritanceMetadata(value);\n    }\n    // -------------------------------------------------------------------------\n    // Public Static Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Creates a property paths for a given entity.\n     *\n     * @deprecated\n     */\n    static createPropertyPath(metadata, entity, prefix = \"\") {\n        const paths = [];\n        Object.keys(entity).forEach((key) => {\n            // check for function is needed in the cases when createPropertyPath used on values contain a function as a value\n            // example: .update().set({ name: () => `SUBSTR('', 1, 2)` })\n            const parentPath = prefix ? prefix + \".\" + key : key;\n            if (metadata.hasEmbeddedWithPropertyPath(parentPath)) {\n                const subPaths = this.createPropertyPath(metadata, entity[key], parentPath);\n                paths.push(...subPaths);\n            }\n            else {\n                const path = prefix ? prefix + \".\" + key : key;\n                paths.push(path);\n            }\n        });\n        return paths;\n    }\n    /**\n     * Finds difference between two entity id maps.\n     * Returns items that exist in the first array and absent in the second array.\n     */\n    static difference(firstIdMaps, secondIdMaps) {\n        return firstIdMaps.filter((firstIdMap) => {\n            return !secondIdMaps.find((secondIdMap) => OrmUtils.compareIds(firstIdMap, secondIdMap));\n        });\n    }\n    /**\n     * Creates value map from the given values and columns.\n     * Examples of usages are primary columns map and join columns map.\n     */\n    static getValueMap(entity, columns, options) {\n        return columns.reduce((map, column) => {\n            const value = column.getEntityValueMap(entity, options);\n            // make sure that none of the values of the columns are not missing\n            if (map === undefined || value === null || value === undefined)\n                return undefined;\n            return OrmUtils.mergeDeep(map, value);\n        }, {});\n    }\n    // ---------------------------------------------------------------------\n    // Public Builder Methods\n    // ---------------------------------------------------------------------\n    build() {\n        var _a;\n        const namingStrategy = this.connection.namingStrategy;\n        const entityPrefix = this.connection.options.entityPrefix;\n        const entitySkipConstructor = this.connection.options.entitySkipConstructor;\n        this.engine = this.tableMetadataArgs.engine;\n        this.database =\n            this.tableMetadataArgs.type === \"entity-child\" &&\n                this.parentEntityMetadata\n                ? this.parentEntityMetadata.database\n                : this.tableMetadataArgs.database;\n        if (this.tableMetadataArgs.schema) {\n            this.schema = this.tableMetadataArgs.schema;\n        }\n        else if (this.tableMetadataArgs.type === \"entity-child\" &&\n            this.parentEntityMetadata) {\n            this.schema = this.parentEntityMetadata.schema;\n        }\n        else if ((_a = this.connection.options) === null || _a === void 0 ? void 0 : _a.hasOwnProperty(\"schema\")) {\n            this.schema = this.connection.options.schema;\n        }\n        this.givenTableName =\n            this.tableMetadataArgs.type === \"entity-child\" &&\n                this.parentEntityMetadata\n                ? this.parentEntityMetadata.givenTableName\n                : this.tableMetadataArgs.name;\n        this.synchronize =\n            this.tableMetadataArgs.synchronize === false ? false : true;\n        this.targetName =\n            typeof this.tableMetadataArgs.target === \"function\"\n                ? this.tableMetadataArgs.target.name\n                : this.tableMetadataArgs.target;\n        if (this.tableMetadataArgs.type === \"closure-junction\") {\n            this.tableNameWithoutPrefix =\n                namingStrategy.closureJunctionTableName(this.givenTableName);\n        }\n        else if (this.tableMetadataArgs.type === \"entity-child\" &&\n            this.parentEntityMetadata) {\n            this.tableNameWithoutPrefix = namingStrategy.tableName(this.parentEntityMetadata.targetName, this.parentEntityMetadata.givenTableName);\n        }\n        else {\n            this.tableNameWithoutPrefix = namingStrategy.tableName(this.targetName, this.givenTableName);\n            if (this.tableMetadataArgs.type === \"junction\" &&\n                this.connection.driver.maxAliasLength &&\n                this.connection.driver.maxAliasLength > 0 &&\n                this.tableNameWithoutPrefix.length >\n                    this.connection.driver.maxAliasLength) {\n                // note: we are not using DriverUtils.buildAlias here because we would like to avoid\n                // hashed table names. However, current algorithm also isn't perfect, but we cannot\n                // change it, since it's a big breaking change. Planned to 0.4.0\n                this.tableNameWithoutPrefix = shorten(this.tableNameWithoutPrefix, { separator: \"_\", segmentLength: 3 });\n            }\n        }\n        this.tableName = entityPrefix\n            ? namingStrategy.prefixTableName(entityPrefix, this.tableNameWithoutPrefix)\n            : this.tableNameWithoutPrefix;\n        this.target = this.target ? this.target : this.tableName;\n        this.name = this.targetName ? this.targetName : this.tableName;\n        this.expression = this.tableMetadataArgs.expression;\n        this.withoutRowid =\n            this.tableMetadataArgs.withoutRowid === true ? true : false;\n        this.tablePath = this.connection.driver.buildTableName(this.tableName, this.schema, this.database);\n        this.orderBy =\n            typeof this.tableMetadataArgs.orderBy === \"function\"\n                ? this.tableMetadataArgs.orderBy(this.propertiesMap)\n                : this.tableMetadataArgs.orderBy; // todo: is propertiesMap available here? Looks like its not\n        if (entitySkipConstructor !== undefined) {\n            this.isAlwaysUsingConstructor = !entitySkipConstructor;\n        }\n        this.isJunction =\n            this.tableMetadataArgs.type === \"closure-junction\" ||\n                this.tableMetadataArgs.type === \"junction\";\n        this.isClosureJunction =\n            this.tableMetadataArgs.type === \"closure-junction\";\n    }\n    /**\n     * Registers a new column in the entity and recomputes all depend properties.\n     */\n    registerColumn(column) {\n        if (this.ownColumns.indexOf(column) !== -1)\n            return;\n        this.ownColumns.push(column);\n        this.columns = this.embeddeds.reduce((columns, embedded) => columns.concat(embedded.columnsFromTree), this.ownColumns);\n        this.primaryColumns = this.columns.filter((column) => column.isPrimary);\n        this.hasMultiplePrimaryKeys = this.primaryColumns.length > 1;\n        this.hasUUIDGeneratedColumns =\n            this.columns.filter((column) => column.isGenerated || column.generationStrategy === \"uuid\").length > 0;\n        this.propertiesMap = this.createPropertiesMap();\n        if (this.childEntityMetadatas)\n            this.childEntityMetadatas.forEach((entityMetadata) => entityMetadata.registerColumn(column));\n    }\n    /**\n     * Creates a special object - all columns and relations of the object (plus columns and relations from embeds)\n     * in a special format - { propertyName: propertyName }.\n     *\n     * example: Post{ id: number, name: string, counterEmbed: { count: number }, category: Category }.\n     * This method will create following object:\n     * { id: \"id\", counterEmbed: { count: \"counterEmbed.count\" }, category: \"category\" }\n     */\n    createPropertiesMap() {\n        const map = {};\n        this.columns.forEach((column) => OrmUtils.mergeDeep(map, column.createValueMap(column.propertyPath)));\n        this.relations.forEach((relation) => OrmUtils.mergeDeep(map, relation.createValueMap(relation.propertyPath)));\n        return map;\n    }\n    /**\n     * Checks if entity has any column which rely on returning data,\n     * e.g. columns with auto generated value, DEFAULT values considered as dependant of returning data.\n     * For example, if we need to have RETURNING after INSERT (or we need returned id for DBs not supporting RETURNING),\n     * it means we cannot execute bulk inserts in some cases.\n     */\n    getInsertionReturningColumns() {\n        return this.columns.filter((column) => {\n            return (column.default !== undefined ||\n                column.isGenerated ||\n                column.isCreateDate ||\n                column.isUpdateDate ||\n                column.isDeleteDate ||\n                column.isVersion);\n        });\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}