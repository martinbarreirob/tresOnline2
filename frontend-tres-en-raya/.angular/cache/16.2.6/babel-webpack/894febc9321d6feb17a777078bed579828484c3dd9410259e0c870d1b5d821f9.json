{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/practicas/Downloads/angular/tresOnline/frontend-tres-en-raya/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { QueryBuilder } from \"./QueryBuilder\";\nimport { UpdateResult } from \"./result/UpdateResult\";\nimport { ReturningStatementNotSupportedError } from \"../error/ReturningStatementNotSupportedError\";\nimport { ReturningResultsEntityUpdator } from \"./ReturningResultsEntityUpdator\";\nimport { LimitOnUpdateNotSupportedError } from \"../error/LimitOnUpdateNotSupportedError\";\nimport { UpdateValuesMissingError } from \"../error/UpdateValuesMissingError\";\nimport { TypeORMError } from \"../error\";\nimport { EntityPropertyNotFoundError } from \"../error/EntityPropertyNotFoundError\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\nexport class UpdateQueryBuilder extends QueryBuilder {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connectionOrQueryBuilder, queryRunner) {\n    super(connectionOrQueryBuilder, queryRunner);\n    this[\"@instanceof\"] = Symbol.for(\"UpdateQueryBuilder\");\n    this.expressionMap.aliasNamePrefixingEnabled = false;\n  }\n  // -------------------------------------------------------------------------\n  // Public Implemented Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Gets generated SQL query without parameters being replaced.\n   */\n  getQuery() {\n    let sql = this.createComment();\n    sql += this.createCteExpression();\n    sql += this.createUpdateExpression();\n    sql += this.createOrderByExpression();\n    sql += this.createLimitExpression();\n    return this.replacePropertyNamesForTheWholeQuery(sql.trim());\n  }\n  /**\n   * Executes sql generated by query builder and returns raw database results.\n   */\n  execute() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const queryRunner = _this.obtainQueryRunner();\n      let transactionStartedByUs = false;\n      try {\n        // start transaction if it was enabled\n        if (_this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {\n          yield queryRunner.startTransaction();\n          transactionStartedByUs = true;\n        }\n        // call before updation methods in listeners and subscribers\n        if (_this.expressionMap.callListeners === true && _this.expressionMap.mainAlias.hasMetadata) {\n          yield queryRunner.broadcaster.broadcast(\"BeforeUpdate\", _this.expressionMap.mainAlias.metadata, _this.expressionMap.valuesSet);\n        }\n        let declareSql = null;\n        let selectOutputSql = null;\n        // if update entity mode is enabled we may need extra columns for the returning statement\n        const returningResultsEntityUpdator = new ReturningResultsEntityUpdator(queryRunner, _this.expressionMap);\n        const returningColumns = [];\n        if (Array.isArray(_this.expressionMap.returning) && _this.expressionMap.mainAlias.hasMetadata) {\n          for (const columnPath of _this.expressionMap.returning) {\n            returningColumns.push(..._this.expressionMap.mainAlias.metadata.findColumnsWithPropertyPath(columnPath));\n          }\n        }\n        if (_this.expressionMap.updateEntity === true && _this.expressionMap.mainAlias.hasMetadata && _this.expressionMap.whereEntities.length > 0) {\n          _this.expressionMap.extraReturningColumns = returningResultsEntityUpdator.getUpdationReturningColumns();\n          returningColumns.push(..._this.expressionMap.extraReturningColumns.filter(c => !returningColumns.includes(c)));\n        }\n        if (returningColumns.length > 0 && _this.connection.driver.options.type === \"mssql\") {\n          declareSql = _this.connection.driver.buildTableVariableDeclaration(\"@OutputTable\", returningColumns);\n          selectOutputSql = `SELECT * FROM @OutputTable`;\n        }\n        // execute update query\n        const [updateSql, parameters] = _this.getQueryAndParameters();\n        const statements = [declareSql, updateSql, selectOutputSql];\n        const queryResult = yield queryRunner.query(statements.filter(sql => sql != null).join(\";\\n\\n\"), parameters, true);\n        const updateResult = UpdateResult.from(queryResult);\n        // if we are updating entities and entity updation is enabled we must update some of entity columns (like version, update date, etc.)\n        if (_this.expressionMap.updateEntity === true && _this.expressionMap.mainAlias.hasMetadata && _this.expressionMap.whereEntities.length > 0) {\n          yield returningResultsEntityUpdator.update(updateResult, _this.expressionMap.whereEntities);\n        }\n        // call after updation methods in listeners and subscribers\n        if (_this.expressionMap.callListeners === true && _this.expressionMap.mainAlias.hasMetadata) {\n          yield queryRunner.broadcaster.broadcast(\"AfterUpdate\", _this.expressionMap.mainAlias.metadata, _this.expressionMap.valuesSet);\n        }\n        // close transaction if we started it\n        if (transactionStartedByUs) yield queryRunner.commitTransaction();\n        return updateResult;\n      } catch (error) {\n        // rollback transaction if we started it\n        if (transactionStartedByUs) {\n          try {\n            yield queryRunner.rollbackTransaction();\n          } catch (rollbackError) {}\n        }\n        throw error;\n      } finally {\n        if (queryRunner !== _this.queryRunner) {\n          // means we created our own query runner\n          yield queryRunner.release();\n        }\n      }\n    })();\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Values needs to be updated.\n   */\n  set(values) {\n    this.expressionMap.valuesSet = values;\n    return this;\n  }\n  /**\n   * Sets WHERE condition in the query builder.\n   * If you had previously WHERE expression defined,\n   * calling this function will override previously set WHERE conditions.\n   * Additionally you can add parameters used in where expression.\n   */\n  where(where, parameters) {\n    this.expressionMap.wheres = []; // don't move this block below since computeWhereParameter can add where expressions\n    const condition = this.getWhereCondition(where);\n    if (condition) this.expressionMap.wheres = [{\n      type: \"simple\",\n      condition: condition\n    }];\n    if (parameters) this.setParameters(parameters);\n    return this;\n  }\n  /**\n   * Adds new AND WHERE condition in the query builder.\n   * Additionally you can add parameters used in where expression.\n   */\n  andWhere(where, parameters) {\n    this.expressionMap.wheres.push({\n      type: \"and\",\n      condition: this.getWhereCondition(where)\n    });\n    if (parameters) this.setParameters(parameters);\n    return this;\n  }\n  /**\n   * Adds new OR WHERE condition in the query builder.\n   * Additionally you can add parameters used in where expression.\n   */\n  orWhere(where, parameters) {\n    this.expressionMap.wheres.push({\n      type: \"or\",\n      condition: this.getWhereCondition(where)\n    });\n    if (parameters) this.setParameters(parameters);\n    return this;\n  }\n  /**\n   * Sets WHERE condition in the query builder with a condition for the given ids.\n   * If you had previously WHERE expression defined,\n   * calling this function will override previously set WHERE conditions.\n   */\n  whereInIds(ids) {\n    return this.where(this.getWhereInIdsCondition(ids));\n  }\n  /**\n   * Adds new AND WHERE with conditions for the given ids.\n   */\n  andWhereInIds(ids) {\n    return this.andWhere(this.getWhereInIdsCondition(ids));\n  }\n  /**\n   * Adds new OR WHERE with conditions for the given ids.\n   */\n  orWhereInIds(ids) {\n    return this.orWhere(this.getWhereInIdsCondition(ids));\n  }\n  /**\n   * Optional returning/output clause.\n   */\n  output(output) {\n    return this.returning(output);\n  }\n  /**\n   * Optional returning/output clause.\n   */\n  returning(returning) {\n    // not all databases support returning/output cause\n    if (!this.connection.driver.isReturningSqlSupported(\"update\")) {\n      throw new ReturningStatementNotSupportedError();\n    }\n    this.expressionMap.returning = returning;\n    return this;\n  }\n  /**\n   * Sets ORDER BY condition in the query builder.\n   * If you had previously ORDER BY expression defined,\n   * calling this function will override previously set ORDER BY conditions.\n   */\n  orderBy(sort, order = \"ASC\", nulls) {\n    if (sort) {\n      if (typeof sort === \"object\") {\n        this.expressionMap.orderBys = sort;\n      } else {\n        if (nulls) {\n          this.expressionMap.orderBys = {\n            [sort]: {\n              order,\n              nulls\n            }\n          };\n        } else {\n          this.expressionMap.orderBys = {\n            [sort]: order\n          };\n        }\n      }\n    } else {\n      this.expressionMap.orderBys = {};\n    }\n    return this;\n  }\n  /**\n   * Adds ORDER BY condition in the query builder.\n   */\n  addOrderBy(sort, order = \"ASC\", nulls) {\n    if (nulls) {\n      this.expressionMap.orderBys[sort] = {\n        order,\n        nulls\n      };\n    } else {\n      this.expressionMap.orderBys[sort] = order;\n    }\n    return this;\n  }\n  /**\n   * Sets LIMIT - maximum number of rows to be selected.\n   */\n  limit(limit) {\n    this.expressionMap.limit = limit;\n    return this;\n  }\n  /**\n   * Indicates if entity must be updated after update operation.\n   * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).\n   * Enabled by default.\n   */\n  whereEntity(entity) {\n    if (!this.expressionMap.mainAlias.hasMetadata) throw new TypeORMError(`.whereEntity method can only be used on queries which update real entity table.`);\n    this.expressionMap.wheres = [];\n    const entities = Array.isArray(entity) ? entity : [entity];\n    entities.forEach(entity => {\n      const entityIdMap = this.expressionMap.mainAlias.metadata.getEntityIdMap(entity);\n      if (!entityIdMap) throw new TypeORMError(`Provided entity does not have ids set, cannot perform operation.`);\n      this.orWhereInIds(entityIdMap);\n    });\n    this.expressionMap.whereEntities = entities;\n    return this;\n  }\n  /**\n   * Indicates if entity must be updated after update operation.\n   * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).\n   * Enabled by default.\n   */\n  updateEntity(enabled) {\n    this.expressionMap.updateEntity = enabled;\n    return this;\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Creates UPDATE express used to perform insert query.\n   */\n  createUpdateExpression() {\n    const valuesSet = this.getValueSet();\n    const metadata = this.expressionMap.mainAlias.hasMetadata ? this.expressionMap.mainAlias.metadata : undefined;\n    // it doesn't make sense to update undefined properties, so just skip them\n    const valuesSetNormalized = {};\n    for (let key in valuesSet) {\n      if (valuesSet[key] !== undefined) {\n        valuesSetNormalized[key] = valuesSet[key];\n      }\n    }\n    // prepare columns and values to be updated\n    const updateColumnAndValues = [];\n    const updatedColumns = [];\n    if (metadata) {\n      this.createPropertyPath(metadata, valuesSetNormalized).forEach(propertyPath => {\n        // todo: make this and other query builder to work with properly with tables without metadata\n        const columns = metadata.findColumnsWithPropertyPath(propertyPath);\n        if (columns.length <= 0) {\n          throw new EntityPropertyNotFoundError(propertyPath, metadata);\n        }\n        columns.forEach(column => {\n          if (!column.isUpdate || updatedColumns.includes(column)) {\n            return;\n          }\n          updatedColumns.push(column);\n          //\n          let value = column.getEntityValue(valuesSetNormalized);\n          if (column.referencedColumn && typeof value === \"object\" && !(value instanceof Date) && value !== null && !Buffer.isBuffer(value)) {\n            value = column.referencedColumn.getEntityValue(value);\n          } else if (!(typeof value === \"function\")) {\n            value = this.connection.driver.preparePersistentValue(value, column);\n          }\n          // todo: duplication zone\n          if (typeof value === \"function\") {\n            // support for SQL expressions in update query\n            updateColumnAndValues.push(this.escape(column.databaseName) + \" = \" + value());\n          } else if ((this.connection.driver.options.type === \"sap\" || this.connection.driver.options.type === \"spanner\") && value === null) {\n            updateColumnAndValues.push(this.escape(column.databaseName) + \" = NULL\");\n          } else {\n            if (this.connection.driver.options.type === \"mssql\") {\n              value = this.connection.driver.parametrizeValue(column, value);\n            }\n            const paramName = this.createParameter(value);\n            let expression = null;\n            if ((DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === \"aurora-mysql\") && this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {\n              const useLegacy = this.connection.driver.options.legacySpatialSupport;\n              const geomFromText = useLegacy ? \"GeomFromText\" : \"ST_GeomFromText\";\n              if (column.srid != null) {\n                expression = `${geomFromText}(${paramName}, ${column.srid})`;\n              } else {\n                expression = `${geomFromText}(${paramName})`;\n              }\n            } else if (DriverUtils.isPostgresFamily(this.connection.driver) && this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {\n              if (column.srid != null) {\n                expression = `ST_SetSRID(ST_GeomFromGeoJSON(${paramName}), ${column.srid})::${column.type}`;\n              } else {\n                expression = `ST_GeomFromGeoJSON(${paramName})::${column.type}`;\n              }\n            } else if (this.connection.driver.options.type === \"mssql\" && this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {\n              expression = column.type + \"::STGeomFromText(\" + paramName + \", \" + (column.srid || \"0\") + \")\";\n            } else {\n              expression = paramName;\n            }\n            updateColumnAndValues.push(this.escape(column.databaseName) + \" = \" + expression);\n          }\n        });\n      });\n      // Don't allow calling update only with columns that are `update: false`\n      if (updateColumnAndValues.length > 0 || Object.keys(valuesSetNormalized).length === 0) {\n        if (metadata.versionColumn && updatedColumns.indexOf(metadata.versionColumn) === -1) updateColumnAndValues.push(this.escape(metadata.versionColumn.databaseName) + \" = \" + this.escape(metadata.versionColumn.databaseName) + \" + 1\");\n        if (metadata.updateDateColumn && updatedColumns.indexOf(metadata.updateDateColumn) === -1) updateColumnAndValues.push(this.escape(metadata.updateDateColumn.databaseName) + \" = CURRENT_TIMESTAMP\"); // todo: fix issue with CURRENT_TIMESTAMP(6) being used, can \"DEFAULT\" be used?!\n      }\n    } else {\n      Object.keys(valuesSetNormalized).map(key => {\n        let value = valuesSetNormalized[key];\n        // todo: duplication zone\n        if (typeof value === \"function\") {\n          // support for SQL expressions in update query\n          updateColumnAndValues.push(this.escape(key) + \" = \" + value());\n        } else if ((this.connection.driver.options.type === \"sap\" || this.connection.driver.options.type === \"spanner\") && value === null) {\n          updateColumnAndValues.push(this.escape(key) + \" = NULL\");\n        } else {\n          // we need to store array values in a special class to make sure parameter replacement will work correctly\n          // if (value instanceof Array)\n          //     value = new ArrayParameter(value);\n          const paramName = this.createParameter(value);\n          updateColumnAndValues.push(this.escape(key) + \" = \" + paramName);\n        }\n      });\n    }\n    if (updateColumnAndValues.length <= 0) {\n      throw new UpdateValuesMissingError();\n    }\n    // get a table name and all column database names\n    const whereExpression = this.createWhereExpression();\n    const returningExpression = this.createReturningExpression(\"update\");\n    if (returningExpression === \"\") {\n      return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(\", \")}${whereExpression}`; // todo: how do we replace aliases in where to nothing?\n    }\n\n    if (this.connection.driver.options.type === \"mssql\") {\n      return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(\", \")} OUTPUT ${returningExpression}${whereExpression}`;\n    }\n    return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(\", \")}${whereExpression} RETURNING ${returningExpression}`;\n  }\n  /**\n   * Creates \"ORDER BY\" part of SQL query.\n   */\n  createOrderByExpression() {\n    const orderBys = this.expressionMap.orderBys;\n    if (Object.keys(orderBys).length > 0) return \" ORDER BY \" + Object.keys(orderBys).map(columnName => {\n      if (typeof orderBys[columnName] === \"string\") {\n        return this.replacePropertyNames(columnName) + \" \" + orderBys[columnName];\n      } else {\n        return this.replacePropertyNames(columnName) + \" \" + orderBys[columnName].order + \" \" + orderBys[columnName].nulls;\n      }\n    }).join(\", \");\n    return \"\";\n  }\n  /**\n   * Creates \"LIMIT\" parts of SQL query.\n   */\n  createLimitExpression() {\n    let limit = this.expressionMap.limit;\n    if (limit) {\n      if (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === \"aurora-mysql\") {\n        return \" LIMIT \" + limit;\n      } else {\n        throw new LimitOnUpdateNotSupportedError();\n      }\n    }\n    return \"\";\n  }\n  /**\n   * Gets array of values need to be inserted into the target table.\n   */\n  getValueSet() {\n    if (typeof this.expressionMap.valuesSet === \"object\") return this.expressionMap.valuesSet;\n    throw new UpdateValuesMissingError();\n  }\n}","map":{"version":3,"names":["QueryBuilder","UpdateResult","ReturningStatementNotSupportedError","ReturningResultsEntityUpdator","LimitOnUpdateNotSupportedError","UpdateValuesMissingError","TypeORMError","EntityPropertyNotFoundError","DriverUtils","UpdateQueryBuilder","constructor","connectionOrQueryBuilder","queryRunner","Symbol","for","expressionMap","aliasNamePrefixingEnabled","getQuery","sql","createComment","createCteExpression","createUpdateExpression","createOrderByExpression","createLimitExpression","replacePropertyNamesForTheWholeQuery","trim","execute","_this","_asyncToGenerator","obtainQueryRunner","transactionStartedByUs","useTransaction","isTransactionActive","startTransaction","callListeners","mainAlias","hasMetadata","broadcaster","broadcast","metadata","valuesSet","declareSql","selectOutputSql","returningResultsEntityUpdator","returningColumns","Array","isArray","returning","columnPath","push","findColumnsWithPropertyPath","updateEntity","whereEntities","length","extraReturningColumns","getUpdationReturningColumns","filter","c","includes","connection","driver","options","type","buildTableVariableDeclaration","updateSql","parameters","getQueryAndParameters","statements","queryResult","query","join","updateResult","from","update","commitTransaction","error","rollbackTransaction","rollbackError","release","set","values","where","wheres","condition","getWhereCondition","setParameters","andWhere","orWhere","whereInIds","ids","getWhereInIdsCondition","andWhereInIds","orWhereInIds","output","isReturningSqlSupported","orderBy","sort","order","nulls","orderBys","addOrderBy","limit","whereEntity","entity","entities","forEach","entityIdMap","getEntityIdMap","enabled","getValueSet","undefined","valuesSetNormalized","key","updateColumnAndValues","updatedColumns","createPropertyPath","propertyPath","columns","column","isUpdate","value","getEntityValue","referencedColumn","Date","Buffer","isBuffer","preparePersistentValue","escape","databaseName","parametrizeValue","paramName","createParameter","expression","isMySQLFamily","spatialTypes","indexOf","useLegacy","legacySpatialSupport","geomFromText","srid","isPostgresFamily","Object","keys","versionColumn","updateDateColumn","map","whereExpression","createWhereExpression","returningExpression","createReturningExpression","getTableName","getMainTableName","columnName","replacePropertyNames"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/query-builder/UpdateQueryBuilder.js"],"sourcesContent":["import { QueryBuilder } from \"./QueryBuilder\";\nimport { UpdateResult } from \"./result/UpdateResult\";\nimport { ReturningStatementNotSupportedError } from \"../error/ReturningStatementNotSupportedError\";\nimport { ReturningResultsEntityUpdator } from \"./ReturningResultsEntityUpdator\";\nimport { LimitOnUpdateNotSupportedError } from \"../error/LimitOnUpdateNotSupportedError\";\nimport { UpdateValuesMissingError } from \"../error/UpdateValuesMissingError\";\nimport { TypeORMError } from \"../error\";\nimport { EntityPropertyNotFoundError } from \"../error/EntityPropertyNotFoundError\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\nexport class UpdateQueryBuilder extends QueryBuilder {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n    constructor(connectionOrQueryBuilder, queryRunner) {\n        super(connectionOrQueryBuilder, queryRunner);\n        this[\"@instanceof\"] = Symbol.for(\"UpdateQueryBuilder\");\n        this.expressionMap.aliasNamePrefixingEnabled = false;\n    }\n    // -------------------------------------------------------------------------\n    // Public Implemented Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Gets generated SQL query without parameters being replaced.\n     */\n    getQuery() {\n        let sql = this.createComment();\n        sql += this.createCteExpression();\n        sql += this.createUpdateExpression();\n        sql += this.createOrderByExpression();\n        sql += this.createLimitExpression();\n        return this.replacePropertyNamesForTheWholeQuery(sql.trim());\n    }\n    /**\n     * Executes sql generated by query builder and returns raw database results.\n     */\n    async execute() {\n        const queryRunner = this.obtainQueryRunner();\n        let transactionStartedByUs = false;\n        try {\n            // start transaction if it was enabled\n            if (this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false) {\n                await queryRunner.startTransaction();\n                transactionStartedByUs = true;\n            }\n            // call before updation methods in listeners and subscribers\n            if (this.expressionMap.callListeners === true &&\n                this.expressionMap.mainAlias.hasMetadata) {\n                await queryRunner.broadcaster.broadcast(\"BeforeUpdate\", this.expressionMap.mainAlias.metadata, this.expressionMap.valuesSet);\n            }\n            let declareSql = null;\n            let selectOutputSql = null;\n            // if update entity mode is enabled we may need extra columns for the returning statement\n            const returningResultsEntityUpdator = new ReturningResultsEntityUpdator(queryRunner, this.expressionMap);\n            const returningColumns = [];\n            if (Array.isArray(this.expressionMap.returning) &&\n                this.expressionMap.mainAlias.hasMetadata) {\n                for (const columnPath of this.expressionMap.returning) {\n                    returningColumns.push(...this.expressionMap.mainAlias.metadata.findColumnsWithPropertyPath(columnPath));\n                }\n            }\n            if (this.expressionMap.updateEntity === true &&\n                this.expressionMap.mainAlias.hasMetadata &&\n                this.expressionMap.whereEntities.length > 0) {\n                this.expressionMap.extraReturningColumns =\n                    returningResultsEntityUpdator.getUpdationReturningColumns();\n                returningColumns.push(...this.expressionMap.extraReturningColumns.filter((c) => !returningColumns.includes(c)));\n            }\n            if (returningColumns.length > 0 &&\n                this.connection.driver.options.type === \"mssql\") {\n                declareSql = this.connection.driver.buildTableVariableDeclaration(\"@OutputTable\", returningColumns);\n                selectOutputSql = `SELECT * FROM @OutputTable`;\n            }\n            // execute update query\n            const [updateSql, parameters] = this.getQueryAndParameters();\n            const statements = [declareSql, updateSql, selectOutputSql];\n            const queryResult = await queryRunner.query(statements.filter((sql) => sql != null).join(\";\\n\\n\"), parameters, true);\n            const updateResult = UpdateResult.from(queryResult);\n            // if we are updating entities and entity updation is enabled we must update some of entity columns (like version, update date, etc.)\n            if (this.expressionMap.updateEntity === true &&\n                this.expressionMap.mainAlias.hasMetadata &&\n                this.expressionMap.whereEntities.length > 0) {\n                await returningResultsEntityUpdator.update(updateResult, this.expressionMap.whereEntities);\n            }\n            // call after updation methods in listeners and subscribers\n            if (this.expressionMap.callListeners === true &&\n                this.expressionMap.mainAlias.hasMetadata) {\n                await queryRunner.broadcaster.broadcast(\"AfterUpdate\", this.expressionMap.mainAlias.metadata, this.expressionMap.valuesSet);\n            }\n            // close transaction if we started it\n            if (transactionStartedByUs)\n                await queryRunner.commitTransaction();\n            return updateResult;\n        }\n        catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction();\n                }\n                catch (rollbackError) { }\n            }\n            throw error;\n        }\n        finally {\n            if (queryRunner !== this.queryRunner) {\n                // means we created our own query runner\n                await queryRunner.release();\n            }\n        }\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Values needs to be updated.\n     */\n    set(values) {\n        this.expressionMap.valuesSet = values;\n        return this;\n    }\n    /**\n     * Sets WHERE condition in the query builder.\n     * If you had previously WHERE expression defined,\n     * calling this function will override previously set WHERE conditions.\n     * Additionally you can add parameters used in where expression.\n     */\n    where(where, parameters) {\n        this.expressionMap.wheres = []; // don't move this block below since computeWhereParameter can add where expressions\n        const condition = this.getWhereCondition(where);\n        if (condition)\n            this.expressionMap.wheres = [\n                { type: \"simple\", condition: condition },\n            ];\n        if (parameters)\n            this.setParameters(parameters);\n        return this;\n    }\n    /**\n     * Adds new AND WHERE condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    andWhere(where, parameters) {\n        this.expressionMap.wheres.push({\n            type: \"and\",\n            condition: this.getWhereCondition(where),\n        });\n        if (parameters)\n            this.setParameters(parameters);\n        return this;\n    }\n    /**\n     * Adds new OR WHERE condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    orWhere(where, parameters) {\n        this.expressionMap.wheres.push({\n            type: \"or\",\n            condition: this.getWhereCondition(where),\n        });\n        if (parameters)\n            this.setParameters(parameters);\n        return this;\n    }\n    /**\n     * Sets WHERE condition in the query builder with a condition for the given ids.\n     * If you had previously WHERE expression defined,\n     * calling this function will override previously set WHERE conditions.\n     */\n    whereInIds(ids) {\n        return this.where(this.getWhereInIdsCondition(ids));\n    }\n    /**\n     * Adds new AND WHERE with conditions for the given ids.\n     */\n    andWhereInIds(ids) {\n        return this.andWhere(this.getWhereInIdsCondition(ids));\n    }\n    /**\n     * Adds new OR WHERE with conditions for the given ids.\n     */\n    orWhereInIds(ids) {\n        return this.orWhere(this.getWhereInIdsCondition(ids));\n    }\n    /**\n     * Optional returning/output clause.\n     */\n    output(output) {\n        return this.returning(output);\n    }\n    /**\n     * Optional returning/output clause.\n     */\n    returning(returning) {\n        // not all databases support returning/output cause\n        if (!this.connection.driver.isReturningSqlSupported(\"update\")) {\n            throw new ReturningStatementNotSupportedError();\n        }\n        this.expressionMap.returning = returning;\n        return this;\n    }\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(sort, order = \"ASC\", nulls) {\n        if (sort) {\n            if (typeof sort === \"object\") {\n                this.expressionMap.orderBys = sort;\n            }\n            else {\n                if (nulls) {\n                    this.expressionMap.orderBys = {\n                        [sort]: { order, nulls },\n                    };\n                }\n                else {\n                    this.expressionMap.orderBys = { [sort]: order };\n                }\n            }\n        }\n        else {\n            this.expressionMap.orderBys = {};\n        }\n        return this;\n    }\n    /**\n     * Adds ORDER BY condition in the query builder.\n     */\n    addOrderBy(sort, order = \"ASC\", nulls) {\n        if (nulls) {\n            this.expressionMap.orderBys[sort] = { order, nulls };\n        }\n        else {\n            this.expressionMap.orderBys[sort] = order;\n        }\n        return this;\n    }\n    /**\n     * Sets LIMIT - maximum number of rows to be selected.\n     */\n    limit(limit) {\n        this.expressionMap.limit = limit;\n        return this;\n    }\n    /**\n     * Indicates if entity must be updated after update operation.\n     * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).\n     * Enabled by default.\n     */\n    whereEntity(entity) {\n        if (!this.expressionMap.mainAlias.hasMetadata)\n            throw new TypeORMError(`.whereEntity method can only be used on queries which update real entity table.`);\n        this.expressionMap.wheres = [];\n        const entities = Array.isArray(entity) ? entity : [entity];\n        entities.forEach((entity) => {\n            const entityIdMap = this.expressionMap.mainAlias.metadata.getEntityIdMap(entity);\n            if (!entityIdMap)\n                throw new TypeORMError(`Provided entity does not have ids set, cannot perform operation.`);\n            this.orWhereInIds(entityIdMap);\n        });\n        this.expressionMap.whereEntities = entities;\n        return this;\n    }\n    /**\n     * Indicates if entity must be updated after update operation.\n     * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).\n     * Enabled by default.\n     */\n    updateEntity(enabled) {\n        this.expressionMap.updateEntity = enabled;\n        return this;\n    }\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Creates UPDATE express used to perform insert query.\n     */\n    createUpdateExpression() {\n        const valuesSet = this.getValueSet();\n        const metadata = this.expressionMap.mainAlias.hasMetadata\n            ? this.expressionMap.mainAlias.metadata\n            : undefined;\n        // it doesn't make sense to update undefined properties, so just skip them\n        const valuesSetNormalized = {};\n        for (let key in valuesSet) {\n            if (valuesSet[key] !== undefined) {\n                valuesSetNormalized[key] = valuesSet[key];\n            }\n        }\n        // prepare columns and values to be updated\n        const updateColumnAndValues = [];\n        const updatedColumns = [];\n        if (metadata) {\n            this.createPropertyPath(metadata, valuesSetNormalized).forEach((propertyPath) => {\n                // todo: make this and other query builder to work with properly with tables without metadata\n                const columns = metadata.findColumnsWithPropertyPath(propertyPath);\n                if (columns.length <= 0) {\n                    throw new EntityPropertyNotFoundError(propertyPath, metadata);\n                }\n                columns.forEach((column) => {\n                    if (!column.isUpdate ||\n                        updatedColumns.includes(column)) {\n                        return;\n                    }\n                    updatedColumns.push(column);\n                    //\n                    let value = column.getEntityValue(valuesSetNormalized);\n                    if (column.referencedColumn &&\n                        typeof value === \"object\" &&\n                        !(value instanceof Date) &&\n                        value !== null &&\n                        !Buffer.isBuffer(value)) {\n                        value =\n                            column.referencedColumn.getEntityValue(value);\n                    }\n                    else if (!(typeof value === \"function\")) {\n                        value =\n                            this.connection.driver.preparePersistentValue(value, column);\n                    }\n                    // todo: duplication zone\n                    if (typeof value === \"function\") {\n                        // support for SQL expressions in update query\n                        updateColumnAndValues.push(this.escape(column.databaseName) +\n                            \" = \" +\n                            value());\n                    }\n                    else if ((this.connection.driver.options.type === \"sap\" ||\n                        this.connection.driver.options.type ===\n                            \"spanner\") &&\n                        value === null) {\n                        updateColumnAndValues.push(this.escape(column.databaseName) + \" = NULL\");\n                    }\n                    else {\n                        if (this.connection.driver.options.type === \"mssql\") {\n                            value = this.connection.driver.parametrizeValue(column, value);\n                        }\n                        const paramName = this.createParameter(value);\n                        let expression = null;\n                        if ((DriverUtils.isMySQLFamily(this.connection.driver) ||\n                            this.connection.driver.options.type ===\n                                \"aurora-mysql\") &&\n                            this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {\n                            const useLegacy = this.connection.driver.options.legacySpatialSupport;\n                            const geomFromText = useLegacy\n                                ? \"GeomFromText\"\n                                : \"ST_GeomFromText\";\n                            if (column.srid != null) {\n                                expression = `${geomFromText}(${paramName}, ${column.srid})`;\n                            }\n                            else {\n                                expression = `${geomFromText}(${paramName})`;\n                            }\n                        }\n                        else if (DriverUtils.isPostgresFamily(this.connection.driver) &&\n                            this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {\n                            if (column.srid != null) {\n                                expression = `ST_SetSRID(ST_GeomFromGeoJSON(${paramName}), ${column.srid})::${column.type}`;\n                            }\n                            else {\n                                expression = `ST_GeomFromGeoJSON(${paramName})::${column.type}`;\n                            }\n                        }\n                        else if (this.connection.driver.options.type ===\n                            \"mssql\" &&\n                            this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {\n                            expression =\n                                column.type +\n                                    \"::STGeomFromText(\" +\n                                    paramName +\n                                    \", \" +\n                                    (column.srid || \"0\") +\n                                    \")\";\n                        }\n                        else {\n                            expression = paramName;\n                        }\n                        updateColumnAndValues.push(this.escape(column.databaseName) +\n                            \" = \" +\n                            expression);\n                    }\n                });\n            });\n            // Don't allow calling update only with columns that are `update: false`\n            if (updateColumnAndValues.length > 0 ||\n                Object.keys(valuesSetNormalized).length === 0) {\n                if (metadata.versionColumn &&\n                    updatedColumns.indexOf(metadata.versionColumn) === -1)\n                    updateColumnAndValues.push(this.escape(metadata.versionColumn.databaseName) +\n                        \" = \" +\n                        this.escape(metadata.versionColumn.databaseName) +\n                        \" + 1\");\n                if (metadata.updateDateColumn &&\n                    updatedColumns.indexOf(metadata.updateDateColumn) === -1)\n                    updateColumnAndValues.push(this.escape(metadata.updateDateColumn.databaseName) +\n                        \" = CURRENT_TIMESTAMP\"); // todo: fix issue with CURRENT_TIMESTAMP(6) being used, can \"DEFAULT\" be used?!\n            }\n        }\n        else {\n            Object.keys(valuesSetNormalized).map((key) => {\n                let value = valuesSetNormalized[key];\n                // todo: duplication zone\n                if (typeof value === \"function\") {\n                    // support for SQL expressions in update query\n                    updateColumnAndValues.push(this.escape(key) + \" = \" + value());\n                }\n                else if ((this.connection.driver.options.type === \"sap\" ||\n                    this.connection.driver.options.type === \"spanner\") &&\n                    value === null) {\n                    updateColumnAndValues.push(this.escape(key) + \" = NULL\");\n                }\n                else {\n                    // we need to store array values in a special class to make sure parameter replacement will work correctly\n                    // if (value instanceof Array)\n                    //     value = new ArrayParameter(value);\n                    const paramName = this.createParameter(value);\n                    updateColumnAndValues.push(this.escape(key) + \" = \" + paramName);\n                }\n            });\n        }\n        if (updateColumnAndValues.length <= 0) {\n            throw new UpdateValuesMissingError();\n        }\n        // get a table name and all column database names\n        const whereExpression = this.createWhereExpression();\n        const returningExpression = this.createReturningExpression(\"update\");\n        if (returningExpression === \"\") {\n            return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(\", \")}${whereExpression}`; // todo: how do we replace aliases in where to nothing?\n        }\n        if (this.connection.driver.options.type === \"mssql\") {\n            return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(\", \")} OUTPUT ${returningExpression}${whereExpression}`;\n        }\n        return `UPDATE ${this.getTableName(this.getMainTableName())} SET ${updateColumnAndValues.join(\", \")}${whereExpression} RETURNING ${returningExpression}`;\n    }\n    /**\n     * Creates \"ORDER BY\" part of SQL query.\n     */\n    createOrderByExpression() {\n        const orderBys = this.expressionMap.orderBys;\n        if (Object.keys(orderBys).length > 0)\n            return (\" ORDER BY \" +\n                Object.keys(orderBys)\n                    .map((columnName) => {\n                    if (typeof orderBys[columnName] === \"string\") {\n                        return (this.replacePropertyNames(columnName) +\n                            \" \" +\n                            orderBys[columnName]);\n                    }\n                    else {\n                        return (this.replacePropertyNames(columnName) +\n                            \" \" +\n                            orderBys[columnName].order +\n                            \" \" +\n                            orderBys[columnName].nulls);\n                    }\n                })\n                    .join(\", \"));\n        return \"\";\n    }\n    /**\n     * Creates \"LIMIT\" parts of SQL query.\n     */\n    createLimitExpression() {\n        let limit = this.expressionMap.limit;\n        if (limit) {\n            if (DriverUtils.isMySQLFamily(this.connection.driver) ||\n                this.connection.driver.options.type === \"aurora-mysql\") {\n                return \" LIMIT \" + limit;\n            }\n            else {\n                throw new LimitOnUpdateNotSupportedError();\n            }\n        }\n        return \"\";\n    }\n    /**\n     * Gets array of values need to be inserted into the target table.\n     */\n    getValueSet() {\n        if (typeof this.expressionMap.valuesSet === \"object\")\n            return this.expressionMap.valuesSet;\n        throw new UpdateValuesMissingError();\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}