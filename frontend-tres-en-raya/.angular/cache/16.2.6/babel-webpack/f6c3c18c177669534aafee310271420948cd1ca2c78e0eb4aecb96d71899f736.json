{"ast":null,"code":"import { ObjectUtils } from \"../../util/ObjectUtils\";\n/**\n * Transforms plain old javascript object\n * Entity is constructed based on its entity metadata.\n */\nexport class PlainObjectToNewEntityTransformer {\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  transform(newEntity, object, metadata, getLazyRelationsPromiseValue = false) {\n    // console.log(\"groupAndTransform entity:\", newEntity);\n    // console.log(\"groupAndTransform object:\", object);\n    this.groupAndTransform(newEntity, object, metadata, getLazyRelationsPromiseValue);\n    // console.log(\"result:\", newEntity);\n    return newEntity;\n  }\n  // -------------------------------------------------------------------------\n  // Private Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Since db returns a duplicated rows of the data where accuracies of the same object can be duplicated\n   * we need to group our result and we must have some unique id (primary key in our case)\n   */\n  groupAndTransform(entity, object, metadata, getLazyRelationsPromiseValue = false) {\n    // console.log(\"groupAndTransform entity:\", entity);\n    // console.log(\"groupAndTransform object:\", object);\n    // copy regular column properties from the given object\n    metadata.nonVirtualColumns.forEach(column => {\n      const objectColumnValue = column.getEntityValue(object);\n      if (objectColumnValue !== undefined) column.setEntityValue(entity, objectColumnValue);\n    });\n    // // copy relation properties from the given object\n    if (metadata.relations.length) {\n      metadata.relations.forEach(relation => {\n        let entityRelatedValue = relation.getEntityValue(entity);\n        const objectRelatedValue = relation.getEntityValue(object, getLazyRelationsPromiseValue);\n        if (objectRelatedValue === undefined) return;\n        if (relation.isOneToMany || relation.isManyToMany) {\n          if (!Array.isArray(objectRelatedValue)) return;\n          if (!entityRelatedValue) {\n            entityRelatedValue = [];\n            relation.setEntityValue(entity, entityRelatedValue);\n          }\n          objectRelatedValue.forEach(objectRelatedValueItem => {\n            // check if we have this item from the merging object in the original entity we merge into\n            let objectRelatedValueEntity = entityRelatedValue.find(entityRelatedValueItem => {\n              return relation.inverseEntityMetadata.compareEntities(objectRelatedValueItem, entityRelatedValueItem);\n            });\n            const inverseEntityMetadata = relation.inverseEntityMetadata.findInheritanceMetadata(objectRelatedValueItem);\n            // if such item already exist then merge new data into it, if its not we create a new entity and merge it into the array\n            if (!objectRelatedValueEntity) {\n              objectRelatedValueEntity = inverseEntityMetadata.create(undefined, {\n                fromDeserializer: true\n              });\n              entityRelatedValue.push(objectRelatedValueEntity);\n            }\n            this.groupAndTransform(objectRelatedValueEntity, objectRelatedValueItem, inverseEntityMetadata, getLazyRelationsPromiseValue);\n          });\n        } else {\n          // if related object isn't an object (direct relation id for example)\n          // we just set it to the entity relation, we don't need anything more from it\n          // however we do it only if original entity does not have this relation set to object\n          // to prevent full overriding of objects\n          if (!ObjectUtils.isObject(objectRelatedValue)) {\n            if (!ObjectUtils.isObject(entityRelatedValue)) relation.setEntityValue(entity, objectRelatedValue);\n            return;\n          }\n          const inverseEntityMetadata = relation.inverseEntityMetadata.findInheritanceMetadata(objectRelatedValue);\n          if (!entityRelatedValue) {\n            entityRelatedValue = inverseEntityMetadata.create(undefined, {\n              fromDeserializer: true\n            });\n            relation.setEntityValue(entity, entityRelatedValue);\n          }\n          this.groupAndTransform(entityRelatedValue, objectRelatedValue, inverseEntityMetadata, getLazyRelationsPromiseValue);\n        }\n      });\n    }\n  }\n}","map":{"version":3,"names":["ObjectUtils","PlainObjectToNewEntityTransformer","transform","newEntity","object","metadata","getLazyRelationsPromiseValue","groupAndTransform","entity","nonVirtualColumns","forEach","column","objectColumnValue","getEntityValue","undefined","setEntityValue","relations","length","relation","entityRelatedValue","objectRelatedValue","isOneToMany","isManyToMany","Array","isArray","objectRelatedValueItem","objectRelatedValueEntity","find","entityRelatedValueItem","inverseEntityMetadata","compareEntities","findInheritanceMetadata","create","fromDeserializer","push","isObject"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/query-builder/transformer/PlainObjectToNewEntityTransformer.js"],"sourcesContent":["import { ObjectUtils } from \"../../util/ObjectUtils\";\n/**\n * Transforms plain old javascript object\n * Entity is constructed based on its entity metadata.\n */\nexport class PlainObjectToNewEntityTransformer {\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    transform(newEntity, object, metadata, getLazyRelationsPromiseValue = false) {\n        // console.log(\"groupAndTransform entity:\", newEntity);\n        // console.log(\"groupAndTransform object:\", object);\n        this.groupAndTransform(newEntity, object, metadata, getLazyRelationsPromiseValue);\n        // console.log(\"result:\", newEntity);\n        return newEntity;\n    }\n    // -------------------------------------------------------------------------\n    // Private Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Since db returns a duplicated rows of the data where accuracies of the same object can be duplicated\n     * we need to group our result and we must have some unique id (primary key in our case)\n     */\n    groupAndTransform(entity, object, metadata, getLazyRelationsPromiseValue = false) {\n        // console.log(\"groupAndTransform entity:\", entity);\n        // console.log(\"groupAndTransform object:\", object);\n        // copy regular column properties from the given object\n        metadata.nonVirtualColumns.forEach((column) => {\n            const objectColumnValue = column.getEntityValue(object);\n            if (objectColumnValue !== undefined)\n                column.setEntityValue(entity, objectColumnValue);\n        });\n        // // copy relation properties from the given object\n        if (metadata.relations.length) {\n            metadata.relations.forEach((relation) => {\n                let entityRelatedValue = relation.getEntityValue(entity);\n                const objectRelatedValue = relation.getEntityValue(object, getLazyRelationsPromiseValue);\n                if (objectRelatedValue === undefined)\n                    return;\n                if (relation.isOneToMany || relation.isManyToMany) {\n                    if (!Array.isArray(objectRelatedValue))\n                        return;\n                    if (!entityRelatedValue) {\n                        entityRelatedValue = [];\n                        relation.setEntityValue(entity, entityRelatedValue);\n                    }\n                    objectRelatedValue.forEach((objectRelatedValueItem) => {\n                        // check if we have this item from the merging object in the original entity we merge into\n                        let objectRelatedValueEntity = entityRelatedValue.find((entityRelatedValueItem) => {\n                            return relation.inverseEntityMetadata.compareEntities(objectRelatedValueItem, entityRelatedValueItem);\n                        });\n                        const inverseEntityMetadata = relation.inverseEntityMetadata.findInheritanceMetadata(objectRelatedValueItem);\n                        // if such item already exist then merge new data into it, if its not we create a new entity and merge it into the array\n                        if (!objectRelatedValueEntity) {\n                            objectRelatedValueEntity =\n                                inverseEntityMetadata.create(undefined, {\n                                    fromDeserializer: true,\n                                });\n                            entityRelatedValue.push(objectRelatedValueEntity);\n                        }\n                        this.groupAndTransform(objectRelatedValueEntity, objectRelatedValueItem, inverseEntityMetadata, getLazyRelationsPromiseValue);\n                    });\n                }\n                else {\n                    // if related object isn't an object (direct relation id for example)\n                    // we just set it to the entity relation, we don't need anything more from it\n                    // however we do it only if original entity does not have this relation set to object\n                    // to prevent full overriding of objects\n                    if (!ObjectUtils.isObject(objectRelatedValue)) {\n                        if (!ObjectUtils.isObject(entityRelatedValue))\n                            relation.setEntityValue(entity, objectRelatedValue);\n                        return;\n                    }\n                    const inverseEntityMetadata = relation.inverseEntityMetadata.findInheritanceMetadata(objectRelatedValue);\n                    if (!entityRelatedValue) {\n                        entityRelatedValue = inverseEntityMetadata.create(undefined, {\n                            fromDeserializer: true,\n                        });\n                        relation.setEntityValue(entity, entityRelatedValue);\n                    }\n                    this.groupAndTransform(entityRelatedValue, objectRelatedValue, inverseEntityMetadata, getLazyRelationsPromiseValue);\n                }\n            });\n        }\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}