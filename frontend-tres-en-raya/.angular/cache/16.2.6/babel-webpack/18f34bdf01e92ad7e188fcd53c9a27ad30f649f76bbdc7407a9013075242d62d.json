{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/practicas/Downloads/angular/tresOnline/frontend-tres-en-raya/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { TransactionNotStartedError } from \"../../error/TransactionNotStartedError\";\nimport { TableColumn } from \"../../schema-builder/table/TableColumn\";\nimport { Table } from \"../../schema-builder/table/Table\";\nimport { TableIndex } from \"../../schema-builder/table/TableIndex\";\nimport { TableForeignKey } from \"../../schema-builder/table/TableForeignKey\";\nimport { View } from \"../../schema-builder/view/View\";\nimport { Query } from \"../Query\";\nimport { TableUnique } from \"../../schema-builder/table/TableUnique\";\nimport { BaseQueryRunner } from \"../../query-runner/BaseQueryRunner\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\nimport { TableCheck } from \"../../schema-builder/table/TableCheck\";\nimport { TransactionAlreadyStartedError, TypeORMError } from \"../../error\";\nimport { MetadataTableType } from \"../types/MetadataTableType\";\nimport { InstanceChecker } from \"../../util/InstanceChecker\";\n/**\n * Runs queries on a single sqlite database connection.\n */\nexport class AbstractSqliteQueryRunner extends BaseQueryRunner {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor() {\n    super();\n    this.transactionPromise = null;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Creates/uses database connection from the connection pool to perform further operations.\n   * Returns obtained database connection.\n   */\n  connect() {\n    return Promise.resolve(this.driver.databaseConnection);\n  }\n  /**\n   * Releases used database connection.\n   * We just clear loaded tables and sql in memory, because sqlite do not support multiple connections thus query runners.\n   */\n  release() {\n    this.loadedTables = [];\n    this.clearSqlMemory();\n    return Promise.resolve();\n  }\n  /**\n   * Starts transaction.\n   */\n  startTransaction(isolationLevel) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (_this.driver.transactionSupport === \"none\") throw new TypeORMError(`Transactions aren't supported by ${_this.connection.driver.options.type}.`);\n      if (_this.isTransactionActive && _this.driver.transactionSupport === \"simple\") throw new TransactionAlreadyStartedError();\n      if (isolationLevel && isolationLevel !== \"READ UNCOMMITTED\" && isolationLevel !== \"SERIALIZABLE\") throw new TypeORMError(`SQLite only supports SERIALIZABLE and READ UNCOMMITTED isolation`);\n      _this.isTransactionActive = true;\n      try {\n        yield _this.broadcaster.broadcast(\"BeforeTransactionStart\");\n      } catch (err) {\n        _this.isTransactionActive = false;\n        throw err;\n      }\n      if (_this.transactionDepth === 0) {\n        if (isolationLevel) {\n          if (isolationLevel === \"READ UNCOMMITTED\") {\n            yield _this.query(\"PRAGMA read_uncommitted = true\");\n          } else {\n            yield _this.query(\"PRAGMA read_uncommitted = false\");\n          }\n        }\n        yield _this.query(\"BEGIN TRANSACTION\");\n      } else {\n        yield _this.query(`SAVEPOINT typeorm_${_this.transactionDepth}`);\n      }\n      _this.transactionDepth += 1;\n      yield _this.broadcaster.broadcast(\"AfterTransactionStart\");\n    })();\n  }\n  /**\n   * Commits transaction.\n   * Error will be thrown if transaction was not started.\n   */\n  commitTransaction() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this2.isTransactionActive) throw new TransactionNotStartedError();\n      yield _this2.broadcaster.broadcast(\"BeforeTransactionCommit\");\n      if (_this2.transactionDepth > 1) {\n        yield _this2.query(`RELEASE SAVEPOINT typeorm_${_this2.transactionDepth - 1}`);\n      } else {\n        yield _this2.query(\"COMMIT\");\n        _this2.isTransactionActive = false;\n      }\n      _this2.transactionDepth -= 1;\n      yield _this2.broadcaster.broadcast(\"AfterTransactionCommit\");\n    })();\n  }\n  /**\n   * Rollbacks transaction.\n   * Error will be thrown if transaction was not started.\n   */\n  rollbackTransaction() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this3.isTransactionActive) throw new TransactionNotStartedError();\n      yield _this3.broadcaster.broadcast(\"BeforeTransactionRollback\");\n      if (_this3.transactionDepth > 1) {\n        yield _this3.query(`ROLLBACK TO SAVEPOINT typeorm_${_this3.transactionDepth - 1}`);\n      } else {\n        yield _this3.query(\"ROLLBACK\");\n        _this3.isTransactionActive = false;\n      }\n      _this3.transactionDepth -= 1;\n      yield _this3.broadcaster.broadcast(\"AfterTransactionRollback\");\n    })();\n  }\n  /**\n   * Returns raw data stream.\n   */\n  stream(query, parameters, onEnd, onError) {\n    throw new TypeORMError(`Stream is not supported by sqlite driver.`);\n  }\n  /**\n   * Returns all available database names including system databases.\n   */\n  getDatabases() {\n    return _asyncToGenerator(function* () {\n      return Promise.resolve([]);\n    })();\n  }\n  /**\n   * Returns all available schema names including system schemas.\n   * If database parameter specified, returns schemas of that database.\n   */\n  getSchemas(database) {\n    return _asyncToGenerator(function* () {\n      return Promise.resolve([]);\n    })();\n  }\n  /**\n   * Checks if database with the given name exist.\n   */\n  hasDatabase(database) {\n    return _asyncToGenerator(function* () {\n      return Promise.resolve(false);\n    })();\n  }\n  /**\n   * Loads currently using database\n   */\n  getCurrentDatabase() {\n    return _asyncToGenerator(function* () {\n      return Promise.resolve(undefined);\n    })();\n  }\n  /**\n   * Checks if schema with the given name exist.\n   */\n  hasSchema(schema) {\n    return _asyncToGenerator(function* () {\n      throw new TypeORMError(`This driver does not support table schemas`);\n    })();\n  }\n  /**\n   * Loads currently using database schema\n   */\n  getCurrentSchema() {\n    return _asyncToGenerator(function* () {\n      return Promise.resolve(undefined);\n    })();\n  }\n  /**\n   * Checks if table with the given name exist in the database.\n   */\n  hasTable(tableOrName) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const tableName = InstanceChecker.isTable(tableOrName) ? tableOrName.name : tableOrName;\n      const sql = `SELECT * FROM \"sqlite_master\" WHERE \"type\" = 'table' AND \"name\" = '${tableName}'`;\n      const result = yield _this4.query(sql);\n      return result.length ? true : false;\n    })();\n  }\n  /**\n   * Checks if column with the given name exist in the given table.\n   */\n  hasColumn(tableOrName, columnName) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const tableName = InstanceChecker.isTable(tableOrName) ? tableOrName.name : tableOrName;\n      const sql = `PRAGMA table_xinfo(${_this5.escapePath(tableName)})`;\n      const columns = yield _this5.query(sql);\n      return !!columns.find(column => column[\"name\"] === columnName);\n    })();\n  }\n  /**\n   * Creates a new database.\n   */\n  createDatabase(database, ifNotExist) {\n    return _asyncToGenerator(function* () {\n      return Promise.resolve();\n    })();\n  }\n  /**\n   * Drops database.\n   */\n  dropDatabase(database, ifExist) {\n    return _asyncToGenerator(function* () {\n      return Promise.resolve();\n    })();\n  }\n  /**\n   * Creates a new table schema.\n   */\n  createSchema(schemaPath, ifNotExist) {\n    return _asyncToGenerator(function* () {\n      return Promise.resolve();\n    })();\n  }\n  /**\n   * Drops table schema.\n   */\n  dropSchema(schemaPath, ifExist) {\n    return _asyncToGenerator(function* () {\n      return Promise.resolve();\n    })();\n  }\n  /**\n   * Creates a new table.\n   */\n  createTable(table, ifNotExist = false, createForeignKeys = true, createIndices = true) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const upQueries = [];\n      const downQueries = [];\n      if (ifNotExist) {\n        const isTableExist = yield _this6.hasTable(table);\n        if (isTableExist) return Promise.resolve();\n      }\n      upQueries.push(_this6.createTableSql(table, createForeignKeys));\n      downQueries.push(_this6.dropTableSql(table));\n      if (createIndices) {\n        table.indices.forEach(index => {\n          // new index may be passed without name. In this case we generate index name manually.\n          if (!index.name) index.name = _this6.connection.namingStrategy.indexName(table, index.columnNames, index.where);\n          upQueries.push(_this6.createIndexSql(table, index));\n          downQueries.push(_this6.dropIndexSql(index));\n        });\n      }\n      // if table have column with generated type, we must add the expression to the metadata table\n      const generatedColumns = table.columns.filter(column => column.generatedType && column.asExpression);\n      for (const column of generatedColumns) {\n        const insertQuery = _this6.insertTypeormMetadataSql({\n          table: table.name,\n          type: MetadataTableType.GENERATED_COLUMN,\n          name: column.name,\n          value: column.asExpression\n        });\n        const deleteQuery = _this6.deleteTypeormMetadataSql({\n          table: table.name,\n          type: MetadataTableType.GENERATED_COLUMN,\n          name: column.name\n        });\n        upQueries.push(insertQuery);\n        downQueries.push(deleteQuery);\n      }\n      yield _this6.executeQueries(upQueries, downQueries);\n    })();\n  }\n  /**\n   * Drops the table.\n   */\n  dropTable(tableOrName, ifExist, dropForeignKeys = true, dropIndices = true) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      if (ifExist) {\n        const isTableExist = yield _this7.hasTable(tableOrName);\n        if (!isTableExist) return Promise.resolve();\n      }\n      // if dropTable called with dropForeignKeys = true, we must create foreign keys in down query.\n      const createForeignKeys = dropForeignKeys;\n      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield _this7.getCachedTable(tableOrName);\n      const upQueries = [];\n      const downQueries = [];\n      if (dropIndices) {\n        table.indices.forEach(index => {\n          upQueries.push(_this7.dropIndexSql(index));\n          downQueries.push(_this7.createIndexSql(table, index));\n        });\n      }\n      upQueries.push(_this7.dropTableSql(table, ifExist));\n      downQueries.push(_this7.createTableSql(table, createForeignKeys));\n      // if table had columns with generated type, we must remove the expression from the metadata table\n      const generatedColumns = table.columns.filter(column => column.generatedType && column.asExpression);\n      for (const column of generatedColumns) {\n        const deleteQuery = _this7.deleteTypeormMetadataSql({\n          table: table.name,\n          type: MetadataTableType.GENERATED_COLUMN,\n          name: column.name\n        });\n        const insertQuery = _this7.insertTypeormMetadataSql({\n          table: table.name,\n          type: MetadataTableType.GENERATED_COLUMN,\n          name: column.name,\n          value: column.asExpression\n        });\n        upQueries.push(deleteQuery);\n        downQueries.push(insertQuery);\n      }\n      yield _this7.executeQueries(upQueries, downQueries);\n    })();\n  }\n  /**\n   * Creates a new view.\n   */\n  createView(view, syncWithMetadata = false) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      const upQueries = [];\n      const downQueries = [];\n      upQueries.push(_this8.createViewSql(view));\n      if (syncWithMetadata) upQueries.push(_this8.insertViewDefinitionSql(view));\n      downQueries.push(_this8.dropViewSql(view));\n      if (syncWithMetadata) downQueries.push(_this8.deleteViewDefinitionSql(view));\n      yield _this8.executeQueries(upQueries, downQueries);\n    })();\n  }\n  /**\n   * Drops the view.\n   */\n  dropView(target) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      const viewName = InstanceChecker.isView(target) ? target.name : target;\n      const view = yield _this9.getCachedView(viewName);\n      const upQueries = [];\n      const downQueries = [];\n      upQueries.push(_this9.deleteViewDefinitionSql(view));\n      upQueries.push(_this9.dropViewSql(view));\n      downQueries.push(_this9.insertViewDefinitionSql(view));\n      downQueries.push(_this9.createViewSql(view));\n      yield _this9.executeQueries(upQueries, downQueries);\n    })();\n  }\n  /**\n   * Renames the given table.\n   */\n  renameTable(oldTableOrName, newTableName) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      const oldTable = InstanceChecker.isTable(oldTableOrName) ? oldTableOrName : yield _this10.getCachedTable(oldTableOrName);\n      const newTable = oldTable.clone();\n      newTable.name = newTableName;\n      // rename table\n      const up = new Query(`ALTER TABLE ${_this10.escapePath(oldTable.name)} RENAME TO ${_this10.escapePath(newTableName)}`);\n      const down = new Query(`ALTER TABLE ${_this10.escapePath(newTableName)} RENAME TO ${_this10.escapePath(oldTable.name)}`);\n      yield _this10.executeQueries(up, down);\n      // rename unique constraints\n      newTable.uniques.forEach(unique => {\n        const oldUniqueName = _this10.connection.namingStrategy.uniqueConstraintName(oldTable, unique.columnNames);\n        // Skip renaming if Unique has user defined constraint name\n        if (unique.name !== oldUniqueName) return;\n        unique.name = _this10.connection.namingStrategy.uniqueConstraintName(newTable, unique.columnNames);\n      });\n      // rename foreign key constraints\n      newTable.foreignKeys.forEach(foreignKey => {\n        const oldForeignKeyName = _this10.connection.namingStrategy.foreignKeyName(oldTable, foreignKey.columnNames, _this10.getTablePath(foreignKey), foreignKey.referencedColumnNames);\n        // Skip renaming if foreign key has user defined constraint name\n        if (foreignKey.name !== oldForeignKeyName) return;\n        foreignKey.name = _this10.connection.namingStrategy.foreignKeyName(newTable, foreignKey.columnNames, _this10.getTablePath(foreignKey), foreignKey.referencedColumnNames);\n      });\n      // rename indices\n      newTable.indices.forEach(index => {\n        const oldIndexName = _this10.connection.namingStrategy.indexName(oldTable, index.columnNames, index.where);\n        // Skip renaming if Index has user defined constraint name\n        if (index.name !== oldIndexName) return;\n        index.name = _this10.connection.namingStrategy.indexName(newTable, index.columnNames, index.where);\n      });\n      // rename old table;\n      oldTable.name = newTable.name;\n      // recreate table with new constraint names\n      yield _this10.recreateTable(newTable, oldTable);\n    })();\n  }\n  /**\n   * Creates a new column from the column in the table.\n   */\n  addColumn(tableOrName, column) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield _this11.getCachedTable(tableOrName);\n      return _this11.addColumns(table, [column]);\n    })();\n  }\n  /**\n   * Creates a new columns from the column in the table.\n   */\n  addColumns(tableOrName, columns) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield _this12.getCachedTable(tableOrName);\n      const changedTable = table.clone();\n      columns.forEach(column => changedTable.addColumn(column));\n      yield _this12.recreateTable(changedTable, table);\n    })();\n  }\n  /**\n   * Renames column in the given table.\n   */\n  renameColumn(tableOrName, oldTableColumnOrName, newTableColumnOrName) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield _this13.getCachedTable(tableOrName);\n      const oldColumn = InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find(c => c.name === oldTableColumnOrName);\n      if (!oldColumn) throw new TypeORMError(`Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`);\n      let newColumn = undefined;\n      if (InstanceChecker.isTableColumn(newTableColumnOrName)) {\n        newColumn = newTableColumnOrName;\n      } else {\n        newColumn = oldColumn.clone();\n        newColumn.name = newTableColumnOrName;\n      }\n      return _this13.changeColumn(table, oldColumn, newColumn);\n    })();\n  }\n  /**\n   * Changes a column in the table.\n   */\n  changeColumn(tableOrName, oldTableColumnOrName, newColumn) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield _this14.getCachedTable(tableOrName);\n      const oldColumn = InstanceChecker.isTableColumn(oldTableColumnOrName) ? oldTableColumnOrName : table.columns.find(c => c.name === oldTableColumnOrName);\n      if (!oldColumn) throw new TypeORMError(`Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`);\n      yield _this14.changeColumns(table, [{\n        oldColumn,\n        newColumn\n      }]);\n    })();\n  }\n  /**\n   * Changes a column in the table.\n   * Changed column looses all its keys in the db.\n   */\n  changeColumns(tableOrName, changedColumns) {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield _this15.getCachedTable(tableOrName);\n      const changedTable = table.clone();\n      changedColumns.forEach(changedColumnSet => {\n        if (changedColumnSet.newColumn.name !== changedColumnSet.oldColumn.name) {\n          changedTable.findColumnUniques(changedColumnSet.oldColumn).forEach(unique => {\n            const uniqueName = _this15.connection.namingStrategy.uniqueConstraintName(table, unique.columnNames);\n            unique.columnNames.splice(unique.columnNames.indexOf(changedColumnSet.oldColumn.name), 1);\n            unique.columnNames.push(changedColumnSet.newColumn.name);\n            // rename Unique only if it has default constraint name\n            if (unique.name === uniqueName) {\n              unique.name = _this15.connection.namingStrategy.uniqueConstraintName(changedTable, unique.columnNames);\n            }\n          });\n          changedTable.findColumnForeignKeys(changedColumnSet.oldColumn).forEach(foreignKey => {\n            const foreignKeyName = _this15.connection.namingStrategy.foreignKeyName(table, foreignKey.columnNames, _this15.getTablePath(foreignKey), foreignKey.referencedColumnNames);\n            foreignKey.columnNames.splice(foreignKey.columnNames.indexOf(changedColumnSet.oldColumn.name), 1);\n            foreignKey.columnNames.push(changedColumnSet.newColumn.name);\n            // rename FK only if it has default constraint name\n            if (foreignKey.name === foreignKeyName) {\n              foreignKey.name = _this15.connection.namingStrategy.foreignKeyName(changedTable, foreignKey.columnNames, _this15.getTablePath(foreignKey), foreignKey.referencedColumnNames);\n            }\n          });\n          changedTable.findColumnIndices(changedColumnSet.oldColumn).forEach(index => {\n            const indexName = _this15.connection.namingStrategy.indexName(table, index.columnNames, index.where);\n            index.columnNames.splice(index.columnNames.indexOf(changedColumnSet.oldColumn.name), 1);\n            index.columnNames.push(changedColumnSet.newColumn.name);\n            // rename Index only if it has default constraint name\n            if (index.name === indexName) {\n              index.name = _this15.connection.namingStrategy.indexName(changedTable, index.columnNames, index.where);\n            }\n          });\n        }\n        const originalColumn = changedTable.columns.find(column => column.name === changedColumnSet.oldColumn.name);\n        if (originalColumn) changedTable.columns[changedTable.columns.indexOf(originalColumn)] = changedColumnSet.newColumn;\n      });\n      yield _this15.recreateTable(changedTable, table);\n    })();\n  }\n  /**\n   * Drops column in the table.\n   */\n  dropColumn(tableOrName, columnOrName) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield _this16.getCachedTable(tableOrName);\n      const column = InstanceChecker.isTableColumn(columnOrName) ? columnOrName : table.findColumnByName(columnOrName);\n      if (!column) throw new TypeORMError(`Column \"${columnOrName}\" was not found in table \"${table.name}\"`);\n      yield _this16.dropColumns(table, [column]);\n    })();\n  }\n  /**\n   * Drops the columns in the table.\n   */\n  dropColumns(tableOrName, columns) {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield _this17.getCachedTable(tableOrName);\n      // clone original table and remove column and its constraints from cloned table\n      const changedTable = table.clone();\n      columns.forEach(column => {\n        const columnInstance = InstanceChecker.isTableColumn(column) ? column : table.findColumnByName(column);\n        if (!columnInstance) throw new Error(`Column \"${column}\" was not found in table \"${table.name}\"`);\n        changedTable.removeColumn(columnInstance);\n        changedTable.findColumnUniques(columnInstance).forEach(unique => changedTable.removeUniqueConstraint(unique));\n        changedTable.findColumnIndices(columnInstance).forEach(index => changedTable.removeIndex(index));\n        changedTable.findColumnForeignKeys(columnInstance).forEach(fk => changedTable.removeForeignKey(fk));\n      });\n      yield _this17.recreateTable(changedTable, table);\n    })();\n  }\n  /**\n   * Creates a new primary key.\n   */\n  createPrimaryKey(tableOrName, columnNames) {\n    var _this18 = this;\n    return _asyncToGenerator(function* () {\n      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield _this18.getCachedTable(tableOrName);\n      // clone original table and mark columns as primary\n      const changedTable = table.clone();\n      changedTable.columns.forEach(column => {\n        if (columnNames.find(columnName => columnName === column.name)) column.isPrimary = true;\n      });\n      yield _this18.recreateTable(changedTable, table);\n      // mark columns as primary in original table\n      table.columns.forEach(column => {\n        if (columnNames.find(columnName => columnName === column.name)) column.isPrimary = true;\n      });\n    })();\n  }\n  /**\n   * Updates composite primary keys.\n   */\n  updatePrimaryKeys(tableOrName, columns) {\n    return _asyncToGenerator(function* () {\n      yield Promise.resolve();\n    })();\n  }\n  /**\n   * Drops a primary key.\n   */\n  dropPrimaryKey(tableOrName) {\n    var _this19 = this;\n    return _asyncToGenerator(function* () {\n      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield _this19.getCachedTable(tableOrName);\n      // clone original table and mark primary columns as non-primary\n      const changedTable = table.clone();\n      changedTable.primaryColumns.forEach(column => {\n        column.isPrimary = false;\n      });\n      yield _this19.recreateTable(changedTable, table);\n      // mark primary columns as non-primary in original table\n      table.primaryColumns.forEach(column => {\n        column.isPrimary = false;\n      });\n    })();\n  }\n  /**\n   * Creates a new unique constraint.\n   */\n  createUniqueConstraint(tableOrName, uniqueConstraint) {\n    var _this20 = this;\n    return _asyncToGenerator(function* () {\n      yield _this20.createUniqueConstraints(tableOrName, [uniqueConstraint]);\n    })();\n  }\n  /**\n   * Creates a new unique constraints.\n   */\n  createUniqueConstraints(tableOrName, uniqueConstraints) {\n    var _this21 = this;\n    return _asyncToGenerator(function* () {\n      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield _this21.getCachedTable(tableOrName);\n      // clone original table and add unique constraints in to cloned table\n      const changedTable = table.clone();\n      uniqueConstraints.forEach(uniqueConstraint => changedTable.addUniqueConstraint(uniqueConstraint));\n      yield _this21.recreateTable(changedTable, table);\n    })();\n  }\n  /**\n   * Drops an unique constraint.\n   */\n  dropUniqueConstraint(tableOrName, uniqueOrName) {\n    var _this22 = this;\n    return _asyncToGenerator(function* () {\n      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield _this22.getCachedTable(tableOrName);\n      const uniqueConstraint = InstanceChecker.isTableUnique(uniqueOrName) ? uniqueOrName : table.uniques.find(u => u.name === uniqueOrName);\n      if (!uniqueConstraint) throw new TypeORMError(`Supplied unique constraint was not found in table ${table.name}`);\n      yield _this22.dropUniqueConstraints(table, [uniqueConstraint]);\n    })();\n  }\n  /**\n   * Creates an unique constraints.\n   */\n  dropUniqueConstraints(tableOrName, uniqueConstraints) {\n    var _this23 = this;\n    return _asyncToGenerator(function* () {\n      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield _this23.getCachedTable(tableOrName);\n      // clone original table and remove unique constraints from cloned table\n      const changedTable = table.clone();\n      uniqueConstraints.forEach(uniqueConstraint => changedTable.removeUniqueConstraint(uniqueConstraint));\n      yield _this23.recreateTable(changedTable, table);\n    })();\n  }\n  /**\n   * Creates new check constraint.\n   */\n  createCheckConstraint(tableOrName, checkConstraint) {\n    var _this24 = this;\n    return _asyncToGenerator(function* () {\n      yield _this24.createCheckConstraints(tableOrName, [checkConstraint]);\n    })();\n  }\n  /**\n   * Creates new check constraints.\n   */\n  createCheckConstraints(tableOrName, checkConstraints) {\n    var _this25 = this;\n    return _asyncToGenerator(function* () {\n      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield _this25.getCachedTable(tableOrName);\n      // clone original table and add check constraints in to cloned table\n      const changedTable = table.clone();\n      checkConstraints.forEach(checkConstraint => changedTable.addCheckConstraint(checkConstraint));\n      yield _this25.recreateTable(changedTable, table);\n    })();\n  }\n  /**\n   * Drops check constraint.\n   */\n  dropCheckConstraint(tableOrName, checkOrName) {\n    var _this26 = this;\n    return _asyncToGenerator(function* () {\n      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield _this26.getCachedTable(tableOrName);\n      const checkConstraint = InstanceChecker.isTableCheck(checkOrName) ? checkOrName : table.checks.find(c => c.name === checkOrName);\n      if (!checkConstraint) throw new TypeORMError(`Supplied check constraint was not found in table ${table.name}`);\n      yield _this26.dropCheckConstraints(table, [checkConstraint]);\n    })();\n  }\n  /**\n   * Drops check constraints.\n   */\n  dropCheckConstraints(tableOrName, checkConstraints) {\n    var _this27 = this;\n    return _asyncToGenerator(function* () {\n      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield _this27.getCachedTable(tableOrName);\n      // clone original table and remove check constraints from cloned table\n      const changedTable = table.clone();\n      checkConstraints.forEach(checkConstraint => changedTable.removeCheckConstraint(checkConstraint));\n      yield _this27.recreateTable(changedTable, table);\n    })();\n  }\n  /**\n   * Creates a new exclusion constraint.\n   */\n  createExclusionConstraint(tableOrName, exclusionConstraint) {\n    return _asyncToGenerator(function* () {\n      throw new TypeORMError(`Sqlite does not support exclusion constraints.`);\n    })();\n  }\n  /**\n   * Creates a new exclusion constraints.\n   */\n  createExclusionConstraints(tableOrName, exclusionConstraints) {\n    return _asyncToGenerator(function* () {\n      throw new TypeORMError(`Sqlite does not support exclusion constraints.`);\n    })();\n  }\n  /**\n   * Drops exclusion constraint.\n   */\n  dropExclusionConstraint(tableOrName, exclusionOrName) {\n    return _asyncToGenerator(function* () {\n      throw new TypeORMError(`Sqlite does not support exclusion constraints.`);\n    })();\n  }\n  /**\n   * Drops exclusion constraints.\n   */\n  dropExclusionConstraints(tableOrName, exclusionConstraints) {\n    return _asyncToGenerator(function* () {\n      throw new TypeORMError(`Sqlite does not support exclusion constraints.`);\n    })();\n  }\n  /**\n   * Creates a new foreign key.\n   */\n  createForeignKey(tableOrName, foreignKey) {\n    var _this28 = this;\n    return _asyncToGenerator(function* () {\n      yield _this28.createForeignKeys(tableOrName, [foreignKey]);\n    })();\n  }\n  /**\n   * Creates a new foreign keys.\n   */\n  createForeignKeys(tableOrName, foreignKeys) {\n    var _this29 = this;\n    return _asyncToGenerator(function* () {\n      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield _this29.getCachedTable(tableOrName);\n      // clone original table and add foreign keys in to cloned table\n      const changedTable = table.clone();\n      foreignKeys.forEach(foreignKey => changedTable.addForeignKey(foreignKey));\n      yield _this29.recreateTable(changedTable, table);\n    })();\n  }\n  /**\n   * Drops a foreign key from the table.\n   */\n  dropForeignKey(tableOrName, foreignKeyOrName) {\n    var _this30 = this;\n    return _asyncToGenerator(function* () {\n      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield _this30.getCachedTable(tableOrName);\n      const foreignKey = InstanceChecker.isTableForeignKey(foreignKeyOrName) ? foreignKeyOrName : table.foreignKeys.find(fk => fk.name === foreignKeyOrName);\n      if (!foreignKey) throw new TypeORMError(`Supplied foreign key was not found in table ${table.name}`);\n      yield _this30.dropForeignKeys(tableOrName, [foreignKey]);\n    })();\n  }\n  /**\n   * Drops a foreign keys from the table.\n   */\n  dropForeignKeys(tableOrName, foreignKeys) {\n    var _this31 = this;\n    return _asyncToGenerator(function* () {\n      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield _this31.getCachedTable(tableOrName);\n      // clone original table and remove foreign keys from cloned table\n      const changedTable = table.clone();\n      foreignKeys.forEach(foreignKey => changedTable.removeForeignKey(foreignKey));\n      yield _this31.recreateTable(changedTable, table);\n    })();\n  }\n  /**\n   * Creates a new index.\n   */\n  createIndex(tableOrName, index) {\n    var _this32 = this;\n    return _asyncToGenerator(function* () {\n      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield _this32.getCachedTable(tableOrName);\n      // new index may be passed without name. In this case we generate index name manually.\n      if (!index.name) index.name = _this32.generateIndexName(table, index);\n      const up = _this32.createIndexSql(table, index);\n      const down = _this32.dropIndexSql(index);\n      yield _this32.executeQueries(up, down);\n      table.addIndex(index);\n    })();\n  }\n  /**\n   * Creates a new indices\n   */\n  createIndices(tableOrName, indices) {\n    var _this33 = this;\n    return _asyncToGenerator(function* () {\n      const promises = indices.map(index => _this33.createIndex(tableOrName, index));\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Drops an index from the table.\n   */\n  dropIndex(tableOrName, indexOrName) {\n    var _this34 = this;\n    return _asyncToGenerator(function* () {\n      const table = InstanceChecker.isTable(tableOrName) ? tableOrName : yield _this34.getCachedTable(tableOrName);\n      const index = InstanceChecker.isTableIndex(indexOrName) ? indexOrName : table.indices.find(i => i.name === indexOrName);\n      if (!index) throw new TypeORMError(`Supplied index ${indexOrName} was not found in table ${table.name}`);\n      // old index may be passed without name. In this case we generate index name manually.\n      if (!index.name) index.name = _this34.generateIndexName(table, index);\n      const up = _this34.dropIndexSql(index);\n      const down = _this34.createIndexSql(table, index);\n      yield _this34.executeQueries(up, down);\n      table.removeIndex(index);\n    })();\n  }\n  /**\n   * Drops an indices from the table.\n   */\n  dropIndices(tableOrName, indices) {\n    var _this35 = this;\n    return _asyncToGenerator(function* () {\n      const promises = indices.map(index => _this35.dropIndex(tableOrName, index));\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Clears all table contents.\n   * Note: this operation uses SQL's TRUNCATE query which cannot be reverted in transactions.\n   */\n  clearTable(tableName) {\n    var _this36 = this;\n    return _asyncToGenerator(function* () {\n      yield _this36.query(`DELETE FROM ${_this36.escapePath(tableName)}`);\n    })();\n  }\n  /**\n   * Removes all tables from the currently connected database.\n   */\n  clearDatabase(database) {\n    var _this37 = this;\n    return _asyncToGenerator(function* () {\n      let dbPath = undefined;\n      if (database && _this37.driver.getAttachedDatabaseHandleByRelativePath(database)) {\n        dbPath = _this37.driver.getAttachedDatabaseHandleByRelativePath(database);\n      }\n      yield _this37.query(`PRAGMA foreign_keys = OFF`);\n      const isAnotherTransactionActive = _this37.isTransactionActive;\n      if (!isAnotherTransactionActive) yield _this37.startTransaction();\n      try {\n        const selectViewDropsQuery = dbPath ? `SELECT 'DROP VIEW \"${dbPath}\".\"' || name || '\";' as query FROM \"${dbPath}\".\"sqlite_master\" WHERE \"type\" = 'view'` : `SELECT 'DROP VIEW \"' || name || '\";' as query FROM \"sqlite_master\" WHERE \"type\" = 'view'`;\n        const dropViewQueries = yield _this37.query(selectViewDropsQuery);\n        yield Promise.all(dropViewQueries.map(q => _this37.query(q[\"query\"])));\n        const selectTableDropsQuery = dbPath ? `SELECT 'DROP TABLE \"${dbPath}\".\"' || name || '\";' as query FROM \"${dbPath}\".\"sqlite_master\" WHERE \"type\" = 'table' AND \"name\" != 'sqlite_sequence'` : `SELECT 'DROP TABLE \"' || name || '\";' as query FROM \"sqlite_master\" WHERE \"type\" = 'table' AND \"name\" != 'sqlite_sequence'`;\n        const dropTableQueries = yield _this37.query(selectTableDropsQuery);\n        yield Promise.all(dropTableQueries.map(q => _this37.query(q[\"query\"])));\n        if (!isAnotherTransactionActive) yield _this37.commitTransaction();\n      } catch (error) {\n        try {\n          // we throw original error even if rollback thrown an error\n          if (!isAnotherTransactionActive) yield _this37.rollbackTransaction();\n        } catch (rollbackError) {}\n        throw error;\n      } finally {\n        yield _this37.query(`PRAGMA foreign_keys = ON`);\n      }\n    })();\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  loadViews(viewNames) {\n    var _this38 = this;\n    return _asyncToGenerator(function* () {\n      const hasTable = yield _this38.hasTable(_this38.getTypeormMetadataTableName());\n      if (!hasTable) {\n        return [];\n      }\n      if (!viewNames) {\n        viewNames = [];\n      }\n      const viewNamesString = viewNames.map(name => \"'\" + name + \"'\").join(\", \");\n      let query = `SELECT \"t\".* FROM \"${_this38.getTypeormMetadataTableName()}\" \"t\" INNER JOIN \"sqlite_master\" s ON \"s\".\"name\" = \"t\".\"name\" AND \"s\".\"type\" = 'view' WHERE \"t\".\"type\" = '${MetadataTableType.VIEW}'`;\n      if (viewNamesString.length > 0) query += ` AND \"t\".\"name\" IN (${viewNamesString})`;\n      const dbViews = yield _this38.query(query);\n      return dbViews.map(dbView => {\n        const view = new View();\n        view.name = dbView[\"name\"];\n        view.expression = dbView[\"value\"];\n        return view;\n      });\n    })();\n  }\n  loadTableRecords(tablePath, tableOrIndex) {\n    var _this39 = this;\n    return _asyncToGenerator(function* () {\n      let database = undefined;\n      const [schema, tableName] = _this39.splitTablePath(tablePath);\n      if (schema && _this39.driver.getAttachedDatabasePathRelativeByHandle(schema)) {\n        database = _this39.driver.getAttachedDatabasePathRelativeByHandle(schema);\n      }\n      return _this39.query(`SELECT ${database ? `'${database}'` : null} as database, ${schema ? `'${schema}'` : null} as schema, * FROM ${schema ? `\"${schema}\".` : \"\"}${_this39.escapePath(`sqlite_master`)} WHERE \"type\" = '${tableOrIndex}' AND \"${tableOrIndex === \"table\" ? \"name\" : \"tbl_name\"}\" IN ('${tableName}')`);\n    })();\n  }\n  loadPragmaRecords(tablePath, pragma) {\n    var _this40 = this;\n    return _asyncToGenerator(function* () {\n      const [, tableName] = _this40.splitTablePath(tablePath);\n      return _this40.query(`PRAGMA ${pragma}(\"${tableName}\")`);\n    })();\n  }\n  /**\n   * Loads all tables (with given names) from the database and creates a Table from them.\n   */\n  loadTables(tableNames) {\n    var _this41 = this;\n    return _asyncToGenerator(function* () {\n      // if no tables given then no need to proceed\n      if (tableNames && tableNames.length === 0) {\n        return [];\n      }\n      let dbTables = [];\n      let dbIndicesDef;\n      if (!tableNames) {\n        const tablesSql = `SELECT * FROM \"sqlite_master\" WHERE \"type\" = 'table'`;\n        dbTables.push(...(yield _this41.query(tablesSql)));\n        const tableNamesString = dbTables.map(({\n          name\n        }) => `'${name}'`).join(\", \");\n        dbIndicesDef = yield _this41.query(`SELECT * FROM \"sqlite_master\" WHERE \"type\" = 'index' AND \"tbl_name\" IN (${tableNamesString})`);\n      } else {\n        const tableNamesWithoutDot = tableNames.filter(tableName => {\n          return tableName.split(\".\").length === 1;\n        }).map(tableName => `'${tableName}'`);\n        const tableNamesWithDot = tableNames.filter(tableName => {\n          return tableName.split(\".\").length > 1;\n        });\n        const queryPromises = type => {\n          const promises = [...tableNamesWithDot.map(tableName => _this41.loadTableRecords(tableName, type))];\n          if (tableNamesWithoutDot.length) {\n            promises.push(_this41.query(`SELECT * FROM \"sqlite_master\" WHERE \"type\" = '${type}' AND \"${type === \"table\" ? \"name\" : \"tbl_name\"}\" IN (${tableNamesWithoutDot})`));\n          }\n          return promises;\n        };\n        dbTables = (yield Promise.all(queryPromises(\"table\"))).reduce((acc, res) => [...acc, ...res], []).filter(Boolean);\n        dbIndicesDef = (yield Promise.all(queryPromises(\"index\"))).reduce((acc, res) => [...acc, ...res], []).filter(Boolean);\n      }\n      // if tables were not found in the db, no need to proceed\n      if (dbTables.length === 0) {\n        return [];\n      }\n      // create table schemas for loaded tables\n      return Promise.all(dbTables.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (dbTable) {\n          const tablePath = dbTable[\"database\"] && _this41.driver.getAttachedDatabaseHandleByRelativePath(dbTable[\"database\"]) ? `${_this41.driver.getAttachedDatabaseHandleByRelativePath(dbTable[\"database\"])}.${dbTable[\"name\"]}` : dbTable[\"name\"];\n          const sql = dbTable[\"sql\"];\n          const withoutRowid = sql.includes(\"WITHOUT ROWID\");\n          const table = new Table({\n            name: tablePath,\n            withoutRowid\n          });\n          // load columns and indices\n          const [dbColumns, dbIndices, dbForeignKeys] = yield Promise.all([_this41.loadPragmaRecords(tablePath, `table_xinfo`), _this41.loadPragmaRecords(tablePath, `index_list`), _this41.loadPragmaRecords(tablePath, `foreign_key_list`)]);\n          // find column name with auto increment\n          let autoIncrementColumnName = undefined;\n          const tableSql = dbTable[\"sql\"];\n          let autoIncrementIndex = tableSql.toUpperCase().indexOf(\"AUTOINCREMENT\");\n          if (autoIncrementIndex !== -1) {\n            autoIncrementColumnName = tableSql.substr(0, autoIncrementIndex);\n            const comma = autoIncrementColumnName.lastIndexOf(\",\");\n            const bracket = autoIncrementColumnName.lastIndexOf(\"(\");\n            if (comma !== -1) {\n              autoIncrementColumnName = autoIncrementColumnName.substr(comma);\n              autoIncrementColumnName = autoIncrementColumnName.substr(0, autoIncrementColumnName.lastIndexOf('\"'));\n              autoIncrementColumnName = autoIncrementColumnName.substr(autoIncrementColumnName.indexOf('\"') + 1);\n            } else if (bracket !== -1) {\n              autoIncrementColumnName = autoIncrementColumnName.substr(bracket);\n              autoIncrementColumnName = autoIncrementColumnName.substr(0, autoIncrementColumnName.lastIndexOf('\"'));\n              autoIncrementColumnName = autoIncrementColumnName.substr(autoIncrementColumnName.indexOf('\"') + 1);\n            }\n          }\n          // create columns from the loaded columns\n          table.columns = yield Promise.all(dbColumns.map( /*#__PURE__*/function () {\n            var _ref2 = _asyncToGenerator(function* (dbColumn) {\n              const tableColumn = new TableColumn();\n              tableColumn.name = dbColumn[\"name\"];\n              tableColumn.type = dbColumn[\"type\"].toLowerCase();\n              tableColumn.default = dbColumn[\"dflt_value\"] !== null && dbColumn[\"dflt_value\"] !== undefined ? dbColumn[\"dflt_value\"] : undefined;\n              tableColumn.isNullable = dbColumn[\"notnull\"] === 0;\n              // primary keys are numbered starting with 1, columns that aren't primary keys are marked with 0\n              tableColumn.isPrimary = dbColumn[\"pk\"] > 0;\n              tableColumn.comment = \"\"; // SQLite does not support column comments\n              tableColumn.isGenerated = autoIncrementColumnName === dbColumn[\"name\"];\n              if (tableColumn.isGenerated) {\n                tableColumn.generationStrategy = \"increment\";\n              }\n              if (dbColumn[\"hidden\"] === 2 || dbColumn[\"hidden\"] === 3) {\n                tableColumn.generatedType = dbColumn[\"hidden\"] === 2 ? \"VIRTUAL\" : \"STORED\";\n                const asExpressionQuery = yield _this41.selectTypeormMetadataSql({\n                  table: table.name,\n                  type: MetadataTableType.GENERATED_COLUMN,\n                  name: tableColumn.name\n                });\n                const results = yield _this41.query(asExpressionQuery.query, asExpressionQuery.parameters);\n                if (results[0] && results[0].value) {\n                  tableColumn.asExpression = results[0].value;\n                } else {\n                  tableColumn.asExpression = \"\";\n                }\n              }\n              if (tableColumn.type === \"varchar\") {\n                // Check if this is an enum\n                const enumMatch = sql.match(new RegExp('\"(' + tableColumn.name + \")\\\" varchar CHECK\\\\s*\\\\(\\\\s*\\\"\\\\1\\\"\\\\s+IN\\\\s*\\\\(('[^']+'(?:\\\\s*,\\\\s*'[^']+')+)\\\\s*\\\\)\\\\s*\\\\)\"));\n                if (enumMatch) {\n                  // This is an enum\n                  tableColumn.enum = enumMatch[2].substr(1, enumMatch[2].length - 2).split(\"','\");\n                }\n              }\n              // parse datatype and attempt to retrieve length, precision and scale\n              let pos = tableColumn.type.indexOf(\"(\");\n              if (pos !== -1) {\n                const fullType = tableColumn.type;\n                let dataType = fullType.substr(0, pos);\n                if (!!_this41.driver.withLengthColumnTypes.find(col => col === dataType)) {\n                  let len = parseInt(fullType.substring(pos + 1, fullType.length - 1));\n                  if (len) {\n                    tableColumn.length = len.toString();\n                    tableColumn.type = dataType; // remove the length part from the datatype\n                  }\n                }\n\n                if (!!_this41.driver.withPrecisionColumnTypes.find(col => col === dataType)) {\n                  const re = new RegExp(`^${dataType}\\\\((\\\\d+),?\\\\s?(\\\\d+)?\\\\)`);\n                  const matches = fullType.match(re);\n                  if (matches && matches[1]) {\n                    tableColumn.precision = +matches[1];\n                  }\n                  if (!!_this41.driver.withScaleColumnTypes.find(col => col === dataType)) {\n                    if (matches && matches[2]) {\n                      tableColumn.scale = +matches[2];\n                    }\n                  }\n                  tableColumn.type = dataType; // remove the precision/scale part from the datatype\n                }\n              }\n\n              return tableColumn;\n            });\n            return function (_x2) {\n              return _ref2.apply(this, arguments);\n            };\n          }()));\n          // find foreign key constraints from CREATE TABLE sql\n          let fkResult;\n          const fkMappings = [];\n          const fkRegex = /CONSTRAINT \"([^\"]*)\" FOREIGN KEY ?\\((.*?)\\) REFERENCES \"([^\"]*)\"/g;\n          while ((fkResult = fkRegex.exec(sql)) !== null) {\n            fkMappings.push({\n              name: fkResult[1],\n              columns: fkResult[2].substr(1, fkResult[2].length - 2).split(`\", \"`),\n              referencedTableName: fkResult[3]\n            });\n          }\n          // build foreign keys\n          const tableForeignKeyConstraints = OrmUtils.uniq(dbForeignKeys, dbForeignKey => dbForeignKey[\"id\"]);\n          table.foreignKeys = tableForeignKeyConstraints.map(foreignKey => {\n            const ownForeignKeys = dbForeignKeys.filter(dbForeignKey => dbForeignKey[\"id\"] === foreignKey[\"id\"] && dbForeignKey[\"table\"] === foreignKey[\"table\"]);\n            const columnNames = ownForeignKeys.map(dbForeignKey => dbForeignKey[\"from\"]);\n            const referencedColumnNames = ownForeignKeys.map(dbForeignKey => dbForeignKey[\"to\"]);\n            // find related foreign key mapping\n            const fkMapping = fkMappings.find(it => it.referencedTableName === foreignKey[\"table\"] && it.columns.every(column => columnNames.indexOf(column) !== -1));\n            return new TableForeignKey({\n              name: fkMapping === null || fkMapping === void 0 ? void 0 : fkMapping.name,\n              columnNames: columnNames,\n              referencedTableName: foreignKey[\"table\"],\n              referencedColumnNames: referencedColumnNames,\n              onDelete: foreignKey[\"on_delete\"],\n              onUpdate: foreignKey[\"on_update\"]\n            });\n          });\n          // find unique constraints from CREATE TABLE sql\n          let uniqueRegexResult;\n          const uniqueMappings = [];\n          const uniqueRegex = /CONSTRAINT \"([^\"]*)\" UNIQUE ?\\((.*?)\\)/g;\n          while ((uniqueRegexResult = uniqueRegex.exec(sql)) !== null) {\n            uniqueMappings.push({\n              name: uniqueRegexResult[1],\n              columns: uniqueRegexResult[2].substr(1, uniqueRegexResult[2].length - 2).split(`\", \"`)\n            });\n          }\n          // build unique constraints\n          const tableUniquePromises = dbIndices.filter(dbIndex => dbIndex[\"origin\"] === \"u\").map(dbIndex => dbIndex[\"name\"]).filter((value, index, self) => self.indexOf(value) === index).map( /*#__PURE__*/function () {\n            var _ref3 = _asyncToGenerator(function* (dbIndexName) {\n              const dbIndex = dbIndices.find(dbIndex => dbIndex[\"name\"] === dbIndexName);\n              const indexInfos = yield _this41.query(`PRAGMA index_info(\"${dbIndex[\"name\"]}\")`);\n              const indexColumns = indexInfos.sort((indexInfo1, indexInfo2) => parseInt(indexInfo1[\"seqno\"]) - parseInt(indexInfo2[\"seqno\"])).map(indexInfo => indexInfo[\"name\"]);\n              if (indexColumns.length === 1) {\n                const column = table.columns.find(column => {\n                  return !!indexColumns.find(indexColumn => indexColumn === column.name);\n                });\n                if (column) column.isUnique = true;\n              }\n              // find existent mapping by a column names\n              const foundMapping = uniqueMappings.find(mapping => {\n                return mapping.columns.every(column => indexColumns.indexOf(column) !== -1);\n              });\n              return new TableUnique({\n                name: foundMapping ? foundMapping.name : _this41.connection.namingStrategy.uniqueConstraintName(table, indexColumns),\n                columnNames: indexColumns\n              });\n            });\n            return function (_x3) {\n              return _ref3.apply(this, arguments);\n            };\n          }());\n          table.uniques = yield Promise.all(tableUniquePromises);\n          // build checks\n          let result;\n          const regexp = /CONSTRAINT \"([^\"]*)\" CHECK ?(\\(.*?\\))([,]|[)]$)/g;\n          while ((result = regexp.exec(sql)) !== null) {\n            table.checks.push(new TableCheck({\n              name: result[1],\n              expression: result[2]\n            }));\n          }\n          // build indices\n          const indicesPromises = dbIndices.filter(dbIndex => dbIndex[\"origin\"] === \"c\").map(dbIndex => dbIndex[\"name\"]).filter((value, index, self) => self.indexOf(value) === index) // unqiue\n          .map( /*#__PURE__*/function () {\n            var _ref4 = _asyncToGenerator(function* (dbIndexName) {\n              const indexDef = dbIndicesDef.find(dbIndexDef => dbIndexDef[\"name\"] === dbIndexName);\n              const condition = /WHERE (.*)/.exec(indexDef[\"sql\"]);\n              const dbIndex = dbIndices.find(dbIndex => dbIndex[\"name\"] === dbIndexName);\n              const indexInfos = yield _this41.query(`PRAGMA index_info(\"${dbIndex[\"name\"]}\")`);\n              const indexColumns = indexInfos.sort((indexInfo1, indexInfo2) => parseInt(indexInfo1[\"seqno\"]) - parseInt(indexInfo2[\"seqno\"])).map(indexInfo => indexInfo[\"name\"]);\n              const dbIndexPath = `${dbTable[\"database\"] ? `${dbTable[\"database\"]}.` : \"\"}${dbIndex[\"name\"]}`;\n              const isUnique = dbIndex[\"unique\"] === \"1\" || dbIndex[\"unique\"] === 1;\n              return new TableIndex({\n                table: table,\n                name: dbIndexPath,\n                columnNames: indexColumns,\n                isUnique: isUnique,\n                where: condition ? condition[1] : undefined\n              });\n            });\n            return function (_x4) {\n              return _ref4.apply(this, arguments);\n            };\n          }());\n          const indices = yield Promise.all(indicesPromises);\n          table.indices = indices.filter(index => !!index);\n          return table;\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n    })();\n  }\n  /**\n   * Builds create table sql.\n   */\n  createTableSql(table, createForeignKeys, temporaryTable) {\n    const primaryColumns = table.columns.filter(column => column.isPrimary);\n    const hasAutoIncrement = primaryColumns.find(column => column.isGenerated && column.generationStrategy === \"increment\");\n    const skipPrimary = primaryColumns.length > 1;\n    if (skipPrimary && hasAutoIncrement) throw new TypeORMError(`Sqlite does not support AUTOINCREMENT on composite primary key`);\n    const columnDefinitions = table.columns.map(column => this.buildCreateColumnSql(column, skipPrimary)).join(\", \");\n    const [database] = this.splitTablePath(table.name);\n    let sql = `CREATE TABLE ${this.escapePath(table.name)} (${columnDefinitions}`;\n    let [databaseNew, tableName] = this.splitTablePath(table.name);\n    const newTableName = temporaryTable ? `${databaseNew ? `${databaseNew}.` : \"\"}${tableName.replace(/^temporary_/, \"\")}` : table.name;\n    // need for `addColumn()` method, because it recreates table.\n    table.columns.filter(column => column.isUnique).forEach(column => {\n      const isUniqueExist = table.uniques.some(unique => unique.columnNames.length === 1 && unique.columnNames[0] === column.name);\n      if (!isUniqueExist) table.uniques.push(new TableUnique({\n        name: this.connection.namingStrategy.uniqueConstraintName(table, [column.name]),\n        columnNames: [column.name]\n      }));\n    });\n    if (table.uniques.length > 0) {\n      const uniquesSql = table.uniques.map(unique => {\n        const uniqueName = unique.name ? unique.name : this.connection.namingStrategy.uniqueConstraintName(newTableName, unique.columnNames);\n        const columnNames = unique.columnNames.map(columnName => `\"${columnName}\"`).join(\", \");\n        return `CONSTRAINT \"${uniqueName}\" UNIQUE (${columnNames})`;\n      }).join(\", \");\n      sql += `, ${uniquesSql}`;\n    }\n    if (table.checks.length > 0) {\n      const checksSql = table.checks.map(check => {\n        const checkName = check.name ? check.name : this.connection.namingStrategy.checkConstraintName(newTableName, check.expression);\n        return `CONSTRAINT \"${checkName}\" CHECK (${check.expression})`;\n      }).join(\", \");\n      sql += `, ${checksSql}`;\n    }\n    if (table.foreignKeys.length > 0 && createForeignKeys) {\n      const foreignKeysSql = table.foreignKeys.filter(fk => {\n        const [referencedDatabase] = this.splitTablePath(fk.referencedTableName);\n        if (referencedDatabase !== database) {\n          return false;\n        }\n        return true;\n      }).map(fk => {\n        const [, referencedTable] = this.splitTablePath(fk.referencedTableName);\n        const columnNames = fk.columnNames.map(columnName => `\"${columnName}\"`).join(\", \");\n        if (!fk.name) fk.name = this.connection.namingStrategy.foreignKeyName(newTableName, fk.columnNames, this.getTablePath(fk), fk.referencedColumnNames);\n        const referencedColumnNames = fk.referencedColumnNames.map(columnName => `\"${columnName}\"`).join(\", \");\n        let constraint = `CONSTRAINT \"${fk.name}\" FOREIGN KEY (${columnNames}) REFERENCES \"${referencedTable}\" (${referencedColumnNames})`;\n        if (fk.onDelete) constraint += ` ON DELETE ${fk.onDelete}`;\n        if (fk.onUpdate) constraint += ` ON UPDATE ${fk.onUpdate}`;\n        if (fk.deferrable) constraint += ` DEFERRABLE ${fk.deferrable}`;\n        return constraint;\n      }).join(\", \");\n      sql += `, ${foreignKeysSql}`;\n    }\n    if (primaryColumns.length > 1) {\n      const columnNames = primaryColumns.map(column => `\"${column.name}\"`).join(\", \");\n      sql += `, PRIMARY KEY (${columnNames})`;\n    }\n    sql += `)`;\n    if (table.withoutRowid) {\n      sql += \" WITHOUT ROWID\";\n    }\n    return new Query(sql);\n  }\n  /**\n   * Builds drop table sql.\n   */\n  dropTableSql(tableOrName, ifExist) {\n    const tableName = InstanceChecker.isTable(tableOrName) ? tableOrName.name : tableOrName;\n    const query = ifExist ? `DROP TABLE IF EXISTS ${this.escapePath(tableName)}` : `DROP TABLE ${this.escapePath(tableName)}`;\n    return new Query(query);\n  }\n  createViewSql(view) {\n    if (typeof view.expression === \"string\") {\n      return new Query(`CREATE VIEW \"${view.name}\" AS ${view.expression}`);\n    } else {\n      return new Query(`CREATE VIEW \"${view.name}\" AS ${view.expression(this.connection).getQuery()}`);\n    }\n  }\n  insertViewDefinitionSql(view) {\n    const expression = typeof view.expression === \"string\" ? view.expression.trim() : view.expression(this.connection).getQuery();\n    return this.insertTypeormMetadataSql({\n      type: MetadataTableType.VIEW,\n      name: view.name,\n      value: expression\n    });\n  }\n  /**\n   * Builds drop view sql.\n   */\n  dropViewSql(viewOrPath) {\n    const viewName = InstanceChecker.isView(viewOrPath) ? viewOrPath.name : viewOrPath;\n    return new Query(`DROP VIEW \"${viewName}\"`);\n  }\n  /**\n   * Builds remove view sql.\n   */\n  deleteViewDefinitionSql(viewOrPath) {\n    const viewName = InstanceChecker.isView(viewOrPath) ? viewOrPath.name : viewOrPath;\n    return this.deleteTypeormMetadataSql({\n      type: MetadataTableType.VIEW,\n      name: viewName\n    });\n  }\n  /**\n   * Builds create index sql.\n   */\n  createIndexSql(table, index) {\n    const columns = index.columnNames.map(columnName => `\"${columnName}\"`).join(\", \");\n    const [database, tableName] = this.splitTablePath(table.name);\n    return new Query(`CREATE ${index.isUnique ? \"UNIQUE \" : \"\"}INDEX ${database ? `\"${database}\".` : \"\"}${this.escapePath(index.name)} ON \"${tableName}\" (${columns}) ${index.where ? \"WHERE \" + index.where : \"\"}`);\n  }\n  /**\n   * Builds drop index sql.\n   */\n  dropIndexSql(indexOrName) {\n    let indexName = InstanceChecker.isTableIndex(indexOrName) ? indexOrName.name : indexOrName;\n    return new Query(`DROP INDEX ${this.escapePath(indexName)}`);\n  }\n  /**\n   * Builds a query for create column.\n   */\n  buildCreateColumnSql(column, skipPrimary) {\n    let c = '\"' + column.name + '\"';\n    if (InstanceChecker.isColumnMetadata(column)) {\n      c += \" \" + this.driver.normalizeType(column);\n    } else {\n      c += \" \" + this.connection.driver.createFullType(column);\n    }\n    if (column.enum) c += ' CHECK( \"' + column.name + '\" IN (' + column.enum.map(val => \"'\" + val + \"'\").join(\",\") + \") )\";\n    if (column.isPrimary && !skipPrimary) c += \" PRIMARY KEY\";\n    if (column.isGenerated === true && column.generationStrategy === \"increment\")\n      // don't use skipPrimary here since updates can update already exist primary without auto inc.\n      c += \" AUTOINCREMENT\";\n    if (column.collation) c += \" COLLATE \" + column.collation;\n    if (column.isNullable !== true) c += \" NOT NULL\";\n    if (column.asExpression) {\n      c += ` AS (${column.asExpression}) ${column.generatedType ? column.generatedType : \"VIRTUAL\"}`;\n    } else {\n      if (column.default !== undefined && column.default !== null) c += \" DEFAULT (\" + column.default + \")\";\n    }\n    return c;\n  }\n  recreateTable(newTable, oldTable, migrateData = true) {\n    var _this42 = this;\n    return _asyncToGenerator(function* () {\n      const upQueries = [];\n      const downQueries = [];\n      // drop old table indices\n      oldTable.indices.forEach(index => {\n        upQueries.push(_this42.dropIndexSql(index));\n        downQueries.push(_this42.createIndexSql(oldTable, index));\n      });\n      // change table name into 'temporary_table'\n      let [databaseNew, tableNameNew] = _this42.splitTablePath(newTable.name);\n      let [, tableNameOld] = _this42.splitTablePath(oldTable.name);\n      newTable.name = tableNameNew = `${databaseNew ? `${databaseNew}.` : \"\"}temporary_${tableNameNew}`;\n      // create new table\n      upQueries.push(_this42.createTableSql(newTable, true, true));\n      downQueries.push(_this42.dropTableSql(newTable));\n      // migrate all data from the old table into new table\n      if (migrateData) {\n        let newColumnNames = newTable.columns.filter(column => !column.generatedType).map(column => `\"${column.name}\"`);\n        let oldColumnNames = oldTable.columns.filter(column => !column.generatedType).map(column => `\"${column.name}\"`);\n        if (oldColumnNames.length < newColumnNames.length) {\n          newColumnNames = newTable.columns.filter(column => {\n            const oldColumn = oldTable.columns.find(c => c.name === column.name);\n            if (oldColumn && oldColumn.generatedType) return false;\n            return !column.generatedType && oldColumn;\n          }).map(column => `\"${column.name}\"`);\n        } else if (oldColumnNames.length > newColumnNames.length) {\n          oldColumnNames = oldTable.columns.filter(column => {\n            return !column.generatedType && newTable.columns.find(c => c.name === column.name);\n          }).map(column => `\"${column.name}\"`);\n        }\n        upQueries.push(new Query(`INSERT INTO ${_this42.escapePath(newTable.name)}(${newColumnNames.join(\", \")}) SELECT ${oldColumnNames.join(\", \")} FROM ${_this42.escapePath(oldTable.name)}`));\n        downQueries.push(new Query(`INSERT INTO ${_this42.escapePath(oldTable.name)}(${oldColumnNames.join(\", \")}) SELECT ${newColumnNames.join(\", \")} FROM ${_this42.escapePath(newTable.name)}`));\n      }\n      // drop old table\n      upQueries.push(_this42.dropTableSql(oldTable));\n      downQueries.push(_this42.createTableSql(oldTable, true));\n      // rename old table\n      upQueries.push(new Query(`ALTER TABLE ${_this42.escapePath(newTable.name)} RENAME TO ${_this42.escapePath(tableNameOld)}`));\n      downQueries.push(new Query(`ALTER TABLE ${_this42.escapePath(oldTable.name)} RENAME TO ${_this42.escapePath(tableNameNew)}`));\n      newTable.name = oldTable.name;\n      // recreate table indices\n      newTable.indices.forEach(index => {\n        // new index may be passed without name. In this case we generate index name manually.\n        if (!index.name) index.name = _this42.connection.namingStrategy.indexName(newTable, index.columnNames, index.where);\n        upQueries.push(_this42.createIndexSql(newTable, index));\n        downQueries.push(_this42.dropIndexSql(index));\n      });\n      // update generated columns in \"typeorm_metadata\" table\n      // Step 1: clear data for removed generated columns\n      oldTable.columns.filter(column => {\n        const newTableColumn = newTable.columns.find(c => c.name === column.name);\n        // we should delete record from \"typeorm_metadata\" if generated column was removed\n        // or it was changed to non-generated\n        return column.generatedType && column.asExpression && (!newTableColumn || !newTableColumn.generatedType && !newTableColumn.asExpression);\n      }).forEach(column => {\n        const deleteQuery = _this42.deleteTypeormMetadataSql({\n          table: oldTable.name,\n          type: MetadataTableType.GENERATED_COLUMN,\n          name: column.name\n        });\n        const insertQuery = _this42.insertTypeormMetadataSql({\n          table: oldTable.name,\n          type: MetadataTableType.GENERATED_COLUMN,\n          name: column.name,\n          value: column.asExpression\n        });\n        upQueries.push(deleteQuery);\n        downQueries.push(insertQuery);\n      });\n      // Step 2: add data for new generated columns\n      newTable.columns.filter(column => column.generatedType && column.asExpression && !oldTable.columns.some(c => c.name === column.name)).forEach(column => {\n        const insertQuery = _this42.insertTypeormMetadataSql({\n          table: newTable.name,\n          type: MetadataTableType.GENERATED_COLUMN,\n          name: column.name,\n          value: column.asExpression\n        });\n        const deleteQuery = _this42.deleteTypeormMetadataSql({\n          table: newTable.name,\n          type: MetadataTableType.GENERATED_COLUMN,\n          name: column.name\n        });\n        upQueries.push(insertQuery);\n        downQueries.push(deleteQuery);\n      });\n      // Step 3: update changed expressions\n      newTable.columns.filter(column => column.generatedType && column.asExpression).forEach(column => {\n        const oldColumn = oldTable.columns.find(c => c.name === column.name && c.generatedType && column.generatedType && c.asExpression !== column.asExpression);\n        if (!oldColumn) return;\n        // update expression\n        const deleteQuery = _this42.deleteTypeormMetadataSql({\n          table: oldTable.name,\n          type: MetadataTableType.GENERATED_COLUMN,\n          name: oldColumn.name\n        });\n        const insertQuery = _this42.insertTypeormMetadataSql({\n          table: newTable.name,\n          type: MetadataTableType.GENERATED_COLUMN,\n          name: column.name,\n          value: column.asExpression\n        });\n        upQueries.push(deleteQuery);\n        upQueries.push(insertQuery);\n        // revert update\n        const revertInsertQuery = _this42.insertTypeormMetadataSql({\n          table: newTable.name,\n          type: MetadataTableType.GENERATED_COLUMN,\n          name: oldColumn.name,\n          value: oldColumn.asExpression\n        });\n        const revertDeleteQuery = _this42.deleteTypeormMetadataSql({\n          table: oldTable.name,\n          type: MetadataTableType.GENERATED_COLUMN,\n          name: column.name\n        });\n        downQueries.push(revertInsertQuery);\n        downQueries.push(revertDeleteQuery);\n      });\n      yield _this42.executeQueries(upQueries, downQueries);\n      _this42.replaceCachedTable(oldTable, newTable);\n    })();\n  }\n  /**\n   * tablePath e.g. \"myDB.myTable\", \"myTable\"\n   */\n  splitTablePath(tablePath) {\n    return tablePath.indexOf(\".\") !== -1 ? tablePath.split(\".\") : [undefined, tablePath];\n  }\n  /**\n   * Escapes given table or view path. Tolerates leading/trailing dots\n   */\n  escapePath(target, disableEscape) {\n    const tableName = InstanceChecker.isTable(target) || InstanceChecker.isView(target) ? target.name : target;\n    return tableName.replace(/^\\.+|\\.+$/g, \"\").split(\".\").map(i => disableEscape ? i : `\"${i}\"`).join(\".\");\n  }\n}","map":{"version":3,"names":["TransactionNotStartedError","TableColumn","Table","TableIndex","TableForeignKey","View","Query","TableUnique","BaseQueryRunner","OrmUtils","TableCheck","TransactionAlreadyStartedError","TypeORMError","MetadataTableType","InstanceChecker","AbstractSqliteQueryRunner","constructor","transactionPromise","connect","Promise","resolve","driver","databaseConnection","release","loadedTables","clearSqlMemory","startTransaction","isolationLevel","_this","_asyncToGenerator","transactionSupport","connection","options","type","isTransactionActive","broadcaster","broadcast","err","transactionDepth","query","commitTransaction","_this2","rollbackTransaction","_this3","stream","parameters","onEnd","onError","getDatabases","getSchemas","database","hasDatabase","getCurrentDatabase","undefined","hasSchema","schema","getCurrentSchema","hasTable","tableOrName","_this4","tableName","isTable","name","sql","result","length","hasColumn","columnName","_this5","escapePath","columns","find","column","createDatabase","ifNotExist","dropDatabase","ifExist","createSchema","schemaPath","dropSchema","createTable","table","createForeignKeys","createIndices","_this6","upQueries","downQueries","isTableExist","push","createTableSql","dropTableSql","indices","forEach","index","namingStrategy","indexName","columnNames","where","createIndexSql","dropIndexSql","generatedColumns","filter","generatedType","asExpression","insertQuery","insertTypeormMetadataSql","GENERATED_COLUMN","value","deleteQuery","deleteTypeormMetadataSql","executeQueries","dropTable","dropForeignKeys","dropIndices","_this7","getCachedTable","createView","view","syncWithMetadata","_this8","createViewSql","insertViewDefinitionSql","dropViewSql","deleteViewDefinitionSql","dropView","target","_this9","viewName","isView","getCachedView","renameTable","oldTableOrName","newTableName","_this10","oldTable","newTable","clone","up","down","uniques","unique","oldUniqueName","uniqueConstraintName","foreignKeys","foreignKey","oldForeignKeyName","foreignKeyName","getTablePath","referencedColumnNames","oldIndexName","recreateTable","addColumn","_this11","addColumns","_this12","changedTable","renameColumn","oldTableColumnOrName","newTableColumnOrName","_this13","oldColumn","isTableColumn","c","newColumn","changeColumn","_this14","changeColumns","changedColumns","_this15","changedColumnSet","findColumnUniques","uniqueName","splice","indexOf","findColumnForeignKeys","findColumnIndices","originalColumn","dropColumn","columnOrName","_this16","findColumnByName","dropColumns","_this17","columnInstance","Error","removeColumn","removeUniqueConstraint","removeIndex","fk","removeForeignKey","createPrimaryKey","_this18","isPrimary","updatePrimaryKeys","dropPrimaryKey","_this19","primaryColumns","createUniqueConstraint","uniqueConstraint","_this20","createUniqueConstraints","uniqueConstraints","_this21","addUniqueConstraint","dropUniqueConstraint","uniqueOrName","_this22","isTableUnique","u","dropUniqueConstraints","_this23","createCheckConstraint","checkConstraint","_this24","createCheckConstraints","checkConstraints","_this25","addCheckConstraint","dropCheckConstraint","checkOrName","_this26","isTableCheck","checks","dropCheckConstraints","_this27","removeCheckConstraint","createExclusionConstraint","exclusionConstraint","createExclusionConstraints","exclusionConstraints","dropExclusionConstraint","exclusionOrName","dropExclusionConstraints","createForeignKey","_this28","_this29","addForeignKey","dropForeignKey","foreignKeyOrName","_this30","isTableForeignKey","_this31","createIndex","_this32","generateIndexName","addIndex","_this33","promises","map","all","dropIndex","indexOrName","_this34","isTableIndex","i","_this35","clearTable","_this36","clearDatabase","_this37","dbPath","getAttachedDatabaseHandleByRelativePath","isAnotherTransactionActive","selectViewDropsQuery","dropViewQueries","q","selectTableDropsQuery","dropTableQueries","error","rollbackError","loadViews","viewNames","_this38","getTypeormMetadataTableName","viewNamesString","join","VIEW","dbViews","dbView","expression","loadTableRecords","tablePath","tableOrIndex","_this39","splitTablePath","getAttachedDatabasePathRelativeByHandle","loadPragmaRecords","pragma","_this40","loadTables","tableNames","_this41","dbTables","dbIndicesDef","tablesSql","tableNamesString","tableNamesWithoutDot","split","tableNamesWithDot","queryPromises","reduce","acc","res","Boolean","_ref","dbTable","withoutRowid","includes","dbColumns","dbIndices","dbForeignKeys","autoIncrementColumnName","tableSql","autoIncrementIndex","toUpperCase","substr","comma","lastIndexOf","bracket","_ref2","dbColumn","tableColumn","toLowerCase","default","isNullable","comment","isGenerated","generationStrategy","asExpressionQuery","selectTypeormMetadataSql","results","enumMatch","match","RegExp","enum","pos","fullType","dataType","withLengthColumnTypes","col","len","parseInt","substring","toString","withPrecisionColumnTypes","re","matches","precision","withScaleColumnTypes","scale","_x2","apply","arguments","fkResult","fkMappings","fkRegex","exec","referencedTableName","tableForeignKeyConstraints","uniq","dbForeignKey","ownForeignKeys","fkMapping","it","every","onDelete","onUpdate","uniqueRegexResult","uniqueMappings","uniqueRegex","tableUniquePromises","dbIndex","self","_ref3","dbIndexName","indexInfos","indexColumns","sort","indexInfo1","indexInfo2","indexInfo","indexColumn","isUnique","foundMapping","mapping","_x3","regexp","indicesPromises","_ref4","indexDef","dbIndexDef","condition","dbIndexPath","_x4","_x","temporaryTable","hasAutoIncrement","skipPrimary","columnDefinitions","buildCreateColumnSql","databaseNew","replace","isUniqueExist","some","uniquesSql","checksSql","check","checkName","checkConstraintName","foreignKeysSql","referencedDatabase","referencedTable","constraint","deferrable","getQuery","trim","viewOrPath","isColumnMetadata","normalizeType","createFullType","val","collation","migrateData","_this42","tableNameNew","tableNameOld","newColumnNames","oldColumnNames","newTableColumn","revertInsertQuery","revertDeleteQuery","replaceCachedTable","disableEscape"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/driver/sqlite-abstract/AbstractSqliteQueryRunner.js"],"sourcesContent":["import { TransactionNotStartedError } from \"../../error/TransactionNotStartedError\";\nimport { TableColumn } from \"../../schema-builder/table/TableColumn\";\nimport { Table } from \"../../schema-builder/table/Table\";\nimport { TableIndex } from \"../../schema-builder/table/TableIndex\";\nimport { TableForeignKey } from \"../../schema-builder/table/TableForeignKey\";\nimport { View } from \"../../schema-builder/view/View\";\nimport { Query } from \"../Query\";\nimport { TableUnique } from \"../../schema-builder/table/TableUnique\";\nimport { BaseQueryRunner } from \"../../query-runner/BaseQueryRunner\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\nimport { TableCheck } from \"../../schema-builder/table/TableCheck\";\nimport { TransactionAlreadyStartedError, TypeORMError } from \"../../error\";\nimport { MetadataTableType } from \"../types/MetadataTableType\";\nimport { InstanceChecker } from \"../../util/InstanceChecker\";\n/**\n * Runs queries on a single sqlite database connection.\n */\nexport class AbstractSqliteQueryRunner extends BaseQueryRunner {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n    constructor() {\n        super();\n        this.transactionPromise = null;\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Creates/uses database connection from the connection pool to perform further operations.\n     * Returns obtained database connection.\n     */\n    connect() {\n        return Promise.resolve(this.driver.databaseConnection);\n    }\n    /**\n     * Releases used database connection.\n     * We just clear loaded tables and sql in memory, because sqlite do not support multiple connections thus query runners.\n     */\n    release() {\n        this.loadedTables = [];\n        this.clearSqlMemory();\n        return Promise.resolve();\n    }\n    /**\n     * Starts transaction.\n     */\n    async startTransaction(isolationLevel) {\n        if (this.driver.transactionSupport === \"none\")\n            throw new TypeORMError(`Transactions aren't supported by ${this.connection.driver.options.type}.`);\n        if (this.isTransactionActive &&\n            this.driver.transactionSupport === \"simple\")\n            throw new TransactionAlreadyStartedError();\n        if (isolationLevel &&\n            isolationLevel !== \"READ UNCOMMITTED\" &&\n            isolationLevel !== \"SERIALIZABLE\")\n            throw new TypeORMError(`SQLite only supports SERIALIZABLE and READ UNCOMMITTED isolation`);\n        this.isTransactionActive = true;\n        try {\n            await this.broadcaster.broadcast(\"BeforeTransactionStart\");\n        }\n        catch (err) {\n            this.isTransactionActive = false;\n            throw err;\n        }\n        if (this.transactionDepth === 0) {\n            if (isolationLevel) {\n                if (isolationLevel === \"READ UNCOMMITTED\") {\n                    await this.query(\"PRAGMA read_uncommitted = true\");\n                }\n                else {\n                    await this.query(\"PRAGMA read_uncommitted = false\");\n                }\n            }\n            await this.query(\"BEGIN TRANSACTION\");\n        }\n        else {\n            await this.query(`SAVEPOINT typeorm_${this.transactionDepth}`);\n        }\n        this.transactionDepth += 1;\n        await this.broadcaster.broadcast(\"AfterTransactionStart\");\n    }\n    /**\n     * Commits transaction.\n     * Error will be thrown if transaction was not started.\n     */\n    async commitTransaction() {\n        if (!this.isTransactionActive)\n            throw new TransactionNotStartedError();\n        await this.broadcaster.broadcast(\"BeforeTransactionCommit\");\n        if (this.transactionDepth > 1) {\n            await this.query(`RELEASE SAVEPOINT typeorm_${this.transactionDepth - 1}`);\n        }\n        else {\n            await this.query(\"COMMIT\");\n            this.isTransactionActive = false;\n        }\n        this.transactionDepth -= 1;\n        await this.broadcaster.broadcast(\"AfterTransactionCommit\");\n    }\n    /**\n     * Rollbacks transaction.\n     * Error will be thrown if transaction was not started.\n     */\n    async rollbackTransaction() {\n        if (!this.isTransactionActive)\n            throw new TransactionNotStartedError();\n        await this.broadcaster.broadcast(\"BeforeTransactionRollback\");\n        if (this.transactionDepth > 1) {\n            await this.query(`ROLLBACK TO SAVEPOINT typeorm_${this.transactionDepth - 1}`);\n        }\n        else {\n            await this.query(\"ROLLBACK\");\n            this.isTransactionActive = false;\n        }\n        this.transactionDepth -= 1;\n        await this.broadcaster.broadcast(\"AfterTransactionRollback\");\n    }\n    /**\n     * Returns raw data stream.\n     */\n    stream(query, parameters, onEnd, onError) {\n        throw new TypeORMError(`Stream is not supported by sqlite driver.`);\n    }\n    /**\n     * Returns all available database names including system databases.\n     */\n    async getDatabases() {\n        return Promise.resolve([]);\n    }\n    /**\n     * Returns all available schema names including system schemas.\n     * If database parameter specified, returns schemas of that database.\n     */\n    async getSchemas(database) {\n        return Promise.resolve([]);\n    }\n    /**\n     * Checks if database with the given name exist.\n     */\n    async hasDatabase(database) {\n        return Promise.resolve(false);\n    }\n    /**\n     * Loads currently using database\n     */\n    async getCurrentDatabase() {\n        return Promise.resolve(undefined);\n    }\n    /**\n     * Checks if schema with the given name exist.\n     */\n    async hasSchema(schema) {\n        throw new TypeORMError(`This driver does not support table schemas`);\n    }\n    /**\n     * Loads currently using database schema\n     */\n    async getCurrentSchema() {\n        return Promise.resolve(undefined);\n    }\n    /**\n     * Checks if table with the given name exist in the database.\n     */\n    async hasTable(tableOrName) {\n        const tableName = InstanceChecker.isTable(tableOrName)\n            ? tableOrName.name\n            : tableOrName;\n        const sql = `SELECT * FROM \"sqlite_master\" WHERE \"type\" = 'table' AND \"name\" = '${tableName}'`;\n        const result = await this.query(sql);\n        return result.length ? true : false;\n    }\n    /**\n     * Checks if column with the given name exist in the given table.\n     */\n    async hasColumn(tableOrName, columnName) {\n        const tableName = InstanceChecker.isTable(tableOrName)\n            ? tableOrName.name\n            : tableOrName;\n        const sql = `PRAGMA table_xinfo(${this.escapePath(tableName)})`;\n        const columns = await this.query(sql);\n        return !!columns.find((column) => column[\"name\"] === columnName);\n    }\n    /**\n     * Creates a new database.\n     */\n    async createDatabase(database, ifNotExist) {\n        return Promise.resolve();\n    }\n    /**\n     * Drops database.\n     */\n    async dropDatabase(database, ifExist) {\n        return Promise.resolve();\n    }\n    /**\n     * Creates a new table schema.\n     */\n    async createSchema(schemaPath, ifNotExist) {\n        return Promise.resolve();\n    }\n    /**\n     * Drops table schema.\n     */\n    async dropSchema(schemaPath, ifExist) {\n        return Promise.resolve();\n    }\n    /**\n     * Creates a new table.\n     */\n    async createTable(table, ifNotExist = false, createForeignKeys = true, createIndices = true) {\n        const upQueries = [];\n        const downQueries = [];\n        if (ifNotExist) {\n            const isTableExist = await this.hasTable(table);\n            if (isTableExist)\n                return Promise.resolve();\n        }\n        upQueries.push(this.createTableSql(table, createForeignKeys));\n        downQueries.push(this.dropTableSql(table));\n        if (createIndices) {\n            table.indices.forEach((index) => {\n                // new index may be passed without name. In this case we generate index name manually.\n                if (!index.name)\n                    index.name = this.connection.namingStrategy.indexName(table, index.columnNames, index.where);\n                upQueries.push(this.createIndexSql(table, index));\n                downQueries.push(this.dropIndexSql(index));\n            });\n        }\n        // if table have column with generated type, we must add the expression to the metadata table\n        const generatedColumns = table.columns.filter((column) => column.generatedType && column.asExpression);\n        for (const column of generatedColumns) {\n            const insertQuery = this.insertTypeormMetadataSql({\n                table: table.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n                value: column.asExpression,\n            });\n            const deleteQuery = this.deleteTypeormMetadataSql({\n                table: table.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n            });\n            upQueries.push(insertQuery);\n            downQueries.push(deleteQuery);\n        }\n        await this.executeQueries(upQueries, downQueries);\n    }\n    /**\n     * Drops the table.\n     */\n    async dropTable(tableOrName, ifExist, dropForeignKeys = true, dropIndices = true) {\n        if (ifExist) {\n            const isTableExist = await this.hasTable(tableOrName);\n            if (!isTableExist)\n                return Promise.resolve();\n        }\n        // if dropTable called with dropForeignKeys = true, we must create foreign keys in down query.\n        const createForeignKeys = dropForeignKeys;\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        const upQueries = [];\n        const downQueries = [];\n        if (dropIndices) {\n            table.indices.forEach((index) => {\n                upQueries.push(this.dropIndexSql(index));\n                downQueries.push(this.createIndexSql(table, index));\n            });\n        }\n        upQueries.push(this.dropTableSql(table, ifExist));\n        downQueries.push(this.createTableSql(table, createForeignKeys));\n        // if table had columns with generated type, we must remove the expression from the metadata table\n        const generatedColumns = table.columns.filter((column) => column.generatedType && column.asExpression);\n        for (const column of generatedColumns) {\n            const deleteQuery = this.deleteTypeormMetadataSql({\n                table: table.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n            });\n            const insertQuery = this.insertTypeormMetadataSql({\n                table: table.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n                value: column.asExpression,\n            });\n            upQueries.push(deleteQuery);\n            downQueries.push(insertQuery);\n        }\n        await this.executeQueries(upQueries, downQueries);\n    }\n    /**\n     * Creates a new view.\n     */\n    async createView(view, syncWithMetadata = false) {\n        const upQueries = [];\n        const downQueries = [];\n        upQueries.push(this.createViewSql(view));\n        if (syncWithMetadata)\n            upQueries.push(this.insertViewDefinitionSql(view));\n        downQueries.push(this.dropViewSql(view));\n        if (syncWithMetadata)\n            downQueries.push(this.deleteViewDefinitionSql(view));\n        await this.executeQueries(upQueries, downQueries);\n    }\n    /**\n     * Drops the view.\n     */\n    async dropView(target) {\n        const viewName = InstanceChecker.isView(target) ? target.name : target;\n        const view = await this.getCachedView(viewName);\n        const upQueries = [];\n        const downQueries = [];\n        upQueries.push(this.deleteViewDefinitionSql(view));\n        upQueries.push(this.dropViewSql(view));\n        downQueries.push(this.insertViewDefinitionSql(view));\n        downQueries.push(this.createViewSql(view));\n        await this.executeQueries(upQueries, downQueries);\n    }\n    /**\n     * Renames the given table.\n     */\n    async renameTable(oldTableOrName, newTableName) {\n        const oldTable = InstanceChecker.isTable(oldTableOrName)\n            ? oldTableOrName\n            : await this.getCachedTable(oldTableOrName);\n        const newTable = oldTable.clone();\n        newTable.name = newTableName;\n        // rename table\n        const up = new Query(`ALTER TABLE ${this.escapePath(oldTable.name)} RENAME TO ${this.escapePath(newTableName)}`);\n        const down = new Query(`ALTER TABLE ${this.escapePath(newTableName)} RENAME TO ${this.escapePath(oldTable.name)}`);\n        await this.executeQueries(up, down);\n        // rename unique constraints\n        newTable.uniques.forEach((unique) => {\n            const oldUniqueName = this.connection.namingStrategy.uniqueConstraintName(oldTable, unique.columnNames);\n            // Skip renaming if Unique has user defined constraint name\n            if (unique.name !== oldUniqueName)\n                return;\n            unique.name = this.connection.namingStrategy.uniqueConstraintName(newTable, unique.columnNames);\n        });\n        // rename foreign key constraints\n        newTable.foreignKeys.forEach((foreignKey) => {\n            const oldForeignKeyName = this.connection.namingStrategy.foreignKeyName(oldTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);\n            // Skip renaming if foreign key has user defined constraint name\n            if (foreignKey.name !== oldForeignKeyName)\n                return;\n            foreignKey.name = this.connection.namingStrategy.foreignKeyName(newTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);\n        });\n        // rename indices\n        newTable.indices.forEach((index) => {\n            const oldIndexName = this.connection.namingStrategy.indexName(oldTable, index.columnNames, index.where);\n            // Skip renaming if Index has user defined constraint name\n            if (index.name !== oldIndexName)\n                return;\n            index.name = this.connection.namingStrategy.indexName(newTable, index.columnNames, index.where);\n        });\n        // rename old table;\n        oldTable.name = newTable.name;\n        // recreate table with new constraint names\n        await this.recreateTable(newTable, oldTable);\n    }\n    /**\n     * Creates a new column from the column in the table.\n     */\n    async addColumn(tableOrName, column) {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        return this.addColumns(table, [column]);\n    }\n    /**\n     * Creates a new columns from the column in the table.\n     */\n    async addColumns(tableOrName, columns) {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        const changedTable = table.clone();\n        columns.forEach((column) => changedTable.addColumn(column));\n        await this.recreateTable(changedTable, table);\n    }\n    /**\n     * Renames column in the given table.\n     */\n    async renameColumn(tableOrName, oldTableColumnOrName, newTableColumnOrName) {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        const oldColumn = InstanceChecker.isTableColumn(oldTableColumnOrName)\n            ? oldTableColumnOrName\n            : table.columns.find((c) => c.name === oldTableColumnOrName);\n        if (!oldColumn)\n            throw new TypeORMError(`Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`);\n        let newColumn = undefined;\n        if (InstanceChecker.isTableColumn(newTableColumnOrName)) {\n            newColumn = newTableColumnOrName;\n        }\n        else {\n            newColumn = oldColumn.clone();\n            newColumn.name = newTableColumnOrName;\n        }\n        return this.changeColumn(table, oldColumn, newColumn);\n    }\n    /**\n     * Changes a column in the table.\n     */\n    async changeColumn(tableOrName, oldTableColumnOrName, newColumn) {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        const oldColumn = InstanceChecker.isTableColumn(oldTableColumnOrName)\n            ? oldTableColumnOrName\n            : table.columns.find((c) => c.name === oldTableColumnOrName);\n        if (!oldColumn)\n            throw new TypeORMError(`Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`);\n        await this.changeColumns(table, [{ oldColumn, newColumn }]);\n    }\n    /**\n     * Changes a column in the table.\n     * Changed column looses all its keys in the db.\n     */\n    async changeColumns(tableOrName, changedColumns) {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        const changedTable = table.clone();\n        changedColumns.forEach((changedColumnSet) => {\n            if (changedColumnSet.newColumn.name !==\n                changedColumnSet.oldColumn.name) {\n                changedTable\n                    .findColumnUniques(changedColumnSet.oldColumn)\n                    .forEach((unique) => {\n                    const uniqueName = this.connection.namingStrategy.uniqueConstraintName(table, unique.columnNames);\n                    unique.columnNames.splice(unique.columnNames.indexOf(changedColumnSet.oldColumn.name), 1);\n                    unique.columnNames.push(changedColumnSet.newColumn.name);\n                    // rename Unique only if it has default constraint name\n                    if (unique.name === uniqueName) {\n                        unique.name =\n                            this.connection.namingStrategy.uniqueConstraintName(changedTable, unique.columnNames);\n                    }\n                });\n                changedTable\n                    .findColumnForeignKeys(changedColumnSet.oldColumn)\n                    .forEach((foreignKey) => {\n                    const foreignKeyName = this.connection.namingStrategy.foreignKeyName(table, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);\n                    foreignKey.columnNames.splice(foreignKey.columnNames.indexOf(changedColumnSet.oldColumn.name), 1);\n                    foreignKey.columnNames.push(changedColumnSet.newColumn.name);\n                    // rename FK only if it has default constraint name\n                    if (foreignKey.name === foreignKeyName) {\n                        foreignKey.name =\n                            this.connection.namingStrategy.foreignKeyName(changedTable, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);\n                    }\n                });\n                changedTable\n                    .findColumnIndices(changedColumnSet.oldColumn)\n                    .forEach((index) => {\n                    const indexName = this.connection.namingStrategy.indexName(table, index.columnNames, index.where);\n                    index.columnNames.splice(index.columnNames.indexOf(changedColumnSet.oldColumn.name), 1);\n                    index.columnNames.push(changedColumnSet.newColumn.name);\n                    // rename Index only if it has default constraint name\n                    if (index.name === indexName) {\n                        index.name =\n                            this.connection.namingStrategy.indexName(changedTable, index.columnNames, index.where);\n                    }\n                });\n            }\n            const originalColumn = changedTable.columns.find((column) => column.name === changedColumnSet.oldColumn.name);\n            if (originalColumn)\n                changedTable.columns[changedTable.columns.indexOf(originalColumn)] = changedColumnSet.newColumn;\n        });\n        await this.recreateTable(changedTable, table);\n    }\n    /**\n     * Drops column in the table.\n     */\n    async dropColumn(tableOrName, columnOrName) {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        const column = InstanceChecker.isTableColumn(columnOrName)\n            ? columnOrName\n            : table.findColumnByName(columnOrName);\n        if (!column)\n            throw new TypeORMError(`Column \"${columnOrName}\" was not found in table \"${table.name}\"`);\n        await this.dropColumns(table, [column]);\n    }\n    /**\n     * Drops the columns in the table.\n     */\n    async dropColumns(tableOrName, columns) {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        // clone original table and remove column and its constraints from cloned table\n        const changedTable = table.clone();\n        columns.forEach((column) => {\n            const columnInstance = InstanceChecker.isTableColumn(column)\n                ? column\n                : table.findColumnByName(column);\n            if (!columnInstance)\n                throw new Error(`Column \"${column}\" was not found in table \"${table.name}\"`);\n            changedTable.removeColumn(columnInstance);\n            changedTable\n                .findColumnUniques(columnInstance)\n                .forEach((unique) => changedTable.removeUniqueConstraint(unique));\n            changedTable\n                .findColumnIndices(columnInstance)\n                .forEach((index) => changedTable.removeIndex(index));\n            changedTable\n                .findColumnForeignKeys(columnInstance)\n                .forEach((fk) => changedTable.removeForeignKey(fk));\n        });\n        await this.recreateTable(changedTable, table);\n    }\n    /**\n     * Creates a new primary key.\n     */\n    async createPrimaryKey(tableOrName, columnNames) {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        // clone original table and mark columns as primary\n        const changedTable = table.clone();\n        changedTable.columns.forEach((column) => {\n            if (columnNames.find((columnName) => columnName === column.name))\n                column.isPrimary = true;\n        });\n        await this.recreateTable(changedTable, table);\n        // mark columns as primary in original table\n        table.columns.forEach((column) => {\n            if (columnNames.find((columnName) => columnName === column.name))\n                column.isPrimary = true;\n        });\n    }\n    /**\n     * Updates composite primary keys.\n     */\n    async updatePrimaryKeys(tableOrName, columns) {\n        await Promise.resolve();\n    }\n    /**\n     * Drops a primary key.\n     */\n    async dropPrimaryKey(tableOrName) {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        // clone original table and mark primary columns as non-primary\n        const changedTable = table.clone();\n        changedTable.primaryColumns.forEach((column) => {\n            column.isPrimary = false;\n        });\n        await this.recreateTable(changedTable, table);\n        // mark primary columns as non-primary in original table\n        table.primaryColumns.forEach((column) => {\n            column.isPrimary = false;\n        });\n    }\n    /**\n     * Creates a new unique constraint.\n     */\n    async createUniqueConstraint(tableOrName, uniqueConstraint) {\n        await this.createUniqueConstraints(tableOrName, [uniqueConstraint]);\n    }\n    /**\n     * Creates a new unique constraints.\n     */\n    async createUniqueConstraints(tableOrName, uniqueConstraints) {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        // clone original table and add unique constraints in to cloned table\n        const changedTable = table.clone();\n        uniqueConstraints.forEach((uniqueConstraint) => changedTable.addUniqueConstraint(uniqueConstraint));\n        await this.recreateTable(changedTable, table);\n    }\n    /**\n     * Drops an unique constraint.\n     */\n    async dropUniqueConstraint(tableOrName, uniqueOrName) {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        const uniqueConstraint = InstanceChecker.isTableUnique(uniqueOrName)\n            ? uniqueOrName\n            : table.uniques.find((u) => u.name === uniqueOrName);\n        if (!uniqueConstraint)\n            throw new TypeORMError(`Supplied unique constraint was not found in table ${table.name}`);\n        await this.dropUniqueConstraints(table, [uniqueConstraint]);\n    }\n    /**\n     * Creates an unique constraints.\n     */\n    async dropUniqueConstraints(tableOrName, uniqueConstraints) {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        // clone original table and remove unique constraints from cloned table\n        const changedTable = table.clone();\n        uniqueConstraints.forEach((uniqueConstraint) => changedTable.removeUniqueConstraint(uniqueConstraint));\n        await this.recreateTable(changedTable, table);\n    }\n    /**\n     * Creates new check constraint.\n     */\n    async createCheckConstraint(tableOrName, checkConstraint) {\n        await this.createCheckConstraints(tableOrName, [checkConstraint]);\n    }\n    /**\n     * Creates new check constraints.\n     */\n    async createCheckConstraints(tableOrName, checkConstraints) {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        // clone original table and add check constraints in to cloned table\n        const changedTable = table.clone();\n        checkConstraints.forEach((checkConstraint) => changedTable.addCheckConstraint(checkConstraint));\n        await this.recreateTable(changedTable, table);\n    }\n    /**\n     * Drops check constraint.\n     */\n    async dropCheckConstraint(tableOrName, checkOrName) {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        const checkConstraint = InstanceChecker.isTableCheck(checkOrName)\n            ? checkOrName\n            : table.checks.find((c) => c.name === checkOrName);\n        if (!checkConstraint)\n            throw new TypeORMError(`Supplied check constraint was not found in table ${table.name}`);\n        await this.dropCheckConstraints(table, [checkConstraint]);\n    }\n    /**\n     * Drops check constraints.\n     */\n    async dropCheckConstraints(tableOrName, checkConstraints) {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        // clone original table and remove check constraints from cloned table\n        const changedTable = table.clone();\n        checkConstraints.forEach((checkConstraint) => changedTable.removeCheckConstraint(checkConstraint));\n        await this.recreateTable(changedTable, table);\n    }\n    /**\n     * Creates a new exclusion constraint.\n     */\n    async createExclusionConstraint(tableOrName, exclusionConstraint) {\n        throw new TypeORMError(`Sqlite does not support exclusion constraints.`);\n    }\n    /**\n     * Creates a new exclusion constraints.\n     */\n    async createExclusionConstraints(tableOrName, exclusionConstraints) {\n        throw new TypeORMError(`Sqlite does not support exclusion constraints.`);\n    }\n    /**\n     * Drops exclusion constraint.\n     */\n    async dropExclusionConstraint(tableOrName, exclusionOrName) {\n        throw new TypeORMError(`Sqlite does not support exclusion constraints.`);\n    }\n    /**\n     * Drops exclusion constraints.\n     */\n    async dropExclusionConstraints(tableOrName, exclusionConstraints) {\n        throw new TypeORMError(`Sqlite does not support exclusion constraints.`);\n    }\n    /**\n     * Creates a new foreign key.\n     */\n    async createForeignKey(tableOrName, foreignKey) {\n        await this.createForeignKeys(tableOrName, [foreignKey]);\n    }\n    /**\n     * Creates a new foreign keys.\n     */\n    async createForeignKeys(tableOrName, foreignKeys) {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        // clone original table and add foreign keys in to cloned table\n        const changedTable = table.clone();\n        foreignKeys.forEach((foreignKey) => changedTable.addForeignKey(foreignKey));\n        await this.recreateTable(changedTable, table);\n    }\n    /**\n     * Drops a foreign key from the table.\n     */\n    async dropForeignKey(tableOrName, foreignKeyOrName) {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        const foreignKey = InstanceChecker.isTableForeignKey(foreignKeyOrName)\n            ? foreignKeyOrName\n            : table.foreignKeys.find((fk) => fk.name === foreignKeyOrName);\n        if (!foreignKey)\n            throw new TypeORMError(`Supplied foreign key was not found in table ${table.name}`);\n        await this.dropForeignKeys(tableOrName, [foreignKey]);\n    }\n    /**\n     * Drops a foreign keys from the table.\n     */\n    async dropForeignKeys(tableOrName, foreignKeys) {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        // clone original table and remove foreign keys from cloned table\n        const changedTable = table.clone();\n        foreignKeys.forEach((foreignKey) => changedTable.removeForeignKey(foreignKey));\n        await this.recreateTable(changedTable, table);\n    }\n    /**\n     * Creates a new index.\n     */\n    async createIndex(tableOrName, index) {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        // new index may be passed without name. In this case we generate index name manually.\n        if (!index.name)\n            index.name = this.generateIndexName(table, index);\n        const up = this.createIndexSql(table, index);\n        const down = this.dropIndexSql(index);\n        await this.executeQueries(up, down);\n        table.addIndex(index);\n    }\n    /**\n     * Creates a new indices\n     */\n    async createIndices(tableOrName, indices) {\n        const promises = indices.map((index) => this.createIndex(tableOrName, index));\n        await Promise.all(promises);\n    }\n    /**\n     * Drops an index from the table.\n     */\n    async dropIndex(tableOrName, indexOrName) {\n        const table = InstanceChecker.isTable(tableOrName)\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        const index = InstanceChecker.isTableIndex(indexOrName)\n            ? indexOrName\n            : table.indices.find((i) => i.name === indexOrName);\n        if (!index)\n            throw new TypeORMError(`Supplied index ${indexOrName} was not found in table ${table.name}`);\n        // old index may be passed without name. In this case we generate index name manually.\n        if (!index.name)\n            index.name = this.generateIndexName(table, index);\n        const up = this.dropIndexSql(index);\n        const down = this.createIndexSql(table, index);\n        await this.executeQueries(up, down);\n        table.removeIndex(index);\n    }\n    /**\n     * Drops an indices from the table.\n     */\n    async dropIndices(tableOrName, indices) {\n        const promises = indices.map((index) => this.dropIndex(tableOrName, index));\n        await Promise.all(promises);\n    }\n    /**\n     * Clears all table contents.\n     * Note: this operation uses SQL's TRUNCATE query which cannot be reverted in transactions.\n     */\n    async clearTable(tableName) {\n        await this.query(`DELETE FROM ${this.escapePath(tableName)}`);\n    }\n    /**\n     * Removes all tables from the currently connected database.\n     */\n    async clearDatabase(database) {\n        let dbPath = undefined;\n        if (database &&\n            this.driver.getAttachedDatabaseHandleByRelativePath(database)) {\n            dbPath =\n                this.driver.getAttachedDatabaseHandleByRelativePath(database);\n        }\n        await this.query(`PRAGMA foreign_keys = OFF`);\n        const isAnotherTransactionActive = this.isTransactionActive;\n        if (!isAnotherTransactionActive)\n            await this.startTransaction();\n        try {\n            const selectViewDropsQuery = dbPath\n                ? `SELECT 'DROP VIEW \"${dbPath}\".\"' || name || '\";' as query FROM \"${dbPath}\".\"sqlite_master\" WHERE \"type\" = 'view'`\n                : `SELECT 'DROP VIEW \"' || name || '\";' as query FROM \"sqlite_master\" WHERE \"type\" = 'view'`;\n            const dropViewQueries = await this.query(selectViewDropsQuery);\n            await Promise.all(dropViewQueries.map((q) => this.query(q[\"query\"])));\n            const selectTableDropsQuery = dbPath\n                ? `SELECT 'DROP TABLE \"${dbPath}\".\"' || name || '\";' as query FROM \"${dbPath}\".\"sqlite_master\" WHERE \"type\" = 'table' AND \"name\" != 'sqlite_sequence'`\n                : `SELECT 'DROP TABLE \"' || name || '\";' as query FROM \"sqlite_master\" WHERE \"type\" = 'table' AND \"name\" != 'sqlite_sequence'`;\n            const dropTableQueries = await this.query(selectTableDropsQuery);\n            await Promise.all(dropTableQueries.map((q) => this.query(q[\"query\"])));\n            if (!isAnotherTransactionActive)\n                await this.commitTransaction();\n        }\n        catch (error) {\n            try {\n                // we throw original error even if rollback thrown an error\n                if (!isAnotherTransactionActive)\n                    await this.rollbackTransaction();\n            }\n            catch (rollbackError) { }\n            throw error;\n        }\n        finally {\n            await this.query(`PRAGMA foreign_keys = ON`);\n        }\n    }\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n    async loadViews(viewNames) {\n        const hasTable = await this.hasTable(this.getTypeormMetadataTableName());\n        if (!hasTable) {\n            return [];\n        }\n        if (!viewNames) {\n            viewNames = [];\n        }\n        const viewNamesString = viewNames\n            .map((name) => \"'\" + name + \"'\")\n            .join(\", \");\n        let query = `SELECT \"t\".* FROM \"${this.getTypeormMetadataTableName()}\" \"t\" INNER JOIN \"sqlite_master\" s ON \"s\".\"name\" = \"t\".\"name\" AND \"s\".\"type\" = 'view' WHERE \"t\".\"type\" = '${MetadataTableType.VIEW}'`;\n        if (viewNamesString.length > 0)\n            query += ` AND \"t\".\"name\" IN (${viewNamesString})`;\n        const dbViews = await this.query(query);\n        return dbViews.map((dbView) => {\n            const view = new View();\n            view.name = dbView[\"name\"];\n            view.expression = dbView[\"value\"];\n            return view;\n        });\n    }\n    async loadTableRecords(tablePath, tableOrIndex) {\n        let database = undefined;\n        const [schema, tableName] = this.splitTablePath(tablePath);\n        if (schema &&\n            this.driver.getAttachedDatabasePathRelativeByHandle(schema)) {\n            database =\n                this.driver.getAttachedDatabasePathRelativeByHandle(schema);\n        }\n        return this.query(`SELECT ${database ? `'${database}'` : null} as database, ${schema ? `'${schema}'` : null} as schema, * FROM ${schema ? `\"${schema}\".` : \"\"}${this.escapePath(`sqlite_master`)} WHERE \"type\" = '${tableOrIndex}' AND \"${tableOrIndex === \"table\" ? \"name\" : \"tbl_name\"}\" IN ('${tableName}')`);\n    }\n    async loadPragmaRecords(tablePath, pragma) {\n        const [, tableName] = this.splitTablePath(tablePath);\n        return this.query(`PRAGMA ${pragma}(\"${tableName}\")`);\n    }\n    /**\n     * Loads all tables (with given names) from the database and creates a Table from them.\n     */\n    async loadTables(tableNames) {\n        // if no tables given then no need to proceed\n        if (tableNames && tableNames.length === 0) {\n            return [];\n        }\n        let dbTables = [];\n        let dbIndicesDef;\n        if (!tableNames) {\n            const tablesSql = `SELECT * FROM \"sqlite_master\" WHERE \"type\" = 'table'`;\n            dbTables.push(...(await this.query(tablesSql)));\n            const tableNamesString = dbTables\n                .map(({ name }) => `'${name}'`)\n                .join(\", \");\n            dbIndicesDef = await this.query(`SELECT * FROM \"sqlite_master\" WHERE \"type\" = 'index' AND \"tbl_name\" IN (${tableNamesString})`);\n        }\n        else {\n            const tableNamesWithoutDot = tableNames\n                .filter((tableName) => {\n                return tableName.split(\".\").length === 1;\n            })\n                .map((tableName) => `'${tableName}'`);\n            const tableNamesWithDot = tableNames.filter((tableName) => {\n                return tableName.split(\".\").length > 1;\n            });\n            const queryPromises = (type) => {\n                const promises = [\n                    ...tableNamesWithDot.map((tableName) => this.loadTableRecords(tableName, type)),\n                ];\n                if (tableNamesWithoutDot.length) {\n                    promises.push(this.query(`SELECT * FROM \"sqlite_master\" WHERE \"type\" = '${type}' AND \"${type === \"table\" ? \"name\" : \"tbl_name\"}\" IN (${tableNamesWithoutDot})`));\n                }\n                return promises;\n            };\n            dbTables = (await Promise.all(queryPromises(\"table\")))\n                .reduce((acc, res) => [...acc, ...res], [])\n                .filter(Boolean);\n            dbIndicesDef = (await Promise.all(queryPromises(\"index\")))\n                .reduce((acc, res) => [...acc, ...res], [])\n                .filter(Boolean);\n        }\n        // if tables were not found in the db, no need to proceed\n        if (dbTables.length === 0) {\n            return [];\n        }\n        // create table schemas for loaded tables\n        return Promise.all(dbTables.map(async (dbTable) => {\n            const tablePath = dbTable[\"database\"] &&\n                this.driver.getAttachedDatabaseHandleByRelativePath(dbTable[\"database\"])\n                ? `${this.driver.getAttachedDatabaseHandleByRelativePath(dbTable[\"database\"])}.${dbTable[\"name\"]}`\n                : dbTable[\"name\"];\n            const sql = dbTable[\"sql\"];\n            const withoutRowid = sql.includes(\"WITHOUT ROWID\");\n            const table = new Table({ name: tablePath, withoutRowid });\n            // load columns and indices\n            const [dbColumns, dbIndices, dbForeignKeys] = await Promise.all([\n                this.loadPragmaRecords(tablePath, `table_xinfo`),\n                this.loadPragmaRecords(tablePath, `index_list`),\n                this.loadPragmaRecords(tablePath, `foreign_key_list`),\n            ]);\n            // find column name with auto increment\n            let autoIncrementColumnName = undefined;\n            const tableSql = dbTable[\"sql\"];\n            let autoIncrementIndex = tableSql\n                .toUpperCase()\n                .indexOf(\"AUTOINCREMENT\");\n            if (autoIncrementIndex !== -1) {\n                autoIncrementColumnName = tableSql.substr(0, autoIncrementIndex);\n                const comma = autoIncrementColumnName.lastIndexOf(\",\");\n                const bracket = autoIncrementColumnName.lastIndexOf(\"(\");\n                if (comma !== -1) {\n                    autoIncrementColumnName =\n                        autoIncrementColumnName.substr(comma);\n                    autoIncrementColumnName =\n                        autoIncrementColumnName.substr(0, autoIncrementColumnName.lastIndexOf('\"'));\n                    autoIncrementColumnName =\n                        autoIncrementColumnName.substr(autoIncrementColumnName.indexOf('\"') + 1);\n                }\n                else if (bracket !== -1) {\n                    autoIncrementColumnName =\n                        autoIncrementColumnName.substr(bracket);\n                    autoIncrementColumnName =\n                        autoIncrementColumnName.substr(0, autoIncrementColumnName.lastIndexOf('\"'));\n                    autoIncrementColumnName =\n                        autoIncrementColumnName.substr(autoIncrementColumnName.indexOf('\"') + 1);\n                }\n            }\n            // create columns from the loaded columns\n            table.columns = await Promise.all(dbColumns.map(async (dbColumn) => {\n                const tableColumn = new TableColumn();\n                tableColumn.name = dbColumn[\"name\"];\n                tableColumn.type = dbColumn[\"type\"].toLowerCase();\n                tableColumn.default =\n                    dbColumn[\"dflt_value\"] !== null &&\n                        dbColumn[\"dflt_value\"] !== undefined\n                        ? dbColumn[\"dflt_value\"]\n                        : undefined;\n                tableColumn.isNullable = dbColumn[\"notnull\"] === 0;\n                // primary keys are numbered starting with 1, columns that aren't primary keys are marked with 0\n                tableColumn.isPrimary = dbColumn[\"pk\"] > 0;\n                tableColumn.comment = \"\"; // SQLite does not support column comments\n                tableColumn.isGenerated =\n                    autoIncrementColumnName === dbColumn[\"name\"];\n                if (tableColumn.isGenerated) {\n                    tableColumn.generationStrategy = \"increment\";\n                }\n                if (dbColumn[\"hidden\"] === 2 ||\n                    dbColumn[\"hidden\"] === 3) {\n                    tableColumn.generatedType =\n                        dbColumn[\"hidden\"] === 2 ? \"VIRTUAL\" : \"STORED\";\n                    const asExpressionQuery = await this.selectTypeormMetadataSql({\n                        table: table.name,\n                        type: MetadataTableType.GENERATED_COLUMN,\n                        name: tableColumn.name,\n                    });\n                    const results = await this.query(asExpressionQuery.query, asExpressionQuery.parameters);\n                    if (results[0] && results[0].value) {\n                        tableColumn.asExpression = results[0].value;\n                    }\n                    else {\n                        tableColumn.asExpression = \"\";\n                    }\n                }\n                if (tableColumn.type === \"varchar\") {\n                    // Check if this is an enum\n                    const enumMatch = sql.match(new RegExp('\"(' +\n                        tableColumn.name +\n                        \")\\\" varchar CHECK\\\\s*\\\\(\\\\s*\\\"\\\\1\\\"\\\\s+IN\\\\s*\\\\(('[^']+'(?:\\\\s*,\\\\s*'[^']+')+)\\\\s*\\\\)\\\\s*\\\\)\"));\n                    if (enumMatch) {\n                        // This is an enum\n                        tableColumn.enum = enumMatch[2]\n                            .substr(1, enumMatch[2].length - 2)\n                            .split(\"','\");\n                    }\n                }\n                // parse datatype and attempt to retrieve length, precision and scale\n                let pos = tableColumn.type.indexOf(\"(\");\n                if (pos !== -1) {\n                    const fullType = tableColumn.type;\n                    let dataType = fullType.substr(0, pos);\n                    if (!!this.driver.withLengthColumnTypes.find((col) => col === dataType)) {\n                        let len = parseInt(fullType.substring(pos + 1, fullType.length - 1));\n                        if (len) {\n                            tableColumn.length = len.toString();\n                            tableColumn.type = dataType; // remove the length part from the datatype\n                        }\n                    }\n                    if (!!this.driver.withPrecisionColumnTypes.find((col) => col === dataType)) {\n                        const re = new RegExp(`^${dataType}\\\\((\\\\d+),?\\\\s?(\\\\d+)?\\\\)`);\n                        const matches = fullType.match(re);\n                        if (matches && matches[1]) {\n                            tableColumn.precision = +matches[1];\n                        }\n                        if (!!this.driver.withScaleColumnTypes.find((col) => col === dataType)) {\n                            if (matches && matches[2]) {\n                                tableColumn.scale = +matches[2];\n                            }\n                        }\n                        tableColumn.type = dataType; // remove the precision/scale part from the datatype\n                    }\n                }\n                return tableColumn;\n            }));\n            // find foreign key constraints from CREATE TABLE sql\n            let fkResult;\n            const fkMappings = [];\n            const fkRegex = /CONSTRAINT \"([^\"]*)\" FOREIGN KEY ?\\((.*?)\\) REFERENCES \"([^\"]*)\"/g;\n            while ((fkResult = fkRegex.exec(sql)) !== null) {\n                fkMappings.push({\n                    name: fkResult[1],\n                    columns: fkResult[2]\n                        .substr(1, fkResult[2].length - 2)\n                        .split(`\", \"`),\n                    referencedTableName: fkResult[3],\n                });\n            }\n            // build foreign keys\n            const tableForeignKeyConstraints = OrmUtils.uniq(dbForeignKeys, (dbForeignKey) => dbForeignKey[\"id\"]);\n            table.foreignKeys = tableForeignKeyConstraints.map((foreignKey) => {\n                const ownForeignKeys = dbForeignKeys.filter((dbForeignKey) => dbForeignKey[\"id\"] === foreignKey[\"id\"] &&\n                    dbForeignKey[\"table\"] === foreignKey[\"table\"]);\n                const columnNames = ownForeignKeys.map((dbForeignKey) => dbForeignKey[\"from\"]);\n                const referencedColumnNames = ownForeignKeys.map((dbForeignKey) => dbForeignKey[\"to\"]);\n                // find related foreign key mapping\n                const fkMapping = fkMappings.find((it) => it.referencedTableName ===\n                    foreignKey[\"table\"] &&\n                    it.columns.every((column) => columnNames.indexOf(column) !== -1));\n                return new TableForeignKey({\n                    name: fkMapping === null || fkMapping === void 0 ? void 0 : fkMapping.name,\n                    columnNames: columnNames,\n                    referencedTableName: foreignKey[\"table\"],\n                    referencedColumnNames: referencedColumnNames,\n                    onDelete: foreignKey[\"on_delete\"],\n                    onUpdate: foreignKey[\"on_update\"],\n                });\n            });\n            // find unique constraints from CREATE TABLE sql\n            let uniqueRegexResult;\n            const uniqueMappings = [];\n            const uniqueRegex = /CONSTRAINT \"([^\"]*)\" UNIQUE ?\\((.*?)\\)/g;\n            while ((uniqueRegexResult = uniqueRegex.exec(sql)) !== null) {\n                uniqueMappings.push({\n                    name: uniqueRegexResult[1],\n                    columns: uniqueRegexResult[2]\n                        .substr(1, uniqueRegexResult[2].length - 2)\n                        .split(`\", \"`),\n                });\n            }\n            // build unique constraints\n            const tableUniquePromises = dbIndices\n                .filter((dbIndex) => dbIndex[\"origin\"] === \"u\")\n                .map((dbIndex) => dbIndex[\"name\"])\n                .filter((value, index, self) => self.indexOf(value) === index)\n                .map(async (dbIndexName) => {\n                const dbIndex = dbIndices.find((dbIndex) => dbIndex[\"name\"] === dbIndexName);\n                const indexInfos = await this.query(`PRAGMA index_info(\"${dbIndex[\"name\"]}\")`);\n                const indexColumns = indexInfos\n                    .sort((indexInfo1, indexInfo2) => parseInt(indexInfo1[\"seqno\"]) -\n                    parseInt(indexInfo2[\"seqno\"]))\n                    .map((indexInfo) => indexInfo[\"name\"]);\n                if (indexColumns.length === 1) {\n                    const column = table.columns.find((column) => {\n                        return !!indexColumns.find((indexColumn) => indexColumn === column.name);\n                    });\n                    if (column)\n                        column.isUnique = true;\n                }\n                // find existent mapping by a column names\n                const foundMapping = uniqueMappings.find((mapping) => {\n                    return mapping.columns.every((column) => indexColumns.indexOf(column) !== -1);\n                });\n                return new TableUnique({\n                    name: foundMapping\n                        ? foundMapping.name\n                        : this.connection.namingStrategy.uniqueConstraintName(table, indexColumns),\n                    columnNames: indexColumns,\n                });\n            });\n            table.uniques = (await Promise.all(tableUniquePromises));\n            // build checks\n            let result;\n            const regexp = /CONSTRAINT \"([^\"]*)\" CHECK ?(\\(.*?\\))([,]|[)]$)/g;\n            while ((result = regexp.exec(sql)) !== null) {\n                table.checks.push(new TableCheck({\n                    name: result[1],\n                    expression: result[2],\n                }));\n            }\n            // build indices\n            const indicesPromises = dbIndices\n                .filter((dbIndex) => dbIndex[\"origin\"] === \"c\")\n                .map((dbIndex) => dbIndex[\"name\"])\n                .filter((value, index, self) => self.indexOf(value) === index) // unqiue\n                .map(async (dbIndexName) => {\n                const indexDef = dbIndicesDef.find((dbIndexDef) => dbIndexDef[\"name\"] === dbIndexName);\n                const condition = /WHERE (.*)/.exec(indexDef[\"sql\"]);\n                const dbIndex = dbIndices.find((dbIndex) => dbIndex[\"name\"] === dbIndexName);\n                const indexInfos = await this.query(`PRAGMA index_info(\"${dbIndex[\"name\"]}\")`);\n                const indexColumns = indexInfos\n                    .sort((indexInfo1, indexInfo2) => parseInt(indexInfo1[\"seqno\"]) -\n                    parseInt(indexInfo2[\"seqno\"]))\n                    .map((indexInfo) => indexInfo[\"name\"]);\n                const dbIndexPath = `${dbTable[\"database\"] ? `${dbTable[\"database\"]}.` : \"\"}${dbIndex[\"name\"]}`;\n                const isUnique = dbIndex[\"unique\"] === \"1\" ||\n                    dbIndex[\"unique\"] === 1;\n                return new TableIndex({\n                    table: table,\n                    name: dbIndexPath,\n                    columnNames: indexColumns,\n                    isUnique: isUnique,\n                    where: condition ? condition[1] : undefined,\n                });\n            });\n            const indices = await Promise.all(indicesPromises);\n            table.indices = indices.filter((index) => !!index);\n            return table;\n        }));\n    }\n    /**\n     * Builds create table sql.\n     */\n    createTableSql(table, createForeignKeys, temporaryTable) {\n        const primaryColumns = table.columns.filter((column) => column.isPrimary);\n        const hasAutoIncrement = primaryColumns.find((column) => column.isGenerated && column.generationStrategy === \"increment\");\n        const skipPrimary = primaryColumns.length > 1;\n        if (skipPrimary && hasAutoIncrement)\n            throw new TypeORMError(`Sqlite does not support AUTOINCREMENT on composite primary key`);\n        const columnDefinitions = table.columns\n            .map((column) => this.buildCreateColumnSql(column, skipPrimary))\n            .join(\", \");\n        const [database] = this.splitTablePath(table.name);\n        let sql = `CREATE TABLE ${this.escapePath(table.name)} (${columnDefinitions}`;\n        let [databaseNew, tableName] = this.splitTablePath(table.name);\n        const newTableName = temporaryTable\n            ? `${databaseNew ? `${databaseNew}.` : \"\"}${tableName.replace(/^temporary_/, \"\")}`\n            : table.name;\n        // need for `addColumn()` method, because it recreates table.\n        table.columns\n            .filter((column) => column.isUnique)\n            .forEach((column) => {\n            const isUniqueExist = table.uniques.some((unique) => unique.columnNames.length === 1 &&\n                unique.columnNames[0] === column.name);\n            if (!isUniqueExist)\n                table.uniques.push(new TableUnique({\n                    name: this.connection.namingStrategy.uniqueConstraintName(table, [column.name]),\n                    columnNames: [column.name],\n                }));\n        });\n        if (table.uniques.length > 0) {\n            const uniquesSql = table.uniques\n                .map((unique) => {\n                const uniqueName = unique.name\n                    ? unique.name\n                    : this.connection.namingStrategy.uniqueConstraintName(newTableName, unique.columnNames);\n                const columnNames = unique.columnNames\n                    .map((columnName) => `\"${columnName}\"`)\n                    .join(\", \");\n                return `CONSTRAINT \"${uniqueName}\" UNIQUE (${columnNames})`;\n            })\n                .join(\", \");\n            sql += `, ${uniquesSql}`;\n        }\n        if (table.checks.length > 0) {\n            const checksSql = table.checks\n                .map((check) => {\n                const checkName = check.name\n                    ? check.name\n                    : this.connection.namingStrategy.checkConstraintName(newTableName, check.expression);\n                return `CONSTRAINT \"${checkName}\" CHECK (${check.expression})`;\n            })\n                .join(\", \");\n            sql += `, ${checksSql}`;\n        }\n        if (table.foreignKeys.length > 0 && createForeignKeys) {\n            const foreignKeysSql = table.foreignKeys\n                .filter((fk) => {\n                const [referencedDatabase] = this.splitTablePath(fk.referencedTableName);\n                if (referencedDatabase !== database) {\n                    return false;\n                }\n                return true;\n            })\n                .map((fk) => {\n                const [, referencedTable] = this.splitTablePath(fk.referencedTableName);\n                const columnNames = fk.columnNames\n                    .map((columnName) => `\"${columnName}\"`)\n                    .join(\", \");\n                if (!fk.name)\n                    fk.name = this.connection.namingStrategy.foreignKeyName(newTableName, fk.columnNames, this.getTablePath(fk), fk.referencedColumnNames);\n                const referencedColumnNames = fk.referencedColumnNames\n                    .map((columnName) => `\"${columnName}\"`)\n                    .join(\", \");\n                let constraint = `CONSTRAINT \"${fk.name}\" FOREIGN KEY (${columnNames}) REFERENCES \"${referencedTable}\" (${referencedColumnNames})`;\n                if (fk.onDelete)\n                    constraint += ` ON DELETE ${fk.onDelete}`;\n                if (fk.onUpdate)\n                    constraint += ` ON UPDATE ${fk.onUpdate}`;\n                if (fk.deferrable)\n                    constraint += ` DEFERRABLE ${fk.deferrable}`;\n                return constraint;\n            })\n                .join(\", \");\n            sql += `, ${foreignKeysSql}`;\n        }\n        if (primaryColumns.length > 1) {\n            const columnNames = primaryColumns\n                .map((column) => `\"${column.name}\"`)\n                .join(\", \");\n            sql += `, PRIMARY KEY (${columnNames})`;\n        }\n        sql += `)`;\n        if (table.withoutRowid) {\n            sql += \" WITHOUT ROWID\";\n        }\n        return new Query(sql);\n    }\n    /**\n     * Builds drop table sql.\n     */\n    dropTableSql(tableOrName, ifExist) {\n        const tableName = InstanceChecker.isTable(tableOrName)\n            ? tableOrName.name\n            : tableOrName;\n        const query = ifExist\n            ? `DROP TABLE IF EXISTS ${this.escapePath(tableName)}`\n            : `DROP TABLE ${this.escapePath(tableName)}`;\n        return new Query(query);\n    }\n    createViewSql(view) {\n        if (typeof view.expression === \"string\") {\n            return new Query(`CREATE VIEW \"${view.name}\" AS ${view.expression}`);\n        }\n        else {\n            return new Query(`CREATE VIEW \"${view.name}\" AS ${view\n                .expression(this.connection)\n                .getQuery()}`);\n        }\n    }\n    insertViewDefinitionSql(view) {\n        const expression = typeof view.expression === \"string\"\n            ? view.expression.trim()\n            : view.expression(this.connection).getQuery();\n        return this.insertTypeormMetadataSql({\n            type: MetadataTableType.VIEW,\n            name: view.name,\n            value: expression,\n        });\n    }\n    /**\n     * Builds drop view sql.\n     */\n    dropViewSql(viewOrPath) {\n        const viewName = InstanceChecker.isView(viewOrPath)\n            ? viewOrPath.name\n            : viewOrPath;\n        return new Query(`DROP VIEW \"${viewName}\"`);\n    }\n    /**\n     * Builds remove view sql.\n     */\n    deleteViewDefinitionSql(viewOrPath) {\n        const viewName = InstanceChecker.isView(viewOrPath)\n            ? viewOrPath.name\n            : viewOrPath;\n        return this.deleteTypeormMetadataSql({\n            type: MetadataTableType.VIEW,\n            name: viewName,\n        });\n    }\n    /**\n     * Builds create index sql.\n     */\n    createIndexSql(table, index) {\n        const columns = index.columnNames\n            .map((columnName) => `\"${columnName}\"`)\n            .join(\", \");\n        const [database, tableName] = this.splitTablePath(table.name);\n        return new Query(`CREATE ${index.isUnique ? \"UNIQUE \" : \"\"}INDEX ${database ? `\"${database}\".` : \"\"}${this.escapePath(index.name)} ON \"${tableName}\" (${columns}) ${index.where ? \"WHERE \" + index.where : \"\"}`);\n    }\n    /**\n     * Builds drop index sql.\n     */\n    dropIndexSql(indexOrName) {\n        let indexName = InstanceChecker.isTableIndex(indexOrName)\n            ? indexOrName.name\n            : indexOrName;\n        return new Query(`DROP INDEX ${this.escapePath(indexName)}`);\n    }\n    /**\n     * Builds a query for create column.\n     */\n    buildCreateColumnSql(column, skipPrimary) {\n        let c = '\"' + column.name + '\"';\n        if (InstanceChecker.isColumnMetadata(column)) {\n            c += \" \" + this.driver.normalizeType(column);\n        }\n        else {\n            c += \" \" + this.connection.driver.createFullType(column);\n        }\n        if (column.enum)\n            c +=\n                ' CHECK( \"' +\n                    column.name +\n                    '\" IN (' +\n                    column.enum.map((val) => \"'\" + val + \"'\").join(\",\") +\n                    \") )\";\n        if (column.isPrimary && !skipPrimary)\n            c += \" PRIMARY KEY\";\n        if (column.isGenerated === true &&\n            column.generationStrategy === \"increment\")\n            // don't use skipPrimary here since updates can update already exist primary without auto inc.\n            c += \" AUTOINCREMENT\";\n        if (column.collation)\n            c += \" COLLATE \" + column.collation;\n        if (column.isNullable !== true)\n            c += \" NOT NULL\";\n        if (column.asExpression) {\n            c += ` AS (${column.asExpression}) ${column.generatedType ? column.generatedType : \"VIRTUAL\"}`;\n        }\n        else {\n            if (column.default !== undefined && column.default !== null)\n                c += \" DEFAULT (\" + column.default + \")\";\n        }\n        return c;\n    }\n    async recreateTable(newTable, oldTable, migrateData = true) {\n        const upQueries = [];\n        const downQueries = [];\n        // drop old table indices\n        oldTable.indices.forEach((index) => {\n            upQueries.push(this.dropIndexSql(index));\n            downQueries.push(this.createIndexSql(oldTable, index));\n        });\n        // change table name into 'temporary_table'\n        let [databaseNew, tableNameNew] = this.splitTablePath(newTable.name);\n        let [, tableNameOld] = this.splitTablePath(oldTable.name);\n        newTable.name = tableNameNew = `${databaseNew ? `${databaseNew}.` : \"\"}temporary_${tableNameNew}`;\n        // create new table\n        upQueries.push(this.createTableSql(newTable, true, true));\n        downQueries.push(this.dropTableSql(newTable));\n        // migrate all data from the old table into new table\n        if (migrateData) {\n            let newColumnNames = newTable.columns\n                .filter((column) => !column.generatedType)\n                .map((column) => `\"${column.name}\"`);\n            let oldColumnNames = oldTable.columns\n                .filter((column) => !column.generatedType)\n                .map((column) => `\"${column.name}\"`);\n            if (oldColumnNames.length < newColumnNames.length) {\n                newColumnNames = newTable.columns\n                    .filter((column) => {\n                    const oldColumn = oldTable.columns.find((c) => c.name === column.name);\n                    if (oldColumn && oldColumn.generatedType)\n                        return false;\n                    return !column.generatedType && oldColumn;\n                })\n                    .map((column) => `\"${column.name}\"`);\n            }\n            else if (oldColumnNames.length > newColumnNames.length) {\n                oldColumnNames = oldTable.columns\n                    .filter((column) => {\n                    return (!column.generatedType &&\n                        newTable.columns.find((c) => c.name === column.name));\n                })\n                    .map((column) => `\"${column.name}\"`);\n            }\n            upQueries.push(new Query(`INSERT INTO ${this.escapePath(newTable.name)}(${newColumnNames.join(\", \")}) SELECT ${oldColumnNames.join(\", \")} FROM ${this.escapePath(oldTable.name)}`));\n            downQueries.push(new Query(`INSERT INTO ${this.escapePath(oldTable.name)}(${oldColumnNames.join(\", \")}) SELECT ${newColumnNames.join(\", \")} FROM ${this.escapePath(newTable.name)}`));\n        }\n        // drop old table\n        upQueries.push(this.dropTableSql(oldTable));\n        downQueries.push(this.createTableSql(oldTable, true));\n        // rename old table\n        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(newTable.name)} RENAME TO ${this.escapePath(tableNameOld)}`));\n        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(oldTable.name)} RENAME TO ${this.escapePath(tableNameNew)}`));\n        newTable.name = oldTable.name;\n        // recreate table indices\n        newTable.indices.forEach((index) => {\n            // new index may be passed without name. In this case we generate index name manually.\n            if (!index.name)\n                index.name = this.connection.namingStrategy.indexName(newTable, index.columnNames, index.where);\n            upQueries.push(this.createIndexSql(newTable, index));\n            downQueries.push(this.dropIndexSql(index));\n        });\n        // update generated columns in \"typeorm_metadata\" table\n        // Step 1: clear data for removed generated columns\n        oldTable.columns\n            .filter((column) => {\n            const newTableColumn = newTable.columns.find((c) => c.name === column.name);\n            // we should delete record from \"typeorm_metadata\" if generated column was removed\n            // or it was changed to non-generated\n            return (column.generatedType &&\n                column.asExpression &&\n                (!newTableColumn ||\n                    (!newTableColumn.generatedType &&\n                        !newTableColumn.asExpression)));\n        })\n            .forEach((column) => {\n            const deleteQuery = this.deleteTypeormMetadataSql({\n                table: oldTable.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n            });\n            const insertQuery = this.insertTypeormMetadataSql({\n                table: oldTable.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n                value: column.asExpression,\n            });\n            upQueries.push(deleteQuery);\n            downQueries.push(insertQuery);\n        });\n        // Step 2: add data for new generated columns\n        newTable.columns\n            .filter((column) => column.generatedType &&\n            column.asExpression &&\n            !oldTable.columns.some((c) => c.name === column.name))\n            .forEach((column) => {\n            const insertQuery = this.insertTypeormMetadataSql({\n                table: newTable.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n                value: column.asExpression,\n            });\n            const deleteQuery = this.deleteTypeormMetadataSql({\n                table: newTable.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n            });\n            upQueries.push(insertQuery);\n            downQueries.push(deleteQuery);\n        });\n        // Step 3: update changed expressions\n        newTable.columns\n            .filter((column) => column.generatedType && column.asExpression)\n            .forEach((column) => {\n            const oldColumn = oldTable.columns.find((c) => c.name === column.name &&\n                c.generatedType &&\n                column.generatedType &&\n                c.asExpression !== column.asExpression);\n            if (!oldColumn)\n                return;\n            // update expression\n            const deleteQuery = this.deleteTypeormMetadataSql({\n                table: oldTable.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: oldColumn.name,\n            });\n            const insertQuery = this.insertTypeormMetadataSql({\n                table: newTable.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n                value: column.asExpression,\n            });\n            upQueries.push(deleteQuery);\n            upQueries.push(insertQuery);\n            // revert update\n            const revertInsertQuery = this.insertTypeormMetadataSql({\n                table: newTable.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: oldColumn.name,\n                value: oldColumn.asExpression,\n            });\n            const revertDeleteQuery = this.deleteTypeormMetadataSql({\n                table: oldTable.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n            });\n            downQueries.push(revertInsertQuery);\n            downQueries.push(revertDeleteQuery);\n        });\n        await this.executeQueries(upQueries, downQueries);\n        this.replaceCachedTable(oldTable, newTable);\n    }\n    /**\n     * tablePath e.g. \"myDB.myTable\", \"myTable\"\n     */\n    splitTablePath(tablePath) {\n        return (tablePath.indexOf(\".\") !== -1\n            ? tablePath.split(\".\")\n            : [undefined, tablePath]);\n    }\n    /**\n     * Escapes given table or view path. Tolerates leading/trailing dots\n     */\n    escapePath(target, disableEscape) {\n        const tableName = InstanceChecker.isTable(target) || InstanceChecker.isView(target)\n            ? target.name\n            : target;\n        return tableName\n            .replace(/^\\.+|\\.+$/g, \"\")\n            .split(\".\")\n            .map((i) => (disableEscape ? i : `\"${i}\"`))\n            .join(\".\");\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}