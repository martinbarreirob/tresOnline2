{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/practicas/Downloads/angular/tresOnline/frontend-tres-en-raya/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { DefaultNamingStrategy } from \"../naming-strategy/DefaultNamingStrategy\";\nimport { CannotConnectAlreadyConnectedError, CannotExecuteNotConnectedError, EntityMetadataNotFoundError, QueryRunnerProviderAlreadyReleasedError, TypeORMError } from \"../error\";\nimport { MigrationExecutor } from \"../migration/MigrationExecutor\";\nimport { EntityMetadataValidator } from \"../metadata-builder/EntityMetadataValidator\";\nimport { EntityManagerFactory } from \"../entity-manager/EntityManagerFactory\";\nimport { DriverFactory } from \"../driver/DriverFactory\";\nimport { ConnectionMetadataBuilder } from \"../connection/ConnectionMetadataBuilder\";\nimport { SelectQueryBuilder } from \"../query-builder/SelectQueryBuilder\";\nimport { LoggerFactory } from \"../logger/LoggerFactory\";\nimport { QueryResultCacheFactory } from \"../cache/QueryResultCacheFactory\";\nimport { RelationLoader } from \"../query-builder/RelationLoader\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\nimport { RelationIdLoader } from \"../query-builder/RelationIdLoader\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\n/**\n * DataSource is a pre-defined connection configuration to a specific database.\n * You can have multiple data sources connected (with multiple connections in it),\n * connected to multiple databases in your application.\n *\n * Before, it was called `Connection`, but now `Connection` is deprecated\n * because `Connection` isn't the best name for what it's actually is.\n */\nexport class DataSource {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(options) {\n    this[\"@instanceof\"] = Symbol.for(\"DataSource\");\n    /**\n     * Migration instances that are registered for this connection.\n     */\n    this.migrations = [];\n    /**\n     * Entity subscriber instances that are registered for this connection.\n     */\n    this.subscribers = [];\n    /**\n     * All entity metadatas that are registered for this connection.\n     */\n    this.entityMetadatas = [];\n    /**\n     * All entity metadatas that are registered for this connection.\n     * This is a copy of #.entityMetadatas property -> used for more performant searches.\n     */\n    this.entityMetadatasMap = new Map();\n    this.name = options.name || \"default\";\n    this.options = options;\n    this.logger = new LoggerFactory().create(this.options.logger, this.options.logging);\n    this.driver = new DriverFactory().create(this);\n    this.manager = this.createEntityManager();\n    this.namingStrategy = options.namingStrategy || new DefaultNamingStrategy();\n    this.metadataTableName = options.metadataTableName || \"typeorm_metadata\";\n    this.queryResultCache = options.cache ? new QueryResultCacheFactory(this).create() : undefined;\n    this.relationLoader = new RelationLoader(this);\n    this.relationIdLoader = new RelationIdLoader(this);\n    this.isInitialized = false;\n  }\n  // -------------------------------------------------------------------------\n  // Public Accessors\n  // -------------------------------------------------------------------------\n  /**\n   Indicates if DataSource is initialized or not.\n   *\n   * @deprecated use .isInitialized instead\n   */\n  get isConnected() {\n    return this.isInitialized;\n  }\n  /**\n   * Gets the mongodb entity manager that allows to perform mongodb-specific repository operations\n   * with any entity in this connection.\n   *\n   * Available only in mongodb connections.\n   */\n  get mongoManager() {\n    if (!InstanceChecker.isMongoEntityManager(this.manager)) throw new TypeORMError(`MongoEntityManager is only available for MongoDB databases.`);\n    return this.manager;\n  }\n  /**\n   * Gets a sql.js specific Entity Manager that allows to perform special load and save operations\n   *\n   * Available only in connection with the sqljs driver.\n   */\n  get sqljsManager() {\n    if (!InstanceChecker.isSqljsEntityManager(this.manager)) throw new TypeORMError(`SqljsEntityManager is only available for Sqljs databases.`);\n    return this.manager;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Updates current connection options with provided options.\n   */\n  setOptions(options) {\n    Object.assign(this.options, options);\n    if (options.logger || options.logging) {\n      this.logger = new LoggerFactory().create(options.logger || this.options.logger, options.logging || this.options.logging);\n    }\n    if (options.namingStrategy) {\n      this.namingStrategy = options.namingStrategy;\n    }\n    if (options.cache) {\n      this.queryResultCache = new QueryResultCacheFactory(this).create();\n    }\n    // todo: we must update the database in the driver as well, if it was set by setOptions method\n    //  in the future we need to refactor the code and remove \"database\" from the driver, and instead\n    //  use database (and options) from a single place - data source.\n    if (options.database) {\n      this.driver.database = DriverUtils.buildDriverOptions(this.options).database;\n    }\n    // todo: need to take a look if we need to update schema and other \"poor\" properties\n    return this;\n  }\n  /**\n   * Performs connection to the database.\n   * This method should be called once on application bootstrap.\n   * This method not necessarily creates database connection (depend on database type),\n   * but it also can setup a connection pool with database to use.\n   */\n  initialize() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (_this.isInitialized) throw new CannotConnectAlreadyConnectedError(_this.name);\n      // connect to the database via its driver\n      yield _this.driver.connect();\n      // connect to the cache-specific database if cache is enabled\n      if (_this.queryResultCache) yield _this.queryResultCache.connect();\n      // set connected status for the current connection\n      ObjectUtils.assign(_this, {\n        isInitialized: true\n      });\n      try {\n        // build all metadatas registered in the current connection\n        yield _this.buildMetadatas();\n        yield _this.driver.afterConnect();\n        // if option is set - drop schema once connection is done\n        if (_this.options.dropSchema) yield _this.dropDatabase();\n        // if option is set - automatically synchronize a schema\n        if (_this.options.migrationsRun) yield _this.runMigrations({\n          transaction: _this.options.migrationsTransactionMode\n        });\n        // if option is set - automatically synchronize a schema\n        if (_this.options.synchronize) yield _this.synchronize();\n      } catch (error) {\n        // if for some reason build metadata fail (for example validation error during entity metadata check)\n        // connection needs to be closed\n        yield _this.destroy();\n        throw error;\n      }\n      return _this;\n    })();\n  }\n  /**\n   * Performs connection to the database.\n   * This method should be called once on application bootstrap.\n   * This method not necessarily creates database connection (depend on database type),\n   * but it also can setup a connection pool with database to use.\n   *\n   * @deprecated use .initialize method instead\n   */\n  connect() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      return _this2.initialize();\n    })();\n  }\n  /**\n   * Closes connection with the database.\n   * Once connection is closed, you cannot use repositories or perform any operations except opening connection again.\n   */\n  destroy() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this3.isInitialized) throw new CannotExecuteNotConnectedError(_this3.name);\n      yield _this3.driver.disconnect();\n      // disconnect from the cache-specific database if cache was enabled\n      if (_this3.queryResultCache) yield _this3.queryResultCache.disconnect();\n      ObjectUtils.assign(_this3, {\n        isInitialized: false\n      });\n    })();\n  }\n  /**\n   * Closes connection with the database.\n   * Once connection is closed, you cannot use repositories or perform any operations except opening connection again.\n   *\n   * @deprecated use .destroy method instead\n   */\n  close() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      return _this4.destroy();\n    })();\n  }\n  /**\n   * Creates database schema for all entities registered in this connection.\n   * Can be used only after connection to the database is established.\n   *\n   * @param dropBeforeSync If set to true then it drops the database with all its tables and data\n   */\n  synchronize(dropBeforeSync = false) {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this5.isInitialized) throw new CannotExecuteNotConnectedError(_this5.name);\n      if (dropBeforeSync) yield _this5.dropDatabase();\n      const schemaBuilder = _this5.driver.createSchemaBuilder();\n      yield schemaBuilder.build();\n    })();\n  }\n  /**\n   * Drops the database and all its data.\n   * Be careful with this method on production since this method will erase all your database tables and their data.\n   * Can be used only after connection to the database is established.\n   */\n  // TODO rename\n  dropDatabase() {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      const queryRunner = _this6.createQueryRunner();\n      try {\n        if (_this6.driver.options.type === \"mssql\" || DriverUtils.isMySQLFamily(_this6.driver) || _this6.driver.options.type === \"aurora-mysql\" || DriverUtils.isSQLiteFamily(_this6.driver)) {\n          const databases = [];\n          _this6.entityMetadatas.forEach(metadata => {\n            if (metadata.database && databases.indexOf(metadata.database) === -1) databases.push(metadata.database);\n          });\n          if (databases.length === 0 && _this6.driver.database) {\n            databases.push(_this6.driver.database);\n          }\n          if (databases.length === 0) {\n            yield queryRunner.clearDatabase();\n          } else {\n            for (const database of databases) {\n              yield queryRunner.clearDatabase(database);\n            }\n          }\n        } else {\n          yield queryRunner.clearDatabase();\n        }\n      } finally {\n        yield queryRunner.release();\n      }\n    })();\n  }\n  /**\n   * Runs all pending migrations.\n   * Can be used only after connection to the database is established.\n   */\n  runMigrations(options) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this7.isInitialized) throw new CannotExecuteNotConnectedError(_this7.name);\n      const migrationExecutor = new MigrationExecutor(_this7);\n      migrationExecutor.transaction = options && options.transaction || \"all\";\n      migrationExecutor.fake = options && options.fake || false;\n      const successMigrations = yield migrationExecutor.executePendingMigrations();\n      return successMigrations;\n    })();\n  }\n  /**\n   * Reverts last executed migration.\n   * Can be used only after connection to the database is established.\n   */\n  undoLastMigration(options) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this8.isInitialized) throw new CannotExecuteNotConnectedError(_this8.name);\n      const migrationExecutor = new MigrationExecutor(_this8);\n      migrationExecutor.transaction = options && options.transaction || \"all\";\n      migrationExecutor.fake = options && options.fake || false;\n      yield migrationExecutor.undoLastMigration();\n    })();\n  }\n  /**\n   * Lists all migrations and whether they have been run.\n   * Returns true if there are pending migrations\n   */\n  showMigrations() {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this9.isInitialized) {\n        throw new CannotExecuteNotConnectedError(_this9.name);\n      }\n      const migrationExecutor = new MigrationExecutor(_this9);\n      return yield migrationExecutor.showMigrations();\n    })();\n  }\n  /**\n   * Checks if entity metadata exist for the given entity class, target name or table name.\n   */\n  hasMetadata(target) {\n    return !!this.findMetadata(target);\n  }\n  /**\n   * Gets entity metadata for the given entity class or schema name.\n   */\n  getMetadata(target) {\n    const metadata = this.findMetadata(target);\n    if (!metadata) throw new EntityMetadataNotFoundError(target);\n    return metadata;\n  }\n  /**\n   * Gets repository for the given entity.\n   */\n  getRepository(target) {\n    return this.manager.getRepository(target);\n  }\n  /**\n   * Gets tree repository for the given entity class or name.\n   * Only tree-type entities can have a TreeRepository, like ones decorated with @Tree decorator.\n   */\n  getTreeRepository(target) {\n    return this.manager.getTreeRepository(target);\n  }\n  /**\n   * Gets mongodb-specific repository for the given entity class or name.\n   * Works only if connection is mongodb-specific.\n   */\n  getMongoRepository(target) {\n    if (!(this.driver.options.type === \"mongodb\")) throw new TypeORMError(`You can use getMongoRepository only for MongoDB connections.`);\n    return this.manager.getRepository(target);\n  }\n  /**\n   * Gets custom entity repository marked with @EntityRepository decorator.\n   *\n   * @deprecated use Repository.extend function to create a custom repository\n   */\n  getCustomRepository(customRepository) {\n    return this.manager.getCustomRepository(customRepository);\n  }\n  transaction(isolationOrRunInTransaction, runInTransactionParam) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      return _this10.manager.transaction(isolationOrRunInTransaction, runInTransactionParam);\n    })();\n  }\n  /**\n   * Executes raw SQL query and returns raw database results.\n   */\n  query(query, parameters, queryRunner) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      if (InstanceChecker.isMongoEntityManager(_this11.manager)) throw new TypeORMError(`Queries aren't supported by MongoDB.`);\n      if (queryRunner && queryRunner.isReleased) throw new QueryRunnerProviderAlreadyReleasedError();\n      const usedQueryRunner = queryRunner || _this11.createQueryRunner();\n      try {\n        return yield usedQueryRunner.query(query, parameters); // await is needed here because we are using finally\n      } finally {\n        if (!queryRunner) yield usedQueryRunner.release();\n      }\n    })();\n  }\n  /**\n   * Creates a new query builder that can be used to build a SQL query.\n   */\n  createQueryBuilder(entityOrRunner, alias, queryRunner) {\n    if (InstanceChecker.isMongoEntityManager(this.manager)) throw new TypeORMError(`Query Builder is not supported by MongoDB.`);\n    if (alias) {\n      alias = DriverUtils.buildAlias(this.driver, undefined, alias);\n      const metadata = this.getMetadata(entityOrRunner);\n      return new SelectQueryBuilder(this, queryRunner).select(alias).from(metadata.target, alias);\n    } else {\n      return new SelectQueryBuilder(this, entityOrRunner);\n    }\n  }\n  /**\n   * Creates a query runner used for perform queries on a single database connection.\n   * Using query runners you can control your queries to execute using single database connection and\n   * manually control your database transaction.\n   *\n   * Mode is used in replication mode and indicates whatever you want to connect\n   * to master database or any of slave databases.\n   * If you perform writes you must use master database,\n   * if you perform reads you can use slave databases.\n   */\n  createQueryRunner(mode = \"master\") {\n    const queryRunner = this.driver.createQueryRunner(mode);\n    const manager = this.createEntityManager(queryRunner);\n    Object.assign(queryRunner, {\n      manager: manager\n    });\n    return queryRunner;\n  }\n  /**\n   * Gets entity metadata of the junction table (many-to-many table).\n   */\n  getManyToManyMetadata(entityTarget, relationPropertyPath) {\n    const relationMetadata = this.getMetadata(entityTarget).findRelationWithPropertyPath(relationPropertyPath);\n    if (!relationMetadata) throw new TypeORMError(`Relation \"${relationPropertyPath}\" was not found in ${entityTarget} entity.`);\n    if (!relationMetadata.isManyToMany) throw new TypeORMError(`Relation \"${entityTarget}#${relationPropertyPath}\" does not have a many-to-many relationship.` + `You can use this method only on many-to-many relations.`);\n    return relationMetadata.junctionEntityMetadata;\n  }\n  /**\n   * Creates an Entity Manager for the current connection with the help of the EntityManagerFactory.\n   */\n  createEntityManager(queryRunner) {\n    return new EntityManagerFactory().create(this, queryRunner);\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Finds exist entity metadata by the given entity class, target name or table name.\n   */\n  findMetadata(target) {\n    const metadataFromMap = this.entityMetadatasMap.get(target);\n    if (metadataFromMap) return metadataFromMap;\n    for (let [_, metadata] of this.entityMetadatasMap) {\n      if (InstanceChecker.isEntitySchema(target) && metadata.name === target.options.name) {\n        return metadata;\n      }\n      if (typeof target === \"string\") {\n        if (target.indexOf(\".\") !== -1) {\n          if (metadata.tablePath === target) {\n            return metadata;\n          }\n        } else {\n          if (metadata.name === target || metadata.tableName === target) {\n            return metadata;\n          }\n        }\n      }\n      if (ObjectUtils.isObjectWithName(target) && typeof target.name === \"string\") {\n        if (target.name.indexOf(\".\") !== -1) {\n          if (metadata.tablePath === target.name) {\n            return metadata;\n          }\n        } else {\n          if (metadata.name === target.name || metadata.tableName === target.name) {\n            return metadata;\n          }\n        }\n      }\n    }\n    return undefined;\n  }\n  /**\n   * Builds metadatas for all registered classes inside this connection.\n   */\n  buildMetadatas() {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      const connectionMetadataBuilder = new ConnectionMetadataBuilder(_this12);\n      const entityMetadataValidator = new EntityMetadataValidator();\n      // create subscribers instances if they are not disallowed from high-level (for example they can disallowed from migrations run process)\n      const flattenedSubscribers = ObjectUtils.mixedListToArray(_this12.options.subscribers || []);\n      const subscribers = yield connectionMetadataBuilder.buildSubscribers(flattenedSubscribers);\n      ObjectUtils.assign(_this12, {\n        subscribers: subscribers\n      });\n      // build entity metadatas\n      const flattenedEntities = ObjectUtils.mixedListToArray(_this12.options.entities || []);\n      const entityMetadatas = yield connectionMetadataBuilder.buildEntityMetadatas(flattenedEntities);\n      ObjectUtils.assign(_this12, {\n        entityMetadatas: entityMetadatas,\n        entityMetadatasMap: new Map(entityMetadatas.map(metadata => [metadata.target, metadata]))\n      });\n      // create migration instances\n      const flattenedMigrations = ObjectUtils.mixedListToArray(_this12.options.migrations || []);\n      const migrations = yield connectionMetadataBuilder.buildMigrations(flattenedMigrations);\n      ObjectUtils.assign(_this12, {\n        migrations: migrations\n      });\n      // validate all created entity metadatas to make sure user created entities are valid and correct\n      entityMetadataValidator.validateMany(_this12.entityMetadatas.filter(metadata => metadata.tableType !== \"view\"), _this12.driver);\n      // set current data source to the entities\n      for (let entityMetadata of entityMetadatas) {\n        if (InstanceChecker.isBaseEntityConstructor(entityMetadata.target)) {\n          entityMetadata.target.useDataSource(_this12);\n        }\n      }\n    })();\n  }\n}","map":{"version":3,"names":["DefaultNamingStrategy","CannotConnectAlreadyConnectedError","CannotExecuteNotConnectedError","EntityMetadataNotFoundError","QueryRunnerProviderAlreadyReleasedError","TypeORMError","MigrationExecutor","EntityMetadataValidator","EntityManagerFactory","DriverFactory","ConnectionMetadataBuilder","SelectQueryBuilder","LoggerFactory","QueryResultCacheFactory","RelationLoader","ObjectUtils","RelationIdLoader","DriverUtils","InstanceChecker","DataSource","constructor","options","Symbol","for","migrations","subscribers","entityMetadatas","entityMetadatasMap","Map","name","logger","create","logging","driver","manager","createEntityManager","namingStrategy","metadataTableName","queryResultCache","cache","undefined","relationLoader","relationIdLoader","isInitialized","isConnected","mongoManager","isMongoEntityManager","sqljsManager","isSqljsEntityManager","setOptions","Object","assign","database","buildDriverOptions","initialize","_this","_asyncToGenerator","connect","buildMetadatas","afterConnect","dropSchema","dropDatabase","migrationsRun","runMigrations","transaction","migrationsTransactionMode","synchronize","error","destroy","_this2","_this3","disconnect","close","_this4","dropBeforeSync","_this5","schemaBuilder","createSchemaBuilder","build","_this6","queryRunner","createQueryRunner","type","isMySQLFamily","isSQLiteFamily","databases","forEach","metadata","indexOf","push","length","clearDatabase","release","_this7","migrationExecutor","fake","successMigrations","executePendingMigrations","undoLastMigration","_this8","showMigrations","_this9","hasMetadata","target","findMetadata","getMetadata","getRepository","getTreeRepository","getMongoRepository","getCustomRepository","customRepository","isolationOrRunInTransaction","runInTransactionParam","_this10","query","parameters","_this11","isReleased","usedQueryRunner","createQueryBuilder","entityOrRunner","alias","buildAlias","select","from","mode","getManyToManyMetadata","entityTarget","relationPropertyPath","relationMetadata","findRelationWithPropertyPath","isManyToMany","junctionEntityMetadata","metadataFromMap","get","_","isEntitySchema","tablePath","tableName","isObjectWithName","_this12","connectionMetadataBuilder","entityMetadataValidator","flattenedSubscribers","mixedListToArray","buildSubscribers","flattenedEntities","entities","buildEntityMetadatas","map","flattenedMigrations","buildMigrations","validateMany","filter","tableType","entityMetadata","isBaseEntityConstructor","useDataSource"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/data-source/DataSource.js"],"sourcesContent":["import { DefaultNamingStrategy } from \"../naming-strategy/DefaultNamingStrategy\";\nimport { CannotConnectAlreadyConnectedError, CannotExecuteNotConnectedError, EntityMetadataNotFoundError, QueryRunnerProviderAlreadyReleasedError, TypeORMError, } from \"../error\";\nimport { MigrationExecutor } from \"../migration/MigrationExecutor\";\nimport { EntityMetadataValidator } from \"../metadata-builder/EntityMetadataValidator\";\nimport { EntityManagerFactory } from \"../entity-manager/EntityManagerFactory\";\nimport { DriverFactory } from \"../driver/DriverFactory\";\nimport { ConnectionMetadataBuilder } from \"../connection/ConnectionMetadataBuilder\";\nimport { SelectQueryBuilder } from \"../query-builder/SelectQueryBuilder\";\nimport { LoggerFactory } from \"../logger/LoggerFactory\";\nimport { QueryResultCacheFactory } from \"../cache/QueryResultCacheFactory\";\nimport { RelationLoader } from \"../query-builder/RelationLoader\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\nimport { RelationIdLoader } from \"../query-builder/RelationIdLoader\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\n/**\n * DataSource is a pre-defined connection configuration to a specific database.\n * You can have multiple data sources connected (with multiple connections in it),\n * connected to multiple databases in your application.\n *\n * Before, it was called `Connection`, but now `Connection` is deprecated\n * because `Connection` isn't the best name for what it's actually is.\n */\nexport class DataSource {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n    constructor(options) {\n        this[\"@instanceof\"] = Symbol.for(\"DataSource\");\n        /**\n         * Migration instances that are registered for this connection.\n         */\n        this.migrations = [];\n        /**\n         * Entity subscriber instances that are registered for this connection.\n         */\n        this.subscribers = [];\n        /**\n         * All entity metadatas that are registered for this connection.\n         */\n        this.entityMetadatas = [];\n        /**\n         * All entity metadatas that are registered for this connection.\n         * This is a copy of #.entityMetadatas property -> used for more performant searches.\n         */\n        this.entityMetadatasMap = new Map();\n        this.name = options.name || \"default\";\n        this.options = options;\n        this.logger = new LoggerFactory().create(this.options.logger, this.options.logging);\n        this.driver = new DriverFactory().create(this);\n        this.manager = this.createEntityManager();\n        this.namingStrategy =\n            options.namingStrategy || new DefaultNamingStrategy();\n        this.metadataTableName = options.metadataTableName || \"typeorm_metadata\";\n        this.queryResultCache = options.cache\n            ? new QueryResultCacheFactory(this).create()\n            : undefined;\n        this.relationLoader = new RelationLoader(this);\n        this.relationIdLoader = new RelationIdLoader(this);\n        this.isInitialized = false;\n    }\n    // -------------------------------------------------------------------------\n    // Public Accessors\n    // -------------------------------------------------------------------------\n    /**\n     Indicates if DataSource is initialized or not.\n     *\n     * @deprecated use .isInitialized instead\n     */\n    get isConnected() {\n        return this.isInitialized;\n    }\n    /**\n     * Gets the mongodb entity manager that allows to perform mongodb-specific repository operations\n     * with any entity in this connection.\n     *\n     * Available only in mongodb connections.\n     */\n    get mongoManager() {\n        if (!InstanceChecker.isMongoEntityManager(this.manager))\n            throw new TypeORMError(`MongoEntityManager is only available for MongoDB databases.`);\n        return this.manager;\n    }\n    /**\n     * Gets a sql.js specific Entity Manager that allows to perform special load and save operations\n     *\n     * Available only in connection with the sqljs driver.\n     */\n    get sqljsManager() {\n        if (!InstanceChecker.isSqljsEntityManager(this.manager))\n            throw new TypeORMError(`SqljsEntityManager is only available for Sqljs databases.`);\n        return this.manager;\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Updates current connection options with provided options.\n     */\n    setOptions(options) {\n        Object.assign(this.options, options);\n        if (options.logger || options.logging) {\n            this.logger = new LoggerFactory().create(options.logger || this.options.logger, options.logging || this.options.logging);\n        }\n        if (options.namingStrategy) {\n            this.namingStrategy = options.namingStrategy;\n        }\n        if (options.cache) {\n            this.queryResultCache = new QueryResultCacheFactory(this).create();\n        }\n        // todo: we must update the database in the driver as well, if it was set by setOptions method\n        //  in the future we need to refactor the code and remove \"database\" from the driver, and instead\n        //  use database (and options) from a single place - data source.\n        if (options.database) {\n            this.driver.database = DriverUtils.buildDriverOptions(this.options).database;\n        }\n        // todo: need to take a look if we need to update schema and other \"poor\" properties\n        return this;\n    }\n    /**\n     * Performs connection to the database.\n     * This method should be called once on application bootstrap.\n     * This method not necessarily creates database connection (depend on database type),\n     * but it also can setup a connection pool with database to use.\n     */\n    async initialize() {\n        if (this.isInitialized)\n            throw new CannotConnectAlreadyConnectedError(this.name);\n        // connect to the database via its driver\n        await this.driver.connect();\n        // connect to the cache-specific database if cache is enabled\n        if (this.queryResultCache)\n            await this.queryResultCache.connect();\n        // set connected status for the current connection\n        ObjectUtils.assign(this, { isInitialized: true });\n        try {\n            // build all metadatas registered in the current connection\n            await this.buildMetadatas();\n            await this.driver.afterConnect();\n            // if option is set - drop schema once connection is done\n            if (this.options.dropSchema)\n                await this.dropDatabase();\n            // if option is set - automatically synchronize a schema\n            if (this.options.migrationsRun)\n                await this.runMigrations({\n                    transaction: this.options.migrationsTransactionMode,\n                });\n            // if option is set - automatically synchronize a schema\n            if (this.options.synchronize)\n                await this.synchronize();\n        }\n        catch (error) {\n            // if for some reason build metadata fail (for example validation error during entity metadata check)\n            // connection needs to be closed\n            await this.destroy();\n            throw error;\n        }\n        return this;\n    }\n    /**\n     * Performs connection to the database.\n     * This method should be called once on application bootstrap.\n     * This method not necessarily creates database connection (depend on database type),\n     * but it also can setup a connection pool with database to use.\n     *\n     * @deprecated use .initialize method instead\n     */\n    async connect() {\n        return this.initialize();\n    }\n    /**\n     * Closes connection with the database.\n     * Once connection is closed, you cannot use repositories or perform any operations except opening connection again.\n     */\n    async destroy() {\n        if (!this.isInitialized)\n            throw new CannotExecuteNotConnectedError(this.name);\n        await this.driver.disconnect();\n        // disconnect from the cache-specific database if cache was enabled\n        if (this.queryResultCache)\n            await this.queryResultCache.disconnect();\n        ObjectUtils.assign(this, { isInitialized: false });\n    }\n    /**\n     * Closes connection with the database.\n     * Once connection is closed, you cannot use repositories or perform any operations except opening connection again.\n     *\n     * @deprecated use .destroy method instead\n     */\n    async close() {\n        return this.destroy();\n    }\n    /**\n     * Creates database schema for all entities registered in this connection.\n     * Can be used only after connection to the database is established.\n     *\n     * @param dropBeforeSync If set to true then it drops the database with all its tables and data\n     */\n    async synchronize(dropBeforeSync = false) {\n        if (!this.isInitialized)\n            throw new CannotExecuteNotConnectedError(this.name);\n        if (dropBeforeSync)\n            await this.dropDatabase();\n        const schemaBuilder = this.driver.createSchemaBuilder();\n        await schemaBuilder.build();\n    }\n    /**\n     * Drops the database and all its data.\n     * Be careful with this method on production since this method will erase all your database tables and their data.\n     * Can be used only after connection to the database is established.\n     */\n    // TODO rename\n    async dropDatabase() {\n        const queryRunner = this.createQueryRunner();\n        try {\n            if (this.driver.options.type === \"mssql\" ||\n                DriverUtils.isMySQLFamily(this.driver) ||\n                this.driver.options.type === \"aurora-mysql\" ||\n                DriverUtils.isSQLiteFamily(this.driver)) {\n                const databases = [];\n                this.entityMetadatas.forEach((metadata) => {\n                    if (metadata.database &&\n                        databases.indexOf(metadata.database) === -1)\n                        databases.push(metadata.database);\n                });\n                if (databases.length === 0 && this.driver.database) {\n                    databases.push(this.driver.database);\n                }\n                if (databases.length === 0) {\n                    await queryRunner.clearDatabase();\n                }\n                else {\n                    for (const database of databases) {\n                        await queryRunner.clearDatabase(database);\n                    }\n                }\n            }\n            else {\n                await queryRunner.clearDatabase();\n            }\n        }\n        finally {\n            await queryRunner.release();\n        }\n    }\n    /**\n     * Runs all pending migrations.\n     * Can be used only after connection to the database is established.\n     */\n    async runMigrations(options) {\n        if (!this.isInitialized)\n            throw new CannotExecuteNotConnectedError(this.name);\n        const migrationExecutor = new MigrationExecutor(this);\n        migrationExecutor.transaction =\n            (options && options.transaction) || \"all\";\n        migrationExecutor.fake = (options && options.fake) || false;\n        const successMigrations = await migrationExecutor.executePendingMigrations();\n        return successMigrations;\n    }\n    /**\n     * Reverts last executed migration.\n     * Can be used only after connection to the database is established.\n     */\n    async undoLastMigration(options) {\n        if (!this.isInitialized)\n            throw new CannotExecuteNotConnectedError(this.name);\n        const migrationExecutor = new MigrationExecutor(this);\n        migrationExecutor.transaction =\n            (options && options.transaction) || \"all\";\n        migrationExecutor.fake = (options && options.fake) || false;\n        await migrationExecutor.undoLastMigration();\n    }\n    /**\n     * Lists all migrations and whether they have been run.\n     * Returns true if there are pending migrations\n     */\n    async showMigrations() {\n        if (!this.isInitialized) {\n            throw new CannotExecuteNotConnectedError(this.name);\n        }\n        const migrationExecutor = new MigrationExecutor(this);\n        return await migrationExecutor.showMigrations();\n    }\n    /**\n     * Checks if entity metadata exist for the given entity class, target name or table name.\n     */\n    hasMetadata(target) {\n        return !!this.findMetadata(target);\n    }\n    /**\n     * Gets entity metadata for the given entity class or schema name.\n     */\n    getMetadata(target) {\n        const metadata = this.findMetadata(target);\n        if (!metadata)\n            throw new EntityMetadataNotFoundError(target);\n        return metadata;\n    }\n    /**\n     * Gets repository for the given entity.\n     */\n    getRepository(target) {\n        return this.manager.getRepository(target);\n    }\n    /**\n     * Gets tree repository for the given entity class or name.\n     * Only tree-type entities can have a TreeRepository, like ones decorated with @Tree decorator.\n     */\n    getTreeRepository(target) {\n        return this.manager.getTreeRepository(target);\n    }\n    /**\n     * Gets mongodb-specific repository for the given entity class or name.\n     * Works only if connection is mongodb-specific.\n     */\n    getMongoRepository(target) {\n        if (!(this.driver.options.type === \"mongodb\"))\n            throw new TypeORMError(`You can use getMongoRepository only for MongoDB connections.`);\n        return this.manager.getRepository(target);\n    }\n    /**\n     * Gets custom entity repository marked with @EntityRepository decorator.\n     *\n     * @deprecated use Repository.extend function to create a custom repository\n     */\n    getCustomRepository(customRepository) {\n        return this.manager.getCustomRepository(customRepository);\n    }\n    async transaction(isolationOrRunInTransaction, runInTransactionParam) {\n        return this.manager.transaction(isolationOrRunInTransaction, runInTransactionParam);\n    }\n    /**\n     * Executes raw SQL query and returns raw database results.\n     */\n    async query(query, parameters, queryRunner) {\n        if (InstanceChecker.isMongoEntityManager(this.manager))\n            throw new TypeORMError(`Queries aren't supported by MongoDB.`);\n        if (queryRunner && queryRunner.isReleased)\n            throw new QueryRunnerProviderAlreadyReleasedError();\n        const usedQueryRunner = queryRunner || this.createQueryRunner();\n        try {\n            return await usedQueryRunner.query(query, parameters); // await is needed here because we are using finally\n        }\n        finally {\n            if (!queryRunner)\n                await usedQueryRunner.release();\n        }\n    }\n    /**\n     * Creates a new query builder that can be used to build a SQL query.\n     */\n    createQueryBuilder(entityOrRunner, alias, queryRunner) {\n        if (InstanceChecker.isMongoEntityManager(this.manager))\n            throw new TypeORMError(`Query Builder is not supported by MongoDB.`);\n        if (alias) {\n            alias = DriverUtils.buildAlias(this.driver, undefined, alias);\n            const metadata = this.getMetadata(entityOrRunner);\n            return new SelectQueryBuilder(this, queryRunner)\n                .select(alias)\n                .from(metadata.target, alias);\n        }\n        else {\n            return new SelectQueryBuilder(this, entityOrRunner);\n        }\n    }\n    /**\n     * Creates a query runner used for perform queries on a single database connection.\n     * Using query runners you can control your queries to execute using single database connection and\n     * manually control your database transaction.\n     *\n     * Mode is used in replication mode and indicates whatever you want to connect\n     * to master database or any of slave databases.\n     * If you perform writes you must use master database,\n     * if you perform reads you can use slave databases.\n     */\n    createQueryRunner(mode = \"master\") {\n        const queryRunner = this.driver.createQueryRunner(mode);\n        const manager = this.createEntityManager(queryRunner);\n        Object.assign(queryRunner, { manager: manager });\n        return queryRunner;\n    }\n    /**\n     * Gets entity metadata of the junction table (many-to-many table).\n     */\n    getManyToManyMetadata(entityTarget, relationPropertyPath) {\n        const relationMetadata = this.getMetadata(entityTarget).findRelationWithPropertyPath(relationPropertyPath);\n        if (!relationMetadata)\n            throw new TypeORMError(`Relation \"${relationPropertyPath}\" was not found in ${entityTarget} entity.`);\n        if (!relationMetadata.isManyToMany)\n            throw new TypeORMError(`Relation \"${entityTarget}#${relationPropertyPath}\" does not have a many-to-many relationship.` +\n                `You can use this method only on many-to-many relations.`);\n        return relationMetadata.junctionEntityMetadata;\n    }\n    /**\n     * Creates an Entity Manager for the current connection with the help of the EntityManagerFactory.\n     */\n    createEntityManager(queryRunner) {\n        return new EntityManagerFactory().create(this, queryRunner);\n    }\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Finds exist entity metadata by the given entity class, target name or table name.\n     */\n    findMetadata(target) {\n        const metadataFromMap = this.entityMetadatasMap.get(target);\n        if (metadataFromMap)\n            return metadataFromMap;\n        for (let [_, metadata] of this.entityMetadatasMap) {\n            if (InstanceChecker.isEntitySchema(target) &&\n                metadata.name === target.options.name) {\n                return metadata;\n            }\n            if (typeof target === \"string\") {\n                if (target.indexOf(\".\") !== -1) {\n                    if (metadata.tablePath === target) {\n                        return metadata;\n                    }\n                }\n                else {\n                    if (metadata.name === target ||\n                        metadata.tableName === target) {\n                        return metadata;\n                    }\n                }\n            }\n            if (ObjectUtils.isObjectWithName(target) &&\n                typeof target.name === \"string\") {\n                if (target.name.indexOf(\".\") !== -1) {\n                    if (metadata.tablePath === target.name) {\n                        return metadata;\n                    }\n                }\n                else {\n                    if (metadata.name === target.name ||\n                        metadata.tableName === target.name) {\n                        return metadata;\n                    }\n                }\n            }\n        }\n        return undefined;\n    }\n    /**\n     * Builds metadatas for all registered classes inside this connection.\n     */\n    async buildMetadatas() {\n        const connectionMetadataBuilder = new ConnectionMetadataBuilder(this);\n        const entityMetadataValidator = new EntityMetadataValidator();\n        // create subscribers instances if they are not disallowed from high-level (for example they can disallowed from migrations run process)\n        const flattenedSubscribers = ObjectUtils.mixedListToArray(this.options.subscribers || []);\n        const subscribers = await connectionMetadataBuilder.buildSubscribers(flattenedSubscribers);\n        ObjectUtils.assign(this, { subscribers: subscribers });\n        // build entity metadatas\n        const flattenedEntities = ObjectUtils.mixedListToArray(this.options.entities || []);\n        const entityMetadatas = await connectionMetadataBuilder.buildEntityMetadatas(flattenedEntities);\n        ObjectUtils.assign(this, {\n            entityMetadatas: entityMetadatas,\n            entityMetadatasMap: new Map(entityMetadatas.map((metadata) => [metadata.target, metadata])),\n        });\n        // create migration instances\n        const flattenedMigrations = ObjectUtils.mixedListToArray(this.options.migrations || []);\n        const migrations = await connectionMetadataBuilder.buildMigrations(flattenedMigrations);\n        ObjectUtils.assign(this, { migrations: migrations });\n        // validate all created entity metadatas to make sure user created entities are valid and correct\n        entityMetadataValidator.validateMany(this.entityMetadatas.filter((metadata) => metadata.tableType !== \"view\"), this.driver);\n        // set current data source to the entities\n        for (let entityMetadata of entityMetadatas) {\n            if (InstanceChecker.isBaseEntityConstructor(entityMetadata.target)) {\n                entityMetadata.target.useDataSource(this);\n            }\n        }\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}