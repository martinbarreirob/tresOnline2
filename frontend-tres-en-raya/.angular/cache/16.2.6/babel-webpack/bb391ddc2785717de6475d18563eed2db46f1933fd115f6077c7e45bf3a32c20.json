{"ast":null,"code":"import { getMetadataArgsStorage } from \"../../globals\";\nimport { ColumnTypeUndefinedError } from \"../../error/ColumnTypeUndefinedError\";\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n */\nexport function Column(typeOrOptions, options) {\n  return function (object, propertyName) {\n    // normalize parameters\n    let type;\n    if (typeof typeOrOptions === \"string\" || typeof typeOrOptions === \"function\") {\n      type = typeOrOptions;\n    } else if (typeOrOptions) {\n      options = typeOrOptions;\n      type = typeOrOptions.type;\n    }\n    if (!options) options = {};\n    // if type is not given explicitly then try to guess it\n    const reflectMetadataType = Reflect && Reflect.getMetadata ? Reflect.getMetadata(\"design:type\", object, propertyName) : undefined;\n    if (!type && reflectMetadataType)\n      // if type is not given explicitly then try to guess it\n      type = reflectMetadataType;\n    // check if there is no type in column options then set type from first function argument, or guessed one\n    if (!options.type && type) options.type = type;\n    // specify HSTORE type if column is HSTORE\n    if (options.type === \"hstore\" && !options.hstoreType) options.hstoreType = reflectMetadataType === Object ? \"object\" : \"string\";\n    if (typeof typeOrOptions === \"function\") {\n      // register an embedded\n      getMetadataArgsStorage().embeddeds.push({\n        target: object.constructor,\n        propertyName: propertyName,\n        isArray: reflectMetadataType === Array || options.array === true,\n        prefix: options.prefix !== undefined ? options.prefix : undefined,\n        type: typeOrOptions\n      });\n    } else {\n      // register a regular column\n      // if we still don't have a type then we need to give error to user that type is required\n      if (!options.type) throw new ColumnTypeUndefinedError(object, propertyName);\n      // create unique\n      if (options.unique === true) getMetadataArgsStorage().uniques.push({\n        target: object.constructor,\n        columns: [propertyName]\n      });\n      getMetadataArgsStorage().columns.push({\n        target: object.constructor,\n        propertyName: propertyName,\n        mode: \"regular\",\n        options: options\n      });\n      if (options.generated) {\n        getMetadataArgsStorage().generations.push({\n          target: object.constructor,\n          propertyName: propertyName,\n          strategy: typeof options.generated === \"string\" ? options.generated : \"increment\"\n        });\n      }\n    }\n  };\n}","map":{"version":3,"names":["getMetadataArgsStorage","ColumnTypeUndefinedError","Column","typeOrOptions","options","object","propertyName","type","reflectMetadataType","Reflect","getMetadata","undefined","hstoreType","Object","embeddeds","push","target","constructor","isArray","Array","array","prefix","unique","uniques","columns","mode","generated","generations","strategy"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/decorator/columns/Column.js"],"sourcesContent":["import { getMetadataArgsStorage } from \"../../globals\";\nimport { ColumnTypeUndefinedError } from \"../../error/ColumnTypeUndefinedError\";\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n */\nexport function Column(typeOrOptions, options) {\n    return function (object, propertyName) {\n        // normalize parameters\n        let type;\n        if (typeof typeOrOptions === \"string\" ||\n            typeof typeOrOptions === \"function\") {\n            type = typeOrOptions;\n        }\n        else if (typeOrOptions) {\n            options = typeOrOptions;\n            type = typeOrOptions.type;\n        }\n        if (!options)\n            options = {};\n        // if type is not given explicitly then try to guess it\n        const reflectMetadataType = Reflect && Reflect.getMetadata\n            ? Reflect.getMetadata(\"design:type\", object, propertyName)\n            : undefined;\n        if (!type && reflectMetadataType)\n            // if type is not given explicitly then try to guess it\n            type = reflectMetadataType;\n        // check if there is no type in column options then set type from first function argument, or guessed one\n        if (!options.type && type)\n            options.type = type;\n        // specify HSTORE type if column is HSTORE\n        if (options.type === \"hstore\" && !options.hstoreType)\n            options.hstoreType =\n                reflectMetadataType === Object ? \"object\" : \"string\";\n        if (typeof typeOrOptions === \"function\") {\n            // register an embedded\n            getMetadataArgsStorage().embeddeds.push({\n                target: object.constructor,\n                propertyName: propertyName,\n                isArray: reflectMetadataType === Array || options.array === true,\n                prefix: options.prefix !== undefined ? options.prefix : undefined,\n                type: typeOrOptions,\n            });\n        }\n        else {\n            // register a regular column\n            // if we still don't have a type then we need to give error to user that type is required\n            if (!options.type)\n                throw new ColumnTypeUndefinedError(object, propertyName);\n            // create unique\n            if (options.unique === true)\n                getMetadataArgsStorage().uniques.push({\n                    target: object.constructor,\n                    columns: [propertyName],\n                });\n            getMetadataArgsStorage().columns.push({\n                target: object.constructor,\n                propertyName: propertyName,\n                mode: \"regular\",\n                options: options,\n            });\n            if (options.generated) {\n                getMetadataArgsStorage().generations.push({\n                    target: object.constructor,\n                    propertyName: propertyName,\n                    strategy: typeof options.generated === \"string\"\n                        ? options.generated\n                        : \"increment\",\n                });\n            }\n        }\n    };\n}\n\n"],"mappings":"AAAA,SAASA,sBAAsB,QAAQ,eAAe;AACtD,SAASC,wBAAwB,QAAQ,sCAAsC;AAC/E;AACA;AACA;AACA;AACA,OAAO,SAASC,MAAMA,CAACC,aAAa,EAAEC,OAAO,EAAE;EAC3C,OAAO,UAAUC,MAAM,EAAEC,YAAY,EAAE;IACnC;IACA,IAAIC,IAAI;IACR,IAAI,OAAOJ,aAAa,KAAK,QAAQ,IACjC,OAAOA,aAAa,KAAK,UAAU,EAAE;MACrCI,IAAI,GAAGJ,aAAa;IACxB,CAAC,MACI,IAAIA,aAAa,EAAE;MACpBC,OAAO,GAAGD,aAAa;MACvBI,IAAI,GAAGJ,aAAa,CAACI,IAAI;IAC7B;IACA,IAAI,CAACH,OAAO,EACRA,OAAO,GAAG,CAAC,CAAC;IAChB;IACA,MAAMI,mBAAmB,GAAGC,OAAO,IAAIA,OAAO,CAACC,WAAW,GACpDD,OAAO,CAACC,WAAW,CAAC,aAAa,EAAEL,MAAM,EAAEC,YAAY,CAAC,GACxDK,SAAS;IACf,IAAI,CAACJ,IAAI,IAAIC,mBAAmB;MAC5B;MACAD,IAAI,GAAGC,mBAAmB;IAC9B;IACA,IAAI,CAACJ,OAAO,CAACG,IAAI,IAAIA,IAAI,EACrBH,OAAO,CAACG,IAAI,GAAGA,IAAI;IACvB;IACA,IAAIH,OAAO,CAACG,IAAI,KAAK,QAAQ,IAAI,CAACH,OAAO,CAACQ,UAAU,EAChDR,OAAO,CAACQ,UAAU,GACdJ,mBAAmB,KAAKK,MAAM,GAAG,QAAQ,GAAG,QAAQ;IAC5D,IAAI,OAAOV,aAAa,KAAK,UAAU,EAAE;MACrC;MACAH,sBAAsB,CAAC,CAAC,CAACc,SAAS,CAACC,IAAI,CAAC;QACpCC,MAAM,EAAEX,MAAM,CAACY,WAAW;QAC1BX,YAAY,EAAEA,YAAY;QAC1BY,OAAO,EAAEV,mBAAmB,KAAKW,KAAK,IAAIf,OAAO,CAACgB,KAAK,KAAK,IAAI;QAChEC,MAAM,EAAEjB,OAAO,CAACiB,MAAM,KAAKV,SAAS,GAAGP,OAAO,CAACiB,MAAM,GAAGV,SAAS;QACjEJ,IAAI,EAAEJ;MACV,CAAC,CAAC;IACN,CAAC,MACI;MACD;MACA;MACA,IAAI,CAACC,OAAO,CAACG,IAAI,EACb,MAAM,IAAIN,wBAAwB,CAACI,MAAM,EAAEC,YAAY,CAAC;MAC5D;MACA,IAAIF,OAAO,CAACkB,MAAM,KAAK,IAAI,EACvBtB,sBAAsB,CAAC,CAAC,CAACuB,OAAO,CAACR,IAAI,CAAC;QAClCC,MAAM,EAAEX,MAAM,CAACY,WAAW;QAC1BO,OAAO,EAAE,CAAClB,YAAY;MAC1B,CAAC,CAAC;MACNN,sBAAsB,CAAC,CAAC,CAACwB,OAAO,CAACT,IAAI,CAAC;QAClCC,MAAM,EAAEX,MAAM,CAACY,WAAW;QAC1BX,YAAY,EAAEA,YAAY;QAC1BmB,IAAI,EAAE,SAAS;QACfrB,OAAO,EAAEA;MACb,CAAC,CAAC;MACF,IAAIA,OAAO,CAACsB,SAAS,EAAE;QACnB1B,sBAAsB,CAAC,CAAC,CAAC2B,WAAW,CAACZ,IAAI,CAAC;UACtCC,MAAM,EAAEX,MAAM,CAACY,WAAW;UAC1BX,YAAY,EAAEA,YAAY;UAC1BsB,QAAQ,EAAE,OAAOxB,OAAO,CAACsB,SAAS,KAAK,QAAQ,GACzCtB,OAAO,CAACsB,SAAS,GACjB;QACV,CAAC,CAAC;MACN;IACJ;EACJ,CAAC;AACL"},"metadata":{},"sourceType":"module","externalDependencies":[]}