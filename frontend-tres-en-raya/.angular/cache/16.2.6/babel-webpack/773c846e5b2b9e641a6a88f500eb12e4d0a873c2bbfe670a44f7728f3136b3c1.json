{"ast":null,"code":"import { MetadataArgsStorage } from \"../metadata-args/MetadataArgsStorage\";\nimport { EntitySchemaEmbeddedError } from \"./EntitySchemaEmbeddedError\";\n/**\n * Transforms entity schema into metadata args storage.\n * The result will be just like entities read from decorators.\n */\nexport class EntitySchemaTransformer {\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Transforms entity schema into new metadata args storage object.\n   */\n  transform(schemas) {\n    const metadataArgsStorage = new MetadataArgsStorage();\n    schemas.forEach(entitySchema => {\n      var _a;\n      const options = entitySchema.options;\n      // add table metadata args from the schema\n      const tableMetadata = {\n        target: options.target || options.name,\n        name: options.tableName,\n        database: options.database,\n        schema: options.schema,\n        type: options.type || \"regular\",\n        orderBy: options.orderBy,\n        synchronize: options.synchronize,\n        withoutRowid: !!options.withoutRowid,\n        expression: options.expression\n      };\n      metadataArgsStorage.tables.push(tableMetadata);\n      const {\n        inheritance\n      } = options;\n      if (inheritance) {\n        metadataArgsStorage.inheritances.push({\n          target: options.target,\n          pattern: (_a = inheritance.pattern) !== null && _a !== void 0 ? _a : \"STI\",\n          column: inheritance.column ? typeof inheritance.column === \"string\" ? {\n            name: inheritance.column\n          } : inheritance.column : undefined\n        });\n      }\n      this.transformColumnsRecursive(options, metadataArgsStorage);\n    });\n    return metadataArgsStorage;\n  }\n  transformColumnsRecursive(options, metadataArgsStorage) {\n    // add columns metadata args from the schema\n    Object.keys(options.columns).forEach(columnName => {\n      const column = options.columns[columnName];\n      const regularColumn = column;\n      let mode = \"regular\";\n      if (regularColumn.createDate) mode = \"createDate\";\n      if (regularColumn.updateDate) mode = \"updateDate\";\n      if (regularColumn.deleteDate) mode = \"deleteDate\";\n      if (regularColumn.version) mode = \"version\";\n      if (regularColumn.treeChildrenCount) mode = \"treeChildrenCount\";\n      if (regularColumn.treeLevel) mode = \"treeLevel\";\n      if (regularColumn.objectId) mode = \"objectId\";\n      const columnArgs = {\n        target: options.target || options.name,\n        mode: mode,\n        propertyName: columnName,\n        options: {\n          type: regularColumn.type,\n          name: regularColumn.objectId ? \"_id\" : regularColumn.name,\n          primaryKeyConstraintName: regularColumn.primaryKeyConstraintName,\n          length: regularColumn.length,\n          width: regularColumn.width,\n          nullable: regularColumn.nullable,\n          readonly: regularColumn.readonly,\n          update: regularColumn.update,\n          select: regularColumn.select,\n          insert: regularColumn.insert,\n          primary: regularColumn.primary,\n          unique: regularColumn.unique,\n          comment: regularColumn.comment,\n          default: regularColumn.default,\n          onUpdate: regularColumn.onUpdate,\n          precision: regularColumn.precision,\n          scale: regularColumn.scale,\n          zerofill: regularColumn.zerofill,\n          unsigned: regularColumn.unsigned,\n          charset: regularColumn.charset,\n          collation: regularColumn.collation,\n          enum: regularColumn.enum,\n          enumName: regularColumn.enumName,\n          asExpression: regularColumn.asExpression,\n          generatedType: regularColumn.generatedType,\n          hstoreType: regularColumn.hstoreType,\n          array: regularColumn.array,\n          transformer: regularColumn.transformer,\n          spatialFeatureType: regularColumn.spatialFeatureType,\n          srid: regularColumn.srid\n        }\n      };\n      metadataArgsStorage.columns.push(columnArgs);\n      if (regularColumn.generated) {\n        const generationArgs = {\n          target: options.target || options.name,\n          propertyName: columnName,\n          strategy: typeof regularColumn.generated === \"string\" ? regularColumn.generated : \"increment\"\n        };\n        metadataArgsStorage.generations.push(generationArgs);\n      }\n      if (regularColumn.unique) metadataArgsStorage.uniques.push({\n        target: options.target || options.name,\n        columns: [columnName]\n      });\n    });\n    // add relation metadata args from the schema\n    if (options.relations) {\n      Object.keys(options.relations).forEach(relationName => {\n        const relationSchema = options.relations[relationName];\n        const relation = {\n          target: options.target || options.name,\n          propertyName: relationName,\n          relationType: relationSchema.type,\n          isLazy: relationSchema.lazy || false,\n          type: relationSchema.target,\n          inverseSideProperty: relationSchema.inverseSide,\n          isTreeParent: relationSchema.treeParent,\n          isTreeChildren: relationSchema.treeChildren,\n          options: {\n            eager: relationSchema.eager || false,\n            cascade: relationSchema.cascade,\n            nullable: relationSchema.nullable,\n            onDelete: relationSchema.onDelete,\n            onUpdate: relationSchema.onUpdate,\n            deferrable: relationSchema.deferrable,\n            // primary: relationSchema.primary,\n            createForeignKeyConstraints: relationSchema.createForeignKeyConstraints,\n            persistence: relationSchema.persistence,\n            orphanedRowAction: relationSchema.orphanedRowAction\n          }\n        };\n        metadataArgsStorage.relations.push(relation);\n        // add join column\n        if (relationSchema.joinColumn) {\n          if (typeof relationSchema.joinColumn === \"boolean\") {\n            const joinColumn = {\n              target: options.target || options.name,\n              propertyName: relationName\n            };\n            metadataArgsStorage.joinColumns.push(joinColumn);\n          } else {\n            const joinColumnsOptions = Array.isArray(relationSchema.joinColumn) ? relationSchema.joinColumn : [relationSchema.joinColumn];\n            for (const joinColumnOption of joinColumnsOptions) {\n              const joinColumn = {\n                target: options.target || options.name,\n                propertyName: relationName,\n                name: joinColumnOption.name,\n                referencedColumnName: joinColumnOption.referencedColumnName,\n                foreignKeyConstraintName: joinColumnOption.foreignKeyConstraintName\n              };\n              metadataArgsStorage.joinColumns.push(joinColumn);\n            }\n          }\n        }\n        // add join table\n        if (relationSchema.joinTable) {\n          if (typeof relationSchema.joinTable === \"boolean\") {\n            const joinTable = {\n              target: options.target || options.name,\n              propertyName: relationName\n            };\n            metadataArgsStorage.joinTables.push(joinTable);\n          } else {\n            const joinTable = {\n              target: options.target || options.name,\n              propertyName: relationName,\n              name: relationSchema.joinTable.name,\n              database: relationSchema.joinTable.database,\n              schema: relationSchema.joinTable.schema,\n              joinColumns: relationSchema.joinTable.joinColumn ? [relationSchema.joinTable.joinColumn] : relationSchema.joinTable.joinColumns,\n              inverseJoinColumns: relationSchema.joinTable.inverseJoinColumn ? [relationSchema.joinTable.inverseJoinColumn] : relationSchema.joinTable.inverseJoinColumns\n            };\n            metadataArgsStorage.joinTables.push(joinTable);\n          }\n        }\n      });\n    }\n    // add relation id metadata args from the schema\n    if (options.relationIds) {\n      Object.keys(options.relationIds).forEach(relationIdName => {\n        const relationIdOptions = options.relationIds[relationIdName];\n        const relationId = {\n          propertyName: relationIdName,\n          relation: relationIdOptions.relationName,\n          target: options.target || options.name,\n          alias: relationIdOptions.alias,\n          queryBuilderFactory: relationIdOptions.queryBuilderFactory\n        };\n        metadataArgsStorage.relationIds.push(relationId);\n      });\n    }\n    // add index metadata args from the schema\n    if (options.indices) {\n      options.indices.forEach(index => {\n        const indexArgs = {\n          target: options.target || options.name,\n          name: index.name,\n          unique: index.unique === true ? true : false,\n          spatial: index.spatial === true ? true : false,\n          fulltext: index.fulltext === true ? true : false,\n          nullFiltered: index.nullFiltered === true ? true : false,\n          parser: index.parser,\n          synchronize: index.synchronize === false ? false : true,\n          where: index.where,\n          sparse: index.sparse,\n          columns: index.columns\n        };\n        metadataArgsStorage.indices.push(indexArgs);\n      });\n    }\n    // add unique metadata args from the schema\n    if (options.uniques) {\n      options.uniques.forEach(unique => {\n        const uniqueArgs = {\n          target: options.target || options.name,\n          name: unique.name,\n          columns: unique.columns,\n          deferrable: unique.deferrable\n        };\n        metadataArgsStorage.uniques.push(uniqueArgs);\n      });\n    }\n    // add check metadata args from the schema\n    if (options.checks) {\n      options.checks.forEach(check => {\n        const checkArgs = {\n          target: options.target || options.name,\n          name: check.name,\n          expression: check.expression\n        };\n        metadataArgsStorage.checks.push(checkArgs);\n      });\n    }\n    // add exclusion metadata args from the schema\n    if (options.exclusions) {\n      options.exclusions.forEach(exclusion => {\n        const exclusionArgs = {\n          target: options.target || options.name,\n          name: exclusion.name,\n          expression: exclusion.expression\n        };\n        metadataArgsStorage.exclusions.push(exclusionArgs);\n      });\n    }\n    if (options.embeddeds) {\n      Object.keys(options.embeddeds).forEach(columnName => {\n        const embeddedOptions = options.embeddeds[columnName];\n        if (!embeddedOptions.schema) throw EntitySchemaEmbeddedError.createEntitySchemaIsRequiredException(columnName);\n        const embeddedSchema = embeddedOptions.schema.options;\n        metadataArgsStorage.embeddeds.push({\n          target: options.target || options.name,\n          propertyName: columnName,\n          isArray: embeddedOptions.array === true,\n          prefix: embeddedOptions.prefix !== undefined ? embeddedOptions.prefix : undefined,\n          type: () => (embeddedSchema === null || embeddedSchema === void 0 ? void 0 : embeddedSchema.target) || embeddedSchema.name\n        });\n        this.transformColumnsRecursive(embeddedSchema, metadataArgsStorage);\n      });\n    }\n  }\n}","map":{"version":3,"names":["MetadataArgsStorage","EntitySchemaEmbeddedError","EntitySchemaTransformer","transform","schemas","metadataArgsStorage","forEach","entitySchema","_a","options","tableMetadata","target","name","tableName","database","schema","type","orderBy","synchronize","withoutRowid","expression","tables","push","inheritance","inheritances","pattern","column","undefined","transformColumnsRecursive","Object","keys","columns","columnName","regularColumn","mode","createDate","updateDate","deleteDate","version","treeChildrenCount","treeLevel","objectId","columnArgs","propertyName","primaryKeyConstraintName","length","width","nullable","readonly","update","select","insert","primary","unique","comment","default","onUpdate","precision","scale","zerofill","unsigned","charset","collation","enum","enumName","asExpression","generatedType","hstoreType","array","transformer","spatialFeatureType","srid","generated","generationArgs","strategy","generations","uniques","relations","relationName","relationSchema","relation","relationType","isLazy","lazy","inverseSideProperty","inverseSide","isTreeParent","treeParent","isTreeChildren","treeChildren","eager","cascade","onDelete","deferrable","createForeignKeyConstraints","persistence","orphanedRowAction","joinColumn","joinColumns","joinColumnsOptions","Array","isArray","joinColumnOption","referencedColumnName","foreignKeyConstraintName","joinTable","joinTables","inverseJoinColumns","inverseJoinColumn","relationIds","relationIdName","relationIdOptions","relationId","alias","queryBuilderFactory","indices","index","indexArgs","spatial","fulltext","nullFiltered","parser","where","sparse","uniqueArgs","checks","check","checkArgs","exclusions","exclusion","exclusionArgs","embeddeds","embeddedOptions","createEntitySchemaIsRequiredException","embeddedSchema","prefix"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/entity-schema/EntitySchemaTransformer.js"],"sourcesContent":["import { MetadataArgsStorage } from \"../metadata-args/MetadataArgsStorage\";\nimport { EntitySchemaEmbeddedError } from \"./EntitySchemaEmbeddedError\";\n/**\n * Transforms entity schema into metadata args storage.\n * The result will be just like entities read from decorators.\n */\nexport class EntitySchemaTransformer {\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Transforms entity schema into new metadata args storage object.\n     */\n    transform(schemas) {\n        const metadataArgsStorage = new MetadataArgsStorage();\n        schemas.forEach((entitySchema) => {\n            var _a;\n            const options = entitySchema.options;\n            // add table metadata args from the schema\n            const tableMetadata = {\n                target: options.target || options.name,\n                name: options.tableName,\n                database: options.database,\n                schema: options.schema,\n                type: options.type || \"regular\",\n                orderBy: options.orderBy,\n                synchronize: options.synchronize,\n                withoutRowid: !!options.withoutRowid,\n                expression: options.expression,\n            };\n            metadataArgsStorage.tables.push(tableMetadata);\n            const { inheritance } = options;\n            if (inheritance) {\n                metadataArgsStorage.inheritances.push({\n                    target: options.target,\n                    pattern: (_a = inheritance.pattern) !== null && _a !== void 0 ? _a : \"STI\",\n                    column: inheritance.column\n                        ? typeof inheritance.column === \"string\"\n                            ? { name: inheritance.column }\n                            : inheritance.column\n                        : undefined,\n                });\n            }\n            this.transformColumnsRecursive(options, metadataArgsStorage);\n        });\n        return metadataArgsStorage;\n    }\n    transformColumnsRecursive(options, metadataArgsStorage) {\n        // add columns metadata args from the schema\n        Object.keys(options.columns).forEach((columnName) => {\n            const column = options.columns[columnName];\n            const regularColumn = column;\n            let mode = \"regular\";\n            if (regularColumn.createDate)\n                mode = \"createDate\";\n            if (regularColumn.updateDate)\n                mode = \"updateDate\";\n            if (regularColumn.deleteDate)\n                mode = \"deleteDate\";\n            if (regularColumn.version)\n                mode = \"version\";\n            if (regularColumn.treeChildrenCount)\n                mode = \"treeChildrenCount\";\n            if (regularColumn.treeLevel)\n                mode = \"treeLevel\";\n            if (regularColumn.objectId)\n                mode = \"objectId\";\n            const columnArgs = {\n                target: options.target || options.name,\n                mode: mode,\n                propertyName: columnName,\n                options: {\n                    type: regularColumn.type,\n                    name: regularColumn.objectId ? \"_id\" : regularColumn.name,\n                    primaryKeyConstraintName: regularColumn.primaryKeyConstraintName,\n                    length: regularColumn.length,\n                    width: regularColumn.width,\n                    nullable: regularColumn.nullable,\n                    readonly: regularColumn.readonly,\n                    update: regularColumn.update,\n                    select: regularColumn.select,\n                    insert: regularColumn.insert,\n                    primary: regularColumn.primary,\n                    unique: regularColumn.unique,\n                    comment: regularColumn.comment,\n                    default: regularColumn.default,\n                    onUpdate: regularColumn.onUpdate,\n                    precision: regularColumn.precision,\n                    scale: regularColumn.scale,\n                    zerofill: regularColumn.zerofill,\n                    unsigned: regularColumn.unsigned,\n                    charset: regularColumn.charset,\n                    collation: regularColumn.collation,\n                    enum: regularColumn.enum,\n                    enumName: regularColumn.enumName,\n                    asExpression: regularColumn.asExpression,\n                    generatedType: regularColumn.generatedType,\n                    hstoreType: regularColumn.hstoreType,\n                    array: regularColumn.array,\n                    transformer: regularColumn.transformer,\n                    spatialFeatureType: regularColumn.spatialFeatureType,\n                    srid: regularColumn.srid,\n                },\n            };\n            metadataArgsStorage.columns.push(columnArgs);\n            if (regularColumn.generated) {\n                const generationArgs = {\n                    target: options.target || options.name,\n                    propertyName: columnName,\n                    strategy: typeof regularColumn.generated === \"string\"\n                        ? regularColumn.generated\n                        : \"increment\",\n                };\n                metadataArgsStorage.generations.push(generationArgs);\n            }\n            if (regularColumn.unique)\n                metadataArgsStorage.uniques.push({\n                    target: options.target || options.name,\n                    columns: [columnName],\n                });\n        });\n        // add relation metadata args from the schema\n        if (options.relations) {\n            Object.keys(options.relations).forEach((relationName) => {\n                const relationSchema = options.relations[relationName];\n                const relation = {\n                    target: options.target || options.name,\n                    propertyName: relationName,\n                    relationType: relationSchema.type,\n                    isLazy: relationSchema.lazy || false,\n                    type: relationSchema.target,\n                    inverseSideProperty: relationSchema.inverseSide,\n                    isTreeParent: relationSchema.treeParent,\n                    isTreeChildren: relationSchema.treeChildren,\n                    options: {\n                        eager: relationSchema.eager || false,\n                        cascade: relationSchema.cascade,\n                        nullable: relationSchema.nullable,\n                        onDelete: relationSchema.onDelete,\n                        onUpdate: relationSchema.onUpdate,\n                        deferrable: relationSchema.deferrable,\n                        // primary: relationSchema.primary,\n                        createForeignKeyConstraints: relationSchema.createForeignKeyConstraints,\n                        persistence: relationSchema.persistence,\n                        orphanedRowAction: relationSchema.orphanedRowAction,\n                    },\n                };\n                metadataArgsStorage.relations.push(relation);\n                // add join column\n                if (relationSchema.joinColumn) {\n                    if (typeof relationSchema.joinColumn === \"boolean\") {\n                        const joinColumn = {\n                            target: options.target || options.name,\n                            propertyName: relationName,\n                        };\n                        metadataArgsStorage.joinColumns.push(joinColumn);\n                    }\n                    else {\n                        const joinColumnsOptions = Array.isArray(relationSchema.joinColumn)\n                            ? relationSchema.joinColumn\n                            : [relationSchema.joinColumn];\n                        for (const joinColumnOption of joinColumnsOptions) {\n                            const joinColumn = {\n                                target: options.target || options.name,\n                                propertyName: relationName,\n                                name: joinColumnOption.name,\n                                referencedColumnName: joinColumnOption.referencedColumnName,\n                                foreignKeyConstraintName: joinColumnOption.foreignKeyConstraintName,\n                            };\n                            metadataArgsStorage.joinColumns.push(joinColumn);\n                        }\n                    }\n                }\n                // add join table\n                if (relationSchema.joinTable) {\n                    if (typeof relationSchema.joinTable === \"boolean\") {\n                        const joinTable = {\n                            target: options.target || options.name,\n                            propertyName: relationName,\n                        };\n                        metadataArgsStorage.joinTables.push(joinTable);\n                    }\n                    else {\n                        const joinTable = {\n                            target: options.target || options.name,\n                            propertyName: relationName,\n                            name: relationSchema.joinTable.name,\n                            database: relationSchema.joinTable.database,\n                            schema: relationSchema.joinTable.schema,\n                            joinColumns: (relationSchema.joinTable.joinColumn\n                                ? [\n                                    relationSchema.joinTable.joinColumn,\n                                ]\n                                : relationSchema.joinTable.joinColumns),\n                            inverseJoinColumns: (relationSchema.joinTable.inverseJoinColumn\n                                ? [\n                                    relationSchema.joinTable.inverseJoinColumn,\n                                ]\n                                : relationSchema.joinTable.inverseJoinColumns),\n                        };\n                        metadataArgsStorage.joinTables.push(joinTable);\n                    }\n                }\n            });\n        }\n        // add relation id metadata args from the schema\n        if (options.relationIds) {\n            Object.keys(options.relationIds).forEach((relationIdName) => {\n                const relationIdOptions = options.relationIds[relationIdName];\n                const relationId = {\n                    propertyName: relationIdName,\n                    relation: relationIdOptions.relationName,\n                    target: options.target || options.name,\n                    alias: relationIdOptions.alias,\n                    queryBuilderFactory: relationIdOptions.queryBuilderFactory,\n                };\n                metadataArgsStorage.relationIds.push(relationId);\n            });\n        }\n        // add index metadata args from the schema\n        if (options.indices) {\n            options.indices.forEach((index) => {\n                const indexArgs = {\n                    target: options.target || options.name,\n                    name: index.name,\n                    unique: index.unique === true ? true : false,\n                    spatial: index.spatial === true ? true : false,\n                    fulltext: index.fulltext === true ? true : false,\n                    nullFiltered: index.nullFiltered === true ? true : false,\n                    parser: index.parser,\n                    synchronize: index.synchronize === false ? false : true,\n                    where: index.where,\n                    sparse: index.sparse,\n                    columns: index.columns,\n                };\n                metadataArgsStorage.indices.push(indexArgs);\n            });\n        }\n        // add unique metadata args from the schema\n        if (options.uniques) {\n            options.uniques.forEach((unique) => {\n                const uniqueArgs = {\n                    target: options.target || options.name,\n                    name: unique.name,\n                    columns: unique.columns,\n                    deferrable: unique.deferrable,\n                };\n                metadataArgsStorage.uniques.push(uniqueArgs);\n            });\n        }\n        // add check metadata args from the schema\n        if (options.checks) {\n            options.checks.forEach((check) => {\n                const checkArgs = {\n                    target: options.target || options.name,\n                    name: check.name,\n                    expression: check.expression,\n                };\n                metadataArgsStorage.checks.push(checkArgs);\n            });\n        }\n        // add exclusion metadata args from the schema\n        if (options.exclusions) {\n            options.exclusions.forEach((exclusion) => {\n                const exclusionArgs = {\n                    target: options.target || options.name,\n                    name: exclusion.name,\n                    expression: exclusion.expression,\n                };\n                metadataArgsStorage.exclusions.push(exclusionArgs);\n            });\n        }\n        if (options.embeddeds) {\n            Object.keys(options.embeddeds).forEach((columnName) => {\n                const embeddedOptions = options.embeddeds[columnName];\n                if (!embeddedOptions.schema)\n                    throw EntitySchemaEmbeddedError.createEntitySchemaIsRequiredException(columnName);\n                const embeddedSchema = embeddedOptions.schema.options;\n                metadataArgsStorage.embeddeds.push({\n                    target: options.target || options.name,\n                    propertyName: columnName,\n                    isArray: embeddedOptions.array === true,\n                    prefix: embeddedOptions.prefix !== undefined\n                        ? embeddedOptions.prefix\n                        : undefined,\n                    type: () => (embeddedSchema === null || embeddedSchema === void 0 ? void 0 : embeddedSchema.target) || embeddedSchema.name,\n                });\n                this.transformColumnsRecursive(embeddedSchema, metadataArgsStorage);\n            });\n        }\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}