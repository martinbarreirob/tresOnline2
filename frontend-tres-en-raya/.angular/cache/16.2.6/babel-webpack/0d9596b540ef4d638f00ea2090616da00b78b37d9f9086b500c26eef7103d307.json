{"ast":null,"code":"/**\n * This source code is from https://github.com/jriecken/dependency-graph\n * Just added \"any\" types here, wrapper everything into exported class.\n * We cant use a package itself because we want to package \"everything-in-it\" for the frontend users of TypeORM.\n */\n/**\n * A simple dependency graph\n */\nimport { TypeORMError } from \"../error\";\n/**\n * Helper for creating a Depth-First-Search on\n * a set of edges.\n *\n * Detects cycles and throws an Error if one is detected.\n *\n * @param edges The set of edges to DFS through\n * @param leavesOnly Whether to only return \"leaf\" nodes (ones who have no edges)\n * @param result An array in which the results will be populated\n */\nfunction createDFS(edges, leavesOnly, result) {\n  let currentPath = [];\n  let visited = {};\n  return function DFS(currentNode) {\n    visited[currentNode] = true;\n    currentPath.push(currentNode);\n    edges[currentNode].forEach(function (node) {\n      if (!visited[node]) {\n        DFS(node);\n      } else if (currentPath.indexOf(node) >= 0) {\n        currentPath.push(node);\n        throw new TypeORMError(`Dependency Cycle Found: ${currentPath.join(\" -> \")}`);\n      }\n    });\n    currentPath.pop();\n    if ((!leavesOnly || edges[currentNode].length === 0) && result.indexOf(currentNode) === -1) {\n      result.push(currentNode);\n    }\n  };\n}\nexport class DepGraph {\n  constructor() {\n    this.nodes = {};\n    this.outgoingEdges = {}; // Node -> [Dependency Node]\n    this.incomingEdges = {}; // Node -> [Dependant Node]\n  }\n  /**\n   * Add a node to the dependency graph. If a node already exists, this method will do nothing.\n   */\n  addNode(node, data) {\n    if (!this.hasNode(node)) {\n      // Checking the arguments length allows the user to add a node with undefined data\n      if (arguments.length === 2) {\n        this.nodes[node] = data;\n      } else {\n        this.nodes[node] = node;\n      }\n      this.outgoingEdges[node] = [];\n      this.incomingEdges[node] = [];\n    }\n  }\n  /**\n   * Remove a node from the dependency graph. If a node does not exist, this method will do nothing.\n   */\n  removeNode(node) {\n    if (this.hasNode(node)) {\n      delete this.nodes[node];\n      delete this.outgoingEdges[node];\n      delete this.incomingEdges[node];\n      [this.incomingEdges, this.outgoingEdges].forEach(function (edgeList) {\n        Object.keys(edgeList).forEach(function (key) {\n          let idx = edgeList[key].indexOf(node);\n          if (idx >= 0) {\n            edgeList[key].splice(idx, 1);\n          }\n        }, this);\n      });\n    }\n  }\n  /**\n   * Check if a node exists in the graph\n   */\n  hasNode(node) {\n    return this.nodes.hasOwnProperty(node);\n  }\n  /**\n   * Get the data associated with a node name\n   */\n  getNodeData(node) {\n    if (this.hasNode(node)) {\n      return this.nodes[node];\n    } else {\n      throw new TypeORMError(`Node does not exist: ${node}`);\n    }\n  }\n  /**\n   * Set the associated data for a given node name. If the node does not exist, this method will throw an error\n   */\n  setNodeData(node, data) {\n    if (this.hasNode(node)) {\n      this.nodes[node] = data;\n    } else {\n      throw new TypeORMError(`Node does not exist: ${node}`);\n    }\n  }\n  /**\n   * Add a dependency between two nodes. If either of the nodes does not exist,\n   * an Error will be thrown.\n   */\n  addDependency(from, to) {\n    if (!this.hasNode(from)) {\n      throw new TypeORMError(`Node does not exist: ${from}`);\n    }\n    if (!this.hasNode(to)) {\n      throw new TypeORMError(`Node does not exist: ${to}`);\n    }\n    if (this.outgoingEdges[from].indexOf(to) === -1) {\n      this.outgoingEdges[from].push(to);\n    }\n    if (this.incomingEdges[to].indexOf(from) === -1) {\n      this.incomingEdges[to].push(from);\n    }\n    return true;\n  }\n  /**\n   * Remove a dependency between two nodes.\n   */\n  removeDependency(from, to) {\n    let idx;\n    if (this.hasNode(from)) {\n      idx = this.outgoingEdges[from].indexOf(to);\n      if (idx >= 0) {\n        this.outgoingEdges[from].splice(idx, 1);\n      }\n    }\n    if (this.hasNode(to)) {\n      idx = this.incomingEdges[to].indexOf(from);\n      if (idx >= 0) {\n        this.incomingEdges[to].splice(idx, 1);\n      }\n    }\n  }\n  /**\n   * Get an array containing the nodes that the specified node depends on (transitively).\n   *\n   * Throws an Error if the graph has a cycle, or the specified node does not exist.\n   *\n   * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned\n   * in the array.\n   */\n  dependenciesOf(node, leavesOnly) {\n    if (this.hasNode(node)) {\n      let result = [];\n      let DFS = createDFS(this.outgoingEdges, leavesOnly, result);\n      DFS(node);\n      let idx = result.indexOf(node);\n      if (idx >= 0) {\n        result.splice(idx, 1);\n      }\n      return result;\n    } else {\n      throw new TypeORMError(`Node does not exist: ${node}`);\n    }\n  }\n  /**\n   * get an array containing the nodes that depend on the specified node (transitively).\n   *\n   * Throws an Error if the graph has a cycle, or the specified node does not exist.\n   *\n   * If `leavesOnly` is true, only nodes that do not have any dependants will be returned in the array.\n   */\n  dependantsOf(node, leavesOnly) {\n    if (this.hasNode(node)) {\n      let result = [];\n      let DFS = createDFS(this.incomingEdges, leavesOnly, result);\n      DFS(node);\n      let idx = result.indexOf(node);\n      if (idx >= 0) {\n        result.splice(idx, 1);\n      }\n      return result;\n    } else {\n      throw new TypeORMError(`Node does not exist: ${node}`);\n    }\n  }\n  /**\n   * Construct the overall processing order for the dependency graph.\n   *\n   * Throws an Error if the graph has a cycle.\n   *\n   * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned.\n   */\n  overallOrder(leavesOnly) {\n    let self = this;\n    let result = [];\n    let keys = Object.keys(this.nodes);\n    if (keys.length === 0) {\n      return result; // Empty graph\n    } else {\n      // Look for cycles - we run the DFS starting at all the nodes in case there\n      // are several disconnected subgraphs inside this dependency graph.\n      let CycleDFS = createDFS(this.outgoingEdges, false, []);\n      keys.forEach(function (n) {\n        CycleDFS(n);\n      });\n      let DFS = createDFS(this.outgoingEdges, leavesOnly, result);\n      // Find all potential starting points (nodes with nothing depending on them) an\n      // run a DFS starting at these points to get the order\n      keys.filter(function (node) {\n        return self.incomingEdges[node].length === 0;\n      }).forEach(function (n) {\n        DFS(n);\n      });\n      return result;\n    }\n  }\n}","map":{"version":3,"names":["TypeORMError","createDFS","edges","leavesOnly","result","currentPath","visited","DFS","currentNode","push","forEach","node","indexOf","join","pop","length","DepGraph","constructor","nodes","outgoingEdges","incomingEdges","addNode","data","hasNode","arguments","removeNode","edgeList","Object","keys","key","idx","splice","hasOwnProperty","getNodeData","setNodeData","addDependency","from","to","removeDependency","dependenciesOf","dependantsOf","overallOrder","self","CycleDFS","n","filter"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/util/DepGraph.js"],"sourcesContent":["/**\n * This source code is from https://github.com/jriecken/dependency-graph\n * Just added \"any\" types here, wrapper everything into exported class.\n * We cant use a package itself because we want to package \"everything-in-it\" for the frontend users of TypeORM.\n */\n/**\n * A simple dependency graph\n */\nimport { TypeORMError } from \"../error\";\n/**\n * Helper for creating a Depth-First-Search on\n * a set of edges.\n *\n * Detects cycles and throws an Error if one is detected.\n *\n * @param edges The set of edges to DFS through\n * @param leavesOnly Whether to only return \"leaf\" nodes (ones who have no edges)\n * @param result An array in which the results will be populated\n */\nfunction createDFS(edges, leavesOnly, result) {\n    let currentPath = [];\n    let visited = {};\n    return function DFS(currentNode) {\n        visited[currentNode] = true;\n        currentPath.push(currentNode);\n        edges[currentNode].forEach(function (node) {\n            if (!visited[node]) {\n                DFS(node);\n            }\n            else if (currentPath.indexOf(node) >= 0) {\n                currentPath.push(node);\n                throw new TypeORMError(`Dependency Cycle Found: ${currentPath.join(\" -> \")}`);\n            }\n        });\n        currentPath.pop();\n        if ((!leavesOnly || edges[currentNode].length === 0) &&\n            result.indexOf(currentNode) === -1) {\n            result.push(currentNode);\n        }\n    };\n}\nexport class DepGraph {\n    constructor() {\n        this.nodes = {};\n        this.outgoingEdges = {}; // Node -> [Dependency Node]\n        this.incomingEdges = {}; // Node -> [Dependant Node]\n    }\n    /**\n     * Add a node to the dependency graph. If a node already exists, this method will do nothing.\n     */\n    addNode(node, data) {\n        if (!this.hasNode(node)) {\n            // Checking the arguments length allows the user to add a node with undefined data\n            if (arguments.length === 2) {\n                this.nodes[node] = data;\n            }\n            else {\n                this.nodes[node] = node;\n            }\n            this.outgoingEdges[node] = [];\n            this.incomingEdges[node] = [];\n        }\n    }\n    /**\n     * Remove a node from the dependency graph. If a node does not exist, this method will do nothing.\n     */\n    removeNode(node) {\n        if (this.hasNode(node)) {\n            delete this.nodes[node];\n            delete this.outgoingEdges[node];\n            delete this.incomingEdges[node];\n            [this.incomingEdges, this.outgoingEdges].forEach(function (edgeList) {\n                Object.keys(edgeList).forEach(function (key) {\n                    let idx = edgeList[key].indexOf(node);\n                    if (idx >= 0) {\n                        edgeList[key].splice(idx, 1);\n                    }\n                }, this);\n            });\n        }\n    }\n    /**\n     * Check if a node exists in the graph\n     */\n    hasNode(node) {\n        return this.nodes.hasOwnProperty(node);\n    }\n    /**\n     * Get the data associated with a node name\n     */\n    getNodeData(node) {\n        if (this.hasNode(node)) {\n            return this.nodes[node];\n        }\n        else {\n            throw new TypeORMError(`Node does not exist: ${node}`);\n        }\n    }\n    /**\n     * Set the associated data for a given node name. If the node does not exist, this method will throw an error\n     */\n    setNodeData(node, data) {\n        if (this.hasNode(node)) {\n            this.nodes[node] = data;\n        }\n        else {\n            throw new TypeORMError(`Node does not exist: ${node}`);\n        }\n    }\n    /**\n     * Add a dependency between two nodes. If either of the nodes does not exist,\n     * an Error will be thrown.\n     */\n    addDependency(from, to) {\n        if (!this.hasNode(from)) {\n            throw new TypeORMError(`Node does not exist: ${from}`);\n        }\n        if (!this.hasNode(to)) {\n            throw new TypeORMError(`Node does not exist: ${to}`);\n        }\n        if (this.outgoingEdges[from].indexOf(to) === -1) {\n            this.outgoingEdges[from].push(to);\n        }\n        if (this.incomingEdges[to].indexOf(from) === -1) {\n            this.incomingEdges[to].push(from);\n        }\n        return true;\n    }\n    /**\n     * Remove a dependency between two nodes.\n     */\n    removeDependency(from, to) {\n        let idx;\n        if (this.hasNode(from)) {\n            idx = this.outgoingEdges[from].indexOf(to);\n            if (idx >= 0) {\n                this.outgoingEdges[from].splice(idx, 1);\n            }\n        }\n        if (this.hasNode(to)) {\n            idx = this.incomingEdges[to].indexOf(from);\n            if (idx >= 0) {\n                this.incomingEdges[to].splice(idx, 1);\n            }\n        }\n    }\n    /**\n     * Get an array containing the nodes that the specified node depends on (transitively).\n     *\n     * Throws an Error if the graph has a cycle, or the specified node does not exist.\n     *\n     * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned\n     * in the array.\n     */\n    dependenciesOf(node, leavesOnly) {\n        if (this.hasNode(node)) {\n            let result = [];\n            let DFS = createDFS(this.outgoingEdges, leavesOnly, result);\n            DFS(node);\n            let idx = result.indexOf(node);\n            if (idx >= 0) {\n                result.splice(idx, 1);\n            }\n            return result;\n        }\n        else {\n            throw new TypeORMError(`Node does not exist: ${node}`);\n        }\n    }\n    /**\n     * get an array containing the nodes that depend on the specified node (transitively).\n     *\n     * Throws an Error if the graph has a cycle, or the specified node does not exist.\n     *\n     * If `leavesOnly` is true, only nodes that do not have any dependants will be returned in the array.\n     */\n    dependantsOf(node, leavesOnly) {\n        if (this.hasNode(node)) {\n            let result = [];\n            let DFS = createDFS(this.incomingEdges, leavesOnly, result);\n            DFS(node);\n            let idx = result.indexOf(node);\n            if (idx >= 0) {\n                result.splice(idx, 1);\n            }\n            return result;\n        }\n        else {\n            throw new TypeORMError(`Node does not exist: ${node}`);\n        }\n    }\n    /**\n     * Construct the overall processing order for the dependency graph.\n     *\n     * Throws an Error if the graph has a cycle.\n     *\n     * If `leavesOnly` is true, only nodes that do not depend on any other nodes will be returned.\n     */\n    overallOrder(leavesOnly) {\n        let self = this;\n        let result = [];\n        let keys = Object.keys(this.nodes);\n        if (keys.length === 0) {\n            return result; // Empty graph\n        }\n        else {\n            // Look for cycles - we run the DFS starting at all the nodes in case there\n            // are several disconnected subgraphs inside this dependency graph.\n            let CycleDFS = createDFS(this.outgoingEdges, false, []);\n            keys.forEach(function (n) {\n                CycleDFS(n);\n            });\n            let DFS = createDFS(this.outgoingEdges, leavesOnly, result);\n            // Find all potential starting points (nodes with nothing depending on them) an\n            // run a DFS starting at these points to get the order\n            keys.filter(function (node) {\n                return self.incomingEdges[node].length === 0;\n            }).forEach(function (n) {\n                DFS(n);\n            });\n            return result;\n        }\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}