{"ast":null,"code":"import { QueryBuilderUtils } from \"../QueryBuilderUtils\";\nimport { ObjectUtils } from \"../../util/ObjectUtils\";\nimport { TypeORMError } from \"../../error/TypeORMError\";\nexport class RelationCountAttribute {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(expressionMap, relationCountAttribute) {\n    this.expressionMap = expressionMap;\n    ObjectUtils.assign(this, relationCountAttribute || {});\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  get joinInverseSideMetadata() {\n    return this.relation.inverseEntityMetadata;\n  }\n  /**\n   * Alias of the parent of this join.\n   * For example, if we join (\"post.category\", \"categoryAlias\") then \"post\" is a parent alias.\n   * This value is extracted from entityOrProperty value.\n   * This is available when join was made using \"post.category\" syntax.\n   */\n  get parentAlias() {\n    if (!QueryBuilderUtils.isAliasProperty(this.relationName)) throw new TypeORMError(`Given value must be a string representation of alias property`);\n    return this.relationName.split(\".\")[0];\n  }\n  /**\n   * Relation property name of the parent.\n   * This is used to understand what is joined.\n   * For example, if we join (\"post.category\", \"categoryAlias\") then \"category\" is a relation property.\n   * This value is extracted from entityOrProperty value.\n   * This is available when join was made using \"post.category\" syntax.\n   */\n  get relationProperty() {\n    if (!QueryBuilderUtils.isAliasProperty(this.relationName)) throw new TypeORMError(`Given value is a string representation of alias property`);\n    return this.relationName.split(\".\")[1];\n  }\n  get junctionAlias() {\n    const [parentAlias, relationProperty] = this.relationName.split(\".\");\n    return parentAlias + \"_\" + relationProperty + \"_rc\";\n  }\n  /**\n   * Relation of the parent.\n   * This is used to understand what is joined.\n   * This is available when join was made using \"post.category\" syntax.\n   */\n  get relation() {\n    if (!QueryBuilderUtils.isAliasProperty(this.relationName)) throw new TypeORMError(`Given value is a string representation of alias property`);\n    const [parentAlias, propertyPath] = this.relationName.split(\".\");\n    const relationOwnerSelection = this.expressionMap.findAliasByName(parentAlias);\n    const relation = relationOwnerSelection.metadata.findRelationWithPropertyPath(propertyPath);\n    if (!relation) throw new TypeORMError(`Relation with property path ${propertyPath} in entity was not found.`);\n    return relation;\n  }\n  /**\n   * Metadata of the joined entity.\n   * If table without entity was joined, then it will return undefined.\n   */\n  get metadata() {\n    if (!QueryBuilderUtils.isAliasProperty(this.relationName)) throw new TypeORMError(`Given value is a string representation of alias property`);\n    const parentAlias = this.relationName.split(\".\")[0];\n    const selection = this.expressionMap.findAliasByName(parentAlias);\n    return selection.metadata;\n  }\n  get mapToPropertyPropertyName() {\n    return this.mapToProperty.split(\".\")[1];\n  }\n}","map":{"version":3,"names":["QueryBuilderUtils","ObjectUtils","TypeORMError","RelationCountAttribute","constructor","expressionMap","relationCountAttribute","assign","joinInverseSideMetadata","relation","inverseEntityMetadata","parentAlias","isAliasProperty","relationName","split","relationProperty","junctionAlias","propertyPath","relationOwnerSelection","findAliasByName","metadata","findRelationWithPropertyPath","selection","mapToPropertyPropertyName","mapToProperty"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/query-builder/relation-count/RelationCountAttribute.js"],"sourcesContent":["import { QueryBuilderUtils } from \"../QueryBuilderUtils\";\nimport { ObjectUtils } from \"../../util/ObjectUtils\";\nimport { TypeORMError } from \"../../error/TypeORMError\";\nexport class RelationCountAttribute {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n    constructor(expressionMap, relationCountAttribute) {\n        this.expressionMap = expressionMap;\n        ObjectUtils.assign(this, relationCountAttribute || {});\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    get joinInverseSideMetadata() {\n        return this.relation.inverseEntityMetadata;\n    }\n    /**\n     * Alias of the parent of this join.\n     * For example, if we join (\"post.category\", \"categoryAlias\") then \"post\" is a parent alias.\n     * This value is extracted from entityOrProperty value.\n     * This is available when join was made using \"post.category\" syntax.\n     */\n    get parentAlias() {\n        if (!QueryBuilderUtils.isAliasProperty(this.relationName))\n            throw new TypeORMError(`Given value must be a string representation of alias property`);\n        return this.relationName.split(\".\")[0];\n    }\n    /**\n     * Relation property name of the parent.\n     * This is used to understand what is joined.\n     * For example, if we join (\"post.category\", \"categoryAlias\") then \"category\" is a relation property.\n     * This value is extracted from entityOrProperty value.\n     * This is available when join was made using \"post.category\" syntax.\n     */\n    get relationProperty() {\n        if (!QueryBuilderUtils.isAliasProperty(this.relationName))\n            throw new TypeORMError(`Given value is a string representation of alias property`);\n        return this.relationName.split(\".\")[1];\n    }\n    get junctionAlias() {\n        const [parentAlias, relationProperty] = this.relationName.split(\".\");\n        return parentAlias + \"_\" + relationProperty + \"_rc\";\n    }\n    /**\n     * Relation of the parent.\n     * This is used to understand what is joined.\n     * This is available when join was made using \"post.category\" syntax.\n     */\n    get relation() {\n        if (!QueryBuilderUtils.isAliasProperty(this.relationName))\n            throw new TypeORMError(`Given value is a string representation of alias property`);\n        const [parentAlias, propertyPath] = this.relationName.split(\".\");\n        const relationOwnerSelection = this.expressionMap.findAliasByName(parentAlias);\n        const relation = relationOwnerSelection.metadata.findRelationWithPropertyPath(propertyPath);\n        if (!relation)\n            throw new TypeORMError(`Relation with property path ${propertyPath} in entity was not found.`);\n        return relation;\n    }\n    /**\n     * Metadata of the joined entity.\n     * If table without entity was joined, then it will return undefined.\n     */\n    get metadata() {\n        if (!QueryBuilderUtils.isAliasProperty(this.relationName))\n            throw new TypeORMError(`Given value is a string representation of alias property`);\n        const parentAlias = this.relationName.split(\".\")[0];\n        const selection = this.expressionMap.findAliasByName(parentAlias);\n        return selection.metadata;\n    }\n    get mapToPropertyPropertyName() {\n        return this.mapToProperty.split(\".\")[1];\n    }\n}\n\n"],"mappings":"AAAA,SAASA,iBAAiB,QAAQ,sBAAsB;AACxD,SAASC,WAAW,QAAQ,wBAAwB;AACpD,SAASC,YAAY,QAAQ,0BAA0B;AACvD,OAAO,MAAMC,sBAAsB,CAAC;EAChC;EACA;EACA;EACAC,WAAWA,CAACC,aAAa,EAAEC,sBAAsB,EAAE;IAC/C,IAAI,CAACD,aAAa,GAAGA,aAAa;IAClCJ,WAAW,CAACM,MAAM,CAAC,IAAI,EAAED,sBAAsB,IAAI,CAAC,CAAC,CAAC;EAC1D;EACA;EACA;EACA;EACA,IAAIE,uBAAuBA,CAAA,EAAG;IAC1B,OAAO,IAAI,CAACC,QAAQ,CAACC,qBAAqB;EAC9C;EACA;AACJ;AACA;AACA;AACA;AACA;EACI,IAAIC,WAAWA,CAAA,EAAG;IACd,IAAI,CAACX,iBAAiB,CAACY,eAAe,CAAC,IAAI,CAACC,YAAY,CAAC,EACrD,MAAM,IAAIX,YAAY,CAAE,+DAA8D,CAAC;IAC3F,OAAO,IAAI,CAACW,YAAY,CAACC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;EAC1C;EACA;AACJ;AACA;AACA;AACA;AACA;AACA;EACI,IAAIC,gBAAgBA,CAAA,EAAG;IACnB,IAAI,CAACf,iBAAiB,CAACY,eAAe,CAAC,IAAI,CAACC,YAAY,CAAC,EACrD,MAAM,IAAIX,YAAY,CAAE,0DAAyD,CAAC;IACtF,OAAO,IAAI,CAACW,YAAY,CAACC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;EAC1C;EACA,IAAIE,aAAaA,CAAA,EAAG;IAChB,MAAM,CAACL,WAAW,EAAEI,gBAAgB,CAAC,GAAG,IAAI,CAACF,YAAY,CAACC,KAAK,CAAC,GAAG,CAAC;IACpE,OAAOH,WAAW,GAAG,GAAG,GAAGI,gBAAgB,GAAG,KAAK;EACvD;EACA;AACJ;AACA;AACA;AACA;EACI,IAAIN,QAAQA,CAAA,EAAG;IACX,IAAI,CAACT,iBAAiB,CAACY,eAAe,CAAC,IAAI,CAACC,YAAY,CAAC,EACrD,MAAM,IAAIX,YAAY,CAAE,0DAAyD,CAAC;IACtF,MAAM,CAACS,WAAW,EAAEM,YAAY,CAAC,GAAG,IAAI,CAACJ,YAAY,CAACC,KAAK,CAAC,GAAG,CAAC;IAChE,MAAMI,sBAAsB,GAAG,IAAI,CAACb,aAAa,CAACc,eAAe,CAACR,WAAW,CAAC;IAC9E,MAAMF,QAAQ,GAAGS,sBAAsB,CAACE,QAAQ,CAACC,4BAA4B,CAACJ,YAAY,CAAC;IAC3F,IAAI,CAACR,QAAQ,EACT,MAAM,IAAIP,YAAY,CAAE,+BAA8Be,YAAa,2BAA0B,CAAC;IAClG,OAAOR,QAAQ;EACnB;EACA;AACJ;AACA;AACA;EACI,IAAIW,QAAQA,CAAA,EAAG;IACX,IAAI,CAACpB,iBAAiB,CAACY,eAAe,CAAC,IAAI,CAACC,YAAY,CAAC,EACrD,MAAM,IAAIX,YAAY,CAAE,0DAAyD,CAAC;IACtF,MAAMS,WAAW,GAAG,IAAI,CAACE,YAAY,CAACC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;IACnD,MAAMQ,SAAS,GAAG,IAAI,CAACjB,aAAa,CAACc,eAAe,CAACR,WAAW,CAAC;IACjE,OAAOW,SAAS,CAACF,QAAQ;EAC7B;EACA,IAAIG,yBAAyBA,CAAA,EAAG;IAC5B,OAAO,IAAI,CAACC,aAAa,CAACV,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;EAC3C;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}