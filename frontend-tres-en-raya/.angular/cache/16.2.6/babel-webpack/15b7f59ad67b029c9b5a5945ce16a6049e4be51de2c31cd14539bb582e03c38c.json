{"ast":null,"code":"import { DateUtils } from \"../util/DateUtils\";\nimport { OrmUtils } from \"../util/OrmUtils\";\nimport { ApplyValueTransformers } from \"../util/ApplyValueTransformers\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\n/**\n * Finds what columns are changed in the subject entities.\n */\nexport class SubjectChangedColumnsComputer {\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Finds what columns are changed in the subject entities.\n   */\n  compute(subjects) {\n    subjects.forEach(subject => {\n      this.computeDiffColumns(subject);\n      this.computeDiffRelationalColumns(subjects, subject);\n    });\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Differentiate columns from the updated entity and entity stored in the database.\n   */\n  computeDiffColumns(subject) {\n    // if there is no persisted entity then nothing to compute changed in it\n    if (!subject.entity) return;\n    subject.metadata.columns.forEach(column => {\n      // ignore special columns\n      if (column.isVirtual || column.isDiscriminator // ||\n      // column.isUpdateDate ||\n      // column.isVersion ||\n      // column.isCreateDate\n      ) return;\n      const changeMap = subject.changeMaps.find(changeMap => changeMap.column === column);\n      if (changeMap) {\n        subject.changeMaps.splice(subject.changeMaps.indexOf(changeMap), 1);\n      }\n      // get user provided value - column value from the user provided persisted entity\n      const entityValue = column.getEntityValue(subject.entity);\n      // we don't perform operation over undefined properties (but we DO need null properties!)\n      if (entityValue === undefined) return;\n      // if there is no database entity then all columns are treated as new, e.g. changed\n      if (subject.databaseEntity) {\n        // skip transform database value for json / jsonb for comparison later on\n        const shouldTransformDatabaseEntity = column.type !== \"json\" && column.type !== \"jsonb\";\n        // get database value of the column\n        let databaseValue = column.getEntityValue(subject.databaseEntity, shouldTransformDatabaseEntity);\n        // filter out \"relational columns\" only in the case if there is a relation object in entity\n        if (column.relationMetadata) {\n          const value = column.relationMetadata.getEntityValue(subject.entity);\n          if (value !== null && value !== undefined) return;\n        }\n        let normalizedValue = entityValue;\n        // normalize special values to make proper comparision\n        if (entityValue !== null) {\n          switch (column.type) {\n            case \"date\":\n              normalizedValue = DateUtils.mixedDateToDateString(entityValue);\n              break;\n            case \"time\":\n            case \"time with time zone\":\n            case \"time without time zone\":\n            case \"timetz\":\n              normalizedValue = DateUtils.mixedDateToTimeString(entityValue);\n              break;\n            case \"datetime\":\n            case \"datetime2\":\n            case Date:\n            case \"timestamp\":\n            case \"timestamp without time zone\":\n            case \"timestamp with time zone\":\n            case \"timestamp with local time zone\":\n            case \"timestamptz\":\n              normalizedValue = DateUtils.mixedDateToUtcDatetimeString(entityValue);\n              databaseValue = DateUtils.mixedDateToUtcDatetimeString(databaseValue);\n              break;\n            case \"json\":\n            case \"jsonb\":\n              // JSON.stringify doesn't work because postgresql sorts jsonb before save.\n              // If you try to save json '[{\"messages\": \"\", \"attribute Key\": \"\", \"level\":\"\"}] ' as jsonb,\n              // then postgresql will save it as '[{\"level\": \"\", \"message\":\"\", \"attributeKey\": \"\"}]'\n              if (OrmUtils.deepCompare(entityValue, databaseValue)) return;\n              break;\n            case \"simple-array\":\n              normalizedValue = DateUtils.simpleArrayToString(entityValue);\n              databaseValue = DateUtils.simpleArrayToString(databaseValue);\n              break;\n            case \"simple-enum\":\n              normalizedValue = DateUtils.simpleEnumToString(entityValue);\n              databaseValue = DateUtils.simpleEnumToString(databaseValue);\n              break;\n            case \"simple-json\":\n              normalizedValue = DateUtils.simpleJsonToString(entityValue);\n              databaseValue = DateUtils.simpleJsonToString(databaseValue);\n              break;\n          }\n          if (column.transformer) {\n            normalizedValue = ApplyValueTransformers.transformTo(column.transformer, entityValue);\n          }\n        }\n        // if value is not changed - then do nothing\n        if (Buffer.isBuffer(normalizedValue) && Buffer.isBuffer(databaseValue)) {\n          if (normalizedValue.equals(databaseValue)) {\n            return;\n          }\n        } else {\n          if (normalizedValue === databaseValue) return;\n        }\n      }\n      if (!subject.diffColumns.includes(column)) subject.diffColumns.push(column);\n      subject.changeMaps.push({\n        column: column,\n        value: entityValue\n      });\n    });\n  }\n  /**\n   * Difference columns of the owning one-to-one and many-to-one columns.\n   */\n  computeDiffRelationalColumns(allSubjects, subject) {\n    // if there is no persisted entity then nothing to compute changed in it\n    if (!subject.entity) return;\n    subject.metadata.relationsWithJoinColumns.forEach(relation => {\n      // get the related entity from the persisted entity\n      let relatedEntity = relation.getEntityValue(subject.entity);\n      // we don't perform operation over undefined properties (but we DO need null properties!)\n      if (relatedEntity === undefined) return;\n      // if there is no database entity then all relational columns are treated as new, e.g. changed\n      if (subject.databaseEntity) {\n        // here we cover two scenarios:\n        // 1. related entity can be another entity which is natural way\n        // 2. related entity can be just an entity id\n        // if relation entity is just a relation id set (for example post.tag = 1)\n        // then we create an id map from it to make a proper comparision\n        let relatedEntityRelationIdMap = relatedEntity;\n        if (relatedEntityRelationIdMap !== null && ObjectUtils.isObject(relatedEntityRelationIdMap)) relatedEntityRelationIdMap = relation.getRelationIdMap(relatedEntityRelationIdMap);\n        // get database related entity. Since loadRelationIds are used on databaseEntity\n        // related entity will contain only its relation ids\n        const databaseRelatedEntityRelationIdMap = relation.getEntityValue(subject.databaseEntity);\n        // if relation ids are equal then we don't need to update anything\n        const areRelatedIdsEqual = OrmUtils.compareIds(relatedEntityRelationIdMap, databaseRelatedEntityRelationIdMap);\n        if (areRelatedIdsEqual) {\n          return;\n        } else {\n          subject.diffRelations.push(relation);\n        }\n      }\n      // if there is an inserted subject for the related entity of the persisted entity then use it as related entity\n      // this code is used for related entities without ids to be properly inserted (and then updated if needed)\n      const valueSubject = allSubjects.find(subject => subject.mustBeInserted && subject.entity === relatedEntity);\n      if (valueSubject) relatedEntity = valueSubject;\n      // find if there is already a relation to be changed\n      const changeMap = subject.changeMaps.find(changeMap => changeMap.relation === relation);\n      if (changeMap) {\n        // and update its value if it was found\n        changeMap.value = relatedEntity;\n      } else {\n        // if it wasn't found add a new relation for change\n        subject.changeMaps.push({\n          relation: relation,\n          value: relatedEntity\n        });\n      }\n    });\n  }\n}","map":{"version":3,"names":["DateUtils","OrmUtils","ApplyValueTransformers","ObjectUtils","SubjectChangedColumnsComputer","compute","subjects","forEach","subject","computeDiffColumns","computeDiffRelationalColumns","entity","metadata","columns","column","isVirtual","isDiscriminator","changeMap","changeMaps","find","splice","indexOf","entityValue","getEntityValue","undefined","databaseEntity","shouldTransformDatabaseEntity","type","databaseValue","relationMetadata","value","normalizedValue","mixedDateToDateString","mixedDateToTimeString","Date","mixedDateToUtcDatetimeString","deepCompare","simpleArrayToString","simpleEnumToString","simpleJsonToString","transformer","transformTo","Buffer","isBuffer","equals","diffColumns","includes","push","allSubjects","relationsWithJoinColumns","relation","relatedEntity","relatedEntityRelationIdMap","isObject","getRelationIdMap","databaseRelatedEntityRelationIdMap","areRelatedIdsEqual","compareIds","diffRelations","valueSubject","mustBeInserted"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/persistence/SubjectChangedColumnsComputer.js"],"sourcesContent":["import { DateUtils } from \"../util/DateUtils\";\nimport { OrmUtils } from \"../util/OrmUtils\";\nimport { ApplyValueTransformers } from \"../util/ApplyValueTransformers\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\n/**\n * Finds what columns are changed in the subject entities.\n */\nexport class SubjectChangedColumnsComputer {\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Finds what columns are changed in the subject entities.\n     */\n    compute(subjects) {\n        subjects.forEach((subject) => {\n            this.computeDiffColumns(subject);\n            this.computeDiffRelationalColumns(subjects, subject);\n        });\n    }\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Differentiate columns from the updated entity and entity stored in the database.\n     */\n    computeDiffColumns(subject) {\n        // if there is no persisted entity then nothing to compute changed in it\n        if (!subject.entity)\n            return;\n        subject.metadata.columns.forEach((column) => {\n            // ignore special columns\n            if (column.isVirtual ||\n                column.isDiscriminator // ||\n            // column.isUpdateDate ||\n            // column.isVersion ||\n            // column.isCreateDate\n            )\n                return;\n            const changeMap = subject.changeMaps.find((changeMap) => changeMap.column === column);\n            if (changeMap) {\n                subject.changeMaps.splice(subject.changeMaps.indexOf(changeMap), 1);\n            }\n            // get user provided value - column value from the user provided persisted entity\n            const entityValue = column.getEntityValue(subject.entity);\n            // we don't perform operation over undefined properties (but we DO need null properties!)\n            if (entityValue === undefined)\n                return;\n            // if there is no database entity then all columns are treated as new, e.g. changed\n            if (subject.databaseEntity) {\n                // skip transform database value for json / jsonb for comparison later on\n                const shouldTransformDatabaseEntity = column.type !== \"json\" && column.type !== \"jsonb\";\n                // get database value of the column\n                let databaseValue = column.getEntityValue(subject.databaseEntity, shouldTransformDatabaseEntity);\n                // filter out \"relational columns\" only in the case if there is a relation object in entity\n                if (column.relationMetadata) {\n                    const value = column.relationMetadata.getEntityValue(subject.entity);\n                    if (value !== null && value !== undefined)\n                        return;\n                }\n                let normalizedValue = entityValue;\n                // normalize special values to make proper comparision\n                if (entityValue !== null) {\n                    switch (column.type) {\n                        case \"date\":\n                            normalizedValue =\n                                DateUtils.mixedDateToDateString(entityValue);\n                            break;\n                        case \"time\":\n                        case \"time with time zone\":\n                        case \"time without time zone\":\n                        case \"timetz\":\n                            normalizedValue =\n                                DateUtils.mixedDateToTimeString(entityValue);\n                            break;\n                        case \"datetime\":\n                        case \"datetime2\":\n                        case Date:\n                        case \"timestamp\":\n                        case \"timestamp without time zone\":\n                        case \"timestamp with time zone\":\n                        case \"timestamp with local time zone\":\n                        case \"timestamptz\":\n                            normalizedValue =\n                                DateUtils.mixedDateToUtcDatetimeString(entityValue);\n                            databaseValue =\n                                DateUtils.mixedDateToUtcDatetimeString(databaseValue);\n                            break;\n                        case \"json\":\n                        case \"jsonb\":\n                            // JSON.stringify doesn't work because postgresql sorts jsonb before save.\n                            // If you try to save json '[{\"messages\": \"\", \"attribute Key\": \"\", \"level\":\"\"}] ' as jsonb,\n                            // then postgresql will save it as '[{\"level\": \"\", \"message\":\"\", \"attributeKey\": \"\"}]'\n                            if (OrmUtils.deepCompare(entityValue, databaseValue))\n                                return;\n                            break;\n                        case \"simple-array\":\n                            normalizedValue =\n                                DateUtils.simpleArrayToString(entityValue);\n                            databaseValue =\n                                DateUtils.simpleArrayToString(databaseValue);\n                            break;\n                        case \"simple-enum\":\n                            normalizedValue =\n                                DateUtils.simpleEnumToString(entityValue);\n                            databaseValue =\n                                DateUtils.simpleEnumToString(databaseValue);\n                            break;\n                        case \"simple-json\":\n                            normalizedValue =\n                                DateUtils.simpleJsonToString(entityValue);\n                            databaseValue =\n                                DateUtils.simpleJsonToString(databaseValue);\n                            break;\n                    }\n                    if (column.transformer) {\n                        normalizedValue = ApplyValueTransformers.transformTo(column.transformer, entityValue);\n                    }\n                }\n                // if value is not changed - then do nothing\n                if (Buffer.isBuffer(normalizedValue) &&\n                    Buffer.isBuffer(databaseValue)) {\n                    if (normalizedValue.equals(databaseValue)) {\n                        return;\n                    }\n                }\n                else {\n                    if (normalizedValue === databaseValue)\n                        return;\n                }\n            }\n            if (!subject.diffColumns.includes(column))\n                subject.diffColumns.push(column);\n            subject.changeMaps.push({\n                column: column,\n                value: entityValue,\n            });\n        });\n    }\n    /**\n     * Difference columns of the owning one-to-one and many-to-one columns.\n     */\n    computeDiffRelationalColumns(allSubjects, subject) {\n        // if there is no persisted entity then nothing to compute changed in it\n        if (!subject.entity)\n            return;\n        subject.metadata.relationsWithJoinColumns.forEach((relation) => {\n            // get the related entity from the persisted entity\n            let relatedEntity = relation.getEntityValue(subject.entity);\n            // we don't perform operation over undefined properties (but we DO need null properties!)\n            if (relatedEntity === undefined)\n                return;\n            // if there is no database entity then all relational columns are treated as new, e.g. changed\n            if (subject.databaseEntity) {\n                // here we cover two scenarios:\n                // 1. related entity can be another entity which is natural way\n                // 2. related entity can be just an entity id\n                // if relation entity is just a relation id set (for example post.tag = 1)\n                // then we create an id map from it to make a proper comparision\n                let relatedEntityRelationIdMap = relatedEntity;\n                if (relatedEntityRelationIdMap !== null &&\n                    ObjectUtils.isObject(relatedEntityRelationIdMap))\n                    relatedEntityRelationIdMap = relation.getRelationIdMap(relatedEntityRelationIdMap);\n                // get database related entity. Since loadRelationIds are used on databaseEntity\n                // related entity will contain only its relation ids\n                const databaseRelatedEntityRelationIdMap = relation.getEntityValue(subject.databaseEntity);\n                // if relation ids are equal then we don't need to update anything\n                const areRelatedIdsEqual = OrmUtils.compareIds(relatedEntityRelationIdMap, databaseRelatedEntityRelationIdMap);\n                if (areRelatedIdsEqual) {\n                    return;\n                }\n                else {\n                    subject.diffRelations.push(relation);\n                }\n            }\n            // if there is an inserted subject for the related entity of the persisted entity then use it as related entity\n            // this code is used for related entities without ids to be properly inserted (and then updated if needed)\n            const valueSubject = allSubjects.find((subject) => subject.mustBeInserted && subject.entity === relatedEntity);\n            if (valueSubject)\n                relatedEntity = valueSubject;\n            // find if there is already a relation to be changed\n            const changeMap = subject.changeMaps.find((changeMap) => changeMap.relation === relation);\n            if (changeMap) {\n                // and update its value if it was found\n                changeMap.value = relatedEntity;\n            }\n            else {\n                // if it wasn't found add a new relation for change\n                subject.changeMaps.push({\n                    relation: relation,\n                    value: relatedEntity,\n                });\n            }\n        });\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}