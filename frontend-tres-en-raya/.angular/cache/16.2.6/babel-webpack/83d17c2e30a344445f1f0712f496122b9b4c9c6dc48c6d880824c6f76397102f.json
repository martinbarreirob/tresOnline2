{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/practicas/Downloads/angular/tresOnline/frontend-tres-en-raya/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { DriverUtils } from \"../../driver/DriverUtils\";\nimport { TypeORMError } from \"../../error/TypeORMError\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\nexport class RelationIdLoader {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection, queryRunner, relationIdAttributes) {\n    this.connection = connection;\n    this.queryRunner = queryRunner;\n    this.relationIdAttributes = relationIdAttributes;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  load(rawEntities) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const promises = _this.relationIdAttributes.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (relationIdAttr) {\n          if (relationIdAttr.relation.isManyToOne || relationIdAttr.relation.isOneToOneOwner) {\n            // example: Post and Tag\n            // loadRelationIdAndMap(\"post.tagId\", \"post.tag\")\n            // we expect it to load id of tag\n            if (relationIdAttr.queryBuilderFactory) throw new TypeORMError(\"Additional condition can not be used with ManyToOne or OneToOne owner relations.\");\n            const duplicates = {};\n            const results = rawEntities.map(rawEntity => {\n              const result = {};\n              const duplicateParts = [];\n              relationIdAttr.relation.joinColumns.forEach(joinColumn => {\n                result[joinColumn.databaseName] = _this.connection.driver.prepareHydratedValue(rawEntity[DriverUtils.buildAlias(_this.connection.driver, undefined, relationIdAttr.parentAlias, joinColumn.databaseName)], joinColumn.referencedColumn);\n                const duplicatePart = `${joinColumn.databaseName}:${result[joinColumn.databaseName]}`;\n                if (duplicateParts.indexOf(duplicatePart) === -1) {\n                  duplicateParts.push(duplicatePart);\n                }\n              });\n              relationIdAttr.relation.entityMetadata.primaryColumns.forEach(primaryColumn => {\n                result[primaryColumn.databaseName] = _this.connection.driver.prepareHydratedValue(rawEntity[DriverUtils.buildAlias(_this.connection.driver, undefined, relationIdAttr.parentAlias, primaryColumn.databaseName)], primaryColumn);\n                const duplicatePart = `${primaryColumn.databaseName}:${result[primaryColumn.databaseName]}`;\n                if (duplicateParts.indexOf(duplicatePart) === -1) {\n                  duplicateParts.push(duplicatePart);\n                }\n              });\n              duplicateParts.sort();\n              const duplicate = duplicateParts.join(\"::\");\n              if (duplicates[duplicate]) {\n                return null;\n              }\n              duplicates[duplicate] = true;\n              return result;\n            }).filter(v => v);\n            return {\n              relationIdAttribute: relationIdAttr,\n              results: results\n            };\n          } else if (relationIdAttr.relation.isOneToMany || relationIdAttr.relation.isOneToOneNotOwner) {\n            // example: Post and Category\n            // loadRelationIdAndMap(\"post.categoryIds\", \"post.categories\")\n            // we expect it to load array of category ids\n            const relation = relationIdAttr.relation; // \"post.categories\"\n            const joinColumns = relation.isOwning ? relation.joinColumns : relation.inverseRelation.joinColumns;\n            const table = relation.inverseEntityMetadata.target; // category\n            const tableName = relation.inverseEntityMetadata.tableName; // category\n            const tableAlias = relationIdAttr.alias || tableName; // if condition (custom query builder factory) is set then relationIdAttr.alias defined\n            const duplicates = {};\n            const parameters = {};\n            const condition = rawEntities.map((rawEntity, index) => {\n              const duplicateParts = [];\n              const parameterParts = {};\n              const queryPart = joinColumns.map(joinColumn => {\n                const parameterName = joinColumn.databaseName + index;\n                const parameterValue = rawEntity[DriverUtils.buildAlias(_this.connection.driver, undefined, relationIdAttr.parentAlias, joinColumn.referencedColumn.databaseName)];\n                const duplicatePart = `${tableAlias}:${joinColumn.propertyPath}:${parameterValue}`;\n                if (duplicateParts.indexOf(duplicatePart) !== -1) {\n                  return \"\";\n                }\n                duplicateParts.push(duplicatePart);\n                parameterParts[parameterName] = parameterValue;\n                return tableAlias + \".\" + joinColumn.propertyPath + \" = :\" + parameterName;\n              }).filter(v => v).join(\" AND \");\n              duplicateParts.sort();\n              const duplicate = duplicateParts.join(\"::\");\n              if (duplicates[duplicate]) {\n                return \"\";\n              }\n              duplicates[duplicate] = true;\n              Object.assign(parameters, parameterParts);\n              return queryPart;\n            }).filter(v => v).map(condition => \"(\" + condition + \")\").join(\" OR \");\n            // ensure we won't perform redundant queries for joined data which was not found in selection\n            // example: if post.category was not found in db then no need to execute query for category.imageIds\n            if (!condition) return {\n              relationIdAttribute: relationIdAttr,\n              results: []\n            };\n            // generate query:\n            // SELECT category.id, category.postId FROM category category ON category.postId = :postId\n            const qb = _this.connection.createQueryBuilder(_this.queryRunner);\n            const columns = OrmUtils.uniq([...joinColumns, ...relation.inverseRelation.entityMetadata.primaryColumns], column => column.propertyPath);\n            columns.forEach(joinColumn => {\n              qb.addSelect(tableAlias + \".\" + joinColumn.propertyPath, joinColumn.databaseName);\n            });\n            qb.from(table, tableAlias).where(\"(\" + condition + \")\") // need brackets because if we have additional condition and no brackets, it looks like (a = 1) OR (a = 2) AND b = 1, that is incorrect\n            .setParameters(parameters);\n            // apply condition (custom query builder factory)\n            if (relationIdAttr.queryBuilderFactory) relationIdAttr.queryBuilderFactory(qb);\n            const results = yield qb.getRawMany();\n            results.forEach(result => {\n              joinColumns.forEach(column => {\n                result[column.databaseName] = _this.connection.driver.prepareHydratedValue(result[column.databaseName], column.referencedColumn);\n              });\n              relation.inverseRelation.entityMetadata.primaryColumns.forEach(column => {\n                result[column.databaseName] = _this.connection.driver.prepareHydratedValue(result[column.databaseName], column);\n              });\n            });\n            return {\n              relationIdAttribute: relationIdAttr,\n              results\n            };\n          } else {\n            // many-to-many\n            // example: Post and Category\n            // owner side: loadRelationIdAndMap(\"post.categoryIds\", \"post.categories\")\n            // inverse side: loadRelationIdAndMap(\"category.postIds\", \"category.posts\")\n            // we expect it to load array of post ids\n            const relation = relationIdAttr.relation;\n            const joinColumns = relation.isOwning ? relation.joinColumns : relation.inverseRelation.inverseJoinColumns;\n            const inverseJoinColumns = relation.isOwning ? relation.inverseJoinColumns : relation.inverseRelation.joinColumns;\n            const junctionAlias = relationIdAttr.junctionAlias;\n            const inverseSideTableName = relationIdAttr.joinInverseSideMetadata.tableName;\n            const inverseSideTableAlias = relationIdAttr.alias || inverseSideTableName;\n            const junctionTableName = relation.isOwning ? relation.junctionEntityMetadata.tableName : relation.inverseRelation.junctionEntityMetadata.tableName;\n            const mappedColumns = rawEntities.map(rawEntity => {\n              return joinColumns.reduce((map, joinColumn) => {\n                map[joinColumn.propertyPath] = rawEntity[DriverUtils.buildAlias(_this.connection.driver, undefined, relationIdAttr.parentAlias, joinColumn.referencedColumn.databaseName)];\n                return map;\n              }, {});\n            });\n            // ensure we won't perform redundant queries for joined data which was not found in selection\n            // example: if post.category was not found in db then no need to execute query for category.imageIds\n            if (mappedColumns.length === 0) return {\n              relationIdAttribute: relationIdAttr,\n              results: []\n            };\n            const parameters = {};\n            const duplicates = {};\n            const joinColumnConditions = mappedColumns.map((mappedColumn, index) => {\n              const duplicateParts = [];\n              const parameterParts = {};\n              const queryPart = Object.keys(mappedColumn).map(key => {\n                const parameterName = key + index;\n                const parameterValue = mappedColumn[key];\n                const duplicatePart = `${junctionAlias}:${key}:${parameterValue}`;\n                if (duplicateParts.indexOf(duplicatePart) !== -1) {\n                  return \"\";\n                }\n                duplicateParts.push(duplicatePart);\n                parameterParts[parameterName] = parameterValue;\n                return junctionAlias + \".\" + key + \" = :\" + parameterName;\n              }).filter(s => s).join(\" AND \");\n              duplicateParts.sort();\n              const duplicate = duplicateParts.join(\"::\");\n              if (duplicates[duplicate]) {\n                return \"\";\n              }\n              duplicates[duplicate] = true;\n              Object.assign(parameters, parameterParts);\n              return queryPart;\n            }).filter(s => s);\n            const inverseJoinColumnCondition = inverseJoinColumns.map(joinColumn => {\n              return junctionAlias + \".\" + joinColumn.propertyPath + \" = \" + inverseSideTableAlias + \".\" + joinColumn.referencedColumn.propertyPath;\n            }).join(\" AND \");\n            const condition = joinColumnConditions.map(condition => {\n              return \"(\" + condition + \" AND \" + inverseJoinColumnCondition + \")\";\n            }).join(\" OR \");\n            const qb = _this.connection.createQueryBuilder(_this.queryRunner);\n            inverseJoinColumns.forEach(joinColumn => {\n              qb.addSelect(junctionAlias + \".\" + joinColumn.propertyPath, joinColumn.databaseName).addOrderBy(junctionAlias + \".\" + joinColumn.propertyPath);\n            });\n            joinColumns.forEach(joinColumn => {\n              qb.addSelect(junctionAlias + \".\" + joinColumn.propertyPath, joinColumn.databaseName).addOrderBy(junctionAlias + \".\" + joinColumn.propertyPath);\n            });\n            qb.from(inverseSideTableName, inverseSideTableAlias).innerJoin(junctionTableName, junctionAlias, condition).setParameters(parameters);\n            // apply condition (custom query builder factory)\n            if (relationIdAttr.queryBuilderFactory) relationIdAttr.queryBuilderFactory(qb);\n            const results = yield qb.getRawMany();\n            results.forEach(result => {\n              ;\n              [...joinColumns, ...inverseJoinColumns].forEach(column => {\n                result[column.databaseName] = _this.connection.driver.prepareHydratedValue(result[column.databaseName], column.referencedColumn);\n              });\n            });\n            return {\n              relationIdAttribute: relationIdAttr,\n              results\n            };\n          }\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }());\n      return Promise.all(promises);\n    })();\n  }\n}","map":{"version":3,"names":["DriverUtils","TypeORMError","OrmUtils","RelationIdLoader","constructor","connection","queryRunner","relationIdAttributes","load","rawEntities","_this","_asyncToGenerator","promises","map","_ref","relationIdAttr","relation","isManyToOne","isOneToOneOwner","queryBuilderFactory","duplicates","results","rawEntity","result","duplicateParts","joinColumns","forEach","joinColumn","databaseName","driver","prepareHydratedValue","buildAlias","undefined","parentAlias","referencedColumn","duplicatePart","indexOf","push","entityMetadata","primaryColumns","primaryColumn","sort","duplicate","join","filter","v","relationIdAttribute","isOneToMany","isOneToOneNotOwner","isOwning","inverseRelation","table","inverseEntityMetadata","target","tableName","tableAlias","alias","parameters","condition","index","parameterParts","queryPart","parameterName","parameterValue","propertyPath","Object","assign","qb","createQueryBuilder","columns","uniq","column","addSelect","from","where","setParameters","getRawMany","inverseJoinColumns","junctionAlias","inverseSideTableName","joinInverseSideMetadata","inverseSideTableAlias","junctionTableName","junctionEntityMetadata","mappedColumns","reduce","length","joinColumnConditions","mappedColumn","keys","key","s","inverseJoinColumnCondition","addOrderBy","innerJoin","_x","apply","arguments","Promise","all"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/query-builder/relation-id/RelationIdLoader.js"],"sourcesContent":["import { DriverUtils } from \"../../driver/DriverUtils\";\nimport { TypeORMError } from \"../../error/TypeORMError\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\nexport class RelationIdLoader {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n    constructor(connection, queryRunner, relationIdAttributes) {\n        this.connection = connection;\n        this.queryRunner = queryRunner;\n        this.relationIdAttributes = relationIdAttributes;\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    async load(rawEntities) {\n        const promises = this.relationIdAttributes.map(async (relationIdAttr) => {\n            if (relationIdAttr.relation.isManyToOne ||\n                relationIdAttr.relation.isOneToOneOwner) {\n                // example: Post and Tag\n                // loadRelationIdAndMap(\"post.tagId\", \"post.tag\")\n                // we expect it to load id of tag\n                if (relationIdAttr.queryBuilderFactory)\n                    throw new TypeORMError(\"Additional condition can not be used with ManyToOne or OneToOne owner relations.\");\n                const duplicates = {};\n                const results = rawEntities\n                    .map((rawEntity) => {\n                    const result = {};\n                    const duplicateParts = [];\n                    relationIdAttr.relation.joinColumns.forEach((joinColumn) => {\n                        result[joinColumn.databaseName] =\n                            this.connection.driver.prepareHydratedValue(rawEntity[DriverUtils.buildAlias(this.connection.driver, undefined, relationIdAttr.parentAlias, joinColumn.databaseName)], joinColumn.referencedColumn);\n                        const duplicatePart = `${joinColumn.databaseName}:${result[joinColumn.databaseName]}`;\n                        if (duplicateParts.indexOf(duplicatePart) === -1) {\n                            duplicateParts.push(duplicatePart);\n                        }\n                    });\n                    relationIdAttr.relation.entityMetadata.primaryColumns.forEach((primaryColumn) => {\n                        result[primaryColumn.databaseName] =\n                            this.connection.driver.prepareHydratedValue(rawEntity[DriverUtils.buildAlias(this.connection.driver, undefined, relationIdAttr.parentAlias, primaryColumn.databaseName)], primaryColumn);\n                        const duplicatePart = `${primaryColumn.databaseName}:${result[primaryColumn.databaseName]}`;\n                        if (duplicateParts.indexOf(duplicatePart) === -1) {\n                            duplicateParts.push(duplicatePart);\n                        }\n                    });\n                    duplicateParts.sort();\n                    const duplicate = duplicateParts.join(\"::\");\n                    if (duplicates[duplicate]) {\n                        return null;\n                    }\n                    duplicates[duplicate] = true;\n                    return result;\n                })\n                    .filter((v) => v);\n                return {\n                    relationIdAttribute: relationIdAttr,\n                    results: results,\n                };\n            }\n            else if (relationIdAttr.relation.isOneToMany ||\n                relationIdAttr.relation.isOneToOneNotOwner) {\n                // example: Post and Category\n                // loadRelationIdAndMap(\"post.categoryIds\", \"post.categories\")\n                // we expect it to load array of category ids\n                const relation = relationIdAttr.relation; // \"post.categories\"\n                const joinColumns = relation.isOwning\n                    ? relation.joinColumns\n                    : relation.inverseRelation.joinColumns;\n                const table = relation.inverseEntityMetadata.target; // category\n                const tableName = relation.inverseEntityMetadata.tableName; // category\n                const tableAlias = relationIdAttr.alias || tableName; // if condition (custom query builder factory) is set then relationIdAttr.alias defined\n                const duplicates = {};\n                const parameters = {};\n                const condition = rawEntities\n                    .map((rawEntity, index) => {\n                    const duplicateParts = [];\n                    const parameterParts = {};\n                    const queryPart = joinColumns\n                        .map((joinColumn) => {\n                        const parameterName = joinColumn.databaseName + index;\n                        const parameterValue = rawEntity[DriverUtils.buildAlias(this.connection.driver, undefined, relationIdAttr.parentAlias, joinColumn.referencedColumn\n                            .databaseName)];\n                        const duplicatePart = `${tableAlias}:${joinColumn.propertyPath}:${parameterValue}`;\n                        if (duplicateParts.indexOf(duplicatePart) !== -1) {\n                            return \"\";\n                        }\n                        duplicateParts.push(duplicatePart);\n                        parameterParts[parameterName] =\n                            parameterValue;\n                        return (tableAlias +\n                            \".\" +\n                            joinColumn.propertyPath +\n                            \" = :\" +\n                            parameterName);\n                    })\n                        .filter((v) => v)\n                        .join(\" AND \");\n                    duplicateParts.sort();\n                    const duplicate = duplicateParts.join(\"::\");\n                    if (duplicates[duplicate]) {\n                        return \"\";\n                    }\n                    duplicates[duplicate] = true;\n                    Object.assign(parameters, parameterParts);\n                    return queryPart;\n                })\n                    .filter((v) => v)\n                    .map((condition) => \"(\" + condition + \")\")\n                    .join(\" OR \");\n                // ensure we won't perform redundant queries for joined data which was not found in selection\n                // example: if post.category was not found in db then no need to execute query for category.imageIds\n                if (!condition)\n                    return {\n                        relationIdAttribute: relationIdAttr,\n                        results: [],\n                    };\n                // generate query:\n                // SELECT category.id, category.postId FROM category category ON category.postId = :postId\n                const qb = this.connection.createQueryBuilder(this.queryRunner);\n                const columns = OrmUtils.uniq([\n                    ...joinColumns,\n                    ...relation.inverseRelation.entityMetadata\n                        .primaryColumns,\n                ], (column) => column.propertyPath);\n                columns.forEach((joinColumn) => {\n                    qb.addSelect(tableAlias + \".\" + joinColumn.propertyPath, joinColumn.databaseName);\n                });\n                qb.from(table, tableAlias)\n                    .where(\"(\" + condition + \")\") // need brackets because if we have additional condition and no brackets, it looks like (a = 1) OR (a = 2) AND b = 1, that is incorrect\n                    .setParameters(parameters);\n                // apply condition (custom query builder factory)\n                if (relationIdAttr.queryBuilderFactory)\n                    relationIdAttr.queryBuilderFactory(qb);\n                const results = await qb.getRawMany();\n                results.forEach((result) => {\n                    joinColumns.forEach((column) => {\n                        result[column.databaseName] =\n                            this.connection.driver.prepareHydratedValue(result[column.databaseName], column.referencedColumn);\n                    });\n                    relation.inverseRelation.entityMetadata.primaryColumns.forEach((column) => {\n                        result[column.databaseName] =\n                            this.connection.driver.prepareHydratedValue(result[column.databaseName], column);\n                    });\n                });\n                return {\n                    relationIdAttribute: relationIdAttr,\n                    results,\n                };\n            }\n            else {\n                // many-to-many\n                // example: Post and Category\n                // owner side: loadRelationIdAndMap(\"post.categoryIds\", \"post.categories\")\n                // inverse side: loadRelationIdAndMap(\"category.postIds\", \"category.posts\")\n                // we expect it to load array of post ids\n                const relation = relationIdAttr.relation;\n                const joinColumns = relation.isOwning\n                    ? relation.joinColumns\n                    : relation.inverseRelation.inverseJoinColumns;\n                const inverseJoinColumns = relation.isOwning\n                    ? relation.inverseJoinColumns\n                    : relation.inverseRelation.joinColumns;\n                const junctionAlias = relationIdAttr.junctionAlias;\n                const inverseSideTableName = relationIdAttr.joinInverseSideMetadata.tableName;\n                const inverseSideTableAlias = relationIdAttr.alias || inverseSideTableName;\n                const junctionTableName = relation.isOwning\n                    ? relation.junctionEntityMetadata.tableName\n                    : relation.inverseRelation.junctionEntityMetadata\n                        .tableName;\n                const mappedColumns = rawEntities.map((rawEntity) => {\n                    return joinColumns.reduce((map, joinColumn) => {\n                        map[joinColumn.propertyPath] =\n                            rawEntity[DriverUtils.buildAlias(this.connection.driver, undefined, relationIdAttr.parentAlias, joinColumn.referencedColumn\n                                .databaseName)];\n                        return map;\n                    }, {});\n                });\n                // ensure we won't perform redundant queries for joined data which was not found in selection\n                // example: if post.category was not found in db then no need to execute query for category.imageIds\n                if (mappedColumns.length === 0)\n                    return {\n                        relationIdAttribute: relationIdAttr,\n                        results: [],\n                    };\n                const parameters = {};\n                const duplicates = {};\n                const joinColumnConditions = mappedColumns\n                    .map((mappedColumn, index) => {\n                    const duplicateParts = [];\n                    const parameterParts = {};\n                    const queryPart = Object.keys(mappedColumn)\n                        .map((key) => {\n                        const parameterName = key + index;\n                        const parameterValue = mappedColumn[key];\n                        const duplicatePart = `${junctionAlias}:${key}:${parameterValue}`;\n                        if (duplicateParts.indexOf(duplicatePart) !== -1) {\n                            return \"\";\n                        }\n                        duplicateParts.push(duplicatePart);\n                        parameterParts[parameterName] =\n                            parameterValue;\n                        return (junctionAlias +\n                            \".\" +\n                            key +\n                            \" = :\" +\n                            parameterName);\n                    })\n                        .filter((s) => s)\n                        .join(\" AND \");\n                    duplicateParts.sort();\n                    const duplicate = duplicateParts.join(\"::\");\n                    if (duplicates[duplicate]) {\n                        return \"\";\n                    }\n                    duplicates[duplicate] = true;\n                    Object.assign(parameters, parameterParts);\n                    return queryPart;\n                })\n                    .filter((s) => s);\n                const inverseJoinColumnCondition = inverseJoinColumns\n                    .map((joinColumn) => {\n                    return (junctionAlias +\n                        \".\" +\n                        joinColumn.propertyPath +\n                        \" = \" +\n                        inverseSideTableAlias +\n                        \".\" +\n                        joinColumn.referencedColumn.propertyPath);\n                })\n                    .join(\" AND \");\n                const condition = joinColumnConditions\n                    .map((condition) => {\n                    return (\"(\" +\n                        condition +\n                        \" AND \" +\n                        inverseJoinColumnCondition +\n                        \")\");\n                })\n                    .join(\" OR \");\n                const qb = this.connection.createQueryBuilder(this.queryRunner);\n                inverseJoinColumns.forEach((joinColumn) => {\n                    qb.addSelect(junctionAlias + \".\" + joinColumn.propertyPath, joinColumn.databaseName).addOrderBy(junctionAlias + \".\" + joinColumn.propertyPath);\n                });\n                joinColumns.forEach((joinColumn) => {\n                    qb.addSelect(junctionAlias + \".\" + joinColumn.propertyPath, joinColumn.databaseName).addOrderBy(junctionAlias + \".\" + joinColumn.propertyPath);\n                });\n                qb.from(inverseSideTableName, inverseSideTableAlias)\n                    .innerJoin(junctionTableName, junctionAlias, condition)\n                    .setParameters(parameters);\n                // apply condition (custom query builder factory)\n                if (relationIdAttr.queryBuilderFactory)\n                    relationIdAttr.queryBuilderFactory(qb);\n                const results = await qb.getRawMany();\n                results.forEach((result) => {\n                    ;\n                    [...joinColumns, ...inverseJoinColumns].forEach((column) => {\n                        result[column.databaseName] =\n                            this.connection.driver.prepareHydratedValue(result[column.databaseName], column.referencedColumn);\n                    });\n                });\n                return {\n                    relationIdAttribute: relationIdAttr,\n                    results,\n                };\n            }\n        });\n        return Promise.all(promises);\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}