{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/practicas/Downloads/angular/tresOnline/frontend-tres-en-raya/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { SubjectTopoligicalSorter } from \"./SubjectTopoligicalSorter\";\nimport { SubjectChangedColumnsComputer } from \"./SubjectChangedColumnsComputer\";\nimport { SubjectWithoutIdentifierError } from \"../error/SubjectWithoutIdentifierError\";\nimport { SubjectRemovedAndUpdatedError } from \"../error/SubjectRemovedAndUpdatedError\";\nimport { BroadcasterResult } from \"../subscriber/BroadcasterResult\";\nimport { NestedSetSubjectExecutor } from \"./tree/NestedSetSubjectExecutor\";\nimport { ClosureSubjectExecutor } from \"./tree/ClosureSubjectExecutor\";\nimport { MaterializedPathSubjectExecutor } from \"./tree/MaterializedPathSubjectExecutor\";\nimport { OrmUtils } from \"../util/OrmUtils\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\n/**\n * Executes all database operations (inserts, updated, deletes) that must be executed\n * with given persistence subjects.\n */\nexport class SubjectExecutor {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(queryRunner, subjects, options) {\n    // -------------------------------------------------------------------------\n    // Public Properties\n    // -------------------------------------------------------------------------\n    /**\n     * Indicates if executor has any operations to execute (e.g. has insert / update / delete operations to be executed).\n     */\n    this.hasExecutableOperations = false;\n    /**\n     * Subjects that must be inserted.\n     */\n    this.insertSubjects = [];\n    /**\n     * Subjects that must be updated.\n     */\n    this.updateSubjects = [];\n    /**\n     * Subjects that must be removed.\n     */\n    this.removeSubjects = [];\n    /**\n     * Subjects that must be soft-removed.\n     */\n    this.softRemoveSubjects = [];\n    /**\n     * Subjects that must be recovered.\n     */\n    this.recoverSubjects = [];\n    this.queryRunner = queryRunner;\n    this.allSubjects = subjects;\n    this.options = options;\n    this.validate();\n    this.recompute();\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Executes all operations over given array of subjects.\n   * Executes queries using given query runner.\n   */\n  execute() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      // console.time(\"SubjectExecutor.execute\");\n      // broadcast \"before\" events before we start insert / update / remove operations\n      let broadcasterResult = undefined;\n      if (!_this.options || _this.options.listeners !== false) {\n        // console.time(\".broadcastBeforeEventsForAll\");\n        broadcasterResult = _this.broadcastBeforeEventsForAll();\n        if (broadcasterResult.promises.length > 0) yield Promise.all(broadcasterResult.promises);\n        // console.timeEnd(\".broadcastBeforeEventsForAll\");\n      }\n      // since event listeners and subscribers can call save methods and/or trigger entity changes we need to recompute operational subjects\n      // recompute only in the case if any listener or subscriber was really executed\n      if (broadcasterResult && broadcasterResult.count > 0) {\n        // console.time(\".recompute\");\n        _this.insertSubjects.forEach(subject => subject.recompute());\n        _this.updateSubjects.forEach(subject => subject.recompute());\n        _this.removeSubjects.forEach(subject => subject.recompute());\n        _this.softRemoveSubjects.forEach(subject => subject.recompute());\n        _this.recoverSubjects.forEach(subject => subject.recompute());\n        _this.recompute();\n        // console.timeEnd(\".recompute\");\n      }\n      // make sure our insert subjects are sorted (using topological sorting) to make cascade inserts work properly\n      // console.timeEnd(\"prepare\");\n      // execute all insert operations\n      // console.time(\".insertion\");\n      _this.insertSubjects = new SubjectTopoligicalSorter(_this.insertSubjects).sort(\"insert\");\n      yield _this.executeInsertOperations();\n      // console.timeEnd(\".insertion\");\n      // recompute update operations since insertion can create updation operations for the\n      // properties it wasn't able to handle on its own (referenced columns)\n      _this.updateSubjects = _this.allSubjects.filter(subject => subject.mustBeUpdated);\n      // execute update operations\n      // console.time(\".updation\");\n      yield _this.executeUpdateOperations();\n      // console.timeEnd(\".updation\");\n      // make sure our remove subjects are sorted (using topological sorting) when multiple entities are passed for the removal\n      // console.time(\".removal\");\n      _this.removeSubjects = new SubjectTopoligicalSorter(_this.removeSubjects).sort(\"delete\");\n      yield _this.executeRemoveOperations();\n      // console.timeEnd(\".removal\");\n      // recompute soft-remove operations\n      _this.softRemoveSubjects = _this.allSubjects.filter(subject => subject.mustBeSoftRemoved);\n      // execute soft-remove operations\n      yield _this.executeSoftRemoveOperations();\n      // recompute recover operations\n      _this.recoverSubjects = _this.allSubjects.filter(subject => subject.mustBeRecovered);\n      // execute recover operations\n      yield _this.executeRecoverOperations();\n      // update all special columns in persisted entities, like inserted id or remove ids from the removed entities\n      // console.time(\".updateSpecialColumnsInPersistedEntities\");\n      yield _this.updateSpecialColumnsInPersistedEntities();\n      // console.timeEnd(\".updateSpecialColumnsInPersistedEntities\");\n      // finally broadcast \"after\" events after we finish insert / update / remove operations\n      if (!_this.options || _this.options.listeners !== false) {\n        // console.time(\".broadcastAfterEventsForAll\");\n        broadcasterResult = _this.broadcastAfterEventsForAll();\n        if (broadcasterResult.promises.length > 0) yield Promise.all(broadcasterResult.promises);\n        // console.timeEnd(\".broadcastAfterEventsForAll\");\n      }\n      // console.timeEnd(\"SubjectExecutor.execute\");\n    })();\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Validates all given subjects.\n   */\n  validate() {\n    this.allSubjects.forEach(subject => {\n      if (subject.mustBeUpdated && subject.mustBeRemoved) throw new SubjectRemovedAndUpdatedError(subject);\n    });\n  }\n  /**\n   * Performs entity re-computations - finds changed columns, re-builds insert/update/remove subjects.\n   */\n  recompute() {\n    new SubjectChangedColumnsComputer().compute(this.allSubjects);\n    this.insertSubjects = this.allSubjects.filter(subject => subject.mustBeInserted);\n    this.updateSubjects = this.allSubjects.filter(subject => subject.mustBeUpdated);\n    this.removeSubjects = this.allSubjects.filter(subject => subject.mustBeRemoved);\n    this.softRemoveSubjects = this.allSubjects.filter(subject => subject.mustBeSoftRemoved);\n    this.recoverSubjects = this.allSubjects.filter(subject => subject.mustBeRecovered);\n    this.hasExecutableOperations = this.insertSubjects.length > 0 || this.updateSubjects.length > 0 || this.removeSubjects.length > 0 || this.softRemoveSubjects.length > 0 || this.recoverSubjects.length > 0;\n  }\n  /**\n   * Broadcasts \"BEFORE_INSERT\", \"BEFORE_UPDATE\", \"BEFORE_REMOVE\", \"BEFORE_SOFT_REMOVE\", \"BEFORE_RECOVER\" events for all given subjects.\n   */\n  broadcastBeforeEventsForAll() {\n    const result = new BroadcasterResult();\n    if (this.insertSubjects.length) this.insertSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastBeforeInsertEvent(result, subject.metadata, subject.entity));\n    if (this.updateSubjects.length) this.updateSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastBeforeUpdateEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.diffColumns, subject.diffRelations));\n    if (this.removeSubjects.length) this.removeSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastBeforeRemoveEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.identifier));\n    if (this.softRemoveSubjects.length) this.softRemoveSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastBeforeSoftRemoveEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.identifier));\n    if (this.recoverSubjects.length) this.recoverSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastBeforeRecoverEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.identifier));\n    return result;\n  }\n  /**\n   * Broadcasts \"AFTER_INSERT\", \"AFTER_UPDATE\", \"AFTER_REMOVE\", \"AFTER_SOFT_REMOVE\", \"AFTER_RECOVER\" events for all given subjects.\n   * Returns void if there wasn't any listener or subscriber executed.\n   * Note: this method has a performance-optimized code organization.\n   */\n  broadcastAfterEventsForAll() {\n    const result = new BroadcasterResult();\n    if (this.insertSubjects.length) this.insertSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastAfterInsertEvent(result, subject.metadata, subject.entity));\n    if (this.updateSubjects.length) this.updateSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastAfterUpdateEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.diffColumns, subject.diffRelations));\n    if (this.removeSubjects.length) this.removeSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastAfterRemoveEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.identifier));\n    if (this.softRemoveSubjects.length) this.softRemoveSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastAfterSoftRemoveEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.identifier));\n    if (this.recoverSubjects.length) this.recoverSubjects.forEach(subject => this.queryRunner.broadcaster.broadcastAfterRecoverEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.identifier));\n    return result;\n  }\n  /**\n   * Executes insert operations.\n   */\n  executeInsertOperations() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      // group insertion subjects to make bulk insertions\n      const [groupedInsertSubjects, groupedInsertSubjectKeys] = _this2.groupBulkSubjects(_this2.insertSubjects, \"insert\");\n      // then we run insertion in the sequential order which is important since we have an ordered subjects\n      for (const groupName of groupedInsertSubjectKeys) {\n        const subjects = groupedInsertSubjects[groupName];\n        // we must separately insert entities which does not have any values to insert\n        // because its not possible to insert multiple entities with only default values in bulk\n        const bulkInsertMaps = [];\n        const bulkInsertSubjects = [];\n        const singleInsertSubjects = [];\n        if (_this2.queryRunner.connection.driver.options.type === \"mongodb\") {\n          subjects.forEach(subject => {\n            if (subject.metadata.createDateColumn && subject.entity) {\n              subject.entity[subject.metadata.createDateColumn.databaseName] = new Date();\n            }\n            if (subject.metadata.updateDateColumn && subject.entity) {\n              subject.entity[subject.metadata.updateDateColumn.databaseName] = new Date();\n            }\n            subject.createValueSetAndPopChangeMap();\n            bulkInsertSubjects.push(subject);\n            bulkInsertMaps.push(subject.entity);\n          });\n        } else if (_this2.queryRunner.connection.driver.options.type === \"oracle\") {\n          subjects.forEach(subject => {\n            singleInsertSubjects.push(subject);\n          });\n        } else {\n          subjects.forEach(subject => {\n            // we do not insert in bulk in following cases:\n            // - when there is no values in insert (only defaults are inserted), since we cannot use DEFAULT VALUES expression for multiple inserted rows\n            // - when entity is a tree table, since tree tables require extra operation per each inserted row\n            // - when oracle is used, since oracle's bulk insertion is very bad\n            if (subject.changeMaps.length === 0 || subject.metadata.treeType || _this2.queryRunner.connection.driver.options.type === \"oracle\" || _this2.queryRunner.connection.driver.options.type === \"sap\") {\n              singleInsertSubjects.push(subject);\n            } else {\n              bulkInsertSubjects.push(subject);\n              bulkInsertMaps.push(subject.createValueSetAndPopChangeMap());\n            }\n          });\n        }\n        // for mongodb we have a bit different insertion logic\n        if (InstanceChecker.isMongoEntityManager(_this2.queryRunner.manager)) {\n          const insertResult = yield _this2.queryRunner.manager.insert(subjects[0].metadata.target, bulkInsertMaps);\n          subjects.forEach((subject, index) => {\n            subject.identifier = insertResult.identifiers[index];\n            subject.generatedMap = insertResult.generatedMaps[index];\n            subject.insertedValueSet = bulkInsertMaps[index];\n          });\n        } else {\n          // here we execute our insertion query\n          // we need to enable entity updation because we DO need to have updated insertedMap\n          // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n          // also, we disable listeners because we call them on our own in persistence layer\n          if (bulkInsertMaps.length > 0) {\n            const insertResult = yield _this2.queryRunner.manager.createQueryBuilder().insert().into(subjects[0].metadata.target).values(bulkInsertMaps).updateEntity(_this2.options && _this2.options.reload === false ? false : true).callListeners(false).execute();\n            bulkInsertSubjects.forEach((subject, index) => {\n              subject.identifier = insertResult.identifiers[index];\n              subject.generatedMap = insertResult.generatedMaps[index];\n              subject.insertedValueSet = bulkInsertMaps[index];\n            });\n          }\n          // insert subjects which must be inserted in separate requests (all default values)\n          if (singleInsertSubjects.length > 0) {\n            for (const subject of singleInsertSubjects) {\n              subject.insertedValueSet = subject.createValueSetAndPopChangeMap(); // important to have because query builder sets inserted values into it\n              // for nested set we execute additional queries\n              if (subject.metadata.treeType === \"nested-set\") yield new NestedSetSubjectExecutor(_this2.queryRunner).insert(subject);\n              yield _this2.queryRunner.manager.createQueryBuilder().insert().into(subject.metadata.target).values(subject.insertedValueSet).updateEntity(_this2.options && _this2.options.reload === false ? false : true).callListeners(false).execute().then(insertResult => {\n                subject.identifier = insertResult.identifiers[0];\n                subject.generatedMap = insertResult.generatedMaps[0];\n              });\n              // for tree tables we execute additional queries\n              if (subject.metadata.treeType === \"closure-table\") {\n                yield new ClosureSubjectExecutor(_this2.queryRunner).insert(subject);\n              } else if (subject.metadata.treeType === \"materialized-path\") {\n                yield new MaterializedPathSubjectExecutor(_this2.queryRunner).insert(subject);\n              }\n            }\n          }\n        }\n        subjects.forEach(subject => {\n          if (subject.generatedMap) {\n            subject.metadata.columns.forEach(column => {\n              const value = column.getEntityValue(subject.generatedMap);\n              if (value !== undefined && value !== null) {\n                const preparedValue = _this2.queryRunner.connection.driver.prepareHydratedValue(value, column);\n                column.setEntityValue(subject.generatedMap, preparedValue);\n              }\n            });\n          }\n        });\n      }\n    })();\n  }\n  /**\n   * Updates all given subjects in the database.\n   */\n  executeUpdateOperations() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const updateSubject = /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (subject) {\n          if (!subject.identifier) throw new SubjectWithoutIdentifierError(subject);\n          // for mongodb we have a bit different updation logic\n          if (InstanceChecker.isMongoEntityManager(_this3.queryRunner.manager)) {\n            const partialEntity = _this3.cloneMongoSubjectEntity(subject);\n            if (subject.metadata.objectIdColumn && subject.metadata.objectIdColumn.propertyName) {\n              delete partialEntity[subject.metadata.objectIdColumn.propertyName];\n            }\n            if (subject.metadata.createDateColumn && subject.metadata.createDateColumn.propertyName) {\n              delete partialEntity[subject.metadata.createDateColumn.propertyName];\n            }\n            if (subject.metadata.updateDateColumn && subject.metadata.updateDateColumn.propertyName) {\n              partialEntity[subject.metadata.updateDateColumn.propertyName] = new Date();\n            }\n            const manager = _this3.queryRunner.manager;\n            yield manager.update(subject.metadata.target, subject.identifier, partialEntity);\n          } else {\n            const updateMap = subject.createValueSetAndPopChangeMap();\n            // for tree tables we execute additional queries\n            switch (subject.metadata.treeType) {\n              case \"nested-set\":\n                yield new NestedSetSubjectExecutor(_this3.queryRunner).update(subject);\n                break;\n              case \"closure-table\":\n                yield new ClosureSubjectExecutor(_this3.queryRunner).update(subject);\n                break;\n              case \"materialized-path\":\n                yield new MaterializedPathSubjectExecutor(_this3.queryRunner).update(subject);\n                break;\n            }\n            // here we execute our updation query\n            // we need to enable entity updation because we update a subject identifier\n            // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n            // also, we disable listeners because we call them on our own in persistence layer\n            const updateQueryBuilder = _this3.queryRunner.manager.createQueryBuilder().update(subject.metadata.target).set(updateMap).updateEntity(_this3.options && _this3.options.reload === false ? false : true).callListeners(false);\n            if (subject.entity) {\n              updateQueryBuilder.whereEntity(subject.identifier);\n            } else {\n              // in this case identifier is just conditions object to update by\n              updateQueryBuilder.where(subject.identifier);\n            }\n            const updateResult = yield updateQueryBuilder.execute();\n            let updateGeneratedMap = updateResult.generatedMaps[0];\n            if (updateGeneratedMap) {\n              subject.metadata.columns.forEach(column => {\n                const value = column.getEntityValue(updateGeneratedMap);\n                if (value !== undefined && value !== null) {\n                  const preparedValue = _this3.queryRunner.connection.driver.prepareHydratedValue(value, column);\n                  column.setEntityValue(updateGeneratedMap, preparedValue);\n                }\n              });\n              if (!subject.generatedMap) {\n                subject.generatedMap = {};\n              }\n              Object.assign(subject.generatedMap, updateGeneratedMap);\n            }\n          }\n        });\n        return function updateSubject(_x) {\n          return _ref.apply(this, arguments);\n        };\n      }();\n      // Nested sets need to be updated one by one\n      // Split array in two, one with nested set subjects and the other with the remaining subjects\n      const nestedSetSubjects = [];\n      const remainingSubjects = [];\n      for (const subject of _this3.updateSubjects) {\n        if (subject.metadata.treeType === \"nested-set\") {\n          nestedSetSubjects.push(subject);\n        } else {\n          remainingSubjects.push(subject);\n        }\n      }\n      // Run nested set updates one by one\n      const nestedSetPromise = new Promise( /*#__PURE__*/function () {\n        var _ref2 = _asyncToGenerator(function* (ok, fail) {\n          for (const subject of nestedSetSubjects) {\n            try {\n              yield updateSubject(subject);\n            } catch (error) {\n              fail(error);\n            }\n          }\n          ok();\n        });\n        return function (_x2, _x3) {\n          return _ref2.apply(this, arguments);\n        };\n      }());\n      // Run all remaining subjects in parallel\n      yield Promise.all([...remainingSubjects.map(updateSubject), nestedSetPromise]);\n    })();\n  }\n  /**\n   * Removes all given subjects from the database.\n   *\n   * todo: we need to apply topological sort here as well\n   */\n  executeRemoveOperations() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      // group insertion subjects to make bulk insertions\n      const [groupedRemoveSubjects, groupedRemoveSubjectKeys] = _this4.groupBulkSubjects(_this4.removeSubjects, \"delete\");\n      for (const groupName of groupedRemoveSubjectKeys) {\n        const subjects = groupedRemoveSubjects[groupName];\n        const deleteMaps = subjects.map(subject => {\n          if (!subject.identifier) throw new SubjectWithoutIdentifierError(subject);\n          return subject.identifier;\n        });\n        // for mongodb we have a bit different updation logic\n        if (InstanceChecker.isMongoEntityManager(_this4.queryRunner.manager)) {\n          const manager = _this4.queryRunner.manager;\n          yield manager.delete(subjects[0].metadata.target, deleteMaps);\n        } else {\n          // for tree tables we execute additional queries\n          switch (subjects[0].metadata.treeType) {\n            case \"nested-set\":\n              yield new NestedSetSubjectExecutor(_this4.queryRunner).remove(subjects);\n              break;\n            case \"closure-table\":\n              yield new ClosureSubjectExecutor(_this4.queryRunner).remove(subjects);\n              break;\n          }\n          // here we execute our deletion query\n          // we don't need to specify entities and set update entity to true since the only thing query builder\n          // will do for use is a primary keys deletion which is handled by us later once persistence is finished\n          // also, we disable listeners because we call them on our own in persistence layer\n          yield _this4.queryRunner.manager.createQueryBuilder().delete().from(subjects[0].metadata.target).where(deleteMaps).callListeners(false).execute();\n        }\n      }\n    })();\n  }\n  cloneMongoSubjectEntity(subject) {\n    const target = {};\n    if (subject.entity) {\n      for (const column of subject.metadata.columns) {\n        OrmUtils.mergeDeep(target, column.getEntityValueMap(subject.entity));\n      }\n    }\n    return target;\n  }\n  /**\n   * Soft-removes all given subjects in the database.\n   */\n  executeSoftRemoveOperations() {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      yield Promise.all(_this5.softRemoveSubjects.map( /*#__PURE__*/function () {\n        var _ref3 = _asyncToGenerator(function* (subject) {\n          if (!subject.identifier) throw new SubjectWithoutIdentifierError(subject);\n          let updateResult;\n          // for mongodb we have a bit different updation logic\n          if (InstanceChecker.isMongoEntityManager(_this5.queryRunner.manager)) {\n            const partialEntity = _this5.cloneMongoSubjectEntity(subject);\n            if (subject.metadata.objectIdColumn && subject.metadata.objectIdColumn.propertyName) {\n              delete partialEntity[subject.metadata.objectIdColumn.propertyName];\n            }\n            if (subject.metadata.createDateColumn && subject.metadata.createDateColumn.propertyName) {\n              delete partialEntity[subject.metadata.createDateColumn.propertyName];\n            }\n            if (subject.metadata.updateDateColumn && subject.metadata.updateDateColumn.propertyName) {\n              partialEntity[subject.metadata.updateDateColumn.propertyName] = new Date();\n            }\n            if (subject.metadata.deleteDateColumn && subject.metadata.deleteDateColumn.propertyName) {\n              partialEntity[subject.metadata.deleteDateColumn.propertyName] = new Date();\n            }\n            const manager = _this5.queryRunner.manager;\n            updateResult = yield manager.update(subject.metadata.target, subject.identifier, partialEntity);\n          } else {\n            // here we execute our soft-deletion query\n            // we need to enable entity soft-deletion because we update a subject identifier\n            // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n            // also, we disable listeners because we call them on our own in persistence layer\n            const softDeleteQueryBuilder = _this5.queryRunner.manager.createQueryBuilder().softDelete().from(subject.metadata.target).updateEntity(_this5.options && _this5.options.reload === false ? false : true).callListeners(false);\n            if (subject.entity) {\n              softDeleteQueryBuilder.whereEntity(subject.identifier);\n            } else {\n              // in this case identifier is just conditions object to update by\n              softDeleteQueryBuilder.where(subject.identifier);\n            }\n            updateResult = yield softDeleteQueryBuilder.execute();\n          }\n          subject.generatedMap = updateResult.generatedMaps[0];\n          if (subject.generatedMap) {\n            subject.metadata.columns.forEach(column => {\n              const value = column.getEntityValue(subject.generatedMap);\n              if (value !== undefined && value !== null) {\n                const preparedValue = _this5.queryRunner.connection.driver.prepareHydratedValue(value, column);\n                column.setEntityValue(subject.generatedMap, preparedValue);\n              }\n            });\n          }\n          // experiments, remove probably, need to implement tree tables children removal\n          // if (subject.updatedRelationMaps.length > 0) {\n          //     await Promise.all(subject.updatedRelationMaps.map(async updatedRelation => {\n          //         if (!updatedRelation.relation.isTreeParent) return;\n          //         if (!updatedRelation.value !== null) return;\n          //\n          //         if (subject.metadata.treeType === \"closure-table\") {\n          //             await new ClosureSubjectExecutor(this.queryRunner).deleteChildrenOf(subject);\n          //         }\n          //     }));\n          // }\n        });\n        return function (_x4) {\n          return _ref3.apply(this, arguments);\n        };\n      }()));\n    })();\n  }\n  /**\n   * Recovers all given subjects in the database.\n   */\n  executeRecoverOperations() {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      yield Promise.all(_this6.recoverSubjects.map( /*#__PURE__*/function () {\n        var _ref4 = _asyncToGenerator(function* (subject) {\n          if (!subject.identifier) throw new SubjectWithoutIdentifierError(subject);\n          let updateResult;\n          // for mongodb we have a bit different updation logic\n          if (InstanceChecker.isMongoEntityManager(_this6.queryRunner.manager)) {\n            const partialEntity = _this6.cloneMongoSubjectEntity(subject);\n            if (subject.metadata.objectIdColumn && subject.metadata.objectIdColumn.propertyName) {\n              delete partialEntity[subject.metadata.objectIdColumn.propertyName];\n            }\n            if (subject.metadata.createDateColumn && subject.metadata.createDateColumn.propertyName) {\n              delete partialEntity[subject.metadata.createDateColumn.propertyName];\n            }\n            if (subject.metadata.updateDateColumn && subject.metadata.updateDateColumn.propertyName) {\n              partialEntity[subject.metadata.updateDateColumn.propertyName] = new Date();\n            }\n            if (subject.metadata.deleteDateColumn && subject.metadata.deleteDateColumn.propertyName) {\n              partialEntity[subject.metadata.deleteDateColumn.propertyName] = null;\n            }\n            const manager = _this6.queryRunner.manager;\n            updateResult = yield manager.update(subject.metadata.target, subject.identifier, partialEntity);\n          } else {\n            // here we execute our restory query\n            // we need to enable entity restory because we update a subject identifier\n            // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n            // also, we disable listeners because we call them on our own in persistence layer\n            const softDeleteQueryBuilder = _this6.queryRunner.manager.createQueryBuilder().restore().from(subject.metadata.target).updateEntity(_this6.options && _this6.options.reload === false ? false : true).callListeners(false);\n            if (subject.entity) {\n              softDeleteQueryBuilder.whereEntity(subject.identifier);\n            } else {\n              // in this case identifier is just conditions object to update by\n              softDeleteQueryBuilder.where(subject.identifier);\n            }\n            updateResult = yield softDeleteQueryBuilder.execute();\n          }\n          subject.generatedMap = updateResult.generatedMaps[0];\n          if (subject.generatedMap) {\n            subject.metadata.columns.forEach(column => {\n              const value = column.getEntityValue(subject.generatedMap);\n              if (value !== undefined && value !== null) {\n                const preparedValue = _this6.queryRunner.connection.driver.prepareHydratedValue(value, column);\n                column.setEntityValue(subject.generatedMap, preparedValue);\n              }\n            });\n          }\n          // experiments, remove probably, need to implement tree tables children removal\n          // if (subject.updatedRelationMaps.length > 0) {\n          //     await Promise.all(subject.updatedRelationMaps.map(async updatedRelation => {\n          //         if (!updatedRelation.relation.isTreeParent) return;\n          //         if (!updatedRelation.value !== null) return;\n          //\n          //         if (subject.metadata.treeType === \"closure-table\") {\n          //             await new ClosureSubjectExecutor(this.queryRunner).deleteChildrenOf(subject);\n          //         }\n          //     }));\n          // }\n        });\n        return function (_x5) {\n          return _ref4.apply(this, arguments);\n        };\n      }()));\n    })();\n  }\n  /**\n   * Updates all special columns of the saving entities (create date, update date, version, etc.).\n   * Also updates nullable columns and columns with default values.\n   */\n  updateSpecialColumnsInPersistedEntities() {\n    // update inserted entity properties\n    if (this.insertSubjects.length) this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.insertSubjects);\n    // update updated entity properties\n    if (this.updateSubjects.length) this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.updateSubjects);\n    // update soft-removed entity properties\n    if (this.softRemoveSubjects.length) this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.softRemoveSubjects);\n    // update recovered entity properties\n    if (this.recoverSubjects.length) this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.recoverSubjects);\n    // remove ids from the entities that were removed\n    if (this.removeSubjects.length) {\n      this.removeSubjects.forEach(subject => {\n        if (!subject.entity) return;\n        subject.metadata.primaryColumns.forEach(primaryColumn => {\n          primaryColumn.setEntityValue(subject.entity, undefined);\n        });\n      });\n    }\n    // other post-persist updations\n    this.allSubjects.forEach(subject => {\n      if (!subject.entity) return;\n      subject.metadata.relationIds.forEach(relationId => {\n        relationId.setValue(subject.entity);\n      });\n      // mongo _id remove\n      if (InstanceChecker.isMongoEntityManager(this.queryRunner.manager)) {\n        if (subject.metadata.objectIdColumn && subject.metadata.objectIdColumn.databaseName && subject.metadata.objectIdColumn.databaseName !== subject.metadata.objectIdColumn.propertyName) {\n          delete subject.entity[subject.metadata.objectIdColumn.databaseName];\n        }\n      }\n    });\n  }\n  /**\n   * Updates all special columns of the saving entities (create date, update date, version, etc.).\n   * Also updates nullable columns and columns with default values.\n   */\n  updateSpecialColumnsInInsertedAndUpdatedEntities(subjects) {\n    subjects.forEach(subject => {\n      if (!subject.entity) return;\n      // set values to \"null\" for nullable columns that did not have values\n      subject.metadata.columns.forEach(column => {\n        // if table inheritance is used make sure this column is not child's column\n        if (subject.metadata.childEntityMetadatas.length > 0 && subject.metadata.childEntityMetadatas.map(metadata => metadata.target).indexOf(column.target) !== -1) return;\n        // entities does not have virtual columns\n        if (column.isVirtual) return;\n        // update nullable columns\n        if (column.isNullable) {\n          const columnValue = column.getEntityValue(subject.entity);\n          if (columnValue === undefined) column.setEntityValue(subject.entity, null);\n        }\n        // update relational columns\n        if (subject.updatedRelationMaps.length > 0) {\n          subject.updatedRelationMaps.forEach(updatedRelationMap => {\n            updatedRelationMap.relation.joinColumns.forEach(column => {\n              if (column.isVirtual === true) return;\n              column.setEntityValue(subject.entity, ObjectUtils.isObject(updatedRelationMap.value) ? column.referencedColumn.getEntityValue(updatedRelationMap.value) : updatedRelationMap.value);\n            });\n          });\n        }\n      });\n      // merge into entity all generated values returned by a database\n      if (subject.generatedMap) this.queryRunner.manager.merge(subject.metadata.target, subject.entity, subject.generatedMap);\n    });\n  }\n  /**\n   * Groups subjects by metadata names (by tables) to make bulk insertions and deletions possible.\n   * However there are some limitations with bulk insertions of data into tables with generated (increment) columns\n   * in some drivers. Some drivers like mysql and sqlite does not support returning multiple generated columns\n   * after insertion and can only return a single generated column value, that's why its not possible to do bulk insertion,\n   * because it breaks insertion result's generatedMap and leads to problems when this subject is used in other subjects saves.\n   * That's why we only support bulking in junction tables for those drivers.\n   *\n   * Other drivers like postgres and sql server support RETURNING / OUTPUT statement which allows to return generated\n   * id for each inserted row, that's why bulk insertion is not limited to junction tables in there.\n   */\n  groupBulkSubjects(subjects, type) {\n    const group = {};\n    const keys = [];\n    const hasReturningDependColumns = subjects.some(subject => {\n      return subject.metadata.getInsertionReturningColumns().length > 0;\n    });\n    const groupingAllowed = type === \"delete\" || this.queryRunner.connection.driver.isReturningSqlSupported(\"insert\") || hasReturningDependColumns === false;\n    subjects.forEach((subject, index) => {\n      const key = groupingAllowed || subject.metadata.isJunction ? subject.metadata.name : subject.metadata.name + \"_\" + index;\n      if (!group[key]) {\n        group[key] = [subject];\n        keys.push(key);\n      } else {\n        group[key].push(subject);\n      }\n    });\n    return [group, keys];\n  }\n}","map":{"version":3,"names":["SubjectTopoligicalSorter","SubjectChangedColumnsComputer","SubjectWithoutIdentifierError","SubjectRemovedAndUpdatedError","BroadcasterResult","NestedSetSubjectExecutor","ClosureSubjectExecutor","MaterializedPathSubjectExecutor","OrmUtils","ObjectUtils","InstanceChecker","SubjectExecutor","constructor","queryRunner","subjects","options","hasExecutableOperations","insertSubjects","updateSubjects","removeSubjects","softRemoveSubjects","recoverSubjects","allSubjects","validate","recompute","execute","_this","_asyncToGenerator","broadcasterResult","undefined","listeners","broadcastBeforeEventsForAll","promises","length","Promise","all","count","forEach","subject","sort","executeInsertOperations","filter","mustBeUpdated","executeUpdateOperations","executeRemoveOperations","mustBeSoftRemoved","executeSoftRemoveOperations","mustBeRecovered","executeRecoverOperations","updateSpecialColumnsInPersistedEntities","broadcastAfterEventsForAll","mustBeRemoved","compute","mustBeInserted","result","broadcaster","broadcastBeforeInsertEvent","metadata","entity","broadcastBeforeUpdateEvent","databaseEntity","diffColumns","diffRelations","broadcastBeforeRemoveEvent","identifier","broadcastBeforeSoftRemoveEvent","broadcastBeforeRecoverEvent","broadcastAfterInsertEvent","broadcastAfterUpdateEvent","broadcastAfterRemoveEvent","broadcastAfterSoftRemoveEvent","broadcastAfterRecoverEvent","_this2","groupedInsertSubjects","groupedInsertSubjectKeys","groupBulkSubjects","groupName","bulkInsertMaps","bulkInsertSubjects","singleInsertSubjects","connection","driver","type","createDateColumn","databaseName","Date","updateDateColumn","createValueSetAndPopChangeMap","push","changeMaps","treeType","isMongoEntityManager","manager","insertResult","insert","target","index","identifiers","generatedMap","generatedMaps","insertedValueSet","createQueryBuilder","into","values","updateEntity","reload","callListeners","then","columns","column","value","getEntityValue","preparedValue","prepareHydratedValue","setEntityValue","_this3","updateSubject","_ref","partialEntity","cloneMongoSubjectEntity","objectIdColumn","propertyName","update","updateMap","updateQueryBuilder","set","whereEntity","where","updateResult","updateGeneratedMap","Object","assign","_x","apply","arguments","nestedSetSubjects","remainingSubjects","nestedSetPromise","_ref2","ok","fail","error","_x2","_x3","map","_this4","groupedRemoveSubjects","groupedRemoveSubjectKeys","deleteMaps","delete","remove","from","mergeDeep","getEntityValueMap","_this5","_ref3","deleteDateColumn","softDeleteQueryBuilder","softDelete","_x4","_this6","_ref4","restore","_x5","updateSpecialColumnsInInsertedAndUpdatedEntities","primaryColumns","primaryColumn","relationIds","relationId","setValue","childEntityMetadatas","indexOf","isVirtual","isNullable","columnValue","updatedRelationMaps","updatedRelationMap","relation","joinColumns","isObject","referencedColumn","merge","group","keys","hasReturningDependColumns","some","getInsertionReturningColumns","groupingAllowed","isReturningSqlSupported","key","isJunction","name"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/persistence/SubjectExecutor.js"],"sourcesContent":["import { SubjectTopoligicalSorter } from \"./SubjectTopoligicalSorter\";\nimport { SubjectChangedColumnsComputer } from \"./SubjectChangedColumnsComputer\";\nimport { SubjectWithoutIdentifierError } from \"../error/SubjectWithoutIdentifierError\";\nimport { SubjectRemovedAndUpdatedError } from \"../error/SubjectRemovedAndUpdatedError\";\nimport { BroadcasterResult } from \"../subscriber/BroadcasterResult\";\nimport { NestedSetSubjectExecutor } from \"./tree/NestedSetSubjectExecutor\";\nimport { ClosureSubjectExecutor } from \"./tree/ClosureSubjectExecutor\";\nimport { MaterializedPathSubjectExecutor } from \"./tree/MaterializedPathSubjectExecutor\";\nimport { OrmUtils } from \"../util/OrmUtils\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\n/**\n * Executes all database operations (inserts, updated, deletes) that must be executed\n * with given persistence subjects.\n */\nexport class SubjectExecutor {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n    constructor(queryRunner, subjects, options) {\n        // -------------------------------------------------------------------------\n        // Public Properties\n        // -------------------------------------------------------------------------\n        /**\n         * Indicates if executor has any operations to execute (e.g. has insert / update / delete operations to be executed).\n         */\n        this.hasExecutableOperations = false;\n        /**\n         * Subjects that must be inserted.\n         */\n        this.insertSubjects = [];\n        /**\n         * Subjects that must be updated.\n         */\n        this.updateSubjects = [];\n        /**\n         * Subjects that must be removed.\n         */\n        this.removeSubjects = [];\n        /**\n         * Subjects that must be soft-removed.\n         */\n        this.softRemoveSubjects = [];\n        /**\n         * Subjects that must be recovered.\n         */\n        this.recoverSubjects = [];\n        this.queryRunner = queryRunner;\n        this.allSubjects = subjects;\n        this.options = options;\n        this.validate();\n        this.recompute();\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Executes all operations over given array of subjects.\n     * Executes queries using given query runner.\n     */\n    async execute() {\n        // console.time(\"SubjectExecutor.execute\");\n        // broadcast \"before\" events before we start insert / update / remove operations\n        let broadcasterResult = undefined;\n        if (!this.options || this.options.listeners !== false) {\n            // console.time(\".broadcastBeforeEventsForAll\");\n            broadcasterResult = this.broadcastBeforeEventsForAll();\n            if (broadcasterResult.promises.length > 0)\n                await Promise.all(broadcasterResult.promises);\n            // console.timeEnd(\".broadcastBeforeEventsForAll\");\n        }\n        // since event listeners and subscribers can call save methods and/or trigger entity changes we need to recompute operational subjects\n        // recompute only in the case if any listener or subscriber was really executed\n        if (broadcasterResult && broadcasterResult.count > 0) {\n            // console.time(\".recompute\");\n            this.insertSubjects.forEach((subject) => subject.recompute());\n            this.updateSubjects.forEach((subject) => subject.recompute());\n            this.removeSubjects.forEach((subject) => subject.recompute());\n            this.softRemoveSubjects.forEach((subject) => subject.recompute());\n            this.recoverSubjects.forEach((subject) => subject.recompute());\n            this.recompute();\n            // console.timeEnd(\".recompute\");\n        }\n        // make sure our insert subjects are sorted (using topological sorting) to make cascade inserts work properly\n        // console.timeEnd(\"prepare\");\n        // execute all insert operations\n        // console.time(\".insertion\");\n        this.insertSubjects = new SubjectTopoligicalSorter(this.insertSubjects).sort(\"insert\");\n        await this.executeInsertOperations();\n        // console.timeEnd(\".insertion\");\n        // recompute update operations since insertion can create updation operations for the\n        // properties it wasn't able to handle on its own (referenced columns)\n        this.updateSubjects = this.allSubjects.filter((subject) => subject.mustBeUpdated);\n        // execute update operations\n        // console.time(\".updation\");\n        await this.executeUpdateOperations();\n        // console.timeEnd(\".updation\");\n        // make sure our remove subjects are sorted (using topological sorting) when multiple entities are passed for the removal\n        // console.time(\".removal\");\n        this.removeSubjects = new SubjectTopoligicalSorter(this.removeSubjects).sort(\"delete\");\n        await this.executeRemoveOperations();\n        // console.timeEnd(\".removal\");\n        // recompute soft-remove operations\n        this.softRemoveSubjects = this.allSubjects.filter((subject) => subject.mustBeSoftRemoved);\n        // execute soft-remove operations\n        await this.executeSoftRemoveOperations();\n        // recompute recover operations\n        this.recoverSubjects = this.allSubjects.filter((subject) => subject.mustBeRecovered);\n        // execute recover operations\n        await this.executeRecoverOperations();\n        // update all special columns in persisted entities, like inserted id or remove ids from the removed entities\n        // console.time(\".updateSpecialColumnsInPersistedEntities\");\n        await this.updateSpecialColumnsInPersistedEntities();\n        // console.timeEnd(\".updateSpecialColumnsInPersistedEntities\");\n        // finally broadcast \"after\" events after we finish insert / update / remove operations\n        if (!this.options || this.options.listeners !== false) {\n            // console.time(\".broadcastAfterEventsForAll\");\n            broadcasterResult = this.broadcastAfterEventsForAll();\n            if (broadcasterResult.promises.length > 0)\n                await Promise.all(broadcasterResult.promises);\n            // console.timeEnd(\".broadcastAfterEventsForAll\");\n        }\n        // console.timeEnd(\"SubjectExecutor.execute\");\n    }\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Validates all given subjects.\n     */\n    validate() {\n        this.allSubjects.forEach((subject) => {\n            if (subject.mustBeUpdated && subject.mustBeRemoved)\n                throw new SubjectRemovedAndUpdatedError(subject);\n        });\n    }\n    /**\n     * Performs entity re-computations - finds changed columns, re-builds insert/update/remove subjects.\n     */\n    recompute() {\n        new SubjectChangedColumnsComputer().compute(this.allSubjects);\n        this.insertSubjects = this.allSubjects.filter((subject) => subject.mustBeInserted);\n        this.updateSubjects = this.allSubjects.filter((subject) => subject.mustBeUpdated);\n        this.removeSubjects = this.allSubjects.filter((subject) => subject.mustBeRemoved);\n        this.softRemoveSubjects = this.allSubjects.filter((subject) => subject.mustBeSoftRemoved);\n        this.recoverSubjects = this.allSubjects.filter((subject) => subject.mustBeRecovered);\n        this.hasExecutableOperations =\n            this.insertSubjects.length > 0 ||\n                this.updateSubjects.length > 0 ||\n                this.removeSubjects.length > 0 ||\n                this.softRemoveSubjects.length > 0 ||\n                this.recoverSubjects.length > 0;\n    }\n    /**\n     * Broadcasts \"BEFORE_INSERT\", \"BEFORE_UPDATE\", \"BEFORE_REMOVE\", \"BEFORE_SOFT_REMOVE\", \"BEFORE_RECOVER\" events for all given subjects.\n     */\n    broadcastBeforeEventsForAll() {\n        const result = new BroadcasterResult();\n        if (this.insertSubjects.length)\n            this.insertSubjects.forEach((subject) => this.queryRunner.broadcaster.broadcastBeforeInsertEvent(result, subject.metadata, subject.entity));\n        if (this.updateSubjects.length)\n            this.updateSubjects.forEach((subject) => this.queryRunner.broadcaster.broadcastBeforeUpdateEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.diffColumns, subject.diffRelations));\n        if (this.removeSubjects.length)\n            this.removeSubjects.forEach((subject) => this.queryRunner.broadcaster.broadcastBeforeRemoveEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.identifier));\n        if (this.softRemoveSubjects.length)\n            this.softRemoveSubjects.forEach((subject) => this.queryRunner.broadcaster.broadcastBeforeSoftRemoveEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.identifier));\n        if (this.recoverSubjects.length)\n            this.recoverSubjects.forEach((subject) => this.queryRunner.broadcaster.broadcastBeforeRecoverEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.identifier));\n        return result;\n    }\n    /**\n     * Broadcasts \"AFTER_INSERT\", \"AFTER_UPDATE\", \"AFTER_REMOVE\", \"AFTER_SOFT_REMOVE\", \"AFTER_RECOVER\" events for all given subjects.\n     * Returns void if there wasn't any listener or subscriber executed.\n     * Note: this method has a performance-optimized code organization.\n     */\n    broadcastAfterEventsForAll() {\n        const result = new BroadcasterResult();\n        if (this.insertSubjects.length)\n            this.insertSubjects.forEach((subject) => this.queryRunner.broadcaster.broadcastAfterInsertEvent(result, subject.metadata, subject.entity));\n        if (this.updateSubjects.length)\n            this.updateSubjects.forEach((subject) => this.queryRunner.broadcaster.broadcastAfterUpdateEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.diffColumns, subject.diffRelations));\n        if (this.removeSubjects.length)\n            this.removeSubjects.forEach((subject) => this.queryRunner.broadcaster.broadcastAfterRemoveEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.identifier));\n        if (this.softRemoveSubjects.length)\n            this.softRemoveSubjects.forEach((subject) => this.queryRunner.broadcaster.broadcastAfterSoftRemoveEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.identifier));\n        if (this.recoverSubjects.length)\n            this.recoverSubjects.forEach((subject) => this.queryRunner.broadcaster.broadcastAfterRecoverEvent(result, subject.metadata, subject.entity, subject.databaseEntity, subject.identifier));\n        return result;\n    }\n    /**\n     * Executes insert operations.\n     */\n    async executeInsertOperations() {\n        // group insertion subjects to make bulk insertions\n        const [groupedInsertSubjects, groupedInsertSubjectKeys] = this.groupBulkSubjects(this.insertSubjects, \"insert\");\n        // then we run insertion in the sequential order which is important since we have an ordered subjects\n        for (const groupName of groupedInsertSubjectKeys) {\n            const subjects = groupedInsertSubjects[groupName];\n            // we must separately insert entities which does not have any values to insert\n            // because its not possible to insert multiple entities with only default values in bulk\n            const bulkInsertMaps = [];\n            const bulkInsertSubjects = [];\n            const singleInsertSubjects = [];\n            if (this.queryRunner.connection.driver.options.type === \"mongodb\") {\n                subjects.forEach((subject) => {\n                    if (subject.metadata.createDateColumn && subject.entity) {\n                        subject.entity[subject.metadata.createDateColumn.databaseName] = new Date();\n                    }\n                    if (subject.metadata.updateDateColumn && subject.entity) {\n                        subject.entity[subject.metadata.updateDateColumn.databaseName] = new Date();\n                    }\n                    subject.createValueSetAndPopChangeMap();\n                    bulkInsertSubjects.push(subject);\n                    bulkInsertMaps.push(subject.entity);\n                });\n            }\n            else if (this.queryRunner.connection.driver.options.type === \"oracle\") {\n                subjects.forEach((subject) => {\n                    singleInsertSubjects.push(subject);\n                });\n            }\n            else {\n                subjects.forEach((subject) => {\n                    // we do not insert in bulk in following cases:\n                    // - when there is no values in insert (only defaults are inserted), since we cannot use DEFAULT VALUES expression for multiple inserted rows\n                    // - when entity is a tree table, since tree tables require extra operation per each inserted row\n                    // - when oracle is used, since oracle's bulk insertion is very bad\n                    if (subject.changeMaps.length === 0 ||\n                        subject.metadata.treeType ||\n                        this.queryRunner.connection.driver.options.type ===\n                            \"oracle\" ||\n                        this.queryRunner.connection.driver.options.type ===\n                            \"sap\") {\n                        singleInsertSubjects.push(subject);\n                    }\n                    else {\n                        bulkInsertSubjects.push(subject);\n                        bulkInsertMaps.push(subject.createValueSetAndPopChangeMap());\n                    }\n                });\n            }\n            // for mongodb we have a bit different insertion logic\n            if (InstanceChecker.isMongoEntityManager(this.queryRunner.manager)) {\n                const insertResult = await this.queryRunner.manager.insert(subjects[0].metadata.target, bulkInsertMaps);\n                subjects.forEach((subject, index) => {\n                    subject.identifier = insertResult.identifiers[index];\n                    subject.generatedMap = insertResult.generatedMaps[index];\n                    subject.insertedValueSet = bulkInsertMaps[index];\n                });\n            }\n            else {\n                // here we execute our insertion query\n                // we need to enable entity updation because we DO need to have updated insertedMap\n                // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n                // also, we disable listeners because we call them on our own in persistence layer\n                if (bulkInsertMaps.length > 0) {\n                    const insertResult = await this.queryRunner.manager\n                        .createQueryBuilder()\n                        .insert()\n                        .into(subjects[0].metadata.target)\n                        .values(bulkInsertMaps)\n                        .updateEntity(this.options && this.options.reload === false\n                        ? false\n                        : true)\n                        .callListeners(false)\n                        .execute();\n                    bulkInsertSubjects.forEach((subject, index) => {\n                        subject.identifier = insertResult.identifiers[index];\n                        subject.generatedMap = insertResult.generatedMaps[index];\n                        subject.insertedValueSet = bulkInsertMaps[index];\n                    });\n                }\n                // insert subjects which must be inserted in separate requests (all default values)\n                if (singleInsertSubjects.length > 0) {\n                    for (const subject of singleInsertSubjects) {\n                        subject.insertedValueSet =\n                            subject.createValueSetAndPopChangeMap(); // important to have because query builder sets inserted values into it\n                        // for nested set we execute additional queries\n                        if (subject.metadata.treeType === \"nested-set\")\n                            await new NestedSetSubjectExecutor(this.queryRunner).insert(subject);\n                        await this.queryRunner.manager\n                            .createQueryBuilder()\n                            .insert()\n                            .into(subject.metadata.target)\n                            .values(subject.insertedValueSet)\n                            .updateEntity(this.options && this.options.reload === false\n                            ? false\n                            : true)\n                            .callListeners(false)\n                            .execute()\n                            .then((insertResult) => {\n                            subject.identifier = insertResult.identifiers[0];\n                            subject.generatedMap =\n                                insertResult.generatedMaps[0];\n                        });\n                        // for tree tables we execute additional queries\n                        if (subject.metadata.treeType === \"closure-table\") {\n                            await new ClosureSubjectExecutor(this.queryRunner).insert(subject);\n                        }\n                        else if (subject.metadata.treeType === \"materialized-path\") {\n                            await new MaterializedPathSubjectExecutor(this.queryRunner).insert(subject);\n                        }\n                    }\n                }\n            }\n            subjects.forEach((subject) => {\n                if (subject.generatedMap) {\n                    subject.metadata.columns.forEach((column) => {\n                        const value = column.getEntityValue(subject.generatedMap);\n                        if (value !== undefined && value !== null) {\n                            const preparedValue = this.queryRunner.connection.driver.prepareHydratedValue(value, column);\n                            column.setEntityValue(subject.generatedMap, preparedValue);\n                        }\n                    });\n                }\n            });\n        }\n    }\n    /**\n     * Updates all given subjects in the database.\n     */\n    async executeUpdateOperations() {\n        const updateSubject = async (subject) => {\n            if (!subject.identifier)\n                throw new SubjectWithoutIdentifierError(subject);\n            // for mongodb we have a bit different updation logic\n            if (InstanceChecker.isMongoEntityManager(this.queryRunner.manager)) {\n                const partialEntity = this.cloneMongoSubjectEntity(subject);\n                if (subject.metadata.objectIdColumn &&\n                    subject.metadata.objectIdColumn.propertyName) {\n                    delete partialEntity[subject.metadata.objectIdColumn.propertyName];\n                }\n                if (subject.metadata.createDateColumn &&\n                    subject.metadata.createDateColumn.propertyName) {\n                    delete partialEntity[subject.metadata.createDateColumn.propertyName];\n                }\n                if (subject.metadata.updateDateColumn &&\n                    subject.metadata.updateDateColumn.propertyName) {\n                    partialEntity[subject.metadata.updateDateColumn.propertyName] = new Date();\n                }\n                const manager = this.queryRunner.manager;\n                await manager.update(subject.metadata.target, subject.identifier, partialEntity);\n            }\n            else {\n                const updateMap = subject.createValueSetAndPopChangeMap();\n                // for tree tables we execute additional queries\n                switch (subject.metadata.treeType) {\n                    case \"nested-set\":\n                        await new NestedSetSubjectExecutor(this.queryRunner).update(subject);\n                        break;\n                    case \"closure-table\":\n                        await new ClosureSubjectExecutor(this.queryRunner).update(subject);\n                        break;\n                    case \"materialized-path\":\n                        await new MaterializedPathSubjectExecutor(this.queryRunner).update(subject);\n                        break;\n                }\n                // here we execute our updation query\n                // we need to enable entity updation because we update a subject identifier\n                // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n                // also, we disable listeners because we call them on our own in persistence layer\n                const updateQueryBuilder = this.queryRunner.manager\n                    .createQueryBuilder()\n                    .update(subject.metadata.target)\n                    .set(updateMap)\n                    .updateEntity(this.options && this.options.reload === false\n                    ? false\n                    : true)\n                    .callListeners(false);\n                if (subject.entity) {\n                    updateQueryBuilder.whereEntity(subject.identifier);\n                }\n                else {\n                    // in this case identifier is just conditions object to update by\n                    updateQueryBuilder.where(subject.identifier);\n                }\n                const updateResult = await updateQueryBuilder.execute();\n                let updateGeneratedMap = updateResult.generatedMaps[0];\n                if (updateGeneratedMap) {\n                    subject.metadata.columns.forEach((column) => {\n                        const value = column.getEntityValue(updateGeneratedMap);\n                        if (value !== undefined && value !== null) {\n                            const preparedValue = this.queryRunner.connection.driver.prepareHydratedValue(value, column);\n                            column.setEntityValue(updateGeneratedMap, preparedValue);\n                        }\n                    });\n                    if (!subject.generatedMap) {\n                        subject.generatedMap = {};\n                    }\n                    Object.assign(subject.generatedMap, updateGeneratedMap);\n                }\n            }\n        };\n        // Nested sets need to be updated one by one\n        // Split array in two, one with nested set subjects and the other with the remaining subjects\n        const nestedSetSubjects = [];\n        const remainingSubjects = [];\n        for (const subject of this.updateSubjects) {\n            if (subject.metadata.treeType === \"nested-set\") {\n                nestedSetSubjects.push(subject);\n            }\n            else {\n                remainingSubjects.push(subject);\n            }\n        }\n        // Run nested set updates one by one\n        const nestedSetPromise = new Promise(async (ok, fail) => {\n            for (const subject of nestedSetSubjects) {\n                try {\n                    await updateSubject(subject);\n                }\n                catch (error) {\n                    fail(error);\n                }\n            }\n            ok();\n        });\n        // Run all remaining subjects in parallel\n        await Promise.all([\n            ...remainingSubjects.map(updateSubject),\n            nestedSetPromise,\n        ]);\n    }\n    /**\n     * Removes all given subjects from the database.\n     *\n     * todo: we need to apply topological sort here as well\n     */\n    async executeRemoveOperations() {\n        // group insertion subjects to make bulk insertions\n        const [groupedRemoveSubjects, groupedRemoveSubjectKeys] = this.groupBulkSubjects(this.removeSubjects, \"delete\");\n        for (const groupName of groupedRemoveSubjectKeys) {\n            const subjects = groupedRemoveSubjects[groupName];\n            const deleteMaps = subjects.map((subject) => {\n                if (!subject.identifier)\n                    throw new SubjectWithoutIdentifierError(subject);\n                return subject.identifier;\n            });\n            // for mongodb we have a bit different updation logic\n            if (InstanceChecker.isMongoEntityManager(this.queryRunner.manager)) {\n                const manager = this.queryRunner.manager;\n                await manager.delete(subjects[0].metadata.target, deleteMaps);\n            }\n            else {\n                // for tree tables we execute additional queries\n                switch (subjects[0].metadata.treeType) {\n                    case \"nested-set\":\n                        await new NestedSetSubjectExecutor(this.queryRunner).remove(subjects);\n                        break;\n                    case \"closure-table\":\n                        await new ClosureSubjectExecutor(this.queryRunner).remove(subjects);\n                        break;\n                }\n                // here we execute our deletion query\n                // we don't need to specify entities and set update entity to true since the only thing query builder\n                // will do for use is a primary keys deletion which is handled by us later once persistence is finished\n                // also, we disable listeners because we call them on our own in persistence layer\n                await this.queryRunner.manager\n                    .createQueryBuilder()\n                    .delete()\n                    .from(subjects[0].metadata.target)\n                    .where(deleteMaps)\n                    .callListeners(false)\n                    .execute();\n            }\n        }\n    }\n    cloneMongoSubjectEntity(subject) {\n        const target = {};\n        if (subject.entity) {\n            for (const column of subject.metadata.columns) {\n                OrmUtils.mergeDeep(target, column.getEntityValueMap(subject.entity));\n            }\n        }\n        return target;\n    }\n    /**\n     * Soft-removes all given subjects in the database.\n     */\n    async executeSoftRemoveOperations() {\n        await Promise.all(this.softRemoveSubjects.map(async (subject) => {\n            if (!subject.identifier)\n                throw new SubjectWithoutIdentifierError(subject);\n            let updateResult;\n            // for mongodb we have a bit different updation logic\n            if (InstanceChecker.isMongoEntityManager(this.queryRunner.manager)) {\n                const partialEntity = this.cloneMongoSubjectEntity(subject);\n                if (subject.metadata.objectIdColumn &&\n                    subject.metadata.objectIdColumn.propertyName) {\n                    delete partialEntity[subject.metadata.objectIdColumn.propertyName];\n                }\n                if (subject.metadata.createDateColumn &&\n                    subject.metadata.createDateColumn.propertyName) {\n                    delete partialEntity[subject.metadata.createDateColumn.propertyName];\n                }\n                if (subject.metadata.updateDateColumn &&\n                    subject.metadata.updateDateColumn.propertyName) {\n                    partialEntity[subject.metadata.updateDateColumn.propertyName] = new Date();\n                }\n                if (subject.metadata.deleteDateColumn &&\n                    subject.metadata.deleteDateColumn.propertyName) {\n                    partialEntity[subject.metadata.deleteDateColumn.propertyName] = new Date();\n                }\n                const manager = this.queryRunner\n                    .manager;\n                updateResult = await manager.update(subject.metadata.target, subject.identifier, partialEntity);\n            }\n            else {\n                // here we execute our soft-deletion query\n                // we need to enable entity soft-deletion because we update a subject identifier\n                // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n                // also, we disable listeners because we call them on our own in persistence layer\n                const softDeleteQueryBuilder = this.queryRunner.manager\n                    .createQueryBuilder()\n                    .softDelete()\n                    .from(subject.metadata.target)\n                    .updateEntity(this.options && this.options.reload === false\n                    ? false\n                    : true)\n                    .callListeners(false);\n                if (subject.entity) {\n                    softDeleteQueryBuilder.whereEntity(subject.identifier);\n                }\n                else {\n                    // in this case identifier is just conditions object to update by\n                    softDeleteQueryBuilder.where(subject.identifier);\n                }\n                updateResult = await softDeleteQueryBuilder.execute();\n            }\n            subject.generatedMap = updateResult.generatedMaps[0];\n            if (subject.generatedMap) {\n                subject.metadata.columns.forEach((column) => {\n                    const value = column.getEntityValue(subject.generatedMap);\n                    if (value !== undefined && value !== null) {\n                        const preparedValue = this.queryRunner.connection.driver.prepareHydratedValue(value, column);\n                        column.setEntityValue(subject.generatedMap, preparedValue);\n                    }\n                });\n            }\n            // experiments, remove probably, need to implement tree tables children removal\n            // if (subject.updatedRelationMaps.length > 0) {\n            //     await Promise.all(subject.updatedRelationMaps.map(async updatedRelation => {\n            //         if (!updatedRelation.relation.isTreeParent) return;\n            //         if (!updatedRelation.value !== null) return;\n            //\n            //         if (subject.metadata.treeType === \"closure-table\") {\n            //             await new ClosureSubjectExecutor(this.queryRunner).deleteChildrenOf(subject);\n            //         }\n            //     }));\n            // }\n        }));\n    }\n    /**\n     * Recovers all given subjects in the database.\n     */\n    async executeRecoverOperations() {\n        await Promise.all(this.recoverSubjects.map(async (subject) => {\n            if (!subject.identifier)\n                throw new SubjectWithoutIdentifierError(subject);\n            let updateResult;\n            // for mongodb we have a bit different updation logic\n            if (InstanceChecker.isMongoEntityManager(this.queryRunner.manager)) {\n                const partialEntity = this.cloneMongoSubjectEntity(subject);\n                if (subject.metadata.objectIdColumn &&\n                    subject.metadata.objectIdColumn.propertyName) {\n                    delete partialEntity[subject.metadata.objectIdColumn.propertyName];\n                }\n                if (subject.metadata.createDateColumn &&\n                    subject.metadata.createDateColumn.propertyName) {\n                    delete partialEntity[subject.metadata.createDateColumn.propertyName];\n                }\n                if (subject.metadata.updateDateColumn &&\n                    subject.metadata.updateDateColumn.propertyName) {\n                    partialEntity[subject.metadata.updateDateColumn.propertyName] = new Date();\n                }\n                if (subject.metadata.deleteDateColumn &&\n                    subject.metadata.deleteDateColumn.propertyName) {\n                    partialEntity[subject.metadata.deleteDateColumn.propertyName] = null;\n                }\n                const manager = this.queryRunner\n                    .manager;\n                updateResult = await manager.update(subject.metadata.target, subject.identifier, partialEntity);\n            }\n            else {\n                // here we execute our restory query\n                // we need to enable entity restory because we update a subject identifier\n                // which is not same object as our entity that's why we don't need to worry about our entity to get dirty\n                // also, we disable listeners because we call them on our own in persistence layer\n                const softDeleteQueryBuilder = this.queryRunner.manager\n                    .createQueryBuilder()\n                    .restore()\n                    .from(subject.metadata.target)\n                    .updateEntity(this.options && this.options.reload === false\n                    ? false\n                    : true)\n                    .callListeners(false);\n                if (subject.entity) {\n                    softDeleteQueryBuilder.whereEntity(subject.identifier);\n                }\n                else {\n                    // in this case identifier is just conditions object to update by\n                    softDeleteQueryBuilder.where(subject.identifier);\n                }\n                updateResult = await softDeleteQueryBuilder.execute();\n            }\n            subject.generatedMap = updateResult.generatedMaps[0];\n            if (subject.generatedMap) {\n                subject.metadata.columns.forEach((column) => {\n                    const value = column.getEntityValue(subject.generatedMap);\n                    if (value !== undefined && value !== null) {\n                        const preparedValue = this.queryRunner.connection.driver.prepareHydratedValue(value, column);\n                        column.setEntityValue(subject.generatedMap, preparedValue);\n                    }\n                });\n            }\n            // experiments, remove probably, need to implement tree tables children removal\n            // if (subject.updatedRelationMaps.length > 0) {\n            //     await Promise.all(subject.updatedRelationMaps.map(async updatedRelation => {\n            //         if (!updatedRelation.relation.isTreeParent) return;\n            //         if (!updatedRelation.value !== null) return;\n            //\n            //         if (subject.metadata.treeType === \"closure-table\") {\n            //             await new ClosureSubjectExecutor(this.queryRunner).deleteChildrenOf(subject);\n            //         }\n            //     }));\n            // }\n        }));\n    }\n    /**\n     * Updates all special columns of the saving entities (create date, update date, version, etc.).\n     * Also updates nullable columns and columns with default values.\n     */\n    updateSpecialColumnsInPersistedEntities() {\n        // update inserted entity properties\n        if (this.insertSubjects.length)\n            this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.insertSubjects);\n        // update updated entity properties\n        if (this.updateSubjects.length)\n            this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.updateSubjects);\n        // update soft-removed entity properties\n        if (this.softRemoveSubjects.length)\n            this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.softRemoveSubjects);\n        // update recovered entity properties\n        if (this.recoverSubjects.length)\n            this.updateSpecialColumnsInInsertedAndUpdatedEntities(this.recoverSubjects);\n        // remove ids from the entities that were removed\n        if (this.removeSubjects.length) {\n            this.removeSubjects.forEach((subject) => {\n                if (!subject.entity)\n                    return;\n                subject.metadata.primaryColumns.forEach((primaryColumn) => {\n                    primaryColumn.setEntityValue(subject.entity, undefined);\n                });\n            });\n        }\n        // other post-persist updations\n        this.allSubjects.forEach((subject) => {\n            if (!subject.entity)\n                return;\n            subject.metadata.relationIds.forEach((relationId) => {\n                relationId.setValue(subject.entity);\n            });\n            // mongo _id remove\n            if (InstanceChecker.isMongoEntityManager(this.queryRunner.manager)) {\n                if (subject.metadata.objectIdColumn &&\n                    subject.metadata.objectIdColumn.databaseName &&\n                    subject.metadata.objectIdColumn.databaseName !==\n                        subject.metadata.objectIdColumn.propertyName) {\n                    delete subject.entity[subject.metadata.objectIdColumn.databaseName];\n                }\n            }\n        });\n    }\n    /**\n     * Updates all special columns of the saving entities (create date, update date, version, etc.).\n     * Also updates nullable columns and columns with default values.\n     */\n    updateSpecialColumnsInInsertedAndUpdatedEntities(subjects) {\n        subjects.forEach((subject) => {\n            if (!subject.entity)\n                return;\n            // set values to \"null\" for nullable columns that did not have values\n            subject.metadata.columns.forEach((column) => {\n                // if table inheritance is used make sure this column is not child's column\n                if (subject.metadata.childEntityMetadatas.length > 0 &&\n                    subject.metadata.childEntityMetadatas\n                        .map((metadata) => metadata.target)\n                        .indexOf(column.target) !== -1)\n                    return;\n                // entities does not have virtual columns\n                if (column.isVirtual)\n                    return;\n                // update nullable columns\n                if (column.isNullable) {\n                    const columnValue = column.getEntityValue(subject.entity);\n                    if (columnValue === undefined)\n                        column.setEntityValue(subject.entity, null);\n                }\n                // update relational columns\n                if (subject.updatedRelationMaps.length > 0) {\n                    subject.updatedRelationMaps.forEach((updatedRelationMap) => {\n                        updatedRelationMap.relation.joinColumns.forEach((column) => {\n                            if (column.isVirtual === true)\n                                return;\n                            column.setEntityValue(subject.entity, ObjectUtils.isObject(updatedRelationMap.value)\n                                ? column.referencedColumn.getEntityValue(updatedRelationMap.value)\n                                : updatedRelationMap.value);\n                        });\n                    });\n                }\n            });\n            // merge into entity all generated values returned by a database\n            if (subject.generatedMap)\n                this.queryRunner.manager.merge(subject.metadata.target, subject.entity, subject.generatedMap);\n        });\n    }\n    /**\n     * Groups subjects by metadata names (by tables) to make bulk insertions and deletions possible.\n     * However there are some limitations with bulk insertions of data into tables with generated (increment) columns\n     * in some drivers. Some drivers like mysql and sqlite does not support returning multiple generated columns\n     * after insertion and can only return a single generated column value, that's why its not possible to do bulk insertion,\n     * because it breaks insertion result's generatedMap and leads to problems when this subject is used in other subjects saves.\n     * That's why we only support bulking in junction tables for those drivers.\n     *\n     * Other drivers like postgres and sql server support RETURNING / OUTPUT statement which allows to return generated\n     * id for each inserted row, that's why bulk insertion is not limited to junction tables in there.\n     */\n    groupBulkSubjects(subjects, type) {\n        const group = {};\n        const keys = [];\n        const hasReturningDependColumns = subjects.some((subject) => {\n            return subject.metadata.getInsertionReturningColumns().length > 0;\n        });\n        const groupingAllowed = type === \"delete\" ||\n            this.queryRunner.connection.driver.isReturningSqlSupported(\"insert\") ||\n            hasReturningDependColumns === false;\n        subjects.forEach((subject, index) => {\n            const key = groupingAllowed || subject.metadata.isJunction\n                ? subject.metadata.name\n                : subject.metadata.name + \"_\" + index;\n            if (!group[key]) {\n                group[key] = [subject];\n                keys.push(key);\n            }\n            else {\n                group[key].push(subject);\n            }\n        });\n        return [group, keys];\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}