{"ast":null,"code":"import { EntityMetadata } from \"./EntityMetadata\";\nimport { TypeORMError } from \"../error\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\n/**\n * Contains all information about some entity's relation.\n */\nexport class RelationMetadata {\n  // ---------------------------------------------------------------------\n  // Constructor\n  // ---------------------------------------------------------------------\n  constructor(options) {\n    /**\n     * Indicates if this is a parent (can be only many-to-one relation) relation in the tree tables.\n     */\n    this.isTreeParent = false;\n    /**\n     * Indicates if this is a children (can be only one-to-many relation) relation in the tree tables.\n     */\n    this.isTreeChildren = false;\n    /**\n     * Indicates if this relation's column is a primary key.\n     * Can be used only for many-to-one and owner one-to-one relations.\n     */\n    this.isPrimary = false;\n    /**\n     * Indicates if this relation is lazily loaded.\n     */\n    this.isLazy = false;\n    /**\n     * Indicates if this relation is eagerly loaded.\n     */\n    this.isEager = false;\n    /**\n     * Indicates if persistence is enabled for the relation.\n     * By default its enabled, but if you want to avoid any changes in the relation to be reflected in the database you can disable it.\n     * If its disabled you can only change a relation from inverse side of a relation or using relation query builder functionality.\n     * This is useful for performance optimization since its disabling avoid multiple extra queries during entity save.\n     */\n    this.persistenceEnabled = true;\n    /**\n     * If set to true then related objects are allowed to be inserted to the database.\n     */\n    this.isCascadeInsert = false;\n    /**\n     * If set to true then related objects are allowed to be updated in the database.\n     */\n    this.isCascadeUpdate = false;\n    /**\n     * If set to true then related objects are allowed to be remove from the database.\n     */\n    this.isCascadeRemove = false;\n    /**\n     * If set to true then related objects are allowed to be soft-removed from the database.\n     */\n    this.isCascadeSoftRemove = false;\n    /**\n     * If set to true then related objects are allowed to be recovered from the database.\n     */\n    this.isCascadeRecover = false;\n    /**\n     * Indicates if relation column value can be nullable or not.\n     */\n    this.isNullable = true;\n    /**\n     * Indicates whether foreign key constraints will be created for join columns.\n     * Can be used only for many-to-one and owner one-to-one relations.\n     * Defaults to true.\n     */\n    this.createForeignKeyConstraints = true;\n    /**\n     * Indicates if this side is an owner of this relation.\n     */\n    this.isOwning = false;\n    /**\n     * Checks if this relation's type is \"one-to-one\".\n     */\n    this.isOneToOne = false;\n    /**\n     * Checks if this relation is owner side of the \"one-to-one\" relation.\n     * Owner side means this side of relation has a join column in the table.\n     */\n    this.isOneToOneOwner = false;\n    /**\n     * Checks if this relation has a join column (e.g. is it many-to-one or one-to-one owner side).\n     */\n    this.isWithJoinColumn = false;\n    /**\n     * Checks if this relation is NOT owner side of the \"one-to-one\" relation.\n     * NOT owner side means this side of relation does not have a join column in the table.\n     */\n    this.isOneToOneNotOwner = false;\n    /**\n     * Checks if this relation's type is \"one-to-many\".\n     */\n    this.isOneToMany = false;\n    /**\n     * Checks if this relation's type is \"many-to-one\".\n     */\n    this.isManyToOne = false;\n    /**\n     * Checks if this relation's type is \"many-to-many\".\n     */\n    this.isManyToMany = false;\n    /**\n     * Checks if this relation's type is \"many-to-many\", and is owner side of the relationship.\n     * Owner side means this side of relation has a join table.\n     */\n    this.isManyToManyOwner = false;\n    /**\n     * Checks if this relation's type is \"many-to-many\", and is NOT owner side of the relationship.\n     * Not owner side means this side of relation does not have a join table.\n     */\n    this.isManyToManyNotOwner = false;\n    /**\n     * Foreign keys created for this relation.\n     */\n    this.foreignKeys = [];\n    /**\n     * Join table columns.\n     * Join columns can be obtained only from owner side of the relation.\n     * From non-owner side of the relation join columns will be empty.\n     * If this relation is a many-to-one/one-to-one then it takes join columns from the current entity.\n     * If this relation is many-to-many then it takes all owner join columns from the junction entity.\n     */\n    this.joinColumns = [];\n    /**\n     * Inverse join table columns.\n     * Inverse join columns are supported only for many-to-many relations\n     * and can be obtained only from owner side of the relation.\n     * From non-owner side of the relation join columns will be undefined.\n     */\n    this.inverseJoinColumns = [];\n    this.entityMetadata = options.entityMetadata;\n    this.embeddedMetadata = options.embeddedMetadata;\n    const args = options.args;\n    this.target = args.target;\n    this.propertyName = args.propertyName;\n    this.relationType = args.relationType;\n    if (args.inverseSideProperty) this.givenInverseSidePropertyFactory = args.inverseSideProperty;\n    this.isLazy = args.isLazy || false;\n    // this.isCascadeInsert = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf(\"insert\") !== -1);\n    // this.isCascadeUpdate = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf(\"update\") !== -1);\n    // this.isCascadeRemove = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf(\"remove\") !== -1);\n    // this.isCascadeSoftRemove = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf(\"soft-remove\") !== -1);\n    // this.isCascadeRecover = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf(\"recover\") !== -1);\n    this.isCascadeInsert = args.options.cascade === true || Array.isArray(args.options.cascade) && args.options.cascade.indexOf(\"insert\") !== -1;\n    this.isCascadeUpdate = args.options.cascade === true || Array.isArray(args.options.cascade) && args.options.cascade.indexOf(\"update\") !== -1;\n    this.isCascadeRemove = args.options.cascade === true || Array.isArray(args.options.cascade) && args.options.cascade.indexOf(\"remove\") !== -1;\n    this.isCascadeSoftRemove = args.options.cascade === true || Array.isArray(args.options.cascade) && args.options.cascade.indexOf(\"soft-remove\") !== -1;\n    this.isCascadeRecover = args.options.cascade === true || Array.isArray(args.options.cascade) && args.options.cascade.indexOf(\"recover\") !== -1;\n    // this.isPrimary = args.options.primary || false;\n    this.isNullable = args.options.nullable === false || this.isPrimary ? false : true;\n    this.onDelete = args.options.onDelete;\n    this.onUpdate = args.options.onUpdate;\n    this.deferrable = args.options.deferrable;\n    this.createForeignKeyConstraints = args.options.createForeignKeyConstraints === false ? false : true;\n    this.isEager = args.options.eager || false;\n    this.persistenceEnabled = args.options.persistence === false ? false : true;\n    this.orphanedRowAction = args.options.orphanedRowAction || \"nullify\";\n    this.isTreeParent = args.isTreeParent || false;\n    this.isTreeChildren = args.isTreeChildren || false;\n    if (typeof args.type === \"function\") {\n      this.type = typeof args.type === \"function\" ? args.type() : args.type;\n    } else if (InstanceChecker.isEntitySchema(args.type)) {\n      this.type = args.type.options.name;\n    } else if (ObjectUtils.isObject(args.type) && typeof args.type.name === \"string\") {\n      this.type = args.type.name;\n    } else {\n      this.type = args.type;\n    }\n    this.isOneToOne = this.relationType === \"one-to-one\";\n    this.isOneToMany = this.relationType === \"one-to-many\";\n    this.isManyToOne = this.relationType === \"many-to-one\";\n    this.isManyToMany = this.relationType === \"many-to-many\";\n    this.isOneToOneNotOwner = this.isOneToOne ? true : false;\n    this.isManyToManyNotOwner = this.isManyToMany ? true : false;\n  }\n  // ---------------------------------------------------------------------\n  // Public Methods\n  // ---------------------------------------------------------------------\n  /**\n   * Creates join column ids map from the given related entity ids array.\n   */\n  getRelationIdMap(entity) {\n    const joinColumns = this.isOwning ? this.joinColumns : this.inverseRelation.joinColumns;\n    const referencedColumns = joinColumns.map(joinColumn => joinColumn.referencedColumn);\n    // console.log(\"entity\", entity);\n    // console.log(\"referencedColumns\", referencedColumns);\n    return EntityMetadata.getValueMap(entity, referencedColumns);\n  }\n  /**\n   * Ensures that given object is an entity id map.\n   * If given id is an object then it means its already id map.\n   * If given id isn't an object then it means its a value of the id column\n   * and it creates a new id map with this value and name of the primary column.\n   */\n  ensureRelationIdMap(id) {\n    if (ObjectUtils.isObject(id)) return id;\n    const joinColumns = this.isOwning ? this.joinColumns : this.inverseRelation.joinColumns;\n    const referencedColumns = joinColumns.map(joinColumn => joinColumn.referencedColumn);\n    if (referencedColumns.length > 1) throw new TypeORMError(`Cannot create relation id map for a single value because relation contains multiple referenced columns.`);\n    return referencedColumns[0].createValueMap(id);\n  }\n  /**\n   * Extracts column value from the given entity.\n   * If column is in embedded (or recursive embedded) it extracts its value from there.\n   */\n  getEntityValue(entity, getLazyRelationsPromiseValue = false) {\n    if (entity === null || entity === undefined) return undefined;\n    // extract column value from embeddeds of entity if column is in embedded\n    if (this.embeddedMetadata) {\n      // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n      // we need to get value of \"id\" column from the post real entity object\n      // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n      const propertyNames = [...this.embeddedMetadata.parentPropertyNames];\n      // next we need to access post[data][information][counters][this.propertyName] to get column value from the counters\n      // this recursive function takes array of generated property names and gets the post[data][information][counters] embed\n      const extractEmbeddedColumnValue = (propertyNames, value) => {\n        const propertyName = propertyNames.shift();\n        if (propertyName) {\n          if (value[propertyName]) {\n            return extractEmbeddedColumnValue(propertyNames, value[propertyName]);\n          }\n          return undefined;\n        }\n        return value;\n      };\n      // once we get nested embed object we get its column, e.g. post[data][information][counters][this.propertyName]\n      const embeddedObject = extractEmbeddedColumnValue(propertyNames, entity);\n      if (this.isLazy) {\n        if (embeddedObject[\"__\" + this.propertyName + \"__\"] !== undefined) return embeddedObject[\"__\" + this.propertyName + \"__\"];\n        if (getLazyRelationsPromiseValue === true) return embeddedObject[this.propertyName];\n        return undefined;\n      }\n      return embeddedObject ? embeddedObject[this.isLazy ? \"__\" + this.propertyName + \"__\" : this.propertyName] : undefined;\n    } else {\n      // no embeds - no problems. Simply return column name by property name of the entity\n      if (this.isLazy) {\n        if (entity[\"__\" + this.propertyName + \"__\"] !== undefined) return entity[\"__\" + this.propertyName + \"__\"];\n        if (getLazyRelationsPromiseValue === true) return entity[this.propertyName];\n        return undefined;\n      }\n      return entity[this.propertyName];\n    }\n  }\n  /**\n   * Sets given entity's relation's value.\n   * Using of this method helps to set entity relation's value of the lazy and non-lazy relations.\n   *\n   * If merge is set to true, it merges given value into currently\n   */\n  setEntityValue(entity, value) {\n    const propertyName = this.isLazy ? \"__\" + this.propertyName + \"__\" : this.propertyName;\n    if (this.embeddedMetadata) {\n      // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n      const extractEmbeddedColumnValue = (embeddedMetadatas, map) => {\n        // if (!object[embeddedMetadata.propertyName])\n        //     object[embeddedMetadata.propertyName] = embeddedMetadata.create();\n        const embeddedMetadata = embeddedMetadatas.shift();\n        if (embeddedMetadata) {\n          if (!map[embeddedMetadata.propertyName]) map[embeddedMetadata.propertyName] = embeddedMetadata.create();\n          extractEmbeddedColumnValue(embeddedMetadatas, map[embeddedMetadata.propertyName]);\n          return map;\n        }\n        map[propertyName] = value;\n        return map;\n      };\n      return extractEmbeddedColumnValue([...this.embeddedMetadata.embeddedMetadataTree], entity);\n    } else {\n      entity[propertyName] = value;\n    }\n  }\n  /**\n   * Creates entity id map from the given entity ids array.\n   */\n  createValueMap(value) {\n    // extract column value from embeds of entity if column is in embedded\n    if (this.embeddedMetadata) {\n      // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n      // we need to get value of \"id\" column from the post real entity object and return it in a\n      // { data: { information: { counters: { id: ... } } } } format\n      // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n      const propertyNames = [...this.embeddedMetadata.parentPropertyNames];\n      // now need to access post[data][information][counters] to get column value from the counters\n      // and on each step we need to create complex literal object, e.g. first { data },\n      // then { data: { information } }, then { data: { information: { counters } } },\n      // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }\n      // this recursive function helps doing that\n      const extractEmbeddedColumnValue = (propertyNames, map) => {\n        const propertyName = propertyNames.shift();\n        if (propertyName) {\n          map[propertyName] = {};\n          extractEmbeddedColumnValue(propertyNames, map[propertyName]);\n          return map;\n        }\n        map[this.propertyName] = value;\n        return map;\n      };\n      return extractEmbeddedColumnValue(propertyNames, {});\n    } else {\n      // no embeds - no problems. Simply return column property name and its value of the entity\n      return {\n        [this.propertyName]: value\n      };\n    }\n  }\n  // ---------------------------------------------------------------------\n  // Builder Methods\n  // ---------------------------------------------------------------------\n  /**\n   * Builds some depend relation metadata properties.\n   * This builder method should be used only after embedded metadata tree was build.\n   */\n  build() {\n    this.propertyPath = this.buildPropertyPath();\n  }\n  /**\n   * Registers given foreign keys in the relation.\n   * This builder method should be used to register foreign key in the relation.\n   */\n  registerForeignKeys(...foreignKeys) {\n    this.foreignKeys.push(...foreignKeys);\n  }\n  /**\n   * Registers given join columns in the relation.\n   * This builder method should be used to register join column in the relation.\n   */\n  registerJoinColumns(joinColumns = [], inverseJoinColumns = []) {\n    this.joinColumns = joinColumns;\n    this.inverseJoinColumns = inverseJoinColumns;\n    this.isOwning = this.isManyToOne || (this.isManyToMany || this.isOneToOne) && this.joinColumns.length > 0;\n    this.isOneToOneOwner = this.isOneToOne && this.isOwning;\n    this.isOneToOneNotOwner = this.isOneToOne && !this.isOwning;\n    this.isManyToManyOwner = this.isManyToMany && this.isOwning;\n    this.isManyToManyNotOwner = this.isManyToMany && !this.isOwning;\n    this.isWithJoinColumn = this.isManyToOne || this.isOneToOneOwner;\n  }\n  /**\n   * Registers a given junction entity metadata.\n   * This builder method can be called after junction entity metadata for the many-to-many relation was created.\n   */\n  registerJunctionEntityMetadata(junctionEntityMetadata) {\n    this.junctionEntityMetadata = junctionEntityMetadata;\n    this.joinTableName = junctionEntityMetadata.tableName;\n    if (this.inverseRelation) {\n      this.inverseRelation.junctionEntityMetadata = junctionEntityMetadata;\n      this.joinTableName = junctionEntityMetadata.tableName;\n    }\n  }\n  /**\n   * Builds inverse side property path based on given inverse side property factory.\n   * This builder method should be used only after properties map of the inverse entity metadata was build.\n   */\n  buildInverseSidePropertyPath() {\n    if (this.givenInverseSidePropertyFactory) {\n      const ownerEntityPropertiesMap = this.inverseEntityMetadata.propertiesMap;\n      if (typeof this.givenInverseSidePropertyFactory === \"function\") return this.givenInverseSidePropertyFactory(ownerEntityPropertiesMap);\n      if (typeof this.givenInverseSidePropertyFactory === \"string\") return this.givenInverseSidePropertyFactory;\n    } else if (this.isTreeParent && this.entityMetadata.treeChildrenRelation) {\n      return this.entityMetadata.treeChildrenRelation.propertyName;\n    } else if (this.isTreeChildren && this.entityMetadata.treeParentRelation) {\n      return this.entityMetadata.treeParentRelation.propertyName;\n    }\n    return \"\";\n  }\n  /**\n   * Builds relation's property path based on its embedded tree.\n   */\n  buildPropertyPath() {\n    if (!this.embeddedMetadata || !this.embeddedMetadata.parentPropertyNames.length) return this.propertyName;\n    return this.embeddedMetadata.parentPropertyNames.join(\".\") + \".\" + this.propertyName;\n  }\n}","map":{"version":3,"names":["EntityMetadata","TypeORMError","ObjectUtils","InstanceChecker","RelationMetadata","constructor","options","isTreeParent","isTreeChildren","isPrimary","isLazy","isEager","persistenceEnabled","isCascadeInsert","isCascadeUpdate","isCascadeRemove","isCascadeSoftRemove","isCascadeRecover","isNullable","createForeignKeyConstraints","isOwning","isOneToOne","isOneToOneOwner","isWithJoinColumn","isOneToOneNotOwner","isOneToMany","isManyToOne","isManyToMany","isManyToManyOwner","isManyToManyNotOwner","foreignKeys","joinColumns","inverseJoinColumns","entityMetadata","embeddedMetadata","args","target","propertyName","relationType","inverseSideProperty","givenInverseSidePropertyFactory","cascade","Array","isArray","indexOf","nullable","onDelete","onUpdate","deferrable","eager","persistence","orphanedRowAction","type","isEntitySchema","name","isObject","getRelationIdMap","entity","inverseRelation","referencedColumns","map","joinColumn","referencedColumn","getValueMap","ensureRelationIdMap","id","length","createValueMap","getEntityValue","getLazyRelationsPromiseValue","undefined","propertyNames","parentPropertyNames","extractEmbeddedColumnValue","value","shift","embeddedObject","setEntityValue","embeddedMetadatas","create","embeddedMetadataTree","build","propertyPath","buildPropertyPath","registerForeignKeys","push","registerJoinColumns","registerJunctionEntityMetadata","junctionEntityMetadata","joinTableName","tableName","buildInverseSidePropertyPath","ownerEntityPropertiesMap","inverseEntityMetadata","propertiesMap","treeChildrenRelation","treeParentRelation","join"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/metadata/RelationMetadata.js"],"sourcesContent":["import { EntityMetadata } from \"./EntityMetadata\";\nimport { TypeORMError } from \"../error\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\n/**\n * Contains all information about some entity's relation.\n */\nexport class RelationMetadata {\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n    constructor(options) {\n        /**\n         * Indicates if this is a parent (can be only many-to-one relation) relation in the tree tables.\n         */\n        this.isTreeParent = false;\n        /**\n         * Indicates if this is a children (can be only one-to-many relation) relation in the tree tables.\n         */\n        this.isTreeChildren = false;\n        /**\n         * Indicates if this relation's column is a primary key.\n         * Can be used only for many-to-one and owner one-to-one relations.\n         */\n        this.isPrimary = false;\n        /**\n         * Indicates if this relation is lazily loaded.\n         */\n        this.isLazy = false;\n        /**\n         * Indicates if this relation is eagerly loaded.\n         */\n        this.isEager = false;\n        /**\n         * Indicates if persistence is enabled for the relation.\n         * By default its enabled, but if you want to avoid any changes in the relation to be reflected in the database you can disable it.\n         * If its disabled you can only change a relation from inverse side of a relation or using relation query builder functionality.\n         * This is useful for performance optimization since its disabling avoid multiple extra queries during entity save.\n         */\n        this.persistenceEnabled = true;\n        /**\n         * If set to true then related objects are allowed to be inserted to the database.\n         */\n        this.isCascadeInsert = false;\n        /**\n         * If set to true then related objects are allowed to be updated in the database.\n         */\n        this.isCascadeUpdate = false;\n        /**\n         * If set to true then related objects are allowed to be remove from the database.\n         */\n        this.isCascadeRemove = false;\n        /**\n         * If set to true then related objects are allowed to be soft-removed from the database.\n         */\n        this.isCascadeSoftRemove = false;\n        /**\n         * If set to true then related objects are allowed to be recovered from the database.\n         */\n        this.isCascadeRecover = false;\n        /**\n         * Indicates if relation column value can be nullable or not.\n         */\n        this.isNullable = true;\n        /**\n         * Indicates whether foreign key constraints will be created for join columns.\n         * Can be used only for many-to-one and owner one-to-one relations.\n         * Defaults to true.\n         */\n        this.createForeignKeyConstraints = true;\n        /**\n         * Indicates if this side is an owner of this relation.\n         */\n        this.isOwning = false;\n        /**\n         * Checks if this relation's type is \"one-to-one\".\n         */\n        this.isOneToOne = false;\n        /**\n         * Checks if this relation is owner side of the \"one-to-one\" relation.\n         * Owner side means this side of relation has a join column in the table.\n         */\n        this.isOneToOneOwner = false;\n        /**\n         * Checks if this relation has a join column (e.g. is it many-to-one or one-to-one owner side).\n         */\n        this.isWithJoinColumn = false;\n        /**\n         * Checks if this relation is NOT owner side of the \"one-to-one\" relation.\n         * NOT owner side means this side of relation does not have a join column in the table.\n         */\n        this.isOneToOneNotOwner = false;\n        /**\n         * Checks if this relation's type is \"one-to-many\".\n         */\n        this.isOneToMany = false;\n        /**\n         * Checks if this relation's type is \"many-to-one\".\n         */\n        this.isManyToOne = false;\n        /**\n         * Checks if this relation's type is \"many-to-many\".\n         */\n        this.isManyToMany = false;\n        /**\n         * Checks if this relation's type is \"many-to-many\", and is owner side of the relationship.\n         * Owner side means this side of relation has a join table.\n         */\n        this.isManyToManyOwner = false;\n        /**\n         * Checks if this relation's type is \"many-to-many\", and is NOT owner side of the relationship.\n         * Not owner side means this side of relation does not have a join table.\n         */\n        this.isManyToManyNotOwner = false;\n        /**\n         * Foreign keys created for this relation.\n         */\n        this.foreignKeys = [];\n        /**\n         * Join table columns.\n         * Join columns can be obtained only from owner side of the relation.\n         * From non-owner side of the relation join columns will be empty.\n         * If this relation is a many-to-one/one-to-one then it takes join columns from the current entity.\n         * If this relation is many-to-many then it takes all owner join columns from the junction entity.\n         */\n        this.joinColumns = [];\n        /**\n         * Inverse join table columns.\n         * Inverse join columns are supported only for many-to-many relations\n         * and can be obtained only from owner side of the relation.\n         * From non-owner side of the relation join columns will be undefined.\n         */\n        this.inverseJoinColumns = [];\n        this.entityMetadata = options.entityMetadata;\n        this.embeddedMetadata = options.embeddedMetadata;\n        const args = options.args;\n        this.target = args.target;\n        this.propertyName = args.propertyName;\n        this.relationType = args.relationType;\n        if (args.inverseSideProperty)\n            this.givenInverseSidePropertyFactory = args.inverseSideProperty;\n        this.isLazy = args.isLazy || false;\n        // this.isCascadeInsert = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf(\"insert\") !== -1);\n        // this.isCascadeUpdate = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf(\"update\") !== -1);\n        // this.isCascadeRemove = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf(\"remove\") !== -1);\n        // this.isCascadeSoftRemove = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf(\"soft-remove\") !== -1);\n        // this.isCascadeRecover = args.options.cascade === true || (args.options.cascade instanceof Array && args.options.cascade.indexOf(\"recover\") !== -1);\n        this.isCascadeInsert =\n            args.options.cascade === true ||\n                (Array.isArray(args.options.cascade) &&\n                    args.options.cascade.indexOf(\"insert\") !== -1);\n        this.isCascadeUpdate =\n            args.options.cascade === true ||\n                (Array.isArray(args.options.cascade) &&\n                    args.options.cascade.indexOf(\"update\") !== -1);\n        this.isCascadeRemove =\n            args.options.cascade === true ||\n                (Array.isArray(args.options.cascade) &&\n                    args.options.cascade.indexOf(\"remove\") !== -1);\n        this.isCascadeSoftRemove =\n            args.options.cascade === true ||\n                (Array.isArray(args.options.cascade) &&\n                    args.options.cascade.indexOf(\"soft-remove\") !== -1);\n        this.isCascadeRecover =\n            args.options.cascade === true ||\n                (Array.isArray(args.options.cascade) &&\n                    args.options.cascade.indexOf(\"recover\") !== -1);\n        // this.isPrimary = args.options.primary || false;\n        this.isNullable =\n            args.options.nullable === false || this.isPrimary ? false : true;\n        this.onDelete = args.options.onDelete;\n        this.onUpdate = args.options.onUpdate;\n        this.deferrable = args.options.deferrable;\n        this.createForeignKeyConstraints =\n            args.options.createForeignKeyConstraints === false ? false : true;\n        this.isEager = args.options.eager || false;\n        this.persistenceEnabled =\n            args.options.persistence === false ? false : true;\n        this.orphanedRowAction = args.options.orphanedRowAction || \"nullify\";\n        this.isTreeParent = args.isTreeParent || false;\n        this.isTreeChildren = args.isTreeChildren || false;\n        if (typeof args.type === \"function\") {\n            this.type =\n                typeof args.type === \"function\"\n                    ? args.type()\n                    : args.type;\n        }\n        else if (InstanceChecker.isEntitySchema(args.type)) {\n            this.type = args.type.options.name;\n        }\n        else if (ObjectUtils.isObject(args.type) &&\n            typeof args.type.name === \"string\") {\n            this.type = args.type.name;\n        }\n        else {\n            this.type = args.type;\n        }\n        this.isOneToOne = this.relationType === \"one-to-one\";\n        this.isOneToMany = this.relationType === \"one-to-many\";\n        this.isManyToOne = this.relationType === \"many-to-one\";\n        this.isManyToMany = this.relationType === \"many-to-many\";\n        this.isOneToOneNotOwner = this.isOneToOne ? true : false;\n        this.isManyToManyNotOwner = this.isManyToMany ? true : false;\n    }\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n    /**\n     * Creates join column ids map from the given related entity ids array.\n     */\n    getRelationIdMap(entity) {\n        const joinColumns = this.isOwning\n            ? this.joinColumns\n            : this.inverseRelation.joinColumns;\n        const referencedColumns = joinColumns.map((joinColumn) => joinColumn.referencedColumn);\n        // console.log(\"entity\", entity);\n        // console.log(\"referencedColumns\", referencedColumns);\n        return EntityMetadata.getValueMap(entity, referencedColumns);\n    }\n    /**\n     * Ensures that given object is an entity id map.\n     * If given id is an object then it means its already id map.\n     * If given id isn't an object then it means its a value of the id column\n     * and it creates a new id map with this value and name of the primary column.\n     */\n    ensureRelationIdMap(id) {\n        if (ObjectUtils.isObject(id))\n            return id;\n        const joinColumns = this.isOwning\n            ? this.joinColumns\n            : this.inverseRelation.joinColumns;\n        const referencedColumns = joinColumns.map((joinColumn) => joinColumn.referencedColumn);\n        if (referencedColumns.length > 1)\n            throw new TypeORMError(`Cannot create relation id map for a single value because relation contains multiple referenced columns.`);\n        return referencedColumns[0].createValueMap(id);\n    }\n    /**\n     * Extracts column value from the given entity.\n     * If column is in embedded (or recursive embedded) it extracts its value from there.\n     */\n    getEntityValue(entity, getLazyRelationsPromiseValue = false) {\n        if (entity === null || entity === undefined)\n            return undefined;\n        // extract column value from embeddeds of entity if column is in embedded\n        if (this.embeddedMetadata) {\n            // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n            // we need to get value of \"id\" column from the post real entity object\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const propertyNames = [...this.embeddedMetadata.parentPropertyNames];\n            // next we need to access post[data][information][counters][this.propertyName] to get column value from the counters\n            // this recursive function takes array of generated property names and gets the post[data][information][counters] embed\n            const extractEmbeddedColumnValue = (propertyNames, value) => {\n                const propertyName = propertyNames.shift();\n                if (propertyName) {\n                    if (value[propertyName]) {\n                        return extractEmbeddedColumnValue(propertyNames, value[propertyName]);\n                    }\n                    return undefined;\n                }\n                return value;\n            };\n            // once we get nested embed object we get its column, e.g. post[data][information][counters][this.propertyName]\n            const embeddedObject = extractEmbeddedColumnValue(propertyNames, entity);\n            if (this.isLazy) {\n                if (embeddedObject[\"__\" + this.propertyName + \"__\"] !==\n                    undefined)\n                    return embeddedObject[\"__\" + this.propertyName + \"__\"];\n                if (getLazyRelationsPromiseValue === true)\n                    return embeddedObject[this.propertyName];\n                return undefined;\n            }\n            return embeddedObject\n                ? embeddedObject[this.isLazy\n                    ? \"__\" + this.propertyName + \"__\"\n                    : this.propertyName]\n                : undefined;\n        }\n        else {\n            // no embeds - no problems. Simply return column name by property name of the entity\n            if (this.isLazy) {\n                if (entity[\"__\" + this.propertyName + \"__\"] !== undefined)\n                    return entity[\"__\" + this.propertyName + \"__\"];\n                if (getLazyRelationsPromiseValue === true)\n                    return entity[this.propertyName];\n                return undefined;\n            }\n            return entity[this.propertyName];\n        }\n    }\n    /**\n     * Sets given entity's relation's value.\n     * Using of this method helps to set entity relation's value of the lazy and non-lazy relations.\n     *\n     * If merge is set to true, it merges given value into currently\n     */\n    setEntityValue(entity, value) {\n        const propertyName = this.isLazy\n            ? \"__\" + this.propertyName + \"__\"\n            : this.propertyName;\n        if (this.embeddedMetadata) {\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const extractEmbeddedColumnValue = (embeddedMetadatas, map) => {\n                // if (!object[embeddedMetadata.propertyName])\n                //     object[embeddedMetadata.propertyName] = embeddedMetadata.create();\n                const embeddedMetadata = embeddedMetadatas.shift();\n                if (embeddedMetadata) {\n                    if (!map[embeddedMetadata.propertyName])\n                        map[embeddedMetadata.propertyName] =\n                            embeddedMetadata.create();\n                    extractEmbeddedColumnValue(embeddedMetadatas, map[embeddedMetadata.propertyName]);\n                    return map;\n                }\n                map[propertyName] = value;\n                return map;\n            };\n            return extractEmbeddedColumnValue([...this.embeddedMetadata.embeddedMetadataTree], entity);\n        }\n        else {\n            entity[propertyName] = value;\n        }\n    }\n    /**\n     * Creates entity id map from the given entity ids array.\n     */\n    createValueMap(value) {\n        // extract column value from embeds of entity if column is in embedded\n        if (this.embeddedMetadata) {\n            // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n            // we need to get value of \"id\" column from the post real entity object and return it in a\n            // { data: { information: { counters: { id: ... } } } } format\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const propertyNames = [...this.embeddedMetadata.parentPropertyNames];\n            // now need to access post[data][information][counters] to get column value from the counters\n            // and on each step we need to create complex literal object, e.g. first { data },\n            // then { data: { information } }, then { data: { information: { counters } } },\n            // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }\n            // this recursive function helps doing that\n            const extractEmbeddedColumnValue = (propertyNames, map) => {\n                const propertyName = propertyNames.shift();\n                if (propertyName) {\n                    map[propertyName] = {};\n                    extractEmbeddedColumnValue(propertyNames, map[propertyName]);\n                    return map;\n                }\n                map[this.propertyName] = value;\n                return map;\n            };\n            return extractEmbeddedColumnValue(propertyNames, {});\n        }\n        else {\n            // no embeds - no problems. Simply return column property name and its value of the entity\n            return { [this.propertyName]: value };\n        }\n    }\n    // ---------------------------------------------------------------------\n    // Builder Methods\n    // ---------------------------------------------------------------------\n    /**\n     * Builds some depend relation metadata properties.\n     * This builder method should be used only after embedded metadata tree was build.\n     */\n    build() {\n        this.propertyPath = this.buildPropertyPath();\n    }\n    /**\n     * Registers given foreign keys in the relation.\n     * This builder method should be used to register foreign key in the relation.\n     */\n    registerForeignKeys(...foreignKeys) {\n        this.foreignKeys.push(...foreignKeys);\n    }\n    /**\n     * Registers given join columns in the relation.\n     * This builder method should be used to register join column in the relation.\n     */\n    registerJoinColumns(joinColumns = [], inverseJoinColumns = []) {\n        this.joinColumns = joinColumns;\n        this.inverseJoinColumns = inverseJoinColumns;\n        this.isOwning =\n            this.isManyToOne ||\n                ((this.isManyToMany || this.isOneToOne) &&\n                    this.joinColumns.length > 0);\n        this.isOneToOneOwner = this.isOneToOne && this.isOwning;\n        this.isOneToOneNotOwner = this.isOneToOne && !this.isOwning;\n        this.isManyToManyOwner = this.isManyToMany && this.isOwning;\n        this.isManyToManyNotOwner = this.isManyToMany && !this.isOwning;\n        this.isWithJoinColumn = this.isManyToOne || this.isOneToOneOwner;\n    }\n    /**\n     * Registers a given junction entity metadata.\n     * This builder method can be called after junction entity metadata for the many-to-many relation was created.\n     */\n    registerJunctionEntityMetadata(junctionEntityMetadata) {\n        this.junctionEntityMetadata = junctionEntityMetadata;\n        this.joinTableName = junctionEntityMetadata.tableName;\n        if (this.inverseRelation) {\n            this.inverseRelation.junctionEntityMetadata = junctionEntityMetadata;\n            this.joinTableName = junctionEntityMetadata.tableName;\n        }\n    }\n    /**\n     * Builds inverse side property path based on given inverse side property factory.\n     * This builder method should be used only after properties map of the inverse entity metadata was build.\n     */\n    buildInverseSidePropertyPath() {\n        if (this.givenInverseSidePropertyFactory) {\n            const ownerEntityPropertiesMap = this.inverseEntityMetadata.propertiesMap;\n            if (typeof this.givenInverseSidePropertyFactory === \"function\")\n                return this.givenInverseSidePropertyFactory(ownerEntityPropertiesMap);\n            if (typeof this.givenInverseSidePropertyFactory === \"string\")\n                return this.givenInverseSidePropertyFactory;\n        }\n        else if (this.isTreeParent &&\n            this.entityMetadata.treeChildrenRelation) {\n            return this.entityMetadata.treeChildrenRelation.propertyName;\n        }\n        else if (this.isTreeChildren &&\n            this.entityMetadata.treeParentRelation) {\n            return this.entityMetadata.treeParentRelation.propertyName;\n        }\n        return \"\";\n    }\n    /**\n     * Builds relation's property path based on its embedded tree.\n     */\n    buildPropertyPath() {\n        if (!this.embeddedMetadata ||\n            !this.embeddedMetadata.parentPropertyNames.length)\n            return this.propertyName;\n        return (this.embeddedMetadata.parentPropertyNames.join(\".\") +\n            \".\" +\n            this.propertyName);\n    }\n}\n\n"],"mappings":"AAAA,SAASA,cAAc,QAAQ,kBAAkB;AACjD,SAASC,YAAY,QAAQ,UAAU;AACvC,SAASC,WAAW,QAAQ,qBAAqB;AACjD,SAASC,eAAe,QAAQ,yBAAyB;AACzD;AACA;AACA;AACA,OAAO,MAAMC,gBAAgB,CAAC;EAC1B;EACA;EACA;EACAC,WAAWA,CAACC,OAAO,EAAE;IACjB;AACR;AACA;IACQ,IAAI,CAACC,YAAY,GAAG,KAAK;IACzB;AACR;AACA;IACQ,IAAI,CAACC,cAAc,GAAG,KAAK;IAC3B;AACR;AACA;AACA;IACQ,IAAI,CAACC,SAAS,GAAG,KAAK;IACtB;AACR;AACA;IACQ,IAAI,CAACC,MAAM,GAAG,KAAK;IACnB;AACR;AACA;IACQ,IAAI,CAACC,OAAO,GAAG,KAAK;IACpB;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,kBAAkB,GAAG,IAAI;IAC9B;AACR;AACA;IACQ,IAAI,CAACC,eAAe,GAAG,KAAK;IAC5B;AACR;AACA;IACQ,IAAI,CAACC,eAAe,GAAG,KAAK;IAC5B;AACR;AACA;IACQ,IAAI,CAACC,eAAe,GAAG,KAAK;IAC5B;AACR;AACA;IACQ,IAAI,CAACC,mBAAmB,GAAG,KAAK;IAChC;AACR;AACA;IACQ,IAAI,CAACC,gBAAgB,GAAG,KAAK;IAC7B;AACR;AACA;IACQ,IAAI,CAACC,UAAU,GAAG,IAAI;IACtB;AACR;AACA;AACA;AACA;IACQ,IAAI,CAACC,2BAA2B,GAAG,IAAI;IACvC;AACR;AACA;IACQ,IAAI,CAACC,QAAQ,GAAG,KAAK;IACrB;AACR;AACA;IACQ,IAAI,CAACC,UAAU,GAAG,KAAK;IACvB;AACR;AACA;AACA;IACQ,IAAI,CAACC,eAAe,GAAG,KAAK;IAC5B;AACR;AACA;IACQ,IAAI,CAACC,gBAAgB,GAAG,KAAK;IAC7B;AACR;AACA;AACA;IACQ,IAAI,CAACC,kBAAkB,GAAG,KAAK;IAC/B;AACR;AACA;IACQ,IAAI,CAACC,WAAW,GAAG,KAAK;IACxB;AACR;AACA;IACQ,IAAI,CAACC,WAAW,GAAG,KAAK;IACxB;AACR;AACA;IACQ,IAAI,CAACC,YAAY,GAAG,KAAK;IACzB;AACR;AACA;AACA;IACQ,IAAI,CAACC,iBAAiB,GAAG,KAAK;IAC9B;AACR;AACA;AACA;IACQ,IAAI,CAACC,oBAAoB,GAAG,KAAK;IACjC;AACR;AACA;IACQ,IAAI,CAACC,WAAW,GAAG,EAAE;IACrB;AACR;AACA;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,WAAW,GAAG,EAAE;IACrB;AACR;AACA;AACA;AACA;AACA;IACQ,IAAI,CAACC,kBAAkB,GAAG,EAAE;IAC5B,IAAI,CAACC,cAAc,GAAG3B,OAAO,CAAC2B,cAAc;IAC5C,IAAI,CAACC,gBAAgB,GAAG5B,OAAO,CAAC4B,gBAAgB;IAChD,MAAMC,IAAI,GAAG7B,OAAO,CAAC6B,IAAI;IACzB,IAAI,CAACC,MAAM,GAAGD,IAAI,CAACC,MAAM;IACzB,IAAI,CAACC,YAAY,GAAGF,IAAI,CAACE,YAAY;IACrC,IAAI,CAACC,YAAY,GAAGH,IAAI,CAACG,YAAY;IACrC,IAAIH,IAAI,CAACI,mBAAmB,EACxB,IAAI,CAACC,+BAA+B,GAAGL,IAAI,CAACI,mBAAmB;IACnE,IAAI,CAAC7B,MAAM,GAAGyB,IAAI,CAACzB,MAAM,IAAI,KAAK;IAClC;IACA;IACA;IACA;IACA;IACA,IAAI,CAACG,eAAe,GAChBsB,IAAI,CAAC7B,OAAO,CAACmC,OAAO,KAAK,IAAI,IACxBC,KAAK,CAACC,OAAO,CAACR,IAAI,CAAC7B,OAAO,CAACmC,OAAO,CAAC,IAChCN,IAAI,CAAC7B,OAAO,CAACmC,OAAO,CAACG,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAE;IAC1D,IAAI,CAAC9B,eAAe,GAChBqB,IAAI,CAAC7B,OAAO,CAACmC,OAAO,KAAK,IAAI,IACxBC,KAAK,CAACC,OAAO,CAACR,IAAI,CAAC7B,OAAO,CAACmC,OAAO,CAAC,IAChCN,IAAI,CAAC7B,OAAO,CAACmC,OAAO,CAACG,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAE;IAC1D,IAAI,CAAC7B,eAAe,GAChBoB,IAAI,CAAC7B,OAAO,CAACmC,OAAO,KAAK,IAAI,IACxBC,KAAK,CAACC,OAAO,CAACR,IAAI,CAAC7B,OAAO,CAACmC,OAAO,CAAC,IAChCN,IAAI,CAAC7B,OAAO,CAACmC,OAAO,CAACG,OAAO,CAAC,QAAQ,CAAC,KAAK,CAAC,CAAE;IAC1D,IAAI,CAAC5B,mBAAmB,GACpBmB,IAAI,CAAC7B,OAAO,CAACmC,OAAO,KAAK,IAAI,IACxBC,KAAK,CAACC,OAAO,CAACR,IAAI,CAAC7B,OAAO,CAACmC,OAAO,CAAC,IAChCN,IAAI,CAAC7B,OAAO,CAACmC,OAAO,CAACG,OAAO,CAAC,aAAa,CAAC,KAAK,CAAC,CAAE;IAC/D,IAAI,CAAC3B,gBAAgB,GACjBkB,IAAI,CAAC7B,OAAO,CAACmC,OAAO,KAAK,IAAI,IACxBC,KAAK,CAACC,OAAO,CAACR,IAAI,CAAC7B,OAAO,CAACmC,OAAO,CAAC,IAChCN,IAAI,CAAC7B,OAAO,CAACmC,OAAO,CAACG,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,CAAE;IAC3D;IACA,IAAI,CAAC1B,UAAU,GACXiB,IAAI,CAAC7B,OAAO,CAACuC,QAAQ,KAAK,KAAK,IAAI,IAAI,CAACpC,SAAS,GAAG,KAAK,GAAG,IAAI;IACpE,IAAI,CAACqC,QAAQ,GAAGX,IAAI,CAAC7B,OAAO,CAACwC,QAAQ;IACrC,IAAI,CAACC,QAAQ,GAAGZ,IAAI,CAAC7B,OAAO,CAACyC,QAAQ;IACrC,IAAI,CAACC,UAAU,GAAGb,IAAI,CAAC7B,OAAO,CAAC0C,UAAU;IACzC,IAAI,CAAC7B,2BAA2B,GAC5BgB,IAAI,CAAC7B,OAAO,CAACa,2BAA2B,KAAK,KAAK,GAAG,KAAK,GAAG,IAAI;IACrE,IAAI,CAACR,OAAO,GAAGwB,IAAI,CAAC7B,OAAO,CAAC2C,KAAK,IAAI,KAAK;IAC1C,IAAI,CAACrC,kBAAkB,GACnBuB,IAAI,CAAC7B,OAAO,CAAC4C,WAAW,KAAK,KAAK,GAAG,KAAK,GAAG,IAAI;IACrD,IAAI,CAACC,iBAAiB,GAAGhB,IAAI,CAAC7B,OAAO,CAAC6C,iBAAiB,IAAI,SAAS;IACpE,IAAI,CAAC5C,YAAY,GAAG4B,IAAI,CAAC5B,YAAY,IAAI,KAAK;IAC9C,IAAI,CAACC,cAAc,GAAG2B,IAAI,CAAC3B,cAAc,IAAI,KAAK;IAClD,IAAI,OAAO2B,IAAI,CAACiB,IAAI,KAAK,UAAU,EAAE;MACjC,IAAI,CAACA,IAAI,GACL,OAAOjB,IAAI,CAACiB,IAAI,KAAK,UAAU,GACzBjB,IAAI,CAACiB,IAAI,CAAC,CAAC,GACXjB,IAAI,CAACiB,IAAI;IACvB,CAAC,MACI,IAAIjD,eAAe,CAACkD,cAAc,CAAClB,IAAI,CAACiB,IAAI,CAAC,EAAE;MAChD,IAAI,CAACA,IAAI,GAAGjB,IAAI,CAACiB,IAAI,CAAC9C,OAAO,CAACgD,IAAI;IACtC,CAAC,MACI,IAAIpD,WAAW,CAACqD,QAAQ,CAACpB,IAAI,CAACiB,IAAI,CAAC,IACpC,OAAOjB,IAAI,CAACiB,IAAI,CAACE,IAAI,KAAK,QAAQ,EAAE;MACpC,IAAI,CAACF,IAAI,GAAGjB,IAAI,CAACiB,IAAI,CAACE,IAAI;IAC9B,CAAC,MACI;MACD,IAAI,CAACF,IAAI,GAAGjB,IAAI,CAACiB,IAAI;IACzB;IACA,IAAI,CAAC/B,UAAU,GAAG,IAAI,CAACiB,YAAY,KAAK,YAAY;IACpD,IAAI,CAACb,WAAW,GAAG,IAAI,CAACa,YAAY,KAAK,aAAa;IACtD,IAAI,CAACZ,WAAW,GAAG,IAAI,CAACY,YAAY,KAAK,aAAa;IACtD,IAAI,CAACX,YAAY,GAAG,IAAI,CAACW,YAAY,KAAK,cAAc;IACxD,IAAI,CAACd,kBAAkB,GAAG,IAAI,CAACH,UAAU,GAAG,IAAI,GAAG,KAAK;IACxD,IAAI,CAACQ,oBAAoB,GAAG,IAAI,CAACF,YAAY,GAAG,IAAI,GAAG,KAAK;EAChE;EACA;EACA;EACA;EACA;AACJ;AACA;EACI6B,gBAAgBA,CAACC,MAAM,EAAE;IACrB,MAAM1B,WAAW,GAAG,IAAI,CAACX,QAAQ,GAC3B,IAAI,CAACW,WAAW,GAChB,IAAI,CAAC2B,eAAe,CAAC3B,WAAW;IACtC,MAAM4B,iBAAiB,GAAG5B,WAAW,CAAC6B,GAAG,CAAEC,UAAU,IAAKA,UAAU,CAACC,gBAAgB,CAAC;IACtF;IACA;IACA,OAAO9D,cAAc,CAAC+D,WAAW,CAACN,MAAM,EAAEE,iBAAiB,CAAC;EAChE;EACA;AACJ;AACA;AACA;AACA;AACA;EACIK,mBAAmBA,CAACC,EAAE,EAAE;IACpB,IAAI/D,WAAW,CAACqD,QAAQ,CAACU,EAAE,CAAC,EACxB,OAAOA,EAAE;IACb,MAAMlC,WAAW,GAAG,IAAI,CAACX,QAAQ,GAC3B,IAAI,CAACW,WAAW,GAChB,IAAI,CAAC2B,eAAe,CAAC3B,WAAW;IACtC,MAAM4B,iBAAiB,GAAG5B,WAAW,CAAC6B,GAAG,CAAEC,UAAU,IAAKA,UAAU,CAACC,gBAAgB,CAAC;IACtF,IAAIH,iBAAiB,CAACO,MAAM,GAAG,CAAC,EAC5B,MAAM,IAAIjE,YAAY,CAAE,yGAAwG,CAAC;IACrI,OAAO0D,iBAAiB,CAAC,CAAC,CAAC,CAACQ,cAAc,CAACF,EAAE,CAAC;EAClD;EACA;AACJ;AACA;AACA;EACIG,cAAcA,CAACX,MAAM,EAAEY,4BAA4B,GAAG,KAAK,EAAE;IACzD,IAAIZ,MAAM,KAAK,IAAI,IAAIA,MAAM,KAAKa,SAAS,EACvC,OAAOA,SAAS;IACpB;IACA,IAAI,IAAI,CAACpC,gBAAgB,EAAE;MACvB;MACA;MACA;MACA,MAAMqC,aAAa,GAAG,CAAC,GAAG,IAAI,CAACrC,gBAAgB,CAACsC,mBAAmB,CAAC;MACpE;MACA;MACA,MAAMC,0BAA0B,GAAGA,CAACF,aAAa,EAAEG,KAAK,KAAK;QACzD,MAAMrC,YAAY,GAAGkC,aAAa,CAACI,KAAK,CAAC,CAAC;QAC1C,IAAItC,YAAY,EAAE;UACd,IAAIqC,KAAK,CAACrC,YAAY,CAAC,EAAE;YACrB,OAAOoC,0BAA0B,CAACF,aAAa,EAAEG,KAAK,CAACrC,YAAY,CAAC,CAAC;UACzE;UACA,OAAOiC,SAAS;QACpB;QACA,OAAOI,KAAK;MAChB,CAAC;MACD;MACA,MAAME,cAAc,GAAGH,0BAA0B,CAACF,aAAa,EAAEd,MAAM,CAAC;MACxE,IAAI,IAAI,CAAC/C,MAAM,EAAE;QACb,IAAIkE,cAAc,CAAC,IAAI,GAAG,IAAI,CAACvC,YAAY,GAAG,IAAI,CAAC,KAC/CiC,SAAS,EACT,OAAOM,cAAc,CAAC,IAAI,GAAG,IAAI,CAACvC,YAAY,GAAG,IAAI,CAAC;QAC1D,IAAIgC,4BAA4B,KAAK,IAAI,EACrC,OAAOO,cAAc,CAAC,IAAI,CAACvC,YAAY,CAAC;QAC5C,OAAOiC,SAAS;MACpB;MACA,OAAOM,cAAc,GACfA,cAAc,CAAC,IAAI,CAAClE,MAAM,GACtB,IAAI,GAAG,IAAI,CAAC2B,YAAY,GAAG,IAAI,GAC/B,IAAI,CAACA,YAAY,CAAC,GACtBiC,SAAS;IACnB,CAAC,MACI;MACD;MACA,IAAI,IAAI,CAAC5D,MAAM,EAAE;QACb,IAAI+C,MAAM,CAAC,IAAI,GAAG,IAAI,CAACpB,YAAY,GAAG,IAAI,CAAC,KAAKiC,SAAS,EACrD,OAAOb,MAAM,CAAC,IAAI,GAAG,IAAI,CAACpB,YAAY,GAAG,IAAI,CAAC;QAClD,IAAIgC,4BAA4B,KAAK,IAAI,EACrC,OAAOZ,MAAM,CAAC,IAAI,CAACpB,YAAY,CAAC;QACpC,OAAOiC,SAAS;MACpB;MACA,OAAOb,MAAM,CAAC,IAAI,CAACpB,YAAY,CAAC;IACpC;EACJ;EACA;AACJ;AACA;AACA;AACA;AACA;EACIwC,cAAcA,CAACpB,MAAM,EAAEiB,KAAK,EAAE;IAC1B,MAAMrC,YAAY,GAAG,IAAI,CAAC3B,MAAM,GAC1B,IAAI,GAAG,IAAI,CAAC2B,YAAY,GAAG,IAAI,GAC/B,IAAI,CAACA,YAAY;IACvB,IAAI,IAAI,CAACH,gBAAgB,EAAE;MACvB;MACA,MAAMuC,0BAA0B,GAAGA,CAACK,iBAAiB,EAAElB,GAAG,KAAK;QAC3D;QACA;QACA,MAAM1B,gBAAgB,GAAG4C,iBAAiB,CAACH,KAAK,CAAC,CAAC;QAClD,IAAIzC,gBAAgB,EAAE;UAClB,IAAI,CAAC0B,GAAG,CAAC1B,gBAAgB,CAACG,YAAY,CAAC,EACnCuB,GAAG,CAAC1B,gBAAgB,CAACG,YAAY,CAAC,GAC9BH,gBAAgB,CAAC6C,MAAM,CAAC,CAAC;UACjCN,0BAA0B,CAACK,iBAAiB,EAAElB,GAAG,CAAC1B,gBAAgB,CAACG,YAAY,CAAC,CAAC;UACjF,OAAOuB,GAAG;QACd;QACAA,GAAG,CAACvB,YAAY,CAAC,GAAGqC,KAAK;QACzB,OAAOd,GAAG;MACd,CAAC;MACD,OAAOa,0BAA0B,CAAC,CAAC,GAAG,IAAI,CAACvC,gBAAgB,CAAC8C,oBAAoB,CAAC,EAAEvB,MAAM,CAAC;IAC9F,CAAC,MACI;MACDA,MAAM,CAACpB,YAAY,CAAC,GAAGqC,KAAK;IAChC;EACJ;EACA;AACJ;AACA;EACIP,cAAcA,CAACO,KAAK,EAAE;IAClB;IACA,IAAI,IAAI,CAACxC,gBAAgB,EAAE;MACvB;MACA;MACA;MACA;MACA,MAAMqC,aAAa,GAAG,CAAC,GAAG,IAAI,CAACrC,gBAAgB,CAACsC,mBAAmB,CAAC;MACpE;MACA;MACA;MACA;MACA;MACA,MAAMC,0BAA0B,GAAGA,CAACF,aAAa,EAAEX,GAAG,KAAK;QACvD,MAAMvB,YAAY,GAAGkC,aAAa,CAACI,KAAK,CAAC,CAAC;QAC1C,IAAItC,YAAY,EAAE;UACduB,GAAG,CAACvB,YAAY,CAAC,GAAG,CAAC,CAAC;UACtBoC,0BAA0B,CAACF,aAAa,EAAEX,GAAG,CAACvB,YAAY,CAAC,CAAC;UAC5D,OAAOuB,GAAG;QACd;QACAA,GAAG,CAAC,IAAI,CAACvB,YAAY,CAAC,GAAGqC,KAAK;QAC9B,OAAOd,GAAG;MACd,CAAC;MACD,OAAOa,0BAA0B,CAACF,aAAa,EAAE,CAAC,CAAC,CAAC;IACxD,CAAC,MACI;MACD;MACA,OAAO;QAAE,CAAC,IAAI,CAAClC,YAAY,GAAGqC;MAAM,CAAC;IACzC;EACJ;EACA;EACA;EACA;EACA;AACJ;AACA;AACA;EACIO,KAAKA,CAAA,EAAG;IACJ,IAAI,CAACC,YAAY,GAAG,IAAI,CAACC,iBAAiB,CAAC,CAAC;EAChD;EACA;AACJ;AACA;AACA;EACIC,mBAAmBA,CAAC,GAAGtD,WAAW,EAAE;IAChC,IAAI,CAACA,WAAW,CAACuD,IAAI,CAAC,GAAGvD,WAAW,CAAC;EACzC;EACA;AACJ;AACA;AACA;EACIwD,mBAAmBA,CAACvD,WAAW,GAAG,EAAE,EAAEC,kBAAkB,GAAG,EAAE,EAAE;IAC3D,IAAI,CAACD,WAAW,GAAGA,WAAW;IAC9B,IAAI,CAACC,kBAAkB,GAAGA,kBAAkB;IAC5C,IAAI,CAACZ,QAAQ,GACT,IAAI,CAACM,WAAW,IACX,CAAC,IAAI,CAACC,YAAY,IAAI,IAAI,CAACN,UAAU,KAClC,IAAI,CAACU,WAAW,CAACmC,MAAM,GAAG,CAAE;IACxC,IAAI,CAAC5C,eAAe,GAAG,IAAI,CAACD,UAAU,IAAI,IAAI,CAACD,QAAQ;IACvD,IAAI,CAACI,kBAAkB,GAAG,IAAI,CAACH,UAAU,IAAI,CAAC,IAAI,CAACD,QAAQ;IAC3D,IAAI,CAACQ,iBAAiB,GAAG,IAAI,CAACD,YAAY,IAAI,IAAI,CAACP,QAAQ;IAC3D,IAAI,CAACS,oBAAoB,GAAG,IAAI,CAACF,YAAY,IAAI,CAAC,IAAI,CAACP,QAAQ;IAC/D,IAAI,CAACG,gBAAgB,GAAG,IAAI,CAACG,WAAW,IAAI,IAAI,CAACJ,eAAe;EACpE;EACA;AACJ;AACA;AACA;EACIiE,8BAA8BA,CAACC,sBAAsB,EAAE;IACnD,IAAI,CAACA,sBAAsB,GAAGA,sBAAsB;IACpD,IAAI,CAACC,aAAa,GAAGD,sBAAsB,CAACE,SAAS;IACrD,IAAI,IAAI,CAAChC,eAAe,EAAE;MACtB,IAAI,CAACA,eAAe,CAAC8B,sBAAsB,GAAGA,sBAAsB;MACpE,IAAI,CAACC,aAAa,GAAGD,sBAAsB,CAACE,SAAS;IACzD;EACJ;EACA;AACJ;AACA;AACA;EACIC,4BAA4BA,CAAA,EAAG;IAC3B,IAAI,IAAI,CAACnD,+BAA+B,EAAE;MACtC,MAAMoD,wBAAwB,GAAG,IAAI,CAACC,qBAAqB,CAACC,aAAa;MACzE,IAAI,OAAO,IAAI,CAACtD,+BAA+B,KAAK,UAAU,EAC1D,OAAO,IAAI,CAACA,+BAA+B,CAACoD,wBAAwB,CAAC;MACzE,IAAI,OAAO,IAAI,CAACpD,+BAA+B,KAAK,QAAQ,EACxD,OAAO,IAAI,CAACA,+BAA+B;IACnD,CAAC,MACI,IAAI,IAAI,CAACjC,YAAY,IACtB,IAAI,CAAC0B,cAAc,CAAC8D,oBAAoB,EAAE;MAC1C,OAAO,IAAI,CAAC9D,cAAc,CAAC8D,oBAAoB,CAAC1D,YAAY;IAChE,CAAC,MACI,IAAI,IAAI,CAAC7B,cAAc,IACxB,IAAI,CAACyB,cAAc,CAAC+D,kBAAkB,EAAE;MACxC,OAAO,IAAI,CAAC/D,cAAc,CAAC+D,kBAAkB,CAAC3D,YAAY;IAC9D;IACA,OAAO,EAAE;EACb;EACA;AACJ;AACA;EACI8C,iBAAiBA,CAAA,EAAG;IAChB,IAAI,CAAC,IAAI,CAACjD,gBAAgB,IACtB,CAAC,IAAI,CAACA,gBAAgB,CAACsC,mBAAmB,CAACN,MAAM,EACjD,OAAO,IAAI,CAAC7B,YAAY;IAC5B,OAAQ,IAAI,CAACH,gBAAgB,CAACsC,mBAAmB,CAACyB,IAAI,CAAC,GAAG,CAAC,GACvD,GAAG,GACH,IAAI,CAAC5D,YAAY;EACzB;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}