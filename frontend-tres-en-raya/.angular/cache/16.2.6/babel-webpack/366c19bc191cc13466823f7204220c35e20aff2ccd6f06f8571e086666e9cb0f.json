{"ast":null,"code":"import { FindOptionsUtils } from \"../find-options/FindOptionsUtils\";\n/**\n * Wraps entities and creates getters/setters for their relations\n * to be able to lazily load relations when accessing these relations.\n */\nexport class RelationLoader {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection) {\n    this.connection = connection;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Loads relation data for the given entity and its relation.\n   */\n  load(relation, entityOrEntities, queryRunner, queryBuilder) {\n    // todo: check all places where it uses non array\n    if (queryRunner && queryRunner.isReleased) queryRunner = undefined; // get new one if already closed\n    if (relation.isManyToOne || relation.isOneToOneOwner) {\n      return this.loadManyToOneOrOneToOneOwner(relation, entityOrEntities, queryRunner, queryBuilder);\n    } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n      return this.loadOneToManyOrOneToOneNotOwner(relation, entityOrEntities, queryRunner, queryBuilder);\n    } else if (relation.isManyToManyOwner) {\n      return this.loadManyToManyOwner(relation, entityOrEntities, queryRunner, queryBuilder);\n    } else {\n      // many-to-many non owner\n      return this.loadManyToManyNotOwner(relation, entityOrEntities, queryRunner, queryBuilder);\n    }\n  }\n  /**\n   * Loads data for many-to-one and one-to-one owner relations.\n   *\n   * (ow) post.category<=>category.post\n   * loaded: category from post\n   * example: SELECT category.id AS category_id, category.name AS category_name FROM category category\n   *              INNER JOIN post Post ON Post.category=category.id WHERE Post.id=1\n   */\n  loadManyToOneOrOneToOneOwner(relation, entityOrEntities, queryRunner, queryBuilder) {\n    const entities = Array.isArray(entityOrEntities) ? entityOrEntities : [entityOrEntities];\n    const joinAliasName = relation.entityMetadata.name;\n    const qb = queryBuilder ? queryBuilder : this.connection.createQueryBuilder(queryRunner).select(relation.propertyName) // category\n    .from(relation.type, relation.propertyName);\n    const mainAlias = qb.expressionMap.mainAlias.name;\n    const columns = relation.entityMetadata.primaryColumns;\n    const joinColumns = relation.isOwning ? relation.joinColumns : relation.inverseRelation.joinColumns;\n    const conditions = joinColumns.map(joinColumn => {\n      return `${relation.entityMetadata.name}.${joinColumn.propertyName} = ${mainAlias}.${joinColumn.referencedColumn.propertyName}`;\n    }).join(\" AND \");\n    qb.innerJoin(relation.entityMetadata.target, joinAliasName, conditions);\n    if (columns.length === 1) {\n      qb.where(`${joinAliasName}.${columns[0].propertyPath} IN (:...${joinAliasName + \"_\" + columns[0].propertyName})`);\n      qb.setParameter(joinAliasName + \"_\" + columns[0].propertyName, entities.map(entity => columns[0].getEntityValue(entity, true)));\n    } else {\n      const condition = entities.map((entity, entityIndex) => {\n        return columns.map((column, columnIndex) => {\n          const paramName = joinAliasName + \"_entity_\" + entityIndex + \"_\" + columnIndex;\n          qb.setParameter(paramName, column.getEntityValue(entity, true));\n          return joinAliasName + \".\" + column.propertyPath + \" = :\" + paramName;\n        }).join(\" AND \");\n      }).map(condition => \"(\" + condition + \")\").join(\" OR \");\n      qb.where(condition);\n    }\n    FindOptionsUtils.joinEagerRelations(qb, qb.alias, qb.expressionMap.mainAlias.metadata);\n    return qb.getMany();\n    // return qb.getOne(); todo: fix all usages\n  }\n  /**\n   * Loads data for one-to-many and one-to-one not owner relations.\n   *\n   * SELECT post\n   * FROM post post\n   * WHERE post.[joinColumn.name] = entity[joinColumn.referencedColumn]\n   */\n  loadOneToManyOrOneToOneNotOwner(relation, entityOrEntities, queryRunner, queryBuilder) {\n    const entities = Array.isArray(entityOrEntities) ? entityOrEntities : [entityOrEntities];\n    const columns = relation.inverseRelation.joinColumns;\n    const qb = queryBuilder ? queryBuilder : this.connection.createQueryBuilder(queryRunner).select(relation.propertyName).from(relation.inverseRelation.entityMetadata.target, relation.propertyName);\n    const aliasName = qb.expressionMap.mainAlias.name;\n    if (columns.length === 1) {\n      qb.where(`${aliasName}.${columns[0].propertyPath} IN (:...${aliasName + \"_\" + columns[0].propertyName})`);\n      qb.setParameter(aliasName + \"_\" + columns[0].propertyName, entities.map(entity => columns[0].referencedColumn.getEntityValue(entity, true)));\n    } else {\n      const condition = entities.map((entity, entityIndex) => {\n        return columns.map((column, columnIndex) => {\n          const paramName = aliasName + \"_entity_\" + entityIndex + \"_\" + columnIndex;\n          qb.setParameter(paramName, column.referencedColumn.getEntityValue(entity, true));\n          return aliasName + \".\" + column.propertyPath + \" = :\" + paramName;\n        }).join(\" AND \");\n      }).map(condition => \"(\" + condition + \")\").join(\" OR \");\n      qb.where(condition);\n    }\n    FindOptionsUtils.joinEagerRelations(qb, qb.alias, qb.expressionMap.mainAlias.metadata);\n    return qb.getMany();\n    // return relation.isOneToMany ? qb.getMany() : qb.getOne(); todo: fix all usages\n  }\n  /**\n   * Loads data for many-to-many owner relations.\n   *\n   * SELECT category\n   * FROM category category\n   * INNER JOIN post_categories post_categories\n   * ON post_categories.postId = :postId\n   * AND post_categories.categoryId = category.id\n   */\n  loadManyToManyOwner(relation, entityOrEntities, queryRunner, queryBuilder) {\n    const entities = Array.isArray(entityOrEntities) ? entityOrEntities : [entityOrEntities];\n    const parameters = relation.joinColumns.reduce((parameters, joinColumn) => {\n      parameters[joinColumn.propertyName] = entities.map(entity => joinColumn.referencedColumn.getEntityValue(entity, true));\n      return parameters;\n    }, {});\n    const qb = queryBuilder ? queryBuilder : this.connection.createQueryBuilder(queryRunner).select(relation.propertyName).from(relation.type, relation.propertyName);\n    const mainAlias = qb.expressionMap.mainAlias.name;\n    const joinAlias = relation.junctionEntityMetadata.tableName;\n    const joinColumnConditions = relation.joinColumns.map(joinColumn => {\n      return `${joinAlias}.${joinColumn.propertyName} IN (:...${joinColumn.propertyName})`;\n    });\n    const inverseJoinColumnConditions = relation.inverseJoinColumns.map(inverseJoinColumn => {\n      return `${joinAlias}.${inverseJoinColumn.propertyName}=${mainAlias}.${inverseJoinColumn.referencedColumn.propertyName}`;\n    });\n    qb.innerJoin(joinAlias, joinAlias, [...joinColumnConditions, ...inverseJoinColumnConditions].join(\" AND \")).setParameters(parameters);\n    FindOptionsUtils.joinEagerRelations(qb, qb.alias, qb.expressionMap.mainAlias.metadata);\n    return qb.getMany();\n  }\n  /**\n   * Loads data for many-to-many not owner relations.\n   *\n   * SELECT post\n   * FROM post post\n   * INNER JOIN post_categories post_categories\n   * ON post_categories.postId = post.id\n   * AND post_categories.categoryId = post_categories.categoryId\n   */\n  loadManyToManyNotOwner(relation, entityOrEntities, queryRunner, queryBuilder) {\n    const entities = Array.isArray(entityOrEntities) ? entityOrEntities : [entityOrEntities];\n    const qb = queryBuilder ? queryBuilder : this.connection.createQueryBuilder(queryRunner).select(relation.propertyName).from(relation.type, relation.propertyName);\n    const mainAlias = qb.expressionMap.mainAlias.name;\n    const joinAlias = relation.junctionEntityMetadata.tableName;\n    const joinColumnConditions = relation.inverseRelation.joinColumns.map(joinColumn => {\n      return `${joinAlias}.${joinColumn.propertyName} = ${mainAlias}.${joinColumn.referencedColumn.propertyName}`;\n    });\n    const inverseJoinColumnConditions = relation.inverseRelation.inverseJoinColumns.map(inverseJoinColumn => {\n      return `${joinAlias}.${inverseJoinColumn.propertyName} IN (:...${inverseJoinColumn.propertyName})`;\n    });\n    const parameters = relation.inverseRelation.inverseJoinColumns.reduce((parameters, joinColumn) => {\n      parameters[joinColumn.propertyName] = entities.map(entity => joinColumn.referencedColumn.getEntityValue(entity, true));\n      return parameters;\n    }, {});\n    qb.innerJoin(joinAlias, joinAlias, [...joinColumnConditions, ...inverseJoinColumnConditions].join(\" AND \")).setParameters(parameters);\n    FindOptionsUtils.joinEagerRelations(qb, qb.alias, qb.expressionMap.mainAlias.metadata);\n    return qb.getMany();\n  }\n  /**\n   * Wraps given entity and creates getters/setters for its given relation\n   * to be able to lazily load data when accessing this relation.\n   */\n  enableLazyLoad(relation, entity, queryRunner) {\n    const relationLoader = this;\n    const dataIndex = \"__\" + relation.propertyName + \"__\"; // in what property of the entity loaded data will be stored\n    const promiseIndex = \"__promise_\" + relation.propertyName + \"__\"; // in what property of the entity loading promise will be stored\n    const resolveIndex = \"__has_\" + relation.propertyName + \"__\"; // indicates if relation data already was loaded or not, we need this flag if loaded data is empty\n    const setData = (entity, value) => {\n      entity[dataIndex] = value;\n      entity[resolveIndex] = true;\n      delete entity[promiseIndex];\n      return value;\n    };\n    const setPromise = (entity, value) => {\n      delete entity[resolveIndex];\n      delete entity[dataIndex];\n      entity[promiseIndex] = value;\n      value.then(\n      // ensure different value is not assigned yet\n      result => entity[promiseIndex] === value ? setData(entity, result) : result);\n      return value;\n    };\n    Object.defineProperty(entity, relation.propertyName, {\n      get: function () {\n        if (this[resolveIndex] === true || this[dataIndex] !== undefined)\n          // if related data already was loaded then simply return it\n          return Promise.resolve(this[dataIndex]);\n        if (this[promiseIndex])\n          // if related data is loading then return a promise relationLoader loads it\n          return this[promiseIndex];\n        // nothing is loaded yet, load relation data and save it in the model once they are loaded\n        const loader = relationLoader.load(relation, this, queryRunner).then(result => relation.isOneToOne || relation.isManyToOne ? result.length === 0 ? null : result[0] : result);\n        return setPromise(this, loader);\n      },\n      set: function (value) {\n        if (value instanceof Promise) {\n          // if set data is a promise then wait for its resolve and save in the object\n          setPromise(this, value);\n        } else {\n          // if its direct data set (non promise, probably not safe-typed)\n          setData(this, value);\n        }\n      },\n      configurable: true,\n      enumerable: false\n    });\n  }\n}","map":{"version":3,"names":["FindOptionsUtils","RelationLoader","constructor","connection","load","relation","entityOrEntities","queryRunner","queryBuilder","isReleased","undefined","isManyToOne","isOneToOneOwner","loadManyToOneOrOneToOneOwner","isOneToMany","isOneToOneNotOwner","loadOneToManyOrOneToOneNotOwner","isManyToManyOwner","loadManyToManyOwner","loadManyToManyNotOwner","entities","Array","isArray","joinAliasName","entityMetadata","name","qb","createQueryBuilder","select","propertyName","from","type","mainAlias","expressionMap","columns","primaryColumns","joinColumns","isOwning","inverseRelation","conditions","map","joinColumn","referencedColumn","join","innerJoin","target","length","where","propertyPath","setParameter","entity","getEntityValue","condition","entityIndex","column","columnIndex","paramName","joinEagerRelations","alias","metadata","getMany","aliasName","parameters","reduce","joinAlias","junctionEntityMetadata","tableName","joinColumnConditions","inverseJoinColumnConditions","inverseJoinColumns","inverseJoinColumn","setParameters","enableLazyLoad","relationLoader","dataIndex","promiseIndex","resolveIndex","setData","value","setPromise","then","result","Object","defineProperty","get","Promise","resolve","loader","isOneToOne","set","configurable","enumerable"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/query-builder/RelationLoader.js"],"sourcesContent":["import { FindOptionsUtils } from \"../find-options/FindOptionsUtils\";\n/**\n * Wraps entities and creates getters/setters for their relations\n * to be able to lazily load relations when accessing these relations.\n */\nexport class RelationLoader {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n    constructor(connection) {\n        this.connection = connection;\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Loads relation data for the given entity and its relation.\n     */\n    load(relation, entityOrEntities, queryRunner, queryBuilder) {\n        // todo: check all places where it uses non array\n        if (queryRunner && queryRunner.isReleased)\n            queryRunner = undefined; // get new one if already closed\n        if (relation.isManyToOne || relation.isOneToOneOwner) {\n            return this.loadManyToOneOrOneToOneOwner(relation, entityOrEntities, queryRunner, queryBuilder);\n        }\n        else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n            return this.loadOneToManyOrOneToOneNotOwner(relation, entityOrEntities, queryRunner, queryBuilder);\n        }\n        else if (relation.isManyToManyOwner) {\n            return this.loadManyToManyOwner(relation, entityOrEntities, queryRunner, queryBuilder);\n        }\n        else {\n            // many-to-many non owner\n            return this.loadManyToManyNotOwner(relation, entityOrEntities, queryRunner, queryBuilder);\n        }\n    }\n    /**\n     * Loads data for many-to-one and one-to-one owner relations.\n     *\n     * (ow) post.category<=>category.post\n     * loaded: category from post\n     * example: SELECT category.id AS category_id, category.name AS category_name FROM category category\n     *              INNER JOIN post Post ON Post.category=category.id WHERE Post.id=1\n     */\n    loadManyToOneOrOneToOneOwner(relation, entityOrEntities, queryRunner, queryBuilder) {\n        const entities = Array.isArray(entityOrEntities)\n            ? entityOrEntities\n            : [entityOrEntities];\n        const joinAliasName = relation.entityMetadata.name;\n        const qb = queryBuilder\n            ? queryBuilder\n            : this.connection\n                .createQueryBuilder(queryRunner)\n                .select(relation.propertyName) // category\n                .from(relation.type, relation.propertyName);\n        const mainAlias = qb.expressionMap.mainAlias.name;\n        const columns = relation.entityMetadata.primaryColumns;\n        const joinColumns = relation.isOwning\n            ? relation.joinColumns\n            : relation.inverseRelation.joinColumns;\n        const conditions = joinColumns\n            .map((joinColumn) => {\n            return `${relation.entityMetadata.name}.${joinColumn.propertyName} = ${mainAlias}.${joinColumn.referencedColumn.propertyName}`;\n        })\n            .join(\" AND \");\n        qb.innerJoin(relation.entityMetadata.target, joinAliasName, conditions);\n        if (columns.length === 1) {\n            qb.where(`${joinAliasName}.${columns[0].propertyPath} IN (:...${joinAliasName + \"_\" + columns[0].propertyName})`);\n            qb.setParameter(joinAliasName + \"_\" + columns[0].propertyName, entities.map((entity) => columns[0].getEntityValue(entity, true)));\n        }\n        else {\n            const condition = entities\n                .map((entity, entityIndex) => {\n                return columns\n                    .map((column, columnIndex) => {\n                    const paramName = joinAliasName +\n                        \"_entity_\" +\n                        entityIndex +\n                        \"_\" +\n                        columnIndex;\n                    qb.setParameter(paramName, column.getEntityValue(entity, true));\n                    return (joinAliasName +\n                        \".\" +\n                        column.propertyPath +\n                        \" = :\" +\n                        paramName);\n                })\n                    .join(\" AND \");\n            })\n                .map((condition) => \"(\" + condition + \")\")\n                .join(\" OR \");\n            qb.where(condition);\n        }\n        FindOptionsUtils.joinEagerRelations(qb, qb.alias, qb.expressionMap.mainAlias.metadata);\n        return qb.getMany();\n        // return qb.getOne(); todo: fix all usages\n    }\n    /**\n     * Loads data for one-to-many and one-to-one not owner relations.\n     *\n     * SELECT post\n     * FROM post post\n     * WHERE post.[joinColumn.name] = entity[joinColumn.referencedColumn]\n     */\n    loadOneToManyOrOneToOneNotOwner(relation, entityOrEntities, queryRunner, queryBuilder) {\n        const entities = Array.isArray(entityOrEntities)\n            ? entityOrEntities\n            : [entityOrEntities];\n        const columns = relation.inverseRelation.joinColumns;\n        const qb = queryBuilder\n            ? queryBuilder\n            : this.connection\n                .createQueryBuilder(queryRunner)\n                .select(relation.propertyName)\n                .from(relation.inverseRelation.entityMetadata.target, relation.propertyName);\n        const aliasName = qb.expressionMap.mainAlias.name;\n        if (columns.length === 1) {\n            qb.where(`${aliasName}.${columns[0].propertyPath} IN (:...${aliasName + \"_\" + columns[0].propertyName})`);\n            qb.setParameter(aliasName + \"_\" + columns[0].propertyName, entities.map((entity) => columns[0].referencedColumn.getEntityValue(entity, true)));\n        }\n        else {\n            const condition = entities\n                .map((entity, entityIndex) => {\n                return columns\n                    .map((column, columnIndex) => {\n                    const paramName = aliasName +\n                        \"_entity_\" +\n                        entityIndex +\n                        \"_\" +\n                        columnIndex;\n                    qb.setParameter(paramName, column.referencedColumn.getEntityValue(entity, true));\n                    return (aliasName +\n                        \".\" +\n                        column.propertyPath +\n                        \" = :\" +\n                        paramName);\n                })\n                    .join(\" AND \");\n            })\n                .map((condition) => \"(\" + condition + \")\")\n                .join(\" OR \");\n            qb.where(condition);\n        }\n        FindOptionsUtils.joinEagerRelations(qb, qb.alias, qb.expressionMap.mainAlias.metadata);\n        return qb.getMany();\n        // return relation.isOneToMany ? qb.getMany() : qb.getOne(); todo: fix all usages\n    }\n    /**\n     * Loads data for many-to-many owner relations.\n     *\n     * SELECT category\n     * FROM category category\n     * INNER JOIN post_categories post_categories\n     * ON post_categories.postId = :postId\n     * AND post_categories.categoryId = category.id\n     */\n    loadManyToManyOwner(relation, entityOrEntities, queryRunner, queryBuilder) {\n        const entities = Array.isArray(entityOrEntities)\n            ? entityOrEntities\n            : [entityOrEntities];\n        const parameters = relation.joinColumns.reduce((parameters, joinColumn) => {\n            parameters[joinColumn.propertyName] = entities.map((entity) => joinColumn.referencedColumn.getEntityValue(entity, true));\n            return parameters;\n        }, {});\n        const qb = queryBuilder\n            ? queryBuilder\n            : this.connection\n                .createQueryBuilder(queryRunner)\n                .select(relation.propertyName)\n                .from(relation.type, relation.propertyName);\n        const mainAlias = qb.expressionMap.mainAlias.name;\n        const joinAlias = relation.junctionEntityMetadata.tableName;\n        const joinColumnConditions = relation.joinColumns.map((joinColumn) => {\n            return `${joinAlias}.${joinColumn.propertyName} IN (:...${joinColumn.propertyName})`;\n        });\n        const inverseJoinColumnConditions = relation.inverseJoinColumns.map((inverseJoinColumn) => {\n            return `${joinAlias}.${inverseJoinColumn.propertyName}=${mainAlias}.${inverseJoinColumn.referencedColumn.propertyName}`;\n        });\n        qb.innerJoin(joinAlias, joinAlias, [...joinColumnConditions, ...inverseJoinColumnConditions].join(\" AND \")).setParameters(parameters);\n        FindOptionsUtils.joinEagerRelations(qb, qb.alias, qb.expressionMap.mainAlias.metadata);\n        return qb.getMany();\n    }\n    /**\n     * Loads data for many-to-many not owner relations.\n     *\n     * SELECT post\n     * FROM post post\n     * INNER JOIN post_categories post_categories\n     * ON post_categories.postId = post.id\n     * AND post_categories.categoryId = post_categories.categoryId\n     */\n    loadManyToManyNotOwner(relation, entityOrEntities, queryRunner, queryBuilder) {\n        const entities = Array.isArray(entityOrEntities)\n            ? entityOrEntities\n            : [entityOrEntities];\n        const qb = queryBuilder\n            ? queryBuilder\n            : this.connection\n                .createQueryBuilder(queryRunner)\n                .select(relation.propertyName)\n                .from(relation.type, relation.propertyName);\n        const mainAlias = qb.expressionMap.mainAlias.name;\n        const joinAlias = relation.junctionEntityMetadata.tableName;\n        const joinColumnConditions = relation.inverseRelation.joinColumns.map((joinColumn) => {\n            return `${joinAlias}.${joinColumn.propertyName} = ${mainAlias}.${joinColumn.referencedColumn.propertyName}`;\n        });\n        const inverseJoinColumnConditions = relation.inverseRelation.inverseJoinColumns.map((inverseJoinColumn) => {\n            return `${joinAlias}.${inverseJoinColumn.propertyName} IN (:...${inverseJoinColumn.propertyName})`;\n        });\n        const parameters = relation.inverseRelation.inverseJoinColumns.reduce((parameters, joinColumn) => {\n            parameters[joinColumn.propertyName] = entities.map((entity) => joinColumn.referencedColumn.getEntityValue(entity, true));\n            return parameters;\n        }, {});\n        qb.innerJoin(joinAlias, joinAlias, [...joinColumnConditions, ...inverseJoinColumnConditions].join(\" AND \")).setParameters(parameters);\n        FindOptionsUtils.joinEagerRelations(qb, qb.alias, qb.expressionMap.mainAlias.metadata);\n        return qb.getMany();\n    }\n    /**\n     * Wraps given entity and creates getters/setters for its given relation\n     * to be able to lazily load data when accessing this relation.\n     */\n    enableLazyLoad(relation, entity, queryRunner) {\n        const relationLoader = this;\n        const dataIndex = \"__\" + relation.propertyName + \"__\"; // in what property of the entity loaded data will be stored\n        const promiseIndex = \"__promise_\" + relation.propertyName + \"__\"; // in what property of the entity loading promise will be stored\n        const resolveIndex = \"__has_\" + relation.propertyName + \"__\"; // indicates if relation data already was loaded or not, we need this flag if loaded data is empty\n        const setData = (entity, value) => {\n            entity[dataIndex] = value;\n            entity[resolveIndex] = true;\n            delete entity[promiseIndex];\n            return value;\n        };\n        const setPromise = (entity, value) => {\n            delete entity[resolveIndex];\n            delete entity[dataIndex];\n            entity[promiseIndex] = value;\n            value.then(\n            // ensure different value is not assigned yet\n            (result) => entity[promiseIndex] === value\n                ? setData(entity, result)\n                : result);\n            return value;\n        };\n        Object.defineProperty(entity, relation.propertyName, {\n            get: function () {\n                if (this[resolveIndex] === true ||\n                    this[dataIndex] !== undefined)\n                    // if related data already was loaded then simply return it\n                    return Promise.resolve(this[dataIndex]);\n                if (this[promiseIndex])\n                    // if related data is loading then return a promise relationLoader loads it\n                    return this[promiseIndex];\n                // nothing is loaded yet, load relation data and save it in the model once they are loaded\n                const loader = relationLoader\n                    .load(relation, this, queryRunner)\n                    .then((result) => relation.isOneToOne || relation.isManyToOne\n                    ? result.length === 0\n                        ? null\n                        : result[0]\n                    : result);\n                return setPromise(this, loader);\n            },\n            set: function (value) {\n                if (value instanceof Promise) {\n                    // if set data is a promise then wait for its resolve and save in the object\n                    setPromise(this, value);\n                }\n                else {\n                    // if its direct data set (non promise, probably not safe-typed)\n                    setData(this, value);\n                }\n            },\n            configurable: true,\n            enumerable: false,\n        });\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}