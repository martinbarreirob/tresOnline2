{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/practicas/Downloads/angular/tresOnline/frontend-tres-en-raya/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\n/**\n * Loads relation ids for the given entities.\n */\nexport class RelationIdLoader {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection, queryRunner) {\n    this.connection = connection;\n    this.queryRunner = queryRunner;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Loads relation ids of the given entity or entities.\n   */\n  load(relation, entityOrEntities, relatedEntityOrRelatedEntities) {\n    const entities = Array.isArray(entityOrEntities) ? entityOrEntities : [entityOrEntities];\n    const relatedEntities = Array.isArray(relatedEntityOrRelatedEntities) ? relatedEntityOrRelatedEntities : relatedEntityOrRelatedEntities ? [relatedEntityOrRelatedEntities] : undefined;\n    // load relation ids depend of relation type\n    if (relation.isManyToMany) {\n      return this.loadForManyToMany(relation, entities, relatedEntities);\n    } else if (relation.isManyToOne || relation.isOneToOneOwner) {\n      return this.loadForManyToOneAndOneToOneOwner(relation, entities, relatedEntities);\n    } else {\n      // if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n      return this.loadForOneToManyAndOneToOneNotOwner(relation, entities, relatedEntities);\n    }\n  }\n  /**\n   * Loads relation ids of the given entities and groups them into the object with parent and children.\n   *\n   * todo: extract this method?\n   */\n  loadManyToManyRelationIdsAndGroup(relation, entitiesOrEntities, relatedEntityOrEntities, queryBuilder) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      // console.log(\"relation:\", relation.propertyName);\n      // console.log(\"entitiesOrEntities\", entitiesOrEntities);\n      const isMany = relation.isManyToMany || relation.isOneToMany;\n      const entities = Array.isArray(entitiesOrEntities) ? entitiesOrEntities : [entitiesOrEntities];\n      if (!relatedEntityOrEntities) {\n        relatedEntityOrEntities = yield _this.connection.relationLoader.load(relation, entitiesOrEntities, _this.queryRunner, queryBuilder);\n        if (!relatedEntityOrEntities.length) return entities.map(entity => ({\n          entity: entity,\n          related: isMany ? [] : undefined\n        }));\n      }\n      // const relationIds = await this.load(relation, relatedEntityOrEntities!, entitiesOrEntities);\n      const relationIds = yield _this.load(relation, entitiesOrEntities, relatedEntityOrEntities);\n      // console.log(\"entities\", entities);\n      // console.log(\"relatedEntityOrEntities\", relatedEntityOrEntities);\n      // console.log(\"relationIds\", relationIds);\n      const relatedEntities = Array.isArray(relatedEntityOrEntities) ? relatedEntityOrEntities : [relatedEntityOrEntities];\n      let columns = [],\n        inverseColumns = [];\n      if (relation.isManyToManyOwner) {\n        columns = relation.junctionEntityMetadata.inverseColumns.map(column => column.referencedColumn);\n        inverseColumns = relation.junctionEntityMetadata.ownerColumns.map(column => column.referencedColumn);\n      } else if (relation.isManyToManyNotOwner) {\n        columns = relation.junctionEntityMetadata.ownerColumns.map(column => column.referencedColumn);\n        inverseColumns = relation.junctionEntityMetadata.inverseColumns.map(column => column.referencedColumn);\n      } else if (relation.isManyToOne || relation.isOneToOneOwner) {\n        columns = relation.joinColumns.map(column => column.referencedColumn);\n        inverseColumns = relation.entityMetadata.primaryColumns;\n      } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n        columns = relation.inverseRelation.entityMetadata.primaryColumns;\n        inverseColumns = relation.inverseRelation.joinColumns.map(column => column.referencedColumn);\n      } else {}\n      return entities.map(entity => {\n        const group = {\n          entity: entity,\n          related: isMany ? [] : undefined\n        };\n        const entityRelationIds = relationIds.filter(relationId => {\n          return inverseColumns.every(column => {\n            return column.compareEntityValue(entity, relationId[column.entityMetadata.name + \"_\" + column.propertyAliasName]);\n          });\n        });\n        if (!entityRelationIds.length) return group;\n        relatedEntities.forEach(relatedEntity => {\n          entityRelationIds.forEach(relationId => {\n            const relatedEntityMatched = columns.every(column => {\n              return column.compareEntityValue(relatedEntity, relationId[DriverUtils.buildAlias(_this.connection.driver, undefined, column.entityMetadata.name + \"_\" + relation.propertyPath.replace(\".\", \"_\") + \"_\" + column.propertyPath.replace(\".\", \"_\"))]);\n            });\n            if (relatedEntityMatched) {\n              if (isMany) {\n                ;\n                group.related.push(relatedEntity);\n              } else {\n                group.related = relatedEntity;\n              }\n            }\n          });\n        });\n        return group;\n      });\n    })();\n  }\n  /**\n   * Loads relation ids of the given entities and maps them into the given entity property.\n   async loadManyToManyRelationIdsAndMap(\n   relation: RelationMetadata,\n   entityOrEntities: ObjectLiteral|ObjectLiteral[],\n   mapToEntityOrEntities: ObjectLiteral|ObjectLiteral[],\n   propertyName: string\n   ): Promise<void> {\n      const relationIds = await this.loadManyToManyRelationIds(relation, entityOrEntities, mapToEntityOrEntities);\n      const mapToEntities = mapToEntityOrEntities instanceof Array ? mapToEntityOrEntities : [mapToEntityOrEntities];\n      const junctionMetadata = relation.junctionEntityMetadata!;\n      const mainAlias = junctionMetadata.name;\n      const columns = relation.isOwning ? junctionMetadata.inverseColumns : junctionMetadata.ownerColumns;\n      const inverseColumns = relation.isOwning ? junctionMetadata.ownerColumns : junctionMetadata.inverseColumns;\n      mapToEntities.forEach(mapToEntity => {\n          mapToEntity[propertyName] = [];\n          relationIds.forEach(relationId => {\n              const match = inverseColumns.every(column => {\n                  return column.referencedColumn!.getEntityValue(mapToEntity) === relationId[mainAlias + \"_\" + column.propertyName];\n              });\n              if (match) {\n                  if (columns.length === 1) {\n                      mapToEntity[propertyName].push(relationId[mainAlias + \"_\" + columns[0].propertyName]);\n                  } else {\n                      const value = {};\n                      columns.forEach(column => {\n                          column.referencedColumn!.setEntityValue(value, relationId[mainAlias + \"_\" + column.propertyName]);\n                      });\n                      mapToEntity[propertyName].push(value);\n                  }\n              }\n          });\n      });\n  }*/\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Loads relation ids for the many-to-many relation.\n   */\n  loadForManyToMany(relation, entities, relatedEntities) {\n    const junctionMetadata = relation.junctionEntityMetadata;\n    const mainAlias = junctionMetadata.name;\n    const columns = relation.isOwning ? junctionMetadata.ownerColumns : junctionMetadata.inverseColumns;\n    const inverseColumns = relation.isOwning ? junctionMetadata.inverseColumns : junctionMetadata.ownerColumns;\n    const qb = this.connection.createQueryBuilder(this.queryRunner);\n    // select all columns from junction table\n    columns.forEach(column => {\n      const columnName = DriverUtils.buildAlias(this.connection.driver, undefined, column.referencedColumn.entityMetadata.name + \"_\" + column.referencedColumn.propertyPath.replace(\".\", \"_\"));\n      qb.addSelect(mainAlias + \".\" + column.propertyPath, columnName);\n    });\n    inverseColumns.forEach(column => {\n      const columnName = DriverUtils.buildAlias(this.connection.driver, undefined, column.referencedColumn.entityMetadata.name + \"_\" + relation.propertyPath.replace(\".\", \"_\") + \"_\" + column.referencedColumn.propertyPath.replace(\".\", \"_\"));\n      qb.addSelect(mainAlias + \".\" + column.propertyPath, columnName);\n    });\n    // add conditions for the given entities\n    let condition1 = \"\";\n    if (columns.length === 1) {\n      const values = entities.map(entity => columns[0].referencedColumn.getEntityValue(entity));\n      const areAllNumbers = values.every(value => typeof value === \"number\");\n      if (areAllNumbers) {\n        condition1 = `${mainAlias}.${columns[0].propertyPath} IN (${values.join(\", \")})`;\n      } else {\n        qb.setParameter(\"values1\", values);\n        condition1 = mainAlias + \".\" + columns[0].propertyPath + \" IN (:...values1)\"; // todo: use ANY for postgres\n      }\n    } else {\n      condition1 = \"(\" + entities.map((entity, entityIndex) => {\n        return columns.map(column => {\n          const paramName = \"entity1_\" + entityIndex + \"_\" + column.propertyName;\n          qb.setParameter(paramName, column.referencedColumn.getEntityValue(entity));\n          return mainAlias + \".\" + column.propertyPath + \" = :\" + paramName;\n        }).join(\" AND \");\n      }).map(condition => \"(\" + condition + \")\").join(\" OR \") + \")\";\n    }\n    // add conditions for the given inverse entities\n    let condition2 = \"\";\n    if (relatedEntities) {\n      if (inverseColumns.length === 1) {\n        const values = relatedEntities.map(entity => inverseColumns[0].referencedColumn.getEntityValue(entity));\n        const areAllNumbers = values.every(value => typeof value === \"number\");\n        if (areAllNumbers) {\n          condition2 = `${mainAlias}.${inverseColumns[0].propertyPath} IN (${values.join(\", \")})`;\n        } else {\n          qb.setParameter(\"values2\", values);\n          condition2 = mainAlias + \".\" + inverseColumns[0].propertyPath + \" IN (:...values2)\"; // todo: use ANY for postgres\n        }\n      } else {\n        condition2 = \"(\" + relatedEntities.map((entity, entityIndex) => {\n          return inverseColumns.map(column => {\n            const paramName = \"entity2_\" + entityIndex + \"_\" + column.propertyName;\n            qb.setParameter(paramName, column.referencedColumn.getEntityValue(entity));\n            return mainAlias + \".\" + column.propertyPath + \" = :\" + paramName;\n          }).join(\" AND \");\n        }).map(condition => \"(\" + condition + \")\").join(\" OR \") + \")\";\n      }\n    }\n    // qb.from(junctionMetadata.target, mainAlias)\n    //     .where(condition1 + (condition2 ? \" AND \" + condition2 : \"\"));\n    //\n    // // execute query\n    // const { values1, values2 } = qb.getParameters();\n    // console.log(`I can do it`, { values1, values2 });\n    // if (inverseColumns.length === 1 &&\n    //     columns.length === 1 &&\n    //     this.connection.driver instanceof SqliteDriver &&\n    //     (values1.length + values2.length) > 500 &&\n    //     values1.length === values2.length) {\n    //     console.log(`I can do it`);\n    //     return qb.getRawMany();\n    //\n    // } else {\n    //     return qb.getRawMany();\n    // }\n    // execute query\n    const condition = [condition1, condition2].filter(v => v.length > 0).join(\" AND \");\n    return qb.from(junctionMetadata.target, mainAlias).where(condition).getRawMany();\n  }\n  /**\n   * Loads relation ids for the many-to-one and one-to-one owner relations.\n   */\n  loadForManyToOneAndOneToOneOwner(relation, entities, relatedEntities) {\n    const mainAlias = relation.entityMetadata.targetName;\n    // console.log(\"entitiesx\", entities);\n    // console.log(\"relatedEntitiesx\", relatedEntities);\n    const hasAllJoinColumnsInEntity = relation.joinColumns.every(joinColumn => {\n      return !!relation.entityMetadata.nonVirtualColumns.find(column => column === joinColumn);\n    });\n    if (relatedEntities && hasAllJoinColumnsInEntity) {\n      let relationIdMaps = [];\n      entities.forEach(entity => {\n        let relationIdMap = {};\n        relation.entityMetadata.primaryColumns.forEach(primaryColumn => {\n          const key = primaryColumn.entityMetadata.name + \"_\" + primaryColumn.propertyPath.replace(\".\", \"_\");\n          relationIdMap[key] = primaryColumn.getEntityValue(entity);\n        });\n        relatedEntities.forEach(relatedEntity => {\n          relation.joinColumns.forEach(joinColumn => {\n            const entityColumnValue = joinColumn.getEntityValue(entity);\n            const relatedEntityColumnValue = joinColumn.referencedColumn.getEntityValue(relatedEntity);\n            if (entityColumnValue === undefined || relatedEntityColumnValue === undefined) return;\n            if (entityColumnValue === relatedEntityColumnValue) {\n              const key = joinColumn.referencedColumn.entityMetadata.name + \"_\" + relation.propertyPath.replace(\".\", \"_\") + \"_\" + joinColumn.referencedColumn.propertyPath.replace(\".\", \"_\");\n              relationIdMap[key] = relatedEntityColumnValue;\n            }\n          });\n        });\n        if (Object.keys(relationIdMap).length === relation.entityMetadata.primaryColumns.length + relation.joinColumns.length) {\n          relationIdMaps.push(relationIdMap);\n        }\n      });\n      // console.log(\"relationIdMap\", relationIdMaps);\n      // console.log(\"entities.length\", entities.length);\n      if (relationIdMaps.length === entities.length) return Promise.resolve(relationIdMaps);\n    }\n    // select all columns we need\n    const qb = this.connection.createQueryBuilder(this.queryRunner);\n    relation.entityMetadata.primaryColumns.forEach(primaryColumn => {\n      const columnName = DriverUtils.buildAlias(this.connection.driver, undefined, primaryColumn.entityMetadata.name + \"_\" + primaryColumn.propertyPath.replace(\".\", \"_\"));\n      qb.addSelect(mainAlias + \".\" + primaryColumn.propertyPath, columnName);\n    });\n    relation.joinColumns.forEach(column => {\n      const columnName = DriverUtils.buildAlias(this.connection.driver, undefined, column.referencedColumn.entityMetadata.name + \"_\" + relation.propertyPath.replace(\".\", \"_\") + \"_\" + column.referencedColumn.propertyPath.replace(\".\", \"_\"));\n      qb.addSelect(mainAlias + \".\" + column.propertyPath, columnName);\n    });\n    // add condition for entities\n    let condition = \"\";\n    if (relation.entityMetadata.primaryColumns.length === 1) {\n      const values = entities.map(entity => relation.entityMetadata.primaryColumns[0].getEntityValue(entity));\n      const areAllNumbers = values.every(value => typeof value === \"number\");\n      if (areAllNumbers) {\n        condition = `${mainAlias}.${relation.entityMetadata.primaryColumns[0].propertyPath} IN (${values.join(\", \")})`;\n      } else {\n        qb.setParameter(\"values\", values);\n        condition = mainAlias + \".\" + relation.entityMetadata.primaryColumns[0].propertyPath + \" IN (:...values)\"; // todo: use ANY for postgres\n      }\n    } else {\n      condition = entities.map((entity, entityIndex) => {\n        return relation.entityMetadata.primaryColumns.map((column, columnIndex) => {\n          const paramName = \"entity\" + entityIndex + \"_\" + columnIndex;\n          qb.setParameter(paramName, column.getEntityValue(entity));\n          return mainAlias + \".\" + column.propertyPath + \" = :\" + paramName;\n        }).join(\" AND \");\n      }).map(condition => \"(\" + condition + \")\").join(\" OR \");\n    }\n    // execute query\n    return qb.from(relation.entityMetadata.target, mainAlias).where(condition).getRawMany();\n  }\n  /**\n   * Loads relation ids for the one-to-many and one-to-one not owner relations.\n   */\n  loadForOneToManyAndOneToOneNotOwner(relation, entities, relatedEntities) {\n    relation = relation.inverseRelation;\n    if (relation.entityMetadata.primaryColumns.length === relation.joinColumns.length) {\n      const sameReferencedColumns = relation.entityMetadata.primaryColumns.every(column => {\n        return relation.joinColumns.indexOf(column) !== -1;\n      });\n      if (sameReferencedColumns) {\n        return Promise.resolve(entities.map(entity => {\n          const result = {};\n          relation.joinColumns.forEach(function (joinColumn) {\n            const value = joinColumn.referencedColumn.getEntityValue(entity);\n            const joinColumnName = joinColumn.referencedColumn.entityMetadata.name + \"_\" + joinColumn.referencedColumn.propertyPath.replace(\".\", \"_\");\n            const primaryColumnName = joinColumn.entityMetadata.name + \"_\" + relation.inverseRelation.propertyPath.replace(\".\", \"_\") + \"_\" + joinColumn.propertyPath.replace(\".\", \"_\");\n            result[joinColumnName] = value;\n            result[primaryColumnName] = value;\n          });\n          return result;\n        }));\n      }\n    }\n    const mainAlias = relation.entityMetadata.targetName;\n    // select all columns we need\n    const qb = this.connection.createQueryBuilder(this.queryRunner);\n    relation.entityMetadata.primaryColumns.forEach(primaryColumn => {\n      const columnName = DriverUtils.buildAlias(this.connection.driver, undefined, primaryColumn.entityMetadata.name + \"_\" + relation.inverseRelation.propertyPath.replace(\".\", \"_\") + \"_\" + primaryColumn.propertyPath.replace(\".\", \"_\"));\n      qb.addSelect(mainAlias + \".\" + primaryColumn.propertyPath, columnName);\n    });\n    relation.joinColumns.forEach(column => {\n      const columnName = DriverUtils.buildAlias(this.connection.driver, undefined, column.referencedColumn.entityMetadata.name + \"_\" + column.referencedColumn.propertyPath.replace(\".\", \"_\"));\n      qb.addSelect(mainAlias + \".\" + column.propertyPath, columnName);\n    });\n    // add condition for entities\n    let condition = \"\";\n    if (relation.joinColumns.length === 1) {\n      const values = entities.map(entity => relation.joinColumns[0].referencedColumn.getEntityValue(entity));\n      const areAllNumbers = values.every(value => typeof value === \"number\");\n      if (areAllNumbers) {\n        condition = `${mainAlias}.${relation.joinColumns[0].propertyPath} IN (${values.join(\", \")})`;\n      } else {\n        qb.setParameter(\"values\", values);\n        condition = mainAlias + \".\" + relation.joinColumns[0].propertyPath + \" IN (:...values)\"; // todo: use ANY for postgres\n      }\n    } else {\n      condition = entities.map((entity, entityIndex) => {\n        return relation.joinColumns.map((joinColumn, joinColumnIndex) => {\n          const paramName = \"entity\" + entityIndex + \"_\" + joinColumnIndex;\n          qb.setParameter(paramName, joinColumn.referencedColumn.getEntityValue(entity));\n          return mainAlias + \".\" + joinColumn.propertyPath + \" = :\" + paramName;\n        }).join(\" AND \");\n      }).map(condition => \"(\" + condition + \")\").join(\" OR \");\n    }\n    // execute query\n    return qb.from(relation.entityMetadata.target, mainAlias).where(condition).getRawMany();\n  }\n}","map":{"version":3,"names":["DriverUtils","RelationIdLoader","constructor","connection","queryRunner","load","relation","entityOrEntities","relatedEntityOrRelatedEntities","entities","Array","isArray","relatedEntities","undefined","isManyToMany","loadForManyToMany","isManyToOne","isOneToOneOwner","loadForManyToOneAndOneToOneOwner","loadForOneToManyAndOneToOneNotOwner","loadManyToManyRelationIdsAndGroup","entitiesOrEntities","relatedEntityOrEntities","queryBuilder","_this","_asyncToGenerator","isMany","isOneToMany","relationLoader","length","map","entity","related","relationIds","columns","inverseColumns","isManyToManyOwner","junctionEntityMetadata","column","referencedColumn","ownerColumns","isManyToManyNotOwner","joinColumns","entityMetadata","primaryColumns","isOneToOneNotOwner","inverseRelation","group","entityRelationIds","filter","relationId","every","compareEntityValue","name","propertyAliasName","forEach","relatedEntity","relatedEntityMatched","buildAlias","driver","propertyPath","replace","push","junctionMetadata","mainAlias","isOwning","qb","createQueryBuilder","columnName","addSelect","condition1","values","getEntityValue","areAllNumbers","value","join","setParameter","entityIndex","paramName","propertyName","condition","condition2","v","from","target","where","getRawMany","targetName","hasAllJoinColumnsInEntity","joinColumn","nonVirtualColumns","find","relationIdMaps","relationIdMap","primaryColumn","key","entityColumnValue","relatedEntityColumnValue","Object","keys","Promise","resolve","columnIndex","sameReferencedColumns","indexOf","result","joinColumnName","primaryColumnName","joinColumnIndex"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/query-builder/RelationIdLoader.js"],"sourcesContent":["import { DriverUtils } from \"../driver/DriverUtils\";\n/**\n * Loads relation ids for the given entities.\n */\nexport class RelationIdLoader {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n    constructor(connection, queryRunner) {\n        this.connection = connection;\n        this.queryRunner = queryRunner;\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Loads relation ids of the given entity or entities.\n     */\n    load(relation, entityOrEntities, relatedEntityOrRelatedEntities) {\n        const entities = Array.isArray(entityOrEntities)\n            ? entityOrEntities\n            : [entityOrEntities];\n        const relatedEntities = Array.isArray(relatedEntityOrRelatedEntities)\n            ? relatedEntityOrRelatedEntities\n            : relatedEntityOrRelatedEntities\n                ? [relatedEntityOrRelatedEntities]\n                : undefined;\n        // load relation ids depend of relation type\n        if (relation.isManyToMany) {\n            return this.loadForManyToMany(relation, entities, relatedEntities);\n        }\n        else if (relation.isManyToOne || relation.isOneToOneOwner) {\n            return this.loadForManyToOneAndOneToOneOwner(relation, entities, relatedEntities);\n        }\n        else {\n            // if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n            return this.loadForOneToManyAndOneToOneNotOwner(relation, entities, relatedEntities);\n        }\n    }\n    /**\n     * Loads relation ids of the given entities and groups them into the object with parent and children.\n     *\n     * todo: extract this method?\n     */\n    async loadManyToManyRelationIdsAndGroup(relation, entitiesOrEntities, relatedEntityOrEntities, queryBuilder) {\n        // console.log(\"relation:\", relation.propertyName);\n        // console.log(\"entitiesOrEntities\", entitiesOrEntities);\n        const isMany = relation.isManyToMany || relation.isOneToMany;\n        const entities = Array.isArray(entitiesOrEntities)\n            ? entitiesOrEntities\n            : [entitiesOrEntities];\n        if (!relatedEntityOrEntities) {\n            relatedEntityOrEntities = await this.connection.relationLoader.load(relation, entitiesOrEntities, this.queryRunner, queryBuilder);\n            if (!relatedEntityOrEntities.length)\n                return entities.map((entity) => ({\n                    entity: entity,\n                    related: isMany ? [] : undefined,\n                }));\n        }\n        // const relationIds = await this.load(relation, relatedEntityOrEntities!, entitiesOrEntities);\n        const relationIds = await this.load(relation, entitiesOrEntities, relatedEntityOrEntities);\n        // console.log(\"entities\", entities);\n        // console.log(\"relatedEntityOrEntities\", relatedEntityOrEntities);\n        // console.log(\"relationIds\", relationIds);\n        const relatedEntities = Array.isArray(relatedEntityOrEntities)\n            ? relatedEntityOrEntities\n            : [relatedEntityOrEntities];\n        let columns = [], inverseColumns = [];\n        if (relation.isManyToManyOwner) {\n            columns = relation.junctionEntityMetadata.inverseColumns.map((column) => column.referencedColumn);\n            inverseColumns = relation.junctionEntityMetadata.ownerColumns.map((column) => column.referencedColumn);\n        }\n        else if (relation.isManyToManyNotOwner) {\n            columns = relation.junctionEntityMetadata.ownerColumns.map((column) => column.referencedColumn);\n            inverseColumns =\n                relation.junctionEntityMetadata.inverseColumns.map((column) => column.referencedColumn);\n        }\n        else if (relation.isManyToOne || relation.isOneToOneOwner) {\n            columns = relation.joinColumns.map((column) => column.referencedColumn);\n            inverseColumns = relation.entityMetadata.primaryColumns;\n        }\n        else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n            columns = relation.inverseRelation.entityMetadata.primaryColumns;\n            inverseColumns = relation.inverseRelation.joinColumns.map((column) => column.referencedColumn);\n        }\n        else {\n        }\n        return entities.map((entity) => {\n            const group = {\n                entity: entity,\n                related: isMany ? [] : undefined,\n            };\n            const entityRelationIds = relationIds.filter((relationId) => {\n                return inverseColumns.every((column) => {\n                    return column.compareEntityValue(entity, relationId[column.entityMetadata.name +\n                        \"_\" +\n                        column.propertyAliasName]);\n                });\n            });\n            if (!entityRelationIds.length)\n                return group;\n            relatedEntities.forEach((relatedEntity) => {\n                entityRelationIds.forEach((relationId) => {\n                    const relatedEntityMatched = columns.every((column) => {\n                        return column.compareEntityValue(relatedEntity, relationId[DriverUtils.buildAlias(this.connection.driver, undefined, column.entityMetadata.name +\n                            \"_\" +\n                            relation.propertyPath.replace(\".\", \"_\") +\n                            \"_\" +\n                            column.propertyPath.replace(\".\", \"_\"))]);\n                    });\n                    if (relatedEntityMatched) {\n                        if (isMany) {\n                            ;\n                            group.related.push(relatedEntity);\n                        }\n                        else {\n                            group.related = relatedEntity;\n                        }\n                    }\n                });\n            });\n            return group;\n        });\n    }\n    /**\n     * Loads relation ids of the given entities and maps them into the given entity property.\n     async loadManyToManyRelationIdsAndMap(\n     relation: RelationMetadata,\n     entityOrEntities: ObjectLiteral|ObjectLiteral[],\n     mapToEntityOrEntities: ObjectLiteral|ObjectLiteral[],\n     propertyName: string\n     ): Promise<void> {\n        const relationIds = await this.loadManyToManyRelationIds(relation, entityOrEntities, mapToEntityOrEntities);\n        const mapToEntities = mapToEntityOrEntities instanceof Array ? mapToEntityOrEntities : [mapToEntityOrEntities];\n        const junctionMetadata = relation.junctionEntityMetadata!;\n        const mainAlias = junctionMetadata.name;\n        const columns = relation.isOwning ? junctionMetadata.inverseColumns : junctionMetadata.ownerColumns;\n        const inverseColumns = relation.isOwning ? junctionMetadata.ownerColumns : junctionMetadata.inverseColumns;\n        mapToEntities.forEach(mapToEntity => {\n            mapToEntity[propertyName] = [];\n            relationIds.forEach(relationId => {\n                const match = inverseColumns.every(column => {\n                    return column.referencedColumn!.getEntityValue(mapToEntity) === relationId[mainAlias + \"_\" + column.propertyName];\n                });\n                if (match) {\n                    if (columns.length === 1) {\n                        mapToEntity[propertyName].push(relationId[mainAlias + \"_\" + columns[0].propertyName]);\n                    } else {\n                        const value = {};\n                        columns.forEach(column => {\n                            column.referencedColumn!.setEntityValue(value, relationId[mainAlias + \"_\" + column.propertyName]);\n                        });\n                        mapToEntity[propertyName].push(value);\n                    }\n                }\n            });\n        });\n    }*/\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Loads relation ids for the many-to-many relation.\n     */\n    loadForManyToMany(relation, entities, relatedEntities) {\n        const junctionMetadata = relation.junctionEntityMetadata;\n        const mainAlias = junctionMetadata.name;\n        const columns = relation.isOwning\n            ? junctionMetadata.ownerColumns\n            : junctionMetadata.inverseColumns;\n        const inverseColumns = relation.isOwning\n            ? junctionMetadata.inverseColumns\n            : junctionMetadata.ownerColumns;\n        const qb = this.connection.createQueryBuilder(this.queryRunner);\n        // select all columns from junction table\n        columns.forEach((column) => {\n            const columnName = DriverUtils.buildAlias(this.connection.driver, undefined, column.referencedColumn.entityMetadata.name +\n                \"_\" +\n                column.referencedColumn.propertyPath.replace(\".\", \"_\"));\n            qb.addSelect(mainAlias + \".\" + column.propertyPath, columnName);\n        });\n        inverseColumns.forEach((column) => {\n            const columnName = DriverUtils.buildAlias(this.connection.driver, undefined, column.referencedColumn.entityMetadata.name +\n                \"_\" +\n                relation.propertyPath.replace(\".\", \"_\") +\n                \"_\" +\n                column.referencedColumn.propertyPath.replace(\".\", \"_\"));\n            qb.addSelect(mainAlias + \".\" + column.propertyPath, columnName);\n        });\n        // add conditions for the given entities\n        let condition1 = \"\";\n        if (columns.length === 1) {\n            const values = entities.map((entity) => columns[0].referencedColumn.getEntityValue(entity));\n            const areAllNumbers = values.every((value) => typeof value === \"number\");\n            if (areAllNumbers) {\n                condition1 = `${mainAlias}.${columns[0].propertyPath} IN (${values.join(\", \")})`;\n            }\n            else {\n                qb.setParameter(\"values1\", values);\n                condition1 =\n                    mainAlias +\n                        \".\" +\n                        columns[0].propertyPath +\n                        \" IN (:...values1)\"; // todo: use ANY for postgres\n            }\n        }\n        else {\n            condition1 =\n                \"(\" +\n                    entities\n                        .map((entity, entityIndex) => {\n                        return columns\n                            .map((column) => {\n                            const paramName = \"entity1_\" +\n                                entityIndex +\n                                \"_\" +\n                                column.propertyName;\n                            qb.setParameter(paramName, column.referencedColumn.getEntityValue(entity));\n                            return (mainAlias +\n                                \".\" +\n                                column.propertyPath +\n                                \" = :\" +\n                                paramName);\n                        })\n                            .join(\" AND \");\n                    })\n                        .map((condition) => \"(\" + condition + \")\")\n                        .join(\" OR \") +\n                    \")\";\n        }\n        // add conditions for the given inverse entities\n        let condition2 = \"\";\n        if (relatedEntities) {\n            if (inverseColumns.length === 1) {\n                const values = relatedEntities.map((entity) => inverseColumns[0].referencedColumn.getEntityValue(entity));\n                const areAllNumbers = values.every((value) => typeof value === \"number\");\n                if (areAllNumbers) {\n                    condition2 = `${mainAlias}.${inverseColumns[0].propertyPath} IN (${values.join(\", \")})`;\n                }\n                else {\n                    qb.setParameter(\"values2\", values);\n                    condition2 =\n                        mainAlias +\n                            \".\" +\n                            inverseColumns[0].propertyPath +\n                            \" IN (:...values2)\"; // todo: use ANY for postgres\n                }\n            }\n            else {\n                condition2 =\n                    \"(\" +\n                        relatedEntities\n                            .map((entity, entityIndex) => {\n                            return inverseColumns\n                                .map((column) => {\n                                const paramName = \"entity2_\" +\n                                    entityIndex +\n                                    \"_\" +\n                                    column.propertyName;\n                                qb.setParameter(paramName, column.referencedColumn.getEntityValue(entity));\n                                return (mainAlias +\n                                    \".\" +\n                                    column.propertyPath +\n                                    \" = :\" +\n                                    paramName);\n                            })\n                                .join(\" AND \");\n                        })\n                            .map((condition) => \"(\" + condition + \")\")\n                            .join(\" OR \") +\n                        \")\";\n            }\n        }\n        // qb.from(junctionMetadata.target, mainAlias)\n        //     .where(condition1 + (condition2 ? \" AND \" + condition2 : \"\"));\n        //\n        // // execute query\n        // const { values1, values2 } = qb.getParameters();\n        // console.log(`I can do it`, { values1, values2 });\n        // if (inverseColumns.length === 1 &&\n        //     columns.length === 1 &&\n        //     this.connection.driver instanceof SqliteDriver &&\n        //     (values1.length + values2.length) > 500 &&\n        //     values1.length === values2.length) {\n        //     console.log(`I can do it`);\n        //     return qb.getRawMany();\n        //\n        // } else {\n        //     return qb.getRawMany();\n        // }\n        // execute query\n        const condition = [condition1, condition2]\n            .filter((v) => v.length > 0)\n            .join(\" AND \");\n        return qb\n            .from(junctionMetadata.target, mainAlias)\n            .where(condition)\n            .getRawMany();\n    }\n    /**\n     * Loads relation ids for the many-to-one and one-to-one owner relations.\n     */\n    loadForManyToOneAndOneToOneOwner(relation, entities, relatedEntities) {\n        const mainAlias = relation.entityMetadata.targetName;\n        // console.log(\"entitiesx\", entities);\n        // console.log(\"relatedEntitiesx\", relatedEntities);\n        const hasAllJoinColumnsInEntity = relation.joinColumns.every((joinColumn) => {\n            return !!relation.entityMetadata.nonVirtualColumns.find((column) => column === joinColumn);\n        });\n        if (relatedEntities && hasAllJoinColumnsInEntity) {\n            let relationIdMaps = [];\n            entities.forEach((entity) => {\n                let relationIdMap = {};\n                relation.entityMetadata.primaryColumns.forEach((primaryColumn) => {\n                    const key = primaryColumn.entityMetadata.name +\n                        \"_\" +\n                        primaryColumn.propertyPath.replace(\".\", \"_\");\n                    relationIdMap[key] =\n                        primaryColumn.getEntityValue(entity);\n                });\n                relatedEntities.forEach((relatedEntity) => {\n                    relation.joinColumns.forEach((joinColumn) => {\n                        const entityColumnValue = joinColumn.getEntityValue(entity);\n                        const relatedEntityColumnValue = joinColumn.referencedColumn.getEntityValue(relatedEntity);\n                        if (entityColumnValue === undefined ||\n                            relatedEntityColumnValue === undefined)\n                            return;\n                        if (entityColumnValue === relatedEntityColumnValue) {\n                            const key = joinColumn.referencedColumn.entityMetadata\n                                .name +\n                                \"_\" +\n                                relation.propertyPath.replace(\".\", \"_\") +\n                                \"_\" +\n                                joinColumn.referencedColumn.propertyPath.replace(\".\", \"_\");\n                            relationIdMap[key] = relatedEntityColumnValue;\n                        }\n                    });\n                });\n                if (Object.keys(relationIdMap).length ===\n                    relation.entityMetadata.primaryColumns.length +\n                        relation.joinColumns.length) {\n                    relationIdMaps.push(relationIdMap);\n                }\n            });\n            // console.log(\"relationIdMap\", relationIdMaps);\n            // console.log(\"entities.length\", entities.length);\n            if (relationIdMaps.length === entities.length)\n                return Promise.resolve(relationIdMaps);\n        }\n        // select all columns we need\n        const qb = this.connection.createQueryBuilder(this.queryRunner);\n        relation.entityMetadata.primaryColumns.forEach((primaryColumn) => {\n            const columnName = DriverUtils.buildAlias(this.connection.driver, undefined, primaryColumn.entityMetadata.name +\n                \"_\" +\n                primaryColumn.propertyPath.replace(\".\", \"_\"));\n            qb.addSelect(mainAlias + \".\" + primaryColumn.propertyPath, columnName);\n        });\n        relation.joinColumns.forEach((column) => {\n            const columnName = DriverUtils.buildAlias(this.connection.driver, undefined, column.referencedColumn.entityMetadata.name +\n                \"_\" +\n                relation.propertyPath.replace(\".\", \"_\") +\n                \"_\" +\n                column.referencedColumn.propertyPath.replace(\".\", \"_\"));\n            qb.addSelect(mainAlias + \".\" + column.propertyPath, columnName);\n        });\n        // add condition for entities\n        let condition = \"\";\n        if (relation.entityMetadata.primaryColumns.length === 1) {\n            const values = entities.map((entity) => relation.entityMetadata.primaryColumns[0].getEntityValue(entity));\n            const areAllNumbers = values.every((value) => typeof value === \"number\");\n            if (areAllNumbers) {\n                condition = `${mainAlias}.${relation.entityMetadata.primaryColumns[0].propertyPath} IN (${values.join(\", \")})`;\n            }\n            else {\n                qb.setParameter(\"values\", values);\n                condition =\n                    mainAlias +\n                        \".\" +\n                        relation.entityMetadata.primaryColumns[0].propertyPath +\n                        \" IN (:...values)\"; // todo: use ANY for postgres\n            }\n        }\n        else {\n            condition = entities\n                .map((entity, entityIndex) => {\n                return relation.entityMetadata.primaryColumns\n                    .map((column, columnIndex) => {\n                    const paramName = \"entity\" + entityIndex + \"_\" + columnIndex;\n                    qb.setParameter(paramName, column.getEntityValue(entity));\n                    return (mainAlias +\n                        \".\" +\n                        column.propertyPath +\n                        \" = :\" +\n                        paramName);\n                })\n                    .join(\" AND \");\n            })\n                .map((condition) => \"(\" + condition + \")\")\n                .join(\" OR \");\n        }\n        // execute query\n        return qb\n            .from(relation.entityMetadata.target, mainAlias)\n            .where(condition)\n            .getRawMany();\n    }\n    /**\n     * Loads relation ids for the one-to-many and one-to-one not owner relations.\n     */\n    loadForOneToManyAndOneToOneNotOwner(relation, entities, relatedEntities) {\n        relation = relation.inverseRelation;\n        if (relation.entityMetadata.primaryColumns.length ===\n            relation.joinColumns.length) {\n            const sameReferencedColumns = relation.entityMetadata.primaryColumns.every((column) => {\n                return relation.joinColumns.indexOf(column) !== -1;\n            });\n            if (sameReferencedColumns) {\n                return Promise.resolve(entities.map((entity) => {\n                    const result = {};\n                    relation.joinColumns.forEach(function (joinColumn) {\n                        const value = joinColumn.referencedColumn.getEntityValue(entity);\n                        const joinColumnName = joinColumn.referencedColumn.entityMetadata\n                            .name +\n                            \"_\" +\n                            joinColumn.referencedColumn.propertyPath.replace(\".\", \"_\");\n                        const primaryColumnName = joinColumn.entityMetadata.name +\n                            \"_\" +\n                            relation.inverseRelation.propertyPath.replace(\".\", \"_\") +\n                            \"_\" +\n                            joinColumn.propertyPath.replace(\".\", \"_\");\n                        result[joinColumnName] = value;\n                        result[primaryColumnName] = value;\n                    });\n                    return result;\n                }));\n            }\n        }\n        const mainAlias = relation.entityMetadata.targetName;\n        // select all columns we need\n        const qb = this.connection.createQueryBuilder(this.queryRunner);\n        relation.entityMetadata.primaryColumns.forEach((primaryColumn) => {\n            const columnName = DriverUtils.buildAlias(this.connection.driver, undefined, primaryColumn.entityMetadata.name +\n                \"_\" +\n                relation.inverseRelation.propertyPath.replace(\".\", \"_\") +\n                \"_\" +\n                primaryColumn.propertyPath.replace(\".\", \"_\"));\n            qb.addSelect(mainAlias + \".\" + primaryColumn.propertyPath, columnName);\n        });\n        relation.joinColumns.forEach((column) => {\n            const columnName = DriverUtils.buildAlias(this.connection.driver, undefined, column.referencedColumn.entityMetadata.name +\n                \"_\" +\n                column.referencedColumn.propertyPath.replace(\".\", \"_\"));\n            qb.addSelect(mainAlias + \".\" + column.propertyPath, columnName);\n        });\n        // add condition for entities\n        let condition = \"\";\n        if (relation.joinColumns.length === 1) {\n            const values = entities.map((entity) => relation.joinColumns[0].referencedColumn.getEntityValue(entity));\n            const areAllNumbers = values.every((value) => typeof value === \"number\");\n            if (areAllNumbers) {\n                condition = `${mainAlias}.${relation.joinColumns[0].propertyPath} IN (${values.join(\", \")})`;\n            }\n            else {\n                qb.setParameter(\"values\", values);\n                condition =\n                    mainAlias +\n                        \".\" +\n                        relation.joinColumns[0].propertyPath +\n                        \" IN (:...values)\"; // todo: use ANY for postgres\n            }\n        }\n        else {\n            condition = entities\n                .map((entity, entityIndex) => {\n                return relation.joinColumns\n                    .map((joinColumn, joinColumnIndex) => {\n                    const paramName = \"entity\" + entityIndex + \"_\" + joinColumnIndex;\n                    qb.setParameter(paramName, joinColumn.referencedColumn.getEntityValue(entity));\n                    return (mainAlias +\n                        \".\" +\n                        joinColumn.propertyPath +\n                        \" = :\" +\n                        paramName);\n                })\n                    .join(\" AND \");\n            })\n                .map((condition) => \"(\" + condition + \")\")\n                .join(\" OR \");\n        }\n        // execute query\n        return qb\n            .from(relation.entityMetadata.target, mainAlias)\n            .where(condition)\n            .getRawMany();\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}