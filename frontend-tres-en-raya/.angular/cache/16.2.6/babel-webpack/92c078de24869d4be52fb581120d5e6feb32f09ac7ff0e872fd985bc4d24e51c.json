{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/practicas/Downloads/angular/tresOnline/frontend-tres-en-raya/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\nimport { EntityMetadata } from \"../../metadata/EntityMetadata\";\nimport { Brackets } from \"../../query-builder/Brackets\";\n/**\n * Executes subject operations for materialized-path tree entities.\n */\nexport class MaterializedPathSubjectExecutor {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(queryRunner) {\n    this.queryRunner = queryRunner;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Executes operations when subject is being inserted.\n   */\n  insert(subject) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      let parent = subject.metadata.treeParentRelation.getEntityValue(subject.entity); // if entity was attached via parent\n      if (!parent && subject.parentSubject && subject.parentSubject.entity)\n        // if entity was attached via children\n        parent = subject.parentSubject.insertedValueSet ? subject.parentSubject.insertedValueSet : subject.parentSubject.entity;\n      const parentId = subject.metadata.getEntityIdMap(parent);\n      let parentPath = \"\";\n      if (parentId) {\n        parentPath = yield _this.getEntityPath(subject, parentId);\n      }\n      const insertedEntityId = subject.metadata.treeParentRelation.joinColumns.map(joinColumn => {\n        return joinColumn.referencedColumn.getEntityValue(subject.insertedValueSet);\n      }).join(\"_\");\n      yield _this.queryRunner.manager.createQueryBuilder().update(subject.metadata.target).set({\n        [subject.metadata.materializedPathColumn.propertyPath]: parentPath + insertedEntityId + \".\"\n      }).where(subject.identifier).execute();\n    })();\n  }\n  /**\n   * Executes operations when subject is being updated.\n   */\n  update(subject) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      let newParent = subject.metadata.treeParentRelation.getEntityValue(subject.entity); // if entity was attached via parent\n      if (!newParent && subject.parentSubject && subject.parentSubject.entity)\n        // if entity was attached via children\n        newParent = subject.parentSubject.entity;\n      let entity = subject.databaseEntity; // if entity was attached via parent\n      if (!entity && newParent)\n        // if entity was attached via children\n        entity = subject.metadata.treeChildrenRelation.getEntityValue(newParent).find(child => {\n          return Object.entries(subject.identifier).every(([key, value]) => child[key] === value);\n        });\n      const oldParent = subject.metadata.treeParentRelation.getEntityValue(entity);\n      const oldParentId = _this2.getEntityParentReferencedColumnMap(subject, oldParent);\n      const newParentId = _this2.getEntityParentReferencedColumnMap(subject, newParent);\n      // Exit if the new and old parents are the same\n      if (OrmUtils.compareIds(oldParentId, newParentId)) {\n        return;\n      }\n      let newParentPath = \"\";\n      if (newParentId) {\n        newParentPath = yield _this2.getEntityPath(subject, newParentId);\n      }\n      let oldParentPath = \"\";\n      if (oldParentId) {\n        oldParentPath = (yield _this2.getEntityPath(subject, oldParentId)) || \"\";\n      }\n      const entityPath = subject.metadata.treeParentRelation.joinColumns.map(joinColumn => {\n        return joinColumn.referencedColumn.getEntityValue(entity);\n      }).join(\"_\");\n      const propertyPath = subject.metadata.materializedPathColumn.propertyPath;\n      yield _this2.queryRunner.manager.createQueryBuilder().update(subject.metadata.target).set({\n        [propertyPath]: () => `REPLACE(${_this2.queryRunner.connection.driver.escape(propertyPath)}, '${oldParentPath}${entityPath}.', '${newParentPath}${entityPath}.')`\n      }).where(`${propertyPath} LIKE :path`, {\n        path: `${oldParentPath}${entityPath}.%`\n      }).execute();\n    })();\n  }\n  getEntityParentReferencedColumnMap(subject, entity) {\n    if (!entity) return undefined;\n    return EntityMetadata.getValueMap(entity, subject.metadata.treeParentRelation.joinColumns.map(column => column.referencedColumn).filter(v => v != null), {\n      skipNulls: true\n    });\n  }\n  getEntityPath(subject, id) {\n    const metadata = subject.metadata;\n    const normalized = (Array.isArray(id) ? id : [id]).map(id => metadata.ensureEntityIdMap(id));\n    return this.queryRunner.manager.createQueryBuilder().select(subject.metadata.targetName + \".\" + subject.metadata.materializedPathColumn.propertyPath, \"path\").from(subject.metadata.target, subject.metadata.targetName).where(new Brackets(qb => {\n      for (const data of normalized) {\n        qb.orWhere(new Brackets(qb => qb.where(data)));\n      }\n    })).getRawOne().then(result => result ? result[\"path\"] : \"\");\n  }\n}","map":{"version":3,"names":["OrmUtils","EntityMetadata","Brackets","MaterializedPathSubjectExecutor","constructor","queryRunner","insert","subject","_this","_asyncToGenerator","parent","metadata","treeParentRelation","getEntityValue","entity","parentSubject","insertedValueSet","parentId","getEntityIdMap","parentPath","getEntityPath","insertedEntityId","joinColumns","map","joinColumn","referencedColumn","join","manager","createQueryBuilder","update","target","set","materializedPathColumn","propertyPath","where","identifier","execute","_this2","newParent","databaseEntity","treeChildrenRelation","find","child","Object","entries","every","key","value","oldParent","oldParentId","getEntityParentReferencedColumnMap","newParentId","compareIds","newParentPath","oldParentPath","entityPath","connection","driver","escape","path","undefined","getValueMap","column","filter","v","skipNulls","id","normalized","Array","isArray","ensureEntityIdMap","select","targetName","from","qb","data","orWhere","getRawOne","then","result"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/persistence/tree/MaterializedPathSubjectExecutor.js"],"sourcesContent":["import { OrmUtils } from \"../../util/OrmUtils\";\nimport { EntityMetadata } from \"../../metadata/EntityMetadata\";\nimport { Brackets } from \"../../query-builder/Brackets\";\n/**\n * Executes subject operations for materialized-path tree entities.\n */\nexport class MaterializedPathSubjectExecutor {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n    constructor(queryRunner) {\n        this.queryRunner = queryRunner;\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Executes operations when subject is being inserted.\n     */\n    async insert(subject) {\n        let parent = subject.metadata.treeParentRelation.getEntityValue(subject.entity); // if entity was attached via parent\n        if (!parent && subject.parentSubject && subject.parentSubject.entity)\n            // if entity was attached via children\n            parent = subject.parentSubject.insertedValueSet\n                ? subject.parentSubject.insertedValueSet\n                : subject.parentSubject.entity;\n        const parentId = subject.metadata.getEntityIdMap(parent);\n        let parentPath = \"\";\n        if (parentId) {\n            parentPath = await this.getEntityPath(subject, parentId);\n        }\n        const insertedEntityId = subject.metadata\n            .treeParentRelation.joinColumns.map((joinColumn) => {\n            return joinColumn.referencedColumn.getEntityValue(subject.insertedValueSet);\n        })\n            .join(\"_\");\n        await this.queryRunner.manager\n            .createQueryBuilder()\n            .update(subject.metadata.target)\n            .set({\n            [subject.metadata.materializedPathColumn.propertyPath]: parentPath + insertedEntityId + \".\",\n        })\n            .where(subject.identifier)\n            .execute();\n    }\n    /**\n     * Executes operations when subject is being updated.\n     */\n    async update(subject) {\n        let newParent = subject.metadata.treeParentRelation.getEntityValue(subject.entity); // if entity was attached via parent\n        if (!newParent && subject.parentSubject && subject.parentSubject.entity)\n            // if entity was attached via children\n            newParent = subject.parentSubject.entity;\n        let entity = subject.databaseEntity; // if entity was attached via parent\n        if (!entity && newParent)\n            // if entity was attached via children\n            entity = subject.metadata\n                .treeChildrenRelation.getEntityValue(newParent)\n                .find((child) => {\n                return Object.entries(subject.identifier).every(([key, value]) => child[key] === value);\n            });\n        const oldParent = subject.metadata.treeParentRelation.getEntityValue(entity);\n        const oldParentId = this.getEntityParentReferencedColumnMap(subject, oldParent);\n        const newParentId = this.getEntityParentReferencedColumnMap(subject, newParent);\n        // Exit if the new and old parents are the same\n        if (OrmUtils.compareIds(oldParentId, newParentId)) {\n            return;\n        }\n        let newParentPath = \"\";\n        if (newParentId) {\n            newParentPath = await this.getEntityPath(subject, newParentId);\n        }\n        let oldParentPath = \"\";\n        if (oldParentId) {\n            oldParentPath =\n                (await this.getEntityPath(subject, oldParentId)) || \"\";\n        }\n        const entityPath = subject.metadata\n            .treeParentRelation.joinColumns.map((joinColumn) => {\n            return joinColumn.referencedColumn.getEntityValue(entity);\n        })\n            .join(\"_\");\n        const propertyPath = subject.metadata.materializedPathColumn.propertyPath;\n        await this.queryRunner.manager\n            .createQueryBuilder()\n            .update(subject.metadata.target)\n            .set({\n            [propertyPath]: () => `REPLACE(${this.queryRunner.connection.driver.escape(propertyPath)}, '${oldParentPath}${entityPath}.', '${newParentPath}${entityPath}.')`,\n        })\n            .where(`${propertyPath} LIKE :path`, {\n            path: `${oldParentPath}${entityPath}.%`,\n        })\n            .execute();\n    }\n    getEntityParentReferencedColumnMap(subject, entity) {\n        if (!entity)\n            return undefined;\n        return EntityMetadata.getValueMap(entity, subject.metadata\n            .treeParentRelation.joinColumns.map((column) => column.referencedColumn)\n            .filter((v) => v != null), { skipNulls: true });\n    }\n    getEntityPath(subject, id) {\n        const metadata = subject.metadata;\n        const normalized = (Array.isArray(id) ? id : [id]).map((id) => metadata.ensureEntityIdMap(id));\n        return this.queryRunner.manager\n            .createQueryBuilder()\n            .select(subject.metadata.targetName +\n            \".\" +\n            subject.metadata.materializedPathColumn.propertyPath, \"path\")\n            .from(subject.metadata.target, subject.metadata.targetName)\n            .where(new Brackets((qb) => {\n            for (const data of normalized) {\n                qb.orWhere(new Brackets((qb) => qb.where(data)));\n            }\n        }))\n            .getRawOne()\n            .then((result) => (result ? result[\"path\"] : \"\"));\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}