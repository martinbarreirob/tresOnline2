{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/practicas/Downloads/angular/tresOnline/frontend-tres-en-raya/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { QueryBuilder } from \"./QueryBuilder\";\nimport { RelationUpdater } from \"./RelationUpdater\";\nimport { RelationRemover } from \"./RelationRemover\";\nimport { TypeORMError } from \"../error\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\n/**\n * Allows to work with entity relations and perform specific operations with those relations.\n *\n * todo: add transactions everywhere\n */\nexport class RelationQueryBuilder extends QueryBuilder {\n  constructor() {\n    super(...arguments);\n    this[\"@instanceof\"] = Symbol.for(\"RelationQueryBuilder\");\n  }\n  // -------------------------------------------------------------------------\n  // Public Implemented Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Gets generated SQL query without parameters being replaced.\n   */\n  getQuery() {\n    return \"\";\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Sets entity (target) which relations will be updated.\n   */\n  of(entity) {\n    this.expressionMap.of = entity;\n    return this;\n  }\n  /**\n   * Sets entity relation's value.\n   * Value can be entity, entity id or entity id map (if entity has composite ids).\n   * Works only for many-to-one and one-to-one relations.\n   * For many-to-many and one-to-many relations use #add and #remove methods instead.\n   */\n  set(value) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const relation = _this.expressionMap.relationMetadata;\n      if (!_this.expressionMap.of)\n        // todo: move this check before relation query builder creation?\n        throw new TypeORMError(`Entity whose relation needs to be set is not set. Use .of method to define whose relation you want to set.`);\n      if (relation.isManyToMany || relation.isOneToMany) throw new TypeORMError(`Set operation is only supported for many-to-one and one-to-one relations. ` + `However given \"${relation.propertyPath}\" has ${relation.relationType} relation. ` + `Use .add() method instead.`);\n      // if there are multiple join columns then user must send id map as \"value\" argument. check if he really did it\n      if (relation.joinColumns && relation.joinColumns.length > 1 && (!ObjectUtils.isObject(value) || Object.keys(value).length < relation.joinColumns.length)) throw new TypeORMError(`Value to be set into the relation must be a map of relation ids, for example: .set({ firstName: \"...\", lastName: \"...\" })`);\n      const updater = new RelationUpdater(_this, _this.expressionMap);\n      return updater.update(value);\n    })();\n  }\n  /**\n   * Adds (binds) given value to entity relation.\n   * Value can be entity, entity id or entity id map (if entity has composite ids).\n   * Value also can be array of entities, array of entity ids or array of entity id maps (if entity has composite ids).\n   * Works only for many-to-many and one-to-many relations.\n   * For many-to-one and one-to-one use #set method instead.\n   */\n  add(value) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (Array.isArray(value) && value.length === 0) return;\n      const relation = _this2.expressionMap.relationMetadata;\n      if (!_this2.expressionMap.of)\n        // todo: move this check before relation query builder creation?\n        throw new TypeORMError(`Entity whose relation needs to be set is not set. Use .of method to define whose relation you want to set.`);\n      if (relation.isManyToOne || relation.isOneToOne) throw new TypeORMError(`Add operation is only supported for many-to-many and one-to-many relations. ` + `However given \"${relation.propertyPath}\" has ${relation.relationType} relation. ` + `Use .set() method instead.`);\n      // if there are multiple join columns then user must send id map as \"value\" argument. check if he really did it\n      if (relation.joinColumns && relation.joinColumns.length > 1 && (!ObjectUtils.isObject(value) || Object.keys(value).length < relation.joinColumns.length)) throw new TypeORMError(`Value to be set into the relation must be a map of relation ids, for example: .set({ firstName: \"...\", lastName: \"...\" })`);\n      const updater = new RelationUpdater(_this2, _this2.expressionMap);\n      return updater.update(value);\n    })();\n  }\n  /**\n   * Removes (unbinds) given value from entity relation.\n   * Value can be entity, entity id or entity id map (if entity has composite ids).\n   * Value also can be array of entities, array of entity ids or array of entity id maps (if entity has composite ids).\n   * Works only for many-to-many and one-to-many relations.\n   * For many-to-one and one-to-one use #set method instead.\n   */\n  remove(value) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      if (Array.isArray(value) && value.length === 0) return;\n      const relation = _this3.expressionMap.relationMetadata;\n      if (!_this3.expressionMap.of)\n        // todo: move this check before relation query builder creation?\n        throw new TypeORMError(`Entity whose relation needs to be set is not set. Use .of method to define whose relation you want to set.`);\n      if (relation.isManyToOne || relation.isOneToOne) throw new TypeORMError(`Add operation is only supported for many-to-many and one-to-many relations. ` + `However given \"${relation.propertyPath}\" has ${relation.relationType} relation. ` + `Use .set(null) method instead.`);\n      const remover = new RelationRemover(_this3, _this3.expressionMap);\n      return remover.remove(value);\n    })();\n  }\n  /**\n   * Adds (binds) and removes (unbinds) given values to/from entity relation.\n   * Value can be entity, entity id or entity id map (if entity has composite ids).\n   * Value also can be array of entities, array of entity ids or array of entity id maps (if entity has composite ids).\n   * Works only for many-to-many and one-to-many relations.\n   * For many-to-one and one-to-one use #set method instead.\n   */\n  addAndRemove(added, removed) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      yield _this4.remove(removed);\n      yield _this4.add(added);\n    })();\n  }\n  /**\n   * Gets entity's relation id.\n  async getId(): Promise<any> {\n   }*/\n  /**\n   * Gets entity's relation ids.\n  async getIds(): Promise<any[]> {\n      return [];\n  }*/\n  /**\n   * Loads a single entity (relational) from the relation.\n   * You can also provide id of relational entity to filter by.\n   */\n  loadOne() {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      return _this5.loadMany().then(results => results[0]);\n    })();\n  }\n  /**\n   * Loads many entities (relational) from the relation.\n   * You can also provide ids of relational entities to filter by.\n   */\n  loadMany() {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      let of = _this6.expressionMap.of;\n      if (!ObjectUtils.isObject(of)) {\n        const metadata = _this6.expressionMap.mainAlias.metadata;\n        if (metadata.hasMultiplePrimaryKeys) throw new TypeORMError(`Cannot load entity because only one primary key was specified, however entity contains multiple primary keys`);\n        of = metadata.primaryColumns[0].createValueMap(of);\n      }\n      return _this6.connection.relationLoader.load(_this6.expressionMap.relationMetadata, of, _this6.queryRunner);\n    })();\n  }\n}","map":{"version":3,"names":["QueryBuilder","RelationUpdater","RelationRemover","TypeORMError","ObjectUtils","RelationQueryBuilder","constructor","arguments","Symbol","for","getQuery","of","entity","expressionMap","set","value","_this","_asyncToGenerator","relation","relationMetadata","isManyToMany","isOneToMany","propertyPath","relationType","joinColumns","length","isObject","Object","keys","updater","update","add","_this2","Array","isArray","isManyToOne","isOneToOne","remove","_this3","remover","addAndRemove","added","removed","_this4","loadOne","_this5","loadMany","then","results","_this6","metadata","mainAlias","hasMultiplePrimaryKeys","primaryColumns","createValueMap","connection","relationLoader","load","queryRunner"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/query-builder/RelationQueryBuilder.js"],"sourcesContent":["import { QueryBuilder } from \"./QueryBuilder\";\nimport { RelationUpdater } from \"./RelationUpdater\";\nimport { RelationRemover } from \"./RelationRemover\";\nimport { TypeORMError } from \"../error\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\n/**\n * Allows to work with entity relations and perform specific operations with those relations.\n *\n * todo: add transactions everywhere\n */\nexport class RelationQueryBuilder extends QueryBuilder {\n    constructor() {\n        super(...arguments);\n        this[\"@instanceof\"] = Symbol.for(\"RelationQueryBuilder\");\n    }\n    // -------------------------------------------------------------------------\n    // Public Implemented Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Gets generated SQL query without parameters being replaced.\n     */\n    getQuery() {\n        return \"\";\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Sets entity (target) which relations will be updated.\n     */\n    of(entity) {\n        this.expressionMap.of = entity;\n        return this;\n    }\n    /**\n     * Sets entity relation's value.\n     * Value can be entity, entity id or entity id map (if entity has composite ids).\n     * Works only for many-to-one and one-to-one relations.\n     * For many-to-many and one-to-many relations use #add and #remove methods instead.\n     */\n    async set(value) {\n        const relation = this.expressionMap.relationMetadata;\n        if (!this.expressionMap.of)\n            // todo: move this check before relation query builder creation?\n            throw new TypeORMError(`Entity whose relation needs to be set is not set. Use .of method to define whose relation you want to set.`);\n        if (relation.isManyToMany || relation.isOneToMany)\n            throw new TypeORMError(`Set operation is only supported for many-to-one and one-to-one relations. ` +\n                `However given \"${relation.propertyPath}\" has ${relation.relationType} relation. ` +\n                `Use .add() method instead.`);\n        // if there are multiple join columns then user must send id map as \"value\" argument. check if he really did it\n        if (relation.joinColumns &&\n            relation.joinColumns.length > 1 &&\n            (!ObjectUtils.isObject(value) ||\n                Object.keys(value).length < relation.joinColumns.length))\n            throw new TypeORMError(`Value to be set into the relation must be a map of relation ids, for example: .set({ firstName: \"...\", lastName: \"...\" })`);\n        const updater = new RelationUpdater(this, this.expressionMap);\n        return updater.update(value);\n    }\n    /**\n     * Adds (binds) given value to entity relation.\n     * Value can be entity, entity id or entity id map (if entity has composite ids).\n     * Value also can be array of entities, array of entity ids or array of entity id maps (if entity has composite ids).\n     * Works only for many-to-many and one-to-many relations.\n     * For many-to-one and one-to-one use #set method instead.\n     */\n    async add(value) {\n        if (Array.isArray(value) && value.length === 0)\n            return;\n        const relation = this.expressionMap.relationMetadata;\n        if (!this.expressionMap.of)\n            // todo: move this check before relation query builder creation?\n            throw new TypeORMError(`Entity whose relation needs to be set is not set. Use .of method to define whose relation you want to set.`);\n        if (relation.isManyToOne || relation.isOneToOne)\n            throw new TypeORMError(`Add operation is only supported for many-to-many and one-to-many relations. ` +\n                `However given \"${relation.propertyPath}\" has ${relation.relationType} relation. ` +\n                `Use .set() method instead.`);\n        // if there are multiple join columns then user must send id map as \"value\" argument. check if he really did it\n        if (relation.joinColumns &&\n            relation.joinColumns.length > 1 &&\n            (!ObjectUtils.isObject(value) ||\n                Object.keys(value).length < relation.joinColumns.length))\n            throw new TypeORMError(`Value to be set into the relation must be a map of relation ids, for example: .set({ firstName: \"...\", lastName: \"...\" })`);\n        const updater = new RelationUpdater(this, this.expressionMap);\n        return updater.update(value);\n    }\n    /**\n     * Removes (unbinds) given value from entity relation.\n     * Value can be entity, entity id or entity id map (if entity has composite ids).\n     * Value also can be array of entities, array of entity ids or array of entity id maps (if entity has composite ids).\n     * Works only for many-to-many and one-to-many relations.\n     * For many-to-one and one-to-one use #set method instead.\n     */\n    async remove(value) {\n        if (Array.isArray(value) && value.length === 0)\n            return;\n        const relation = this.expressionMap.relationMetadata;\n        if (!this.expressionMap.of)\n            // todo: move this check before relation query builder creation?\n            throw new TypeORMError(`Entity whose relation needs to be set is not set. Use .of method to define whose relation you want to set.`);\n        if (relation.isManyToOne || relation.isOneToOne)\n            throw new TypeORMError(`Add operation is only supported for many-to-many and one-to-many relations. ` +\n                `However given \"${relation.propertyPath}\" has ${relation.relationType} relation. ` +\n                `Use .set(null) method instead.`);\n        const remover = new RelationRemover(this, this.expressionMap);\n        return remover.remove(value);\n    }\n    /**\n     * Adds (binds) and removes (unbinds) given values to/from entity relation.\n     * Value can be entity, entity id or entity id map (if entity has composite ids).\n     * Value also can be array of entities, array of entity ids or array of entity id maps (if entity has composite ids).\n     * Works only for many-to-many and one-to-many relations.\n     * For many-to-one and one-to-one use #set method instead.\n     */\n    async addAndRemove(added, removed) {\n        await this.remove(removed);\n        await this.add(added);\n    }\n    /**\n     * Gets entity's relation id.\n    async getId(): Promise<any> {\n\n    }*/\n    /**\n     * Gets entity's relation ids.\n    async getIds(): Promise<any[]> {\n        return [];\n    }*/\n    /**\n     * Loads a single entity (relational) from the relation.\n     * You can also provide id of relational entity to filter by.\n     */\n    async loadOne() {\n        return this.loadMany().then((results) => results[0]);\n    }\n    /**\n     * Loads many entities (relational) from the relation.\n     * You can also provide ids of relational entities to filter by.\n     */\n    async loadMany() {\n        let of = this.expressionMap.of;\n        if (!ObjectUtils.isObject(of)) {\n            const metadata = this.expressionMap.mainAlias.metadata;\n            if (metadata.hasMultiplePrimaryKeys)\n                throw new TypeORMError(`Cannot load entity because only one primary key was specified, however entity contains multiple primary keys`);\n            of = metadata.primaryColumns[0].createValueMap(of);\n        }\n        return this.connection.relationLoader.load(this.expressionMap.relationMetadata, of, this.queryRunner);\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}