{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/practicas/Downloads/angular/tresOnline/frontend-tres-en-raya/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { QueryFailedError } from \"../../error/QueryFailedError\";\nimport { QueryRunnerAlreadyReleasedError } from \"../../error/QueryRunnerAlreadyReleasedError\";\nimport { TransactionNotStartedError } from \"../../error/TransactionNotStartedError\";\nimport { BaseQueryRunner } from \"../../query-runner/BaseQueryRunner\";\nimport { Table } from \"../../schema-builder/table/Table\";\nimport { TableCheck } from \"../../schema-builder/table/TableCheck\";\nimport { TableColumn } from \"../../schema-builder/table/TableColumn\";\nimport { TableForeignKey } from \"../../schema-builder/table/TableForeignKey\";\nimport { TableIndex } from \"../../schema-builder/table/TableIndex\";\nimport { TableUnique } from \"../../schema-builder/table/TableUnique\";\nimport { View } from \"../../schema-builder/view/View\";\nimport { Broadcaster } from \"../../subscriber/Broadcaster\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\nimport { Query } from \"../Query\";\nimport { TypeORMError } from \"../../error\";\nimport { QueryResult } from \"../../query-runner/QueryResult\";\nimport { MetadataTableType } from \"../types/MetadataTableType\";\n/**\n * Runs queries on a single postgres database connection.\n */\nexport class SpannerQueryRunner extends BaseQueryRunner {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(driver, mode) {\n    super();\n    this.driver = driver;\n    this.connection = driver.connection;\n    this.mode = mode;\n    this.broadcaster = new Broadcaster(this);\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Creates/uses database connection from the connection pool to perform further operations.\n   * Returns obtained database connection.\n   */\n  connect() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      if (_this.session) {\n        return Promise.resolve(_this.session);\n      }\n      const [session] = yield _this.driver.instanceDatabase.createSession({});\n      _this.session = session;\n      _this.sessionTransaction = yield session.transaction();\n      return _this.session;\n    })();\n  }\n  /**\n   * Releases used database connection.\n   * You cannot use query runner methods once its released.\n   */\n  release() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      _this2.isReleased = true;\n      if (_this2.session) {\n        yield _this2.session.delete();\n      }\n      _this2.session = undefined;\n      return Promise.resolve();\n    })();\n  }\n  /**\n   * Starts transaction.\n   */\n  startTransaction(isolationLevel) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      _this3.isTransactionActive = true;\n      try {\n        yield _this3.broadcaster.broadcast(\"BeforeTransactionStart\");\n      } catch (err) {\n        _this3.isTransactionActive = false;\n        throw err;\n      }\n      yield _this3.connect();\n      yield _this3.sessionTransaction.begin();\n      _this3.connection.logger.logQuery(\"START TRANSACTION\");\n      yield _this3.broadcaster.broadcast(\"AfterTransactionStart\");\n    })();\n  }\n  /**\n   * Commits transaction.\n   * Error will be thrown if transaction was not started.\n   */\n  commitTransaction() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this4.isTransactionActive || !_this4.sessionTransaction) throw new TransactionNotStartedError();\n      yield _this4.broadcaster.broadcast(\"BeforeTransactionCommit\");\n      yield _this4.sessionTransaction.commit();\n      _this4.connection.logger.logQuery(\"COMMIT\");\n      _this4.isTransactionActive = false;\n      yield _this4.broadcaster.broadcast(\"AfterTransactionCommit\");\n    })();\n  }\n  /**\n   * Rollbacks transaction.\n   * Error will be thrown if transaction was not started.\n   */\n  rollbackTransaction() {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this5.isTransactionActive || !_this5.sessionTransaction) throw new TransactionNotStartedError();\n      yield _this5.broadcaster.broadcast(\"BeforeTransactionRollback\");\n      yield _this5.sessionTransaction.rollback();\n      _this5.connection.logger.logQuery(\"ROLLBACK\");\n      _this5.isTransactionActive = false;\n      yield _this5.broadcaster.broadcast(\"AfterTransactionRollback\");\n    })();\n  }\n  /**\n   * Executes a given SQL query.\n   */\n  query(query, parameters, useStructuredResult = false) {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      if (_this6.isReleased) throw new QueryRunnerAlreadyReleasedError();\n      try {\n        const queryStartTime = +new Date();\n        yield _this6.connect();\n        let rawResult = undefined;\n        const isSelect = query.startsWith(\"SELECT\");\n        const executor = isSelect && !_this6.isTransactionActive ? _this6.driver.instanceDatabase : _this6.sessionTransaction;\n        if (!_this6.isTransactionActive && !isSelect) {\n          yield _this6.sessionTransaction.begin();\n        }\n        try {\n          _this6.driver.connection.logger.logQuery(query, parameters, _this6);\n          rawResult = yield executor.run({\n            sql: query,\n            params: parameters ? parameters.reduce((params, value, index) => {\n              params[\"param\" + index] = value;\n              return params;\n            }, {}) : undefined,\n            json: true\n          });\n          if (!_this6.isTransactionActive && !isSelect) {\n            yield _this6.sessionTransaction.commit();\n          }\n        } catch (error) {\n          try {\n            // we throw original error even if rollback thrown an error\n            if (!_this6.isTransactionActive && !isSelect) yield _this6.sessionTransaction.rollback();\n          } catch (rollbackError) {}\n          throw error;\n        }\n        // log slow queries if maxQueryExecution time is set\n        const maxQueryExecutionTime = _this6.driver.options.maxQueryExecutionTime;\n        const queryEndTime = +new Date();\n        const queryExecutionTime = queryEndTime - queryStartTime;\n        if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) _this6.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, _this6);\n        const result = new QueryResult();\n        result.raw = rawResult;\n        result.records = rawResult ? rawResult[0] : [];\n        if (rawResult && rawResult[1] && rawResult[1].rowCountExact) {\n          result.affected = parseInt(rawResult[1].rowCountExact);\n        }\n        if (!useStructuredResult) {\n          return result.records;\n        }\n        return result;\n      } catch (err) {\n        _this6.driver.connection.logger.logQueryError(err, query, parameters, _this6);\n        throw new QueryFailedError(query, parameters, err);\n      } finally {}\n    })();\n  }\n  /**\n   * Update database schema.\n   * Used for creating/altering/dropping tables, columns, indexes, etc.\n   *\n   * DDL changing queries should be executed by `updateSchema()` method.\n   */\n  updateDDL(query, parameters) {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      if (_this7.isReleased) throw new QueryRunnerAlreadyReleasedError();\n      _this7.driver.connection.logger.logQuery(query, parameters, _this7);\n      try {\n        const queryStartTime = +new Date();\n        const [operation] = yield _this7.driver.instanceDatabase.updateSchema(query);\n        yield operation.promise();\n        // log slow queries if maxQueryExecution time is set\n        const maxQueryExecutionTime = _this7.driver.options.maxQueryExecutionTime;\n        const queryEndTime = +new Date();\n        const queryExecutionTime = queryEndTime - queryStartTime;\n        if (maxQueryExecutionTime && queryExecutionTime > maxQueryExecutionTime) _this7.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, _this7);\n      } catch (err) {\n        _this7.driver.connection.logger.logQueryError(err, query, parameters, _this7);\n        throw new QueryFailedError(query, parameters, err);\n      }\n    })();\n  }\n  /**\n   * Returns raw data stream.\n   */\n  stream(query, parameters, onEnd, onError) {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      if (_this8.isReleased) throw new QueryRunnerAlreadyReleasedError();\n      try {\n        _this8.driver.connection.logger.logQuery(query, parameters, _this8);\n        const request = {\n          sql: query,\n          params: parameters ? parameters.reduce((params, value, index) => {\n            params[\"param\" + index] = value;\n            return params;\n          }, {}) : undefined,\n          json: true\n        };\n        const stream = _this8.driver.instanceDatabase.runStream(request);\n        if (onEnd) {\n          stream.on(\"end\", onEnd);\n        }\n        if (onError) {\n          stream.on(\"error\", onError);\n        }\n        return stream;\n      } catch (err) {\n        _this8.driver.connection.logger.logQueryError(err, query, parameters, _this8);\n        throw new QueryFailedError(query, parameters, err);\n      }\n    })();\n  }\n  /**\n   * Returns all available database names including system databases.\n   */\n  getDatabases() {\n    return _asyncToGenerator(function* () {\n      return Promise.resolve([]);\n    })();\n  }\n  /**\n   * Returns all available schema names including system schemas.\n   * If database parameter specified, returns schemas of that database.\n   */\n  getSchemas(database) {\n    return _asyncToGenerator(function* () {\n      return Promise.resolve([]);\n    })();\n  }\n  /**\n   * Checks if database with the given name exist.\n   */\n  hasDatabase(database) {\n    return _asyncToGenerator(function* () {\n      throw new TypeORMError(`Check database queries are not supported by Spanner driver.`);\n    })();\n  }\n  /**\n   * Loads currently using database\n   */\n  getCurrentDatabase() {\n    return _asyncToGenerator(function* () {\n      throw new TypeORMError(`Check database queries are not supported by Spanner driver.`);\n    })();\n  }\n  /**\n   * Checks if schema with the given name exist.\n   */\n  hasSchema(schema) {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      const result = yield _this9.query(`SELECT * FROM \"information_schema\".\"schemata\" WHERE \"schema_name\" = '${schema}'`);\n      return result.length ? true : false;\n    })();\n  }\n  /**\n   * Loads currently using database schema\n   */\n  getCurrentSchema() {\n    return _asyncToGenerator(function* () {\n      throw new TypeORMError(`Check schema queries are not supported by Spanner driver.`);\n    })();\n  }\n  /**\n   * Checks if table with the given name exist in the database.\n   */\n  hasTable(tableOrName) {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      const tableName = tableOrName instanceof Table ? tableOrName.name : tableOrName;\n      const sql = `SELECT * FROM \\`INFORMATION_SCHEMA\\`.\\`TABLES\\` ` + `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`TABLE_TYPE\\` = 'BASE TABLE' ` + `AND \\`TABLE_NAME\\` = '${tableName}'`;\n      const result = yield _this10.query(sql);\n      return result.length ? true : false;\n    })();\n  }\n  /**\n   * Checks if column with the given name exist in the given table.\n   */\n  hasColumn(tableOrName, columnName) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      const tableName = tableOrName instanceof Table ? tableOrName.name : tableOrName;\n      const sql = `SELECT * FROM \\`INFORMATION_SCHEMA\\`.\\`COLUMNS\\` ` + `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' ` + `AND \\`TABLE_NAME\\` = '${tableName}' AND \\`COLUMN_NAME\\` = '${columnName}'`;\n      const result = yield _this11.query(sql);\n      return result.length ? true : false;\n    })();\n  }\n  /**\n   * Creates a new database.\n   * Note: Spanner does not support database creation inside a transaction block.\n   */\n  createDatabase(database, ifNotExist) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      if (ifNotExist) {\n        const databaseAlreadyExists = yield _this12.hasDatabase(database);\n        if (databaseAlreadyExists) return Promise.resolve();\n      }\n      const up = `CREATE DATABASE \"${database}\"`;\n      const down = `DROP DATABASE \"${database}\"`;\n      yield _this12.executeQueries(new Query(up), new Query(down));\n    })();\n  }\n  /**\n   * Drops database.\n   * Note: Spanner does not support database dropping inside a transaction block.\n   */\n  dropDatabase(database, ifExist) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      const up = ifExist ? `DROP DATABASE IF EXISTS \"${database}\"` : `DROP DATABASE \"${database}\"`;\n      const down = `CREATE DATABASE \"${database}\"`;\n      yield _this13.executeQueries(new Query(up), new Query(down));\n    })();\n  }\n  /**\n   * Creates a new table schema.\n   */\n  createSchema(schemaPath, ifNotExist) {\n    return _asyncToGenerator(function* () {\n      return Promise.resolve();\n    })();\n  }\n  /**\n   * Drops table schema.\n   */\n  dropSchema(schemaPath, ifExist, isCascade) {\n    return _asyncToGenerator(function* () {\n      return Promise.resolve();\n    })();\n  }\n  /**\n   * Creates a new table.\n   */\n  createTable(table, ifNotExist = false, createForeignKeys = true, createIndices = true) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      if (ifNotExist) {\n        const isTableExist = yield _this14.hasTable(table);\n        if (isTableExist) return Promise.resolve();\n      }\n      const upQueries = [];\n      const downQueries = [];\n      upQueries.push(_this14.createTableSql(table, createForeignKeys));\n      downQueries.push(_this14.dropTableSql(table));\n      // if createForeignKeys is true, we must drop created foreign keys in down query.\n      // createTable does not need separate method to create foreign keys, because it create fk's in the same query with table creation.\n      if (createForeignKeys) table.foreignKeys.forEach(foreignKey => downQueries.push(_this14.dropForeignKeySql(table, foreignKey)));\n      if (createIndices) {\n        table.indices.forEach(index => {\n          // new index may be passed without name. In this case we generate index name manually.\n          if (!index.name) index.name = _this14.connection.namingStrategy.indexName(table, index.columnNames, index.where);\n          upQueries.push(_this14.createIndexSql(table, index));\n          downQueries.push(_this14.dropIndexSql(table, index));\n        });\n      }\n      // if table has column with generated type, we must add the expression to the metadata table\n      const generatedColumns = table.columns.filter(column => column.generatedType && column.asExpression);\n      for (const column of generatedColumns) {\n        const insertQuery = _this14.insertTypeormMetadataSql({\n          table: table.name,\n          type: MetadataTableType.GENERATED_COLUMN,\n          name: column.name,\n          value: column.asExpression\n        });\n        const deleteQuery = _this14.deleteTypeormMetadataSql({\n          table: table.name,\n          type: MetadataTableType.GENERATED_COLUMN,\n          name: column.name\n        });\n        upQueries.push(insertQuery);\n        downQueries.push(deleteQuery);\n      }\n      yield _this14.executeQueries(upQueries, downQueries);\n    })();\n  }\n  /**\n   * Drops the table.\n   */\n  dropTable(target, ifExist, dropForeignKeys = true, dropIndices = true) {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      // It needs because if table does not exist and dropForeignKeys or dropIndices is true, we don't need\n      // to perform drop queries for foreign keys and indices.\n      if (ifExist) {\n        const isTableExist = yield _this15.hasTable(target);\n        if (!isTableExist) return Promise.resolve();\n      }\n      // if dropTable called with dropForeignKeys = true, we must create foreign keys in down query.\n      const createForeignKeys = dropForeignKeys;\n      const tablePath = _this15.getTablePath(target);\n      const table = yield _this15.getCachedTable(tablePath);\n      const upQueries = [];\n      const downQueries = [];\n      if (dropIndices) {\n        table.indices.forEach(index => {\n          upQueries.push(_this15.dropIndexSql(table, index));\n          downQueries.push(_this15.createIndexSql(table, index));\n        });\n      }\n      if (dropForeignKeys) table.foreignKeys.forEach(foreignKey => upQueries.push(_this15.dropForeignKeySql(table, foreignKey)));\n      upQueries.push(_this15.dropTableSql(table));\n      downQueries.push(_this15.createTableSql(table, createForeignKeys));\n      // if table had columns with generated type, we must remove the expression from the metadata table\n      const generatedColumns = table.columns.filter(column => column.generatedType && column.asExpression);\n      for (const column of generatedColumns) {\n        const deleteQuery = _this15.deleteTypeormMetadataSql({\n          table: table.name,\n          type: MetadataTableType.GENERATED_COLUMN,\n          name: column.name\n        });\n        const insertQuery = _this15.insertTypeormMetadataSql({\n          table: table.name,\n          type: MetadataTableType.GENERATED_COLUMN,\n          name: column.name,\n          value: column.asExpression\n        });\n        upQueries.push(deleteQuery);\n        downQueries.push(insertQuery);\n      }\n      yield _this15.executeQueries(upQueries, downQueries);\n    })();\n  }\n  /**\n   * Creates a new view.\n   */\n  createView(view) {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      const upQueries = [];\n      const downQueries = [];\n      upQueries.push(_this16.createViewSql(view));\n      upQueries.push(yield _this16.insertViewDefinitionSql(view));\n      downQueries.push(_this16.dropViewSql(view));\n      downQueries.push(yield _this16.deleteViewDefinitionSql(view));\n      yield _this16.executeQueries(upQueries, downQueries);\n    })();\n  }\n  /**\n   * Drops the view.\n   */\n  dropView(target) {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      const viewName = target instanceof View ? target.name : target;\n      const view = yield _this17.getCachedView(viewName);\n      const upQueries = [];\n      const downQueries = [];\n      upQueries.push(yield _this17.deleteViewDefinitionSql(view));\n      upQueries.push(_this17.dropViewSql(view));\n      downQueries.push(yield _this17.insertViewDefinitionSql(view));\n      downQueries.push(_this17.createViewSql(view));\n      yield _this17.executeQueries(upQueries, downQueries);\n    })();\n  }\n  /**\n   * Renames the given table.\n   */\n  renameTable(oldTableOrName, newTableName) {\n    return _asyncToGenerator(function* () {\n      throw new TypeORMError(`Rename table queries are not supported by Spanner driver.`);\n    })();\n  }\n  /**\n   * Creates a new column from the column in the table.\n   */\n  addColumn(tableOrName, column) {\n    var _this18 = this;\n    return _asyncToGenerator(function* () {\n      const table = tableOrName instanceof Table ? tableOrName : yield _this18.getCachedTable(tableOrName);\n      const clonedTable = table.clone();\n      const upQueries = [];\n      const downQueries = [];\n      upQueries.push(new Query(`ALTER TABLE ${_this18.escapePath(table)} ADD ${_this18.buildCreateColumnSql(column)}`));\n      downQueries.push(new Query(`ALTER TABLE ${_this18.escapePath(table)} DROP COLUMN ${_this18.driver.escape(column.name)}`));\n      // create column index\n      const columnIndex = clonedTable.indices.find(index => index.columnNames.length === 1 && index.columnNames[0] === column.name);\n      if (columnIndex) {\n        upQueries.push(_this18.createIndexSql(table, columnIndex));\n        downQueries.push(_this18.dropIndexSql(table, columnIndex));\n      } else if (column.isUnique) {\n        const uniqueIndex = new TableIndex({\n          name: _this18.connection.namingStrategy.indexName(table, [column.name]),\n          columnNames: [column.name],\n          isUnique: true\n        });\n        clonedTable.indices.push(uniqueIndex);\n        clonedTable.uniques.push(new TableUnique({\n          name: uniqueIndex.name,\n          columnNames: uniqueIndex.columnNames\n        }));\n        upQueries.push(_this18.createIndexSql(table, uniqueIndex));\n        downQueries.push(_this18.dropIndexSql(table, uniqueIndex));\n      }\n      if (column.generatedType && column.asExpression) {\n        const insertQuery = _this18.insertTypeormMetadataSql({\n          table: table.name,\n          type: MetadataTableType.GENERATED_COLUMN,\n          name: column.name,\n          value: column.asExpression\n        });\n        const deleteQuery = _this18.deleteTypeormMetadataSql({\n          table: table.name,\n          type: MetadataTableType.GENERATED_COLUMN,\n          name: column.name\n        });\n        upQueries.push(insertQuery);\n        downQueries.push(deleteQuery);\n      }\n      yield _this18.executeQueries(upQueries, downQueries);\n      clonedTable.addColumn(column);\n      _this18.replaceCachedTable(table, clonedTable);\n    })();\n  }\n  /**\n   * Creates a new columns from the column in the table.\n   */\n  addColumns(tableOrName, columns) {\n    var _this19 = this;\n    return _asyncToGenerator(function* () {\n      for (const column of columns) {\n        yield _this19.addColumn(tableOrName, column);\n      }\n    })();\n  }\n  /**\n   * Renames column in the given table.\n   */\n  renameColumn(tableOrName, oldTableColumnOrName, newTableColumnOrName) {\n    var _this20 = this;\n    return _asyncToGenerator(function* () {\n      const table = tableOrName instanceof Table ? tableOrName : yield _this20.getCachedTable(tableOrName);\n      const oldColumn = oldTableColumnOrName instanceof TableColumn ? oldTableColumnOrName : table.columns.find(c => c.name === oldTableColumnOrName);\n      if (!oldColumn) throw new TypeORMError(`Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`);\n      let newColumn;\n      if (newTableColumnOrName instanceof TableColumn) {\n        newColumn = newTableColumnOrName;\n      } else {\n        newColumn = oldColumn.clone();\n        newColumn.name = newTableColumnOrName;\n      }\n      return _this20.changeColumn(table, oldColumn, newColumn);\n    })();\n  }\n  /**\n   * Changes a column in the table.\n   */\n  changeColumn(tableOrName, oldTableColumnOrName, newColumn) {\n    var _this21 = this;\n    return _asyncToGenerator(function* () {\n      const table = tableOrName instanceof Table ? tableOrName : yield _this21.getCachedTable(tableOrName);\n      let clonedTable = table.clone();\n      const upQueries = [];\n      const downQueries = [];\n      const oldColumn = oldTableColumnOrName instanceof TableColumn ? oldTableColumnOrName : table.columns.find(column => column.name === oldTableColumnOrName);\n      if (!oldColumn) throw new TypeORMError(`Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`);\n      if (oldColumn.name !== newColumn.name || oldColumn.type !== newColumn.type || oldColumn.length !== newColumn.length || oldColumn.isArray !== newColumn.isArray || oldColumn.generatedType !== newColumn.generatedType || oldColumn.asExpression !== newColumn.asExpression) {\n        // To avoid data conversion, we just recreate column\n        yield _this21.dropColumn(table, oldColumn);\n        yield _this21.addColumn(table, newColumn);\n        // update cloned table\n        clonedTable = table.clone();\n      } else {\n        if (newColumn.precision !== oldColumn.precision || newColumn.scale !== oldColumn.scale) {\n          upQueries.push(new Query(`ALTER TABLE ${_this21.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" TYPE ${_this21.driver.createFullType(newColumn)}`));\n          downQueries.push(new Query(`ALTER TABLE ${_this21.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" TYPE ${_this21.driver.createFullType(oldColumn)}`));\n        }\n        if (oldColumn.isNullable !== newColumn.isNullable) {\n          if (newColumn.isNullable) {\n            upQueries.push(new Query(`ALTER TABLE ${_this21.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" DROP NOT NULL`));\n            downQueries.push(new Query(`ALTER TABLE ${_this21.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" SET NOT NULL`));\n          } else {\n            upQueries.push(new Query(`ALTER TABLE ${_this21.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" SET NOT NULL`));\n            downQueries.push(new Query(`ALTER TABLE ${_this21.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" DROP NOT NULL`));\n          }\n        }\n        if (newColumn.isUnique !== oldColumn.isUnique) {\n          if (newColumn.isUnique === true) {\n            const uniqueIndex = new TableIndex({\n              name: _this21.connection.namingStrategy.indexName(table, [newColumn.name]),\n              columnNames: [newColumn.name],\n              isUnique: true\n            });\n            clonedTable.indices.push(uniqueIndex);\n            clonedTable.uniques.push(new TableUnique({\n              name: uniqueIndex.name,\n              columnNames: uniqueIndex.columnNames\n            }));\n            upQueries.push(_this21.createIndexSql(table, uniqueIndex));\n            downQueries.push(_this21.dropIndexSql(table, uniqueIndex));\n          } else {\n            const uniqueIndex = clonedTable.indices.find(index => {\n              return index.columnNames.length === 1 && index.isUnique === true && !!index.columnNames.find(columnName => columnName === newColumn.name);\n            });\n            clonedTable.indices.splice(clonedTable.indices.indexOf(uniqueIndex), 1);\n            const tableUnique = clonedTable.uniques.find(unique => unique.name === uniqueIndex.name);\n            clonedTable.uniques.splice(clonedTable.uniques.indexOf(tableUnique), 1);\n            upQueries.push(_this21.dropIndexSql(table, uniqueIndex));\n            downQueries.push(_this21.createIndexSql(table, uniqueIndex));\n          }\n        }\n      }\n      yield _this21.executeQueries(upQueries, downQueries);\n      _this21.replaceCachedTable(table, clonedTable);\n    })();\n  }\n  /**\n   * Changes a column in the table.\n   */\n  changeColumns(tableOrName, changedColumns) {\n    var _this22 = this;\n    return _asyncToGenerator(function* () {\n      for (const {\n        oldColumn,\n        newColumn\n      } of changedColumns) {\n        yield _this22.changeColumn(tableOrName, oldColumn, newColumn);\n      }\n    })();\n  }\n  /**\n   * Drops column in the table.\n   */\n  dropColumn(tableOrName, columnOrName) {\n    var _this23 = this;\n    return _asyncToGenerator(function* () {\n      const table = tableOrName instanceof Table ? tableOrName : yield _this23.getCachedTable(tableOrName);\n      const column = columnOrName instanceof TableColumn ? columnOrName : table.findColumnByName(columnOrName);\n      if (!column) throw new TypeORMError(`Column \"${columnOrName}\" was not found in table \"${table.name}\"`);\n      const clonedTable = table.clone();\n      const upQueries = [];\n      const downQueries = [];\n      // drop column index\n      const columnIndex = clonedTable.indices.find(index => index.columnNames.length === 1 && index.columnNames[0] === column.name);\n      if (columnIndex) {\n        clonedTable.indices.splice(clonedTable.indices.indexOf(columnIndex), 1);\n        upQueries.push(_this23.dropIndexSql(table, columnIndex));\n        downQueries.push(_this23.createIndexSql(table, columnIndex));\n      }\n      // drop column check\n      const columnCheck = clonedTable.checks.find(check => !!check.columnNames && check.columnNames.length === 1 && check.columnNames[0] === column.name);\n      if (columnCheck) {\n        clonedTable.checks.splice(clonedTable.checks.indexOf(columnCheck), 1);\n        upQueries.push(_this23.dropCheckConstraintSql(table, columnCheck));\n        downQueries.push(_this23.createCheckConstraintSql(table, columnCheck));\n      }\n      upQueries.push(new Query(`ALTER TABLE ${_this23.escapePath(table)} DROP COLUMN ${_this23.driver.escape(column.name)}`));\n      downQueries.push(new Query(`ALTER TABLE ${_this23.escapePath(table)} ADD ${_this23.buildCreateColumnSql(column)}`));\n      if (column.generatedType && column.asExpression) {\n        const deleteQuery = _this23.deleteTypeormMetadataSql({\n          table: table.name,\n          type: MetadataTableType.GENERATED_COLUMN,\n          name: column.name\n        });\n        const insertQuery = _this23.insertTypeormMetadataSql({\n          table: table.name,\n          type: MetadataTableType.GENERATED_COLUMN,\n          name: column.name,\n          value: column.asExpression\n        });\n        upQueries.push(deleteQuery);\n        downQueries.push(insertQuery);\n      }\n      yield _this23.executeQueries(upQueries, downQueries);\n      clonedTable.removeColumn(column);\n      _this23.replaceCachedTable(table, clonedTable);\n    })();\n  }\n  /**\n   * Drops the columns in the table.\n   */\n  dropColumns(tableOrName, columns) {\n    var _this24 = this;\n    return _asyncToGenerator(function* () {\n      for (const column of columns) {\n        yield _this24.dropColumn(tableOrName, column);\n      }\n    })();\n  }\n  /**\n   * Creates a new primary key.\n   *\n   * Not supported in Spanner.\n   * @see https://cloud.google.com/spanner/docs/schema-and-data-model#notes_about_key_columns\n   */\n  createPrimaryKey(tableOrName, columnNames) {\n    return _asyncToGenerator(function* () {\n      throw new Error(\"The keys of a table can't change; you can't add a key column to an existing table or remove a key column from an existing table.\");\n    })();\n  }\n  /**\n   * Updates composite primary keys.\n   */\n  updatePrimaryKeys(tableOrName, columns) {\n    return _asyncToGenerator(function* () {\n      throw new Error(\"The keys of a table can't change; you can't add a key column to an existing table or remove a key column from an existing table.\");\n    })();\n  }\n  /**\n   * Creates a new primary key.\n   *\n   * Not supported in Spanner.\n   * @see https://cloud.google.com/spanner/docs/schema-and-data-model#notes_about_key_columns\n   */\n  dropPrimaryKey(tableOrName) {\n    return _asyncToGenerator(function* () {\n      throw new Error(\"The keys of a table can't change; you can't add a key column to an existing table or remove a key column from an existing table.\");\n    })();\n  }\n  /**\n   * Creates new unique constraint.\n   */\n  createUniqueConstraint(tableOrName, uniqueConstraint) {\n    return _asyncToGenerator(function* () {\n      throw new TypeORMError(`Spanner does not support unique constraints. Use unique index instead.`);\n    })();\n  }\n  /**\n   * Creates new unique constraints.\n   */\n  createUniqueConstraints(tableOrName, uniqueConstraints) {\n    return _asyncToGenerator(function* () {\n      throw new TypeORMError(`Spanner does not support unique constraints. Use unique index instead.`);\n    })();\n  }\n  /**\n   * Drops unique constraint.\n   */\n  dropUniqueConstraint(tableOrName, uniqueOrName) {\n    return _asyncToGenerator(function* () {\n      throw new TypeORMError(`Spanner does not support unique constraints. Use unique index instead.`);\n    })();\n  }\n  /**\n   * Drops unique constraints.\n   */\n  dropUniqueConstraints(tableOrName, uniqueConstraints) {\n    return _asyncToGenerator(function* () {\n      throw new TypeORMError(`Spanner does not support unique constraints. Use unique index instead.`);\n    })();\n  }\n  /**\n   * Creates new check constraint.\n   */\n  createCheckConstraint(tableOrName, checkConstraint) {\n    var _this25 = this;\n    return _asyncToGenerator(function* () {\n      const table = tableOrName instanceof Table ? tableOrName : yield _this25.getCachedTable(tableOrName);\n      // new check constraint may be passed without name. In this case we generate unique name manually.\n      if (!checkConstraint.name) checkConstraint.name = _this25.connection.namingStrategy.checkConstraintName(table, checkConstraint.expression);\n      const up = _this25.createCheckConstraintSql(table, checkConstraint);\n      const down = _this25.dropCheckConstraintSql(table, checkConstraint);\n      yield _this25.executeQueries(up, down);\n      table.addCheckConstraint(checkConstraint);\n    })();\n  }\n  /**\n   * Creates new check constraints.\n   */\n  createCheckConstraints(tableOrName, checkConstraints) {\n    var _this26 = this;\n    return _asyncToGenerator(function* () {\n      const promises = checkConstraints.map(checkConstraint => _this26.createCheckConstraint(tableOrName, checkConstraint));\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Drops check constraint.\n   */\n  dropCheckConstraint(tableOrName, checkOrName) {\n    var _this27 = this;\n    return _asyncToGenerator(function* () {\n      const table = tableOrName instanceof Table ? tableOrName : yield _this27.getCachedTable(tableOrName);\n      const checkConstraint = checkOrName instanceof TableCheck ? checkOrName : table.checks.find(c => c.name === checkOrName);\n      if (!checkConstraint) throw new TypeORMError(`Supplied check constraint was not found in table ${table.name}`);\n      const up = _this27.dropCheckConstraintSql(table, checkConstraint);\n      const down = _this27.createCheckConstraintSql(table, checkConstraint);\n      yield _this27.executeQueries(up, down);\n      table.removeCheckConstraint(checkConstraint);\n    })();\n  }\n  /**\n   * Drops check constraints.\n   */\n  dropCheckConstraints(tableOrName, checkConstraints) {\n    var _this28 = this;\n    return _asyncToGenerator(function* () {\n      const promises = checkConstraints.map(checkConstraint => _this28.dropCheckConstraint(tableOrName, checkConstraint));\n      yield Promise.all(promises);\n    })();\n  }\n  /**\n   * Creates new exclusion constraint.\n   */\n  createExclusionConstraint(tableOrName, exclusionConstraint) {\n    return _asyncToGenerator(function* () {\n      throw new TypeORMError(`Spanner does not support exclusion constraints.`);\n    })();\n  }\n  /**\n   * Creates new exclusion constraints.\n   */\n  createExclusionConstraints(tableOrName, exclusionConstraints) {\n    return _asyncToGenerator(function* () {\n      throw new TypeORMError(`Spanner does not support exclusion constraints.`);\n    })();\n  }\n  /**\n   * Drops exclusion constraint.\n   */\n  dropExclusionConstraint(tableOrName, exclusionOrName) {\n    return _asyncToGenerator(function* () {\n      throw new TypeORMError(`Spanner does not support exclusion constraints.`);\n    })();\n  }\n  /**\n   * Drops exclusion constraints.\n   */\n  dropExclusionConstraints(tableOrName, exclusionConstraints) {\n    return _asyncToGenerator(function* () {\n      throw new TypeORMError(`Spanner does not support exclusion constraints.`);\n    })();\n  }\n  /**\n   * Creates a new foreign key.\n   */\n  createForeignKey(tableOrName, foreignKey) {\n    var _this29 = this;\n    return _asyncToGenerator(function* () {\n      const table = tableOrName instanceof Table ? tableOrName : yield _this29.getCachedTable(tableOrName);\n      // new FK may be passed without name. In this case we generate FK name manually.\n      if (!foreignKey.name) foreignKey.name = _this29.connection.namingStrategy.foreignKeyName(table, foreignKey.columnNames, _this29.getTablePath(foreignKey), foreignKey.referencedColumnNames);\n      const up = _this29.createForeignKeySql(table, foreignKey);\n      const down = _this29.dropForeignKeySql(table, foreignKey);\n      yield _this29.executeQueries(up, down);\n      table.addForeignKey(foreignKey);\n    })();\n  }\n  /**\n   * Creates a new foreign keys.\n   */\n  createForeignKeys(tableOrName, foreignKeys) {\n    var _this30 = this;\n    return _asyncToGenerator(function* () {\n      for (const foreignKey of foreignKeys) {\n        yield _this30.createForeignKey(tableOrName, foreignKey);\n      }\n    })();\n  }\n  /**\n   * Drops a foreign key from the table.\n   */\n  dropForeignKey(tableOrName, foreignKeyOrName) {\n    var _this31 = this;\n    return _asyncToGenerator(function* () {\n      const table = tableOrName instanceof Table ? tableOrName : yield _this31.getCachedTable(tableOrName);\n      const foreignKey = foreignKeyOrName instanceof TableForeignKey ? foreignKeyOrName : table.foreignKeys.find(fk => fk.name === foreignKeyOrName);\n      if (!foreignKey) throw new TypeORMError(`Supplied foreign key was not found in table ${table.name}`);\n      const up = _this31.dropForeignKeySql(table, foreignKey);\n      const down = _this31.createForeignKeySql(table, foreignKey);\n      yield _this31.executeQueries(up, down);\n      table.removeForeignKey(foreignKey);\n    })();\n  }\n  /**\n   * Drops a foreign keys from the table.\n   */\n  dropForeignKeys(tableOrName, foreignKeys) {\n    var _this32 = this;\n    return _asyncToGenerator(function* () {\n      for (const foreignKey of foreignKeys) {\n        yield _this32.dropForeignKey(tableOrName, foreignKey);\n      }\n    })();\n  }\n  /**\n   * Creates a new index.\n   */\n  createIndex(tableOrName, index) {\n    var _this33 = this;\n    return _asyncToGenerator(function* () {\n      const table = tableOrName instanceof Table ? tableOrName : yield _this33.getCachedTable(tableOrName);\n      // new index may be passed without name. In this case we generate index name manually.\n      if (!index.name) index.name = _this33.generateIndexName(table, index);\n      const up = _this33.createIndexSql(table, index);\n      const down = _this33.dropIndexSql(table, index);\n      yield _this33.executeQueries(up, down);\n      table.addIndex(index);\n    })();\n  }\n  /**\n   * Creates a new indices\n   */\n  createIndices(tableOrName, indices) {\n    var _this34 = this;\n    return _asyncToGenerator(function* () {\n      for (const index of indices) {\n        yield _this34.createIndex(tableOrName, index);\n      }\n    })();\n  }\n  /**\n   * Drops an index from the table.\n   */\n  dropIndex(tableOrName, indexOrName) {\n    var _this35 = this;\n    return _asyncToGenerator(function* () {\n      const table = tableOrName instanceof Table ? tableOrName : yield _this35.getCachedTable(tableOrName);\n      const index = indexOrName instanceof TableIndex ? indexOrName : table.indices.find(i => i.name === indexOrName);\n      if (!index) throw new TypeORMError(`Supplied index ${indexOrName} was not found in table ${table.name}`);\n      // new index may be passed without name. In this case we generate index name manually.\n      if (!index.name) index.name = _this35.generateIndexName(table, index);\n      const up = _this35.dropIndexSql(table, index);\n      const down = _this35.createIndexSql(table, index);\n      yield _this35.executeQueries(up, down);\n      table.removeIndex(index);\n    })();\n  }\n  /**\n   * Drops an indices from the table.\n   */\n  dropIndices(tableOrName, indices) {\n    var _this36 = this;\n    return _asyncToGenerator(function* () {\n      for (const index of indices) {\n        yield _this36.dropIndex(tableOrName, index);\n      }\n    })();\n  }\n  /**\n   * Clears all table contents.\n   * Spanner does not support TRUNCATE TABLE statement, so we use DELETE FROM.\n   */\n  clearTable(tableName) {\n    var _this37 = this;\n    return _asyncToGenerator(function* () {\n      yield _this37.query(`DELETE FROM ${_this37.escapePath(tableName)} WHERE true`);\n    })();\n  }\n  /**\n   * Removes all tables from the currently connected database.\n   */\n  clearDatabase() {\n    var _this38 = this;\n    return _asyncToGenerator(function* () {\n      // drop index queries\n      const selectIndexDropsQuery = `SELECT concat('DROP INDEX \\`', INDEX_NAME, '\\`') AS \\`query\\` ` + `FROM \\`INFORMATION_SCHEMA\\`.\\`INDEXES\\` ` + `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`INDEX_TYPE\\` = 'INDEX' AND \\`SPANNER_IS_MANAGED\\` = false`;\n      const dropIndexQueries = yield _this38.query(selectIndexDropsQuery);\n      // drop foreign key queries\n      const selectFKDropsQuery = `SELECT concat('ALTER TABLE \\`', TABLE_NAME, '\\`', ' DROP CONSTRAINT \\`', CONSTRAINT_NAME, '\\`') AS \\`query\\` ` + `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLE_CONSTRAINTS\\` ` + `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`CONSTRAINT_TYPE\\` = 'FOREIGN KEY'`;\n      const dropFKQueries = yield _this38.query(selectFKDropsQuery);\n      // drop view queries\n      // const selectViewDropsQuery = `SELECT concat('DROP VIEW \\`', TABLE_NAME, '\\`') AS \\`query\\` FROM \\`INFORMATION_SCHEMA\\`.\\`VIEWS\\``\n      // const dropViewQueries: ObjectLiteral[] = await this.query(\n      //     selectViewDropsQuery,\n      // )\n      // drop table queries\n      const dropTablesQuery = `SELECT concat('DROP TABLE \\`', TABLE_NAME, '\\`') AS \\`query\\` ` + `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLES\\` ` + `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`TABLE_TYPE\\` = 'BASE TABLE'`;\n      const dropTableQueries = yield _this38.query(dropTablesQuery);\n      if (!dropIndexQueries.length && !dropFKQueries.length &&\n      // !dropViewQueries.length &&\n      !dropTableQueries.length) return;\n      const isAnotherTransactionActive = _this38.isTransactionActive;\n      if (!isAnotherTransactionActive) yield _this38.startTransaction();\n      try {\n        for (let query of dropIndexQueries) {\n          yield _this38.updateDDL(query[\"query\"]);\n        }\n        for (let query of dropFKQueries) {\n          yield _this38.updateDDL(query[\"query\"]);\n        }\n        // for (let query of dropViewQueries) {\n        //     await this.updateDDL(query[\"query\"])\n        // }\n        for (let query of dropTableQueries) {\n          yield _this38.updateDDL(query[\"query\"]);\n        }\n        yield _this38.commitTransaction();\n      } catch (error) {\n        try {\n          // we throw original error even if rollback thrown an error\n          if (!isAnotherTransactionActive) yield _this38.rollbackTransaction();\n        } catch (rollbackError) {}\n        throw error;\n      }\n    })();\n  }\n  // -------------------------------------------------------------------------\n  // Override Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Executes up sql queries.\n   */\n  executeMemoryUpSql() {\n    var _this39 = this;\n    return _asyncToGenerator(function* () {\n      for (const {\n        query,\n        parameters\n      } of _this39.sqlInMemory.upQueries) {\n        if (_this39.isDMLQuery(query)) {\n          yield _this39.query(query, parameters);\n        } else {\n          yield _this39.updateDDL(query, parameters);\n        }\n      }\n    })();\n  }\n  /**\n   * Executes down sql queries.\n   */\n  executeMemoryDownSql() {\n    var _this40 = this;\n    return _asyncToGenerator(function* () {\n      for (const {\n        query,\n        parameters\n      } of _this40.sqlInMemory.downQueries.reverse()) {\n        if (_this40.isDMLQuery(query)) {\n          yield _this40.query(query, parameters);\n        } else {\n          yield _this40.updateDDL(query, parameters);\n        }\n      }\n    })();\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  loadViews(viewNames) {\n    return _asyncToGenerator(function* () {\n      // const hasTable = await this.hasTable(this.getTypeormMetadataTableName())\n      // if (!hasTable) {\n      //     return []\n      // }\n      //\n      // if (!viewNames) {\n      //     viewNames = []\n      // }\n      //\n      // const escapedViewNames = viewNames\n      //     .map((viewName) => `'${viewName}'`)\n      //     .join(\", \")\n      //\n      // const query =\n      //     `SELECT \\`T\\`.*, \\`V\\`.\\`VIEW_DEFINITION\\` FROM ${this.escapePath(\n      //         this.getTypeormMetadataTableName(),\n      //     )} \\`T\\` ` +\n      //     `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`VIEWS\\` \\`V\\` ON \\`V\\`.\\`TABLE_NAME\\` = \\`T\\`.\\`NAME\\` ` +\n      //     `WHERE \\`T\\`.\\`TYPE\\` = '${MetadataTableType.VIEW}' ${\n      //         viewNames.length\n      //             ? ` AND \\`T\\`.\\`NAME\\` IN (${escapedViewNames})`\n      //             : \"\"\n      //     }`\n      // const dbViews = await this.query(query)\n      // return dbViews.map((dbView: any) => {\n      //     const view = new View()\n      //     view.database = dbView[\"NAME\"]\n      //     view.name = this.driver.buildTableName(dbView[\"NAME\"])\n      //     view.expression = dbView[\"NAME\"]\n      //     return view\n      // })\n      return Promise.resolve([]);\n    })();\n  }\n  /**\n   * Loads all tables (with given names) from the database and creates a Table from them.\n   */\n  loadTables(tableNames) {\n    var _this41 = this;\n    return _asyncToGenerator(function* () {\n      if (tableNames && tableNames.length === 0) {\n        return [];\n      }\n      const dbTables = [];\n      if (!tableNames || !tableNames.length) {\n        // Since we don't have any of this data we have to do a scan\n        const tablesSql = `SELECT \\`TABLE_NAME\\` ` + `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLES\\` ` + `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`TABLE_TYPE\\` = 'BASE TABLE'`;\n        dbTables.push(...(yield _this41.query(tablesSql)));\n      } else {\n        const tablesSql = `SELECT \\`TABLE_NAME\\` ` + `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLES\\` ` + `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`TABLE_TYPE\\` = 'BASE TABLE' ` + `AND \\`TABLE_NAME\\` IN (${tableNames.map(tableName => `'${tableName}'`).join(\", \")})`;\n        dbTables.push(...(yield _this41.query(tablesSql)));\n      }\n      // if tables were not found in the db, no need to proceed\n      if (!dbTables.length) return [];\n      const loadedTableNames = dbTables.map(dbTable => `'${dbTable.TABLE_NAME}'`).join(\", \");\n      const columnsSql = `SELECT * FROM \\`INFORMATION_SCHEMA\\`.\\`COLUMNS\\` WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`TABLE_NAME\\` IN (${loadedTableNames})`;\n      const primaryKeySql = `SELECT \\`KCU\\`.\\`TABLE_NAME\\`, \\`KCU\\`.\\`COLUMN_NAME\\` ` + `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLE_CONSTRAINTS\\` \\`TC\\` ` + `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`KEY_COLUMN_USAGE\\` \\`KCU\\` ON \\`KCU\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` + `WHERE \\`TC\\`.\\`TABLE_CATALOG\\` = '' AND \\`TC\\`.\\`TABLE_SCHEMA\\` = '' AND \\`TC\\`.\\`CONSTRAINT_TYPE\\` = 'PRIMARY KEY' ` + `AND \\`TC\\`.\\`TABLE_NAME\\` IN (${loadedTableNames})`;\n      const indicesSql = `SELECT \\`I\\`.\\`TABLE_NAME\\`, \\`I\\`.\\`INDEX_NAME\\`, \\`I\\`.\\`IS_UNIQUE\\`, \\`I\\`.\\`IS_NULL_FILTERED\\`, \\`IC\\`.\\`COLUMN_NAME\\` ` + `FROM \\`INFORMATION_SCHEMA\\`.\\`INDEXES\\` \\`I\\` ` + `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`INDEX_COLUMNS\\` \\`IC\\` ON \\`IC\\`.\\`INDEX_NAME\\` = \\`I\\`.\\`INDEX_NAME\\` ` + `AND \\`IC\\`.\\`TABLE_NAME\\` = \\`I\\`.\\`TABLE_NAME\\` ` + `WHERE \\`I\\`.\\`TABLE_CATALOG\\` = '' AND \\`I\\`.\\`TABLE_SCHEMA\\` = '' AND \\`I\\`.\\`TABLE_NAME\\` IN (${loadedTableNames}) ` + `AND \\`I\\`.\\`INDEX_TYPE\\` = 'INDEX' AND \\`I\\`.\\`SPANNER_IS_MANAGED\\` = false`;\n      const checksSql = `SELECT \\`TC\\`.\\`TABLE_NAME\\`, \\`TC\\`.\\`CONSTRAINT_NAME\\`, \\`CC\\`.\\`CHECK_CLAUSE\\`, \\`CCU\\`.\\`COLUMN_NAME\\`` + `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLE_CONSTRAINTS\\` \\`TC\\` ` + `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`CONSTRAINT_COLUMN_USAGE\\` \\`CCU\\` ON \\`CCU\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` + `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`CHECK_CONSTRAINTS\\` \\`CC\\` ON \\`CC\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` + `WHERE \\`TC\\`.\\`TABLE_CATALOG\\` = '' AND \\`TC\\`.\\`TABLE_SCHEMA\\` = '' AND \\`TC\\`.\\`CONSTRAINT_TYPE\\` = 'CHECK' ` + `AND \\`TC\\`.\\`TABLE_NAME\\` IN (${loadedTableNames}) AND \\`TC\\`.\\`CONSTRAINT_NAME\\` NOT LIKE 'CK_IS_NOT_NULL%'`;\n      const foreignKeysSql = `SELECT \\`TC\\`.\\`TABLE_NAME\\`, \\`TC\\`.\\`CONSTRAINT_NAME\\`, \\`KCU\\`.\\`COLUMN_NAME\\`, ` + `\\`CTU\\`.\\`TABLE_NAME\\` AS \\`REFERENCED_TABLE_NAME\\`, \\`CCU\\`.\\`COLUMN_NAME\\` AS \\`REFERENCED_COLUMN_NAME\\`, ` + `\\`RC\\`.\\`UPDATE_RULE\\`, \\`RC\\`.\\`DELETE_RULE\\` ` + `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLE_CONSTRAINTS\\` \\`TC\\` ` + `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`KEY_COLUMN_USAGE\\` \\`KCU\\` ON \\`KCU\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` + `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`CONSTRAINT_TABLE_USAGE\\` \\`CTU\\` ON \\`CTU\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` + `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`REFERENTIAL_CONSTRAINTS\\` \\`RC\\` ON \\`RC\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` + `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`CONSTRAINT_COLUMN_USAGE\\` \\`CCU\\` ON \\`CCU\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` + `WHERE \\`TC\\`.\\`TABLE_CATALOG\\` = '' AND \\`TC\\`.\\`TABLE_SCHEMA\\` = '' AND \\`TC\\`.\\`CONSTRAINT_TYPE\\` = 'FOREIGN KEY' ` + `AND \\`TC\\`.\\`TABLE_NAME\\` IN (${loadedTableNames})`;\n      const [dbColumns, dbPrimaryKeys, dbIndices, dbChecks, dbForeignKeys] = yield Promise.all([_this41.query(columnsSql), _this41.query(primaryKeySql), _this41.query(indicesSql), _this41.query(checksSql), _this41.query(foreignKeysSql)]);\n      // create tables for loaded tables\n      return Promise.all(dbTables.map( /*#__PURE__*/function () {\n        var _ref = _asyncToGenerator(function* (dbTable) {\n          const table = new Table();\n          table.name = _this41.driver.buildTableName(dbTable[\"TABLE_NAME\"]);\n          // create columns from the loaded columns\n          table.columns = yield Promise.all(dbColumns.filter(dbColumn => dbColumn[\"TABLE_NAME\"] === dbTable[\"TABLE_NAME\"]).map( /*#__PURE__*/function () {\n            var _ref2 = _asyncToGenerator(function* (dbColumn) {\n              const columnUniqueIndices = dbIndices.filter(dbIndex => {\n                return dbIndex[\"TABLE_NAME\"] === dbTable[\"TABLE_NAME\"] && dbIndex[\"COLUMN_NAME\"] === dbColumn[\"COLUMN_NAME\"] && dbIndex[\"IS_UNIQUE\"] === true;\n              });\n              const tableMetadata = _this41.connection.entityMetadatas.find(metadata => _this41.getTablePath(table) === _this41.getTablePath(metadata));\n              const hasIgnoredIndex = columnUniqueIndices.length > 0 && tableMetadata && tableMetadata.indices.some(index => {\n                return columnUniqueIndices.some(uniqueIndex => {\n                  return index.name === uniqueIndex[\"INDEX_NAME\"] && index.synchronize === false;\n                });\n              });\n              const isConstraintComposite = columnUniqueIndices.every(uniqueIndex => {\n                return dbIndices.some(dbIndex => dbIndex[\"INDEX_NAME\"] === uniqueIndex[\"INDEX_NAME\"] && dbIndex[\"COLUMN_NAME\"] !== dbColumn[\"COLUMN_NAME\"]);\n              });\n              const tableColumn = new TableColumn();\n              tableColumn.name = dbColumn[\"COLUMN_NAME\"];\n              let fullType = dbColumn[\"SPANNER_TYPE\"].toLowerCase();\n              if (fullType.indexOf(\"array\") !== -1) {\n                tableColumn.isArray = true;\n                fullType = fullType.substring(fullType.indexOf(\"<\") + 1, fullType.indexOf(\">\"));\n              }\n              if (fullType.indexOf(\"(\") !== -1) {\n                tableColumn.type = fullType.substring(0, fullType.indexOf(\"(\"));\n              } else {\n                tableColumn.type = fullType;\n              }\n              if (_this41.driver.withLengthColumnTypes.indexOf(tableColumn.type) !== -1) {\n                tableColumn.length = fullType.substring(fullType.indexOf(\"(\") + 1, fullType.indexOf(\")\"));\n              }\n              if (dbColumn[\"IS_GENERATED\"] === \"ALWAYS\") {\n                tableColumn.asExpression = dbColumn[\"GENERATION_EXPRESSION\"];\n                tableColumn.generatedType = \"STORED\";\n                // We cannot relay on information_schema.columns.generation_expression, because it is formatted different.\n                const asExpressionQuery = yield _this41.selectTypeormMetadataSql({\n                  table: dbTable[\"TABLE_NAME\"],\n                  type: MetadataTableType.GENERATED_COLUMN,\n                  name: tableColumn.name\n                });\n                const results = yield _this41.query(asExpressionQuery.query, asExpressionQuery.parameters);\n                if (results[0] && results[0].value) {\n                  tableColumn.asExpression = results[0].value;\n                } else {\n                  tableColumn.asExpression = \"\";\n                }\n              }\n              tableColumn.isUnique = columnUniqueIndices.length > 0 && !hasIgnoredIndex && !isConstraintComposite;\n              tableColumn.isNullable = dbColumn[\"IS_NULLABLE\"] === \"YES\";\n              tableColumn.isPrimary = dbPrimaryKeys.some(dbPrimaryKey => {\n                return dbPrimaryKey[\"TABLE_NAME\"] === dbColumn[\"TABLE_NAME\"] && dbPrimaryKey[\"COLUMN_NAME\"] === dbColumn[\"COLUMN_NAME\"];\n              });\n              return tableColumn;\n            });\n            return function (_x2) {\n              return _ref2.apply(this, arguments);\n            };\n          }()));\n          const tableForeignKeys = dbForeignKeys.filter(dbForeignKey => {\n            return dbForeignKey[\"TABLE_NAME\"] === dbTable[\"TABLE_NAME\"];\n          });\n          table.foreignKeys = OrmUtils.uniq(tableForeignKeys, dbForeignKey => dbForeignKey[\"CONSTRAINT_NAME\"]).map(dbForeignKey => {\n            const foreignKeys = tableForeignKeys.filter(dbFk => dbFk[\"CONSTRAINT_NAME\"] === dbForeignKey[\"CONSTRAINT_NAME\"]);\n            return new TableForeignKey({\n              name: dbForeignKey[\"CONSTRAINT_NAME\"],\n              columnNames: OrmUtils.uniq(foreignKeys.map(dbFk => dbFk[\"COLUMN_NAME\"])),\n              referencedDatabase: dbForeignKey[\"REFERENCED_TABLE_SCHEMA\"],\n              referencedTableName: dbForeignKey[\"REFERENCED_TABLE_NAME\"],\n              referencedColumnNames: OrmUtils.uniq(foreignKeys.map(dbFk => dbFk[\"REFERENCED_COLUMN_NAME\"])),\n              onDelete: dbForeignKey[\"DELETE_RULE\"],\n              onUpdate: dbForeignKey[\"UPDATE_RULE\"]\n            });\n          });\n          const tableIndices = dbIndices.filter(dbIndex => dbIndex[\"TABLE_NAME\"] === dbTable[\"TABLE_NAME\"]);\n          table.indices = OrmUtils.uniq(tableIndices, dbIndex => dbIndex[\"INDEX_NAME\"]).map(constraint => {\n            const indices = tableIndices.filter(index => {\n              return index[\"INDEX_NAME\"] === constraint[\"INDEX_NAME\"];\n            });\n            return new TableIndex({\n              table: table,\n              name: constraint[\"INDEX_NAME\"],\n              columnNames: indices.map(i => i[\"COLUMN_NAME\"]),\n              isUnique: constraint[\"IS_UNIQUE\"],\n              isNullFiltered: constraint[\"IS_NULL_FILTERED\"]\n            });\n          });\n          const tableChecks = dbChecks.filter(dbCheck => dbCheck[\"TABLE_NAME\"] === dbTable[\"TABLE_NAME\"]);\n          table.checks = OrmUtils.uniq(tableChecks, dbIndex => dbIndex[\"CONSTRAINT_NAME\"]).map(constraint => {\n            const checks = tableChecks.filter(dbC => dbC[\"CONSTRAINT_NAME\"] === constraint[\"CONSTRAINT_NAME\"]);\n            return new TableCheck({\n              name: constraint[\"CONSTRAINT_NAME\"],\n              columnNames: checks.map(c => c[\"COLUMN_NAME\"]),\n              expression: constraint[\"CHECK_CLAUSE\"]\n            });\n          });\n          return table;\n        });\n        return function (_x) {\n          return _ref.apply(this, arguments);\n        };\n      }()));\n    })();\n  }\n  /**\n   * Builds create table sql.\n   */\n  createTableSql(table, createForeignKeys) {\n    const columnDefinitions = table.columns.map(column => this.buildCreateColumnSql(column)).join(\", \");\n    let sql = `CREATE TABLE ${this.escapePath(table)} (${columnDefinitions}`;\n    // we create unique indexes instead of unique constraints, because Spanner does not have unique constraints.\n    // if we mark column as Unique, it means that we create UNIQUE INDEX.\n    table.columns.filter(column => column.isUnique).forEach(column => {\n      const isUniqueIndexExist = table.indices.some(index => {\n        return index.columnNames.length === 1 && !!index.isUnique && index.columnNames.indexOf(column.name) !== -1;\n      });\n      const isUniqueConstraintExist = table.uniques.some(unique => {\n        return unique.columnNames.length === 1 && unique.columnNames.indexOf(column.name) !== -1;\n      });\n      if (!isUniqueIndexExist && !isUniqueConstraintExist) table.indices.push(new TableIndex({\n        name: this.connection.namingStrategy.uniqueConstraintName(table, [column.name]),\n        columnNames: [column.name],\n        isUnique: true\n      }));\n    });\n    // as Spanner does not have unique constraints, we must create table indices from table uniques and mark them as unique.\n    if (table.uniques.length > 0) {\n      table.uniques.forEach(unique => {\n        const uniqueExist = table.indices.some(index => index.name === unique.name);\n        if (!uniqueExist) {\n          table.indices.push(new TableIndex({\n            name: unique.name,\n            columnNames: unique.columnNames,\n            isUnique: true\n          }));\n        }\n      });\n    }\n    if (table.checks.length > 0) {\n      const checksSql = table.checks.map(check => {\n        const checkName = check.name ? check.name : this.connection.namingStrategy.checkConstraintName(table, check.expression);\n        return `CONSTRAINT \\`${checkName}\\` CHECK (${check.expression})`;\n      }).join(\", \");\n      sql += `, ${checksSql}`;\n    }\n    if (table.foreignKeys.length > 0 && createForeignKeys) {\n      const foreignKeysSql = table.foreignKeys.map(fk => {\n        const columnNames = fk.columnNames.map(columnName => `\\`${columnName}\\``).join(\", \");\n        if (!fk.name) fk.name = this.connection.namingStrategy.foreignKeyName(table, fk.columnNames, this.getTablePath(fk), fk.referencedColumnNames);\n        const referencedColumnNames = fk.referencedColumnNames.map(columnName => `\\`${columnName}\\``).join(\", \");\n        return `CONSTRAINT \\`${fk.name}\\` FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(fk))} (${referencedColumnNames})`;\n      }).join(\", \");\n      sql += `, ${foreignKeysSql}`;\n    }\n    sql += `)`;\n    const primaryColumns = table.columns.filter(column => column.isPrimary);\n    if (primaryColumns.length > 0) {\n      const columnNames = primaryColumns.map(column => this.driver.escape(column.name)).join(\", \");\n      sql += ` PRIMARY KEY (${columnNames})`;\n    }\n    return new Query(sql);\n  }\n  /**\n   * Builds drop table sql.\n   */\n  dropTableSql(tableOrPath) {\n    return new Query(`DROP TABLE ${this.escapePath(tableOrPath)}`);\n  }\n  createViewSql(view) {\n    const materializedClause = view.materialized ? \"MATERIALIZED \" : \"\";\n    const viewName = this.escapePath(view);\n    const expression = typeof view.expression === \"string\" ? view.expression : view.expression(this.connection).getQuery();\n    return new Query(`CREATE ${materializedClause}VIEW ${viewName} SQL SECURITY INVOKER AS ${expression}`);\n  }\n  insertViewDefinitionSql(view) {\n    var _this42 = this;\n    return _asyncToGenerator(function* () {\n      let {\n        schema,\n        tableName: name\n      } = _this42.driver.parseTableName(view);\n      const type = view.materialized ? MetadataTableType.MATERIALIZED_VIEW : MetadataTableType.VIEW;\n      const expression = typeof view.expression === \"string\" ? view.expression.trim() : view.expression(_this42.connection).getQuery();\n      return _this42.insertTypeormMetadataSql({\n        type,\n        schema,\n        name,\n        value: expression\n      });\n    })();\n  }\n  /**\n   * Builds drop view sql.\n   */\n  dropViewSql(view) {\n    const materializedClause = view.materialized ? \"MATERIALIZED \" : \"\";\n    return new Query(`DROP ${materializedClause}VIEW ${this.escapePath(view)}`);\n  }\n  /**\n   * Builds remove view sql.\n   */\n  deleteViewDefinitionSql(view) {\n    var _this43 = this;\n    return _asyncToGenerator(function* () {\n      let {\n        schema,\n        tableName: name\n      } = _this43.driver.parseTableName(view);\n      const type = view.materialized ? MetadataTableType.MATERIALIZED_VIEW : MetadataTableType.VIEW;\n      return _this43.deleteTypeormMetadataSql({\n        type,\n        schema,\n        name\n      });\n    })();\n  }\n  /**\n   * Builds create index sql.\n   */\n  createIndexSql(table, index) {\n    const columns = index.columnNames.map(columnName => this.driver.escape(columnName)).join(\", \");\n    let indexType = \"\";\n    if (index.isUnique) indexType += \"UNIQUE \";\n    if (index.isNullFiltered) indexType += \"NULL_FILTERED \";\n    return new Query(`CREATE ${indexType}INDEX \\`${index.name}\\` ON ${this.escapePath(table)} (${columns})`);\n  }\n  /**\n   * Builds drop index sql.\n   */\n  dropIndexSql(table, indexOrName) {\n    let indexName = indexOrName instanceof TableIndex ? indexOrName.name : indexOrName;\n    return new Query(`DROP INDEX \\`${indexName}\\``);\n  }\n  /**\n   * Builds create check constraint sql.\n   */\n  createCheckConstraintSql(table, checkConstraint) {\n    return new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \\`${checkConstraint.name}\\` CHECK (${checkConstraint.expression})`);\n  }\n  /**\n   * Builds drop check constraint sql.\n   */\n  dropCheckConstraintSql(table, checkOrName) {\n    const checkName = checkOrName instanceof TableCheck ? checkOrName.name : checkOrName;\n    return new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \\`${checkName}\\``);\n  }\n  /**\n   * Builds create foreign key sql.\n   */\n  createForeignKeySql(table, foreignKey) {\n    const columnNames = foreignKey.columnNames.map(column => this.driver.escape(column)).join(\", \");\n    const referencedColumnNames = foreignKey.referencedColumnNames.map(column => this.driver.escape(column)).join(\",\");\n    let sql = `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \\`${foreignKey.name}\\` FOREIGN KEY (${columnNames}) ` + `REFERENCES ${this.escapePath(this.getTablePath(foreignKey))} (${referencedColumnNames})`;\n    return new Query(sql);\n  }\n  /**\n   * Builds drop foreign key sql.\n   */\n  dropForeignKeySql(table, foreignKeyOrName) {\n    const foreignKeyName = foreignKeyOrName instanceof TableForeignKey ? foreignKeyOrName.name : foreignKeyOrName;\n    return new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \\`${foreignKeyName}\\``);\n  }\n  /**\n   * Escapes given table or view path.\n   */\n  escapePath(target) {\n    const {\n      tableName\n    } = this.driver.parseTableName(target);\n    return `\\`${tableName}\\``;\n  }\n  /**\n   * Builds a part of query to create/change a column.\n   */\n  buildCreateColumnSql(column) {\n    let c = `${this.driver.escape(column.name)} ${this.connection.driver.createFullType(column)}`;\n    // Spanner supports only STORED generated column type\n    if (column.generatedType === \"STORED\" && column.asExpression) {\n      c += ` AS (${column.asExpression}) STORED`;\n    } else {\n      if (!column.isNullable) c += \" NOT NULL\";\n    }\n    return c;\n  }\n  /**\n   * Executes sql used special for schema build.\n   */\n  executeQueries(upQueries, downQueries) {\n    var _this44 = this;\n    return _asyncToGenerator(function* () {\n      if (upQueries instanceof Query) upQueries = [upQueries];\n      if (downQueries instanceof Query) downQueries = [downQueries];\n      _this44.sqlInMemory.upQueries.push(...upQueries);\n      _this44.sqlInMemory.downQueries.push(...downQueries);\n      // if sql-in-memory mode is enabled then simply store sql in memory and return\n      if (_this44.sqlMemoryMode === true) return Promise.resolve();\n      for (const {\n        query,\n        parameters\n      } of upQueries) {\n        if (_this44.isDMLQuery(query)) {\n          yield _this44.query(query, parameters);\n        } else {\n          yield _this44.updateDDL(query, parameters);\n        }\n      }\n    })();\n  }\n  isDMLQuery(query) {\n    return query.startsWith(\"INSERT\") || query.startsWith(\"UPDATE\") || query.startsWith(\"DELETE\");\n  }\n}","map":{"version":3,"names":["QueryFailedError","QueryRunnerAlreadyReleasedError","TransactionNotStartedError","BaseQueryRunner","Table","TableCheck","TableColumn","TableForeignKey","TableIndex","TableUnique","View","Broadcaster","OrmUtils","Query","TypeORMError","QueryResult","MetadataTableType","SpannerQueryRunner","constructor","driver","mode","connection","broadcaster","connect","_this","_asyncToGenerator","session","Promise","resolve","instanceDatabase","createSession","sessionTransaction","transaction","release","_this2","isReleased","delete","undefined","startTransaction","isolationLevel","_this3","isTransactionActive","broadcast","err","begin","logger","logQuery","commitTransaction","_this4","commit","rollbackTransaction","_this5","rollback","query","parameters","useStructuredResult","_this6","queryStartTime","Date","rawResult","isSelect","startsWith","executor","run","sql","params","reduce","value","index","json","error","rollbackError","maxQueryExecutionTime","options","queryEndTime","queryExecutionTime","logQuerySlow","result","raw","records","rowCountExact","affected","parseInt","logQueryError","updateDDL","_this7","operation","updateSchema","promise","stream","onEnd","onError","_this8","request","runStream","on","getDatabases","getSchemas","database","hasDatabase","getCurrentDatabase","hasSchema","schema","_this9","length","getCurrentSchema","hasTable","tableOrName","_this10","tableName","name","hasColumn","columnName","_this11","createDatabase","ifNotExist","_this12","databaseAlreadyExists","up","down","executeQueries","dropDatabase","ifExist","_this13","createSchema","schemaPath","dropSchema","isCascade","createTable","table","createForeignKeys","createIndices","_this14","isTableExist","upQueries","downQueries","push","createTableSql","dropTableSql","foreignKeys","forEach","foreignKey","dropForeignKeySql","indices","namingStrategy","indexName","columnNames","where","createIndexSql","dropIndexSql","generatedColumns","columns","filter","column","generatedType","asExpression","insertQuery","insertTypeormMetadataSql","type","GENERATED_COLUMN","deleteQuery","deleteTypeormMetadataSql","dropTable","target","dropForeignKeys","dropIndices","_this15","tablePath","getTablePath","getCachedTable","createView","view","_this16","createViewSql","insertViewDefinitionSql","dropViewSql","deleteViewDefinitionSql","dropView","_this17","viewName","getCachedView","renameTable","oldTableOrName","newTableName","addColumn","_this18","clonedTable","clone","escapePath","buildCreateColumnSql","escape","columnIndex","find","isUnique","uniqueIndex","uniques","replaceCachedTable","addColumns","_this19","renameColumn","oldTableColumnOrName","newTableColumnOrName","_this20","oldColumn","c","newColumn","changeColumn","_this21","isArray","dropColumn","precision","scale","createFullType","isNullable","splice","indexOf","tableUnique","unique","changeColumns","changedColumns","_this22","columnOrName","_this23","findColumnByName","columnCheck","checks","check","dropCheckConstraintSql","createCheckConstraintSql","removeColumn","dropColumns","_this24","createPrimaryKey","Error","updatePrimaryKeys","dropPrimaryKey","createUniqueConstraint","uniqueConstraint","createUniqueConstraints","uniqueConstraints","dropUniqueConstraint","uniqueOrName","dropUniqueConstraints","createCheckConstraint","checkConstraint","_this25","checkConstraintName","expression","addCheckConstraint","createCheckConstraints","checkConstraints","_this26","promises","map","all","dropCheckConstraint","checkOrName","_this27","removeCheckConstraint","dropCheckConstraints","_this28","createExclusionConstraint","exclusionConstraint","createExclusionConstraints","exclusionConstraints","dropExclusionConstraint","exclusionOrName","dropExclusionConstraints","createForeignKey","_this29","foreignKeyName","referencedColumnNames","createForeignKeySql","addForeignKey","_this30","dropForeignKey","foreignKeyOrName","_this31","fk","removeForeignKey","_this32","createIndex","_this33","generateIndexName","addIndex","_this34","dropIndex","indexOrName","_this35","i","removeIndex","_this36","clearTable","_this37","clearDatabase","_this38","selectIndexDropsQuery","dropIndexQueries","selectFKDropsQuery","dropFKQueries","dropTablesQuery","dropTableQueries","isAnotherTransactionActive","executeMemoryUpSql","_this39","sqlInMemory","isDMLQuery","executeMemoryDownSql","_this40","reverse","loadViews","viewNames","loadTables","tableNames","_this41","dbTables","tablesSql","join","loadedTableNames","dbTable","TABLE_NAME","columnsSql","primaryKeySql","indicesSql","checksSql","foreignKeysSql","dbColumns","dbPrimaryKeys","dbIndices","dbChecks","dbForeignKeys","_ref","buildTableName","dbColumn","_ref2","columnUniqueIndices","dbIndex","tableMetadata","entityMetadatas","metadata","hasIgnoredIndex","some","synchronize","isConstraintComposite","every","tableColumn","fullType","toLowerCase","substring","withLengthColumnTypes","asExpressionQuery","selectTypeormMetadataSql","results","isPrimary","dbPrimaryKey","_x2","apply","arguments","tableForeignKeys","dbForeignKey","uniq","dbFk","referencedDatabase","referencedTableName","onDelete","onUpdate","tableIndices","constraint","isNullFiltered","tableChecks","dbCheck","dbC","_x","columnDefinitions","isUniqueIndexExist","isUniqueConstraintExist","uniqueConstraintName","uniqueExist","checkName","primaryColumns","tableOrPath","materializedClause","materialized","getQuery","_this42","parseTableName","MATERIALIZED_VIEW","VIEW","trim","_this43","indexType","_this44","sqlMemoryMode"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/driver/spanner/SpannerQueryRunner.js"],"sourcesContent":["import { QueryFailedError } from \"../../error/QueryFailedError\";\nimport { QueryRunnerAlreadyReleasedError } from \"../../error/QueryRunnerAlreadyReleasedError\";\nimport { TransactionNotStartedError } from \"../../error/TransactionNotStartedError\";\nimport { BaseQueryRunner } from \"../../query-runner/BaseQueryRunner\";\nimport { Table } from \"../../schema-builder/table/Table\";\nimport { TableCheck } from \"../../schema-builder/table/TableCheck\";\nimport { TableColumn } from \"../../schema-builder/table/TableColumn\";\nimport { TableForeignKey } from \"../../schema-builder/table/TableForeignKey\";\nimport { TableIndex } from \"../../schema-builder/table/TableIndex\";\nimport { TableUnique } from \"../../schema-builder/table/TableUnique\";\nimport { View } from \"../../schema-builder/view/View\";\nimport { Broadcaster } from \"../../subscriber/Broadcaster\";\nimport { OrmUtils } from \"../../util/OrmUtils\";\nimport { Query } from \"../Query\";\nimport { TypeORMError } from \"../../error\";\nimport { QueryResult } from \"../../query-runner/QueryResult\";\nimport { MetadataTableType } from \"../types/MetadataTableType\";\n/**\n * Runs queries on a single postgres database connection.\n */\nexport class SpannerQueryRunner extends BaseQueryRunner {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n    constructor(driver, mode) {\n        super();\n        this.driver = driver;\n        this.connection = driver.connection;\n        this.mode = mode;\n        this.broadcaster = new Broadcaster(this);\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Creates/uses database connection from the connection pool to perform further operations.\n     * Returns obtained database connection.\n     */\n    async connect() {\n        if (this.session) {\n            return Promise.resolve(this.session);\n        }\n        const [session] = await this.driver.instanceDatabase.createSession({});\n        this.session = session;\n        this.sessionTransaction = await session.transaction();\n        return this.session;\n    }\n    /**\n     * Releases used database connection.\n     * You cannot use query runner methods once its released.\n     */\n    async release() {\n        this.isReleased = true;\n        if (this.session) {\n            await this.session.delete();\n        }\n        this.session = undefined;\n        return Promise.resolve();\n    }\n    /**\n     * Starts transaction.\n     */\n    async startTransaction(isolationLevel) {\n        this.isTransactionActive = true;\n        try {\n            await this.broadcaster.broadcast(\"BeforeTransactionStart\");\n        }\n        catch (err) {\n            this.isTransactionActive = false;\n            throw err;\n        }\n        await this.connect();\n        await this.sessionTransaction.begin();\n        this.connection.logger.logQuery(\"START TRANSACTION\");\n        await this.broadcaster.broadcast(\"AfterTransactionStart\");\n    }\n    /**\n     * Commits transaction.\n     * Error will be thrown if transaction was not started.\n     */\n    async commitTransaction() {\n        if (!this.isTransactionActive || !this.sessionTransaction)\n            throw new TransactionNotStartedError();\n        await this.broadcaster.broadcast(\"BeforeTransactionCommit\");\n        await this.sessionTransaction.commit();\n        this.connection.logger.logQuery(\"COMMIT\");\n        this.isTransactionActive = false;\n        await this.broadcaster.broadcast(\"AfterTransactionCommit\");\n    }\n    /**\n     * Rollbacks transaction.\n     * Error will be thrown if transaction was not started.\n     */\n    async rollbackTransaction() {\n        if (!this.isTransactionActive || !this.sessionTransaction)\n            throw new TransactionNotStartedError();\n        await this.broadcaster.broadcast(\"BeforeTransactionRollback\");\n        await this.sessionTransaction.rollback();\n        this.connection.logger.logQuery(\"ROLLBACK\");\n        this.isTransactionActive = false;\n        await this.broadcaster.broadcast(\"AfterTransactionRollback\");\n    }\n    /**\n     * Executes a given SQL query.\n     */\n    async query(query, parameters, useStructuredResult = false) {\n        if (this.isReleased)\n            throw new QueryRunnerAlreadyReleasedError();\n        try {\n            const queryStartTime = +new Date();\n            await this.connect();\n            let rawResult = undefined;\n            const isSelect = query.startsWith(\"SELECT\");\n            const executor = isSelect && !this.isTransactionActive\n                ? this.driver.instanceDatabase\n                : this.sessionTransaction;\n            if (!this.isTransactionActive && !isSelect) {\n                await this.sessionTransaction.begin();\n            }\n            try {\n                this.driver.connection.logger.logQuery(query, parameters, this);\n                rawResult = await executor.run({\n                    sql: query,\n                    params: parameters\n                        ? parameters.reduce((params, value, index) => {\n                            params[\"param\" + index] = value;\n                            return params;\n                        }, {})\n                        : undefined,\n                    json: true,\n                });\n                if (!this.isTransactionActive && !isSelect) {\n                    await this.sessionTransaction.commit();\n                }\n            }\n            catch (error) {\n                try {\n                    // we throw original error even if rollback thrown an error\n                    if (!this.isTransactionActive && !isSelect)\n                        await this.sessionTransaction.rollback();\n                }\n                catch (rollbackError) { }\n                throw error;\n            }\n            // log slow queries if maxQueryExecution time is set\n            const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;\n            const queryEndTime = +new Date();\n            const queryExecutionTime = queryEndTime - queryStartTime;\n            if (maxQueryExecutionTime &&\n                queryExecutionTime > maxQueryExecutionTime)\n                this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);\n            const result = new QueryResult();\n            result.raw = rawResult;\n            result.records = rawResult ? rawResult[0] : [];\n            if (rawResult && rawResult[1] && rawResult[1].rowCountExact) {\n                result.affected = parseInt(rawResult[1].rowCountExact);\n            }\n            if (!useStructuredResult) {\n                return result.records;\n            }\n            return result;\n        }\n        catch (err) {\n            this.driver.connection.logger.logQueryError(err, query, parameters, this);\n            throw new QueryFailedError(query, parameters, err);\n        }\n        finally {\n        }\n    }\n    /**\n     * Update database schema.\n     * Used for creating/altering/dropping tables, columns, indexes, etc.\n     *\n     * DDL changing queries should be executed by `updateSchema()` method.\n     */\n    async updateDDL(query, parameters) {\n        if (this.isReleased)\n            throw new QueryRunnerAlreadyReleasedError();\n        this.driver.connection.logger.logQuery(query, parameters, this);\n        try {\n            const queryStartTime = +new Date();\n            const [operation] = await this.driver.instanceDatabase.updateSchema(query);\n            await operation.promise();\n            // log slow queries if maxQueryExecution time is set\n            const maxQueryExecutionTime = this.driver.options.maxQueryExecutionTime;\n            const queryEndTime = +new Date();\n            const queryExecutionTime = queryEndTime - queryStartTime;\n            if (maxQueryExecutionTime &&\n                queryExecutionTime > maxQueryExecutionTime)\n                this.driver.connection.logger.logQuerySlow(queryExecutionTime, query, parameters, this);\n        }\n        catch (err) {\n            this.driver.connection.logger.logQueryError(err, query, parameters, this);\n            throw new QueryFailedError(query, parameters, err);\n        }\n    }\n    /**\n     * Returns raw data stream.\n     */\n    async stream(query, parameters, onEnd, onError) {\n        if (this.isReleased)\n            throw new QueryRunnerAlreadyReleasedError();\n        try {\n            this.driver.connection.logger.logQuery(query, parameters, this);\n            const request = {\n                sql: query,\n                params: parameters\n                    ? parameters.reduce((params, value, index) => {\n                        params[\"param\" + index] = value;\n                        return params;\n                    }, {})\n                    : undefined,\n                json: true,\n            };\n            const stream = this.driver.instanceDatabase.runStream(request);\n            if (onEnd) {\n                stream.on(\"end\", onEnd);\n            }\n            if (onError) {\n                stream.on(\"error\", onError);\n            }\n            return stream;\n        }\n        catch (err) {\n            this.driver.connection.logger.logQueryError(err, query, parameters, this);\n            throw new QueryFailedError(query, parameters, err);\n        }\n    }\n    /**\n     * Returns all available database names including system databases.\n     */\n    async getDatabases() {\n        return Promise.resolve([]);\n    }\n    /**\n     * Returns all available schema names including system schemas.\n     * If database parameter specified, returns schemas of that database.\n     */\n    async getSchemas(database) {\n        return Promise.resolve([]);\n    }\n    /**\n     * Checks if database with the given name exist.\n     */\n    async hasDatabase(database) {\n        throw new TypeORMError(`Check database queries are not supported by Spanner driver.`);\n    }\n    /**\n     * Loads currently using database\n     */\n    async getCurrentDatabase() {\n        throw new TypeORMError(`Check database queries are not supported by Spanner driver.`);\n    }\n    /**\n     * Checks if schema with the given name exist.\n     */\n    async hasSchema(schema) {\n        const result = await this.query(`SELECT * FROM \"information_schema\".\"schemata\" WHERE \"schema_name\" = '${schema}'`);\n        return result.length ? true : false;\n    }\n    /**\n     * Loads currently using database schema\n     */\n    async getCurrentSchema() {\n        throw new TypeORMError(`Check schema queries are not supported by Spanner driver.`);\n    }\n    /**\n     * Checks if table with the given name exist in the database.\n     */\n    async hasTable(tableOrName) {\n        const tableName = tableOrName instanceof Table ? tableOrName.name : tableOrName;\n        const sql = `SELECT * FROM \\`INFORMATION_SCHEMA\\`.\\`TABLES\\` ` +\n            `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`TABLE_TYPE\\` = 'BASE TABLE' ` +\n            `AND \\`TABLE_NAME\\` = '${tableName}'`;\n        const result = await this.query(sql);\n        return result.length ? true : false;\n    }\n    /**\n     * Checks if column with the given name exist in the given table.\n     */\n    async hasColumn(tableOrName, columnName) {\n        const tableName = tableOrName instanceof Table ? tableOrName.name : tableOrName;\n        const sql = `SELECT * FROM \\`INFORMATION_SCHEMA\\`.\\`COLUMNS\\` ` +\n            `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' ` +\n            `AND \\`TABLE_NAME\\` = '${tableName}' AND \\`COLUMN_NAME\\` = '${columnName}'`;\n        const result = await this.query(sql);\n        return result.length ? true : false;\n    }\n    /**\n     * Creates a new database.\n     * Note: Spanner does not support database creation inside a transaction block.\n     */\n    async createDatabase(database, ifNotExist) {\n        if (ifNotExist) {\n            const databaseAlreadyExists = await this.hasDatabase(database);\n            if (databaseAlreadyExists)\n                return Promise.resolve();\n        }\n        const up = `CREATE DATABASE \"${database}\"`;\n        const down = `DROP DATABASE \"${database}\"`;\n        await this.executeQueries(new Query(up), new Query(down));\n    }\n    /**\n     * Drops database.\n     * Note: Spanner does not support database dropping inside a transaction block.\n     */\n    async dropDatabase(database, ifExist) {\n        const up = ifExist\n            ? `DROP DATABASE IF EXISTS \"${database}\"`\n            : `DROP DATABASE \"${database}\"`;\n        const down = `CREATE DATABASE \"${database}\"`;\n        await this.executeQueries(new Query(up), new Query(down));\n    }\n    /**\n     * Creates a new table schema.\n     */\n    async createSchema(schemaPath, ifNotExist) {\n        return Promise.resolve();\n    }\n    /**\n     * Drops table schema.\n     */\n    async dropSchema(schemaPath, ifExist, isCascade) {\n        return Promise.resolve();\n    }\n    /**\n     * Creates a new table.\n     */\n    async createTable(table, ifNotExist = false, createForeignKeys = true, createIndices = true) {\n        if (ifNotExist) {\n            const isTableExist = await this.hasTable(table);\n            if (isTableExist)\n                return Promise.resolve();\n        }\n        const upQueries = [];\n        const downQueries = [];\n        upQueries.push(this.createTableSql(table, createForeignKeys));\n        downQueries.push(this.dropTableSql(table));\n        // if createForeignKeys is true, we must drop created foreign keys in down query.\n        // createTable does not need separate method to create foreign keys, because it create fk's in the same query with table creation.\n        if (createForeignKeys)\n            table.foreignKeys.forEach((foreignKey) => downQueries.push(this.dropForeignKeySql(table, foreignKey)));\n        if (createIndices) {\n            table.indices.forEach((index) => {\n                // new index may be passed without name. In this case we generate index name manually.\n                if (!index.name)\n                    index.name = this.connection.namingStrategy.indexName(table, index.columnNames, index.where);\n                upQueries.push(this.createIndexSql(table, index));\n                downQueries.push(this.dropIndexSql(table, index));\n            });\n        }\n        // if table has column with generated type, we must add the expression to the metadata table\n        const generatedColumns = table.columns.filter((column) => column.generatedType && column.asExpression);\n        for (const column of generatedColumns) {\n            const insertQuery = this.insertTypeormMetadataSql({\n                table: table.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n                value: column.asExpression,\n            });\n            const deleteQuery = this.deleteTypeormMetadataSql({\n                table: table.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n            });\n            upQueries.push(insertQuery);\n            downQueries.push(deleteQuery);\n        }\n        await this.executeQueries(upQueries, downQueries);\n    }\n    /**\n     * Drops the table.\n     */\n    async dropTable(target, ifExist, dropForeignKeys = true, dropIndices = true) {\n        // It needs because if table does not exist and dropForeignKeys or dropIndices is true, we don't need\n        // to perform drop queries for foreign keys and indices.\n        if (ifExist) {\n            const isTableExist = await this.hasTable(target);\n            if (!isTableExist)\n                return Promise.resolve();\n        }\n        // if dropTable called with dropForeignKeys = true, we must create foreign keys in down query.\n        const createForeignKeys = dropForeignKeys;\n        const tablePath = this.getTablePath(target);\n        const table = await this.getCachedTable(tablePath);\n        const upQueries = [];\n        const downQueries = [];\n        if (dropIndices) {\n            table.indices.forEach((index) => {\n                upQueries.push(this.dropIndexSql(table, index));\n                downQueries.push(this.createIndexSql(table, index));\n            });\n        }\n        if (dropForeignKeys)\n            table.foreignKeys.forEach((foreignKey) => upQueries.push(this.dropForeignKeySql(table, foreignKey)));\n        upQueries.push(this.dropTableSql(table));\n        downQueries.push(this.createTableSql(table, createForeignKeys));\n        // if table had columns with generated type, we must remove the expression from the metadata table\n        const generatedColumns = table.columns.filter((column) => column.generatedType && column.asExpression);\n        for (const column of generatedColumns) {\n            const deleteQuery = this.deleteTypeormMetadataSql({\n                table: table.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n            });\n            const insertQuery = this.insertTypeormMetadataSql({\n                table: table.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n                value: column.asExpression,\n            });\n            upQueries.push(deleteQuery);\n            downQueries.push(insertQuery);\n        }\n        await this.executeQueries(upQueries, downQueries);\n    }\n    /**\n     * Creates a new view.\n     */\n    async createView(view) {\n        const upQueries = [];\n        const downQueries = [];\n        upQueries.push(this.createViewSql(view));\n        upQueries.push(await this.insertViewDefinitionSql(view));\n        downQueries.push(this.dropViewSql(view));\n        downQueries.push(await this.deleteViewDefinitionSql(view));\n        await this.executeQueries(upQueries, downQueries);\n    }\n    /**\n     * Drops the view.\n     */\n    async dropView(target) {\n        const viewName = target instanceof View ? target.name : target;\n        const view = await this.getCachedView(viewName);\n        const upQueries = [];\n        const downQueries = [];\n        upQueries.push(await this.deleteViewDefinitionSql(view));\n        upQueries.push(this.dropViewSql(view));\n        downQueries.push(await this.insertViewDefinitionSql(view));\n        downQueries.push(this.createViewSql(view));\n        await this.executeQueries(upQueries, downQueries);\n    }\n    /**\n     * Renames the given table.\n     */\n    async renameTable(oldTableOrName, newTableName) {\n        throw new TypeORMError(`Rename table queries are not supported by Spanner driver.`);\n    }\n    /**\n     * Creates a new column from the column in the table.\n     */\n    async addColumn(tableOrName, column) {\n        const table = tableOrName instanceof Table\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        const clonedTable = table.clone();\n        const upQueries = [];\n        const downQueries = [];\n        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(column)}`));\n        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN ${this.driver.escape(column.name)}`));\n        // create column index\n        const columnIndex = clonedTable.indices.find((index) => index.columnNames.length === 1 &&\n            index.columnNames[0] === column.name);\n        if (columnIndex) {\n            upQueries.push(this.createIndexSql(table, columnIndex));\n            downQueries.push(this.dropIndexSql(table, columnIndex));\n        }\n        else if (column.isUnique) {\n            const uniqueIndex = new TableIndex({\n                name: this.connection.namingStrategy.indexName(table, [\n                    column.name,\n                ]),\n                columnNames: [column.name],\n                isUnique: true,\n            });\n            clonedTable.indices.push(uniqueIndex);\n            clonedTable.uniques.push(new TableUnique({\n                name: uniqueIndex.name,\n                columnNames: uniqueIndex.columnNames,\n            }));\n            upQueries.push(this.createIndexSql(table, uniqueIndex));\n            downQueries.push(this.dropIndexSql(table, uniqueIndex));\n        }\n        if (column.generatedType && column.asExpression) {\n            const insertQuery = this.insertTypeormMetadataSql({\n                table: table.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n                value: column.asExpression,\n            });\n            const deleteQuery = this.deleteTypeormMetadataSql({\n                table: table.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n            });\n            upQueries.push(insertQuery);\n            downQueries.push(deleteQuery);\n        }\n        await this.executeQueries(upQueries, downQueries);\n        clonedTable.addColumn(column);\n        this.replaceCachedTable(table, clonedTable);\n    }\n    /**\n     * Creates a new columns from the column in the table.\n     */\n    async addColumns(tableOrName, columns) {\n        for (const column of columns) {\n            await this.addColumn(tableOrName, column);\n        }\n    }\n    /**\n     * Renames column in the given table.\n     */\n    async renameColumn(tableOrName, oldTableColumnOrName, newTableColumnOrName) {\n        const table = tableOrName instanceof Table\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        const oldColumn = oldTableColumnOrName instanceof TableColumn\n            ? oldTableColumnOrName\n            : table.columns.find((c) => c.name === oldTableColumnOrName);\n        if (!oldColumn)\n            throw new TypeORMError(`Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`);\n        let newColumn;\n        if (newTableColumnOrName instanceof TableColumn) {\n            newColumn = newTableColumnOrName;\n        }\n        else {\n            newColumn = oldColumn.clone();\n            newColumn.name = newTableColumnOrName;\n        }\n        return this.changeColumn(table, oldColumn, newColumn);\n    }\n    /**\n     * Changes a column in the table.\n     */\n    async changeColumn(tableOrName, oldTableColumnOrName, newColumn) {\n        const table = tableOrName instanceof Table\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        let clonedTable = table.clone();\n        const upQueries = [];\n        const downQueries = [];\n        const oldColumn = oldTableColumnOrName instanceof TableColumn\n            ? oldTableColumnOrName\n            : table.columns.find((column) => column.name === oldTableColumnOrName);\n        if (!oldColumn)\n            throw new TypeORMError(`Column \"${oldTableColumnOrName}\" was not found in the \"${table.name}\" table.`);\n        if (oldColumn.name !== newColumn.name ||\n            oldColumn.type !== newColumn.type ||\n            oldColumn.length !== newColumn.length ||\n            oldColumn.isArray !== newColumn.isArray ||\n            oldColumn.generatedType !== newColumn.generatedType ||\n            oldColumn.asExpression !== newColumn.asExpression) {\n            // To avoid data conversion, we just recreate column\n            await this.dropColumn(table, oldColumn);\n            await this.addColumn(table, newColumn);\n            // update cloned table\n            clonedTable = table.clone();\n        }\n        else {\n            if (newColumn.precision !== oldColumn.precision ||\n                newColumn.scale !== oldColumn.scale) {\n                upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" TYPE ${this.driver.createFullType(newColumn)}`));\n                downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${newColumn.name}\" TYPE ${this.driver.createFullType(oldColumn)}`));\n            }\n            if (oldColumn.isNullable !== newColumn.isNullable) {\n                if (newColumn.isNullable) {\n                    upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" DROP NOT NULL`));\n                    downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" SET NOT NULL`));\n                }\n                else {\n                    upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" SET NOT NULL`));\n                    downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ALTER COLUMN \"${oldColumn.name}\" DROP NOT NULL`));\n                }\n            }\n            if (newColumn.isUnique !== oldColumn.isUnique) {\n                if (newColumn.isUnique === true) {\n                    const uniqueIndex = new TableIndex({\n                        name: this.connection.namingStrategy.indexName(table, [\n                            newColumn.name,\n                        ]),\n                        columnNames: [newColumn.name],\n                        isUnique: true,\n                    });\n                    clonedTable.indices.push(uniqueIndex);\n                    clonedTable.uniques.push(new TableUnique({\n                        name: uniqueIndex.name,\n                        columnNames: uniqueIndex.columnNames,\n                    }));\n                    upQueries.push(this.createIndexSql(table, uniqueIndex));\n                    downQueries.push(this.dropIndexSql(table, uniqueIndex));\n                }\n                else {\n                    const uniqueIndex = clonedTable.indices.find((index) => {\n                        return (index.columnNames.length === 1 &&\n                            index.isUnique === true &&\n                            !!index.columnNames.find((columnName) => columnName === newColumn.name));\n                    });\n                    clonedTable.indices.splice(clonedTable.indices.indexOf(uniqueIndex), 1);\n                    const tableUnique = clonedTable.uniques.find((unique) => unique.name === uniqueIndex.name);\n                    clonedTable.uniques.splice(clonedTable.uniques.indexOf(tableUnique), 1);\n                    upQueries.push(this.dropIndexSql(table, uniqueIndex));\n                    downQueries.push(this.createIndexSql(table, uniqueIndex));\n                }\n            }\n        }\n        await this.executeQueries(upQueries, downQueries);\n        this.replaceCachedTable(table, clonedTable);\n    }\n    /**\n     * Changes a column in the table.\n     */\n    async changeColumns(tableOrName, changedColumns) {\n        for (const { oldColumn, newColumn } of changedColumns) {\n            await this.changeColumn(tableOrName, oldColumn, newColumn);\n        }\n    }\n    /**\n     * Drops column in the table.\n     */\n    async dropColumn(tableOrName, columnOrName) {\n        const table = tableOrName instanceof Table\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        const column = columnOrName instanceof TableColumn\n            ? columnOrName\n            : table.findColumnByName(columnOrName);\n        if (!column)\n            throw new TypeORMError(`Column \"${columnOrName}\" was not found in table \"${table.name}\"`);\n        const clonedTable = table.clone();\n        const upQueries = [];\n        const downQueries = [];\n        // drop column index\n        const columnIndex = clonedTable.indices.find((index) => index.columnNames.length === 1 &&\n            index.columnNames[0] === column.name);\n        if (columnIndex) {\n            clonedTable.indices.splice(clonedTable.indices.indexOf(columnIndex), 1);\n            upQueries.push(this.dropIndexSql(table, columnIndex));\n            downQueries.push(this.createIndexSql(table, columnIndex));\n        }\n        // drop column check\n        const columnCheck = clonedTable.checks.find((check) => !!check.columnNames &&\n            check.columnNames.length === 1 &&\n            check.columnNames[0] === column.name);\n        if (columnCheck) {\n            clonedTable.checks.splice(clonedTable.checks.indexOf(columnCheck), 1);\n            upQueries.push(this.dropCheckConstraintSql(table, columnCheck));\n            downQueries.push(this.createCheckConstraintSql(table, columnCheck));\n        }\n        upQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} DROP COLUMN ${this.driver.escape(column.name)}`));\n        downQueries.push(new Query(`ALTER TABLE ${this.escapePath(table)} ADD ${this.buildCreateColumnSql(column)}`));\n        if (column.generatedType && column.asExpression) {\n            const deleteQuery = this.deleteTypeormMetadataSql({\n                table: table.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n            });\n            const insertQuery = this.insertTypeormMetadataSql({\n                table: table.name,\n                type: MetadataTableType.GENERATED_COLUMN,\n                name: column.name,\n                value: column.asExpression,\n            });\n            upQueries.push(deleteQuery);\n            downQueries.push(insertQuery);\n        }\n        await this.executeQueries(upQueries, downQueries);\n        clonedTable.removeColumn(column);\n        this.replaceCachedTable(table, clonedTable);\n    }\n    /**\n     * Drops the columns in the table.\n     */\n    async dropColumns(tableOrName, columns) {\n        for (const column of columns) {\n            await this.dropColumn(tableOrName, column);\n        }\n    }\n    /**\n     * Creates a new primary key.\n     *\n     * Not supported in Spanner.\n     * @see https://cloud.google.com/spanner/docs/schema-and-data-model#notes_about_key_columns\n     */\n    async createPrimaryKey(tableOrName, columnNames) {\n        throw new Error(\"The keys of a table can't change; you can't add a key column to an existing table or remove a key column from an existing table.\");\n    }\n    /**\n     * Updates composite primary keys.\n     */\n    async updatePrimaryKeys(tableOrName, columns) {\n        throw new Error(\"The keys of a table can't change; you can't add a key column to an existing table or remove a key column from an existing table.\");\n    }\n    /**\n     * Creates a new primary key.\n     *\n     * Not supported in Spanner.\n     * @see https://cloud.google.com/spanner/docs/schema-and-data-model#notes_about_key_columns\n     */\n    async dropPrimaryKey(tableOrName) {\n        throw new Error(\"The keys of a table can't change; you can't add a key column to an existing table or remove a key column from an existing table.\");\n    }\n    /**\n     * Creates new unique constraint.\n     */\n    async createUniqueConstraint(tableOrName, uniqueConstraint) {\n        throw new TypeORMError(`Spanner does not support unique constraints. Use unique index instead.`);\n    }\n    /**\n     * Creates new unique constraints.\n     */\n    async createUniqueConstraints(tableOrName, uniqueConstraints) {\n        throw new TypeORMError(`Spanner does not support unique constraints. Use unique index instead.`);\n    }\n    /**\n     * Drops unique constraint.\n     */\n    async dropUniqueConstraint(tableOrName, uniqueOrName) {\n        throw new TypeORMError(`Spanner does not support unique constraints. Use unique index instead.`);\n    }\n    /**\n     * Drops unique constraints.\n     */\n    async dropUniqueConstraints(tableOrName, uniqueConstraints) {\n        throw new TypeORMError(`Spanner does not support unique constraints. Use unique index instead.`);\n    }\n    /**\n     * Creates new check constraint.\n     */\n    async createCheckConstraint(tableOrName, checkConstraint) {\n        const table = tableOrName instanceof Table\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        // new check constraint may be passed without name. In this case we generate unique name manually.\n        if (!checkConstraint.name)\n            checkConstraint.name =\n                this.connection.namingStrategy.checkConstraintName(table, checkConstraint.expression);\n        const up = this.createCheckConstraintSql(table, checkConstraint);\n        const down = this.dropCheckConstraintSql(table, checkConstraint);\n        await this.executeQueries(up, down);\n        table.addCheckConstraint(checkConstraint);\n    }\n    /**\n     * Creates new check constraints.\n     */\n    async createCheckConstraints(tableOrName, checkConstraints) {\n        const promises = checkConstraints.map((checkConstraint) => this.createCheckConstraint(tableOrName, checkConstraint));\n        await Promise.all(promises);\n    }\n    /**\n     * Drops check constraint.\n     */\n    async dropCheckConstraint(tableOrName, checkOrName) {\n        const table = tableOrName instanceof Table\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        const checkConstraint = checkOrName instanceof TableCheck\n            ? checkOrName\n            : table.checks.find((c) => c.name === checkOrName);\n        if (!checkConstraint)\n            throw new TypeORMError(`Supplied check constraint was not found in table ${table.name}`);\n        const up = this.dropCheckConstraintSql(table, checkConstraint);\n        const down = this.createCheckConstraintSql(table, checkConstraint);\n        await this.executeQueries(up, down);\n        table.removeCheckConstraint(checkConstraint);\n    }\n    /**\n     * Drops check constraints.\n     */\n    async dropCheckConstraints(tableOrName, checkConstraints) {\n        const promises = checkConstraints.map((checkConstraint) => this.dropCheckConstraint(tableOrName, checkConstraint));\n        await Promise.all(promises);\n    }\n    /**\n     * Creates new exclusion constraint.\n     */\n    async createExclusionConstraint(tableOrName, exclusionConstraint) {\n        throw new TypeORMError(`Spanner does not support exclusion constraints.`);\n    }\n    /**\n     * Creates new exclusion constraints.\n     */\n    async createExclusionConstraints(tableOrName, exclusionConstraints) {\n        throw new TypeORMError(`Spanner does not support exclusion constraints.`);\n    }\n    /**\n     * Drops exclusion constraint.\n     */\n    async dropExclusionConstraint(tableOrName, exclusionOrName) {\n        throw new TypeORMError(`Spanner does not support exclusion constraints.`);\n    }\n    /**\n     * Drops exclusion constraints.\n     */\n    async dropExclusionConstraints(tableOrName, exclusionConstraints) {\n        throw new TypeORMError(`Spanner does not support exclusion constraints.`);\n    }\n    /**\n     * Creates a new foreign key.\n     */\n    async createForeignKey(tableOrName, foreignKey) {\n        const table = tableOrName instanceof Table\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        // new FK may be passed without name. In this case we generate FK name manually.\n        if (!foreignKey.name)\n            foreignKey.name = this.connection.namingStrategy.foreignKeyName(table, foreignKey.columnNames, this.getTablePath(foreignKey), foreignKey.referencedColumnNames);\n        const up = this.createForeignKeySql(table, foreignKey);\n        const down = this.dropForeignKeySql(table, foreignKey);\n        await this.executeQueries(up, down);\n        table.addForeignKey(foreignKey);\n    }\n    /**\n     * Creates a new foreign keys.\n     */\n    async createForeignKeys(tableOrName, foreignKeys) {\n        for (const foreignKey of foreignKeys) {\n            await this.createForeignKey(tableOrName, foreignKey);\n        }\n    }\n    /**\n     * Drops a foreign key from the table.\n     */\n    async dropForeignKey(tableOrName, foreignKeyOrName) {\n        const table = tableOrName instanceof Table\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        const foreignKey = foreignKeyOrName instanceof TableForeignKey\n            ? foreignKeyOrName\n            : table.foreignKeys.find((fk) => fk.name === foreignKeyOrName);\n        if (!foreignKey)\n            throw new TypeORMError(`Supplied foreign key was not found in table ${table.name}`);\n        const up = this.dropForeignKeySql(table, foreignKey);\n        const down = this.createForeignKeySql(table, foreignKey);\n        await this.executeQueries(up, down);\n        table.removeForeignKey(foreignKey);\n    }\n    /**\n     * Drops a foreign keys from the table.\n     */\n    async dropForeignKeys(tableOrName, foreignKeys) {\n        for (const foreignKey of foreignKeys) {\n            await this.dropForeignKey(tableOrName, foreignKey);\n        }\n    }\n    /**\n     * Creates a new index.\n     */\n    async createIndex(tableOrName, index) {\n        const table = tableOrName instanceof Table\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        // new index may be passed without name. In this case we generate index name manually.\n        if (!index.name)\n            index.name = this.generateIndexName(table, index);\n        const up = this.createIndexSql(table, index);\n        const down = this.dropIndexSql(table, index);\n        await this.executeQueries(up, down);\n        table.addIndex(index);\n    }\n    /**\n     * Creates a new indices\n     */\n    async createIndices(tableOrName, indices) {\n        for (const index of indices) {\n            await this.createIndex(tableOrName, index);\n        }\n    }\n    /**\n     * Drops an index from the table.\n     */\n    async dropIndex(tableOrName, indexOrName) {\n        const table = tableOrName instanceof Table\n            ? tableOrName\n            : await this.getCachedTable(tableOrName);\n        const index = indexOrName instanceof TableIndex\n            ? indexOrName\n            : table.indices.find((i) => i.name === indexOrName);\n        if (!index)\n            throw new TypeORMError(`Supplied index ${indexOrName} was not found in table ${table.name}`);\n        // new index may be passed without name. In this case we generate index name manually.\n        if (!index.name)\n            index.name = this.generateIndexName(table, index);\n        const up = this.dropIndexSql(table, index);\n        const down = this.createIndexSql(table, index);\n        await this.executeQueries(up, down);\n        table.removeIndex(index);\n    }\n    /**\n     * Drops an indices from the table.\n     */\n    async dropIndices(tableOrName, indices) {\n        for (const index of indices) {\n            await this.dropIndex(tableOrName, index);\n        }\n    }\n    /**\n     * Clears all table contents.\n     * Spanner does not support TRUNCATE TABLE statement, so we use DELETE FROM.\n     */\n    async clearTable(tableName) {\n        await this.query(`DELETE FROM ${this.escapePath(tableName)} WHERE true`);\n    }\n    /**\n     * Removes all tables from the currently connected database.\n     */\n    async clearDatabase() {\n        // drop index queries\n        const selectIndexDropsQuery = `SELECT concat('DROP INDEX \\`', INDEX_NAME, '\\`') AS \\`query\\` ` +\n            `FROM \\`INFORMATION_SCHEMA\\`.\\`INDEXES\\` ` +\n            `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`INDEX_TYPE\\` = 'INDEX' AND \\`SPANNER_IS_MANAGED\\` = false`;\n        const dropIndexQueries = await this.query(selectIndexDropsQuery);\n        // drop foreign key queries\n        const selectFKDropsQuery = `SELECT concat('ALTER TABLE \\`', TABLE_NAME, '\\`', ' DROP CONSTRAINT \\`', CONSTRAINT_NAME, '\\`') AS \\`query\\` ` +\n            `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLE_CONSTRAINTS\\` ` +\n            `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`CONSTRAINT_TYPE\\` = 'FOREIGN KEY'`;\n        const dropFKQueries = await this.query(selectFKDropsQuery);\n        // drop view queries\n        // const selectViewDropsQuery = `SELECT concat('DROP VIEW \\`', TABLE_NAME, '\\`') AS \\`query\\` FROM \\`INFORMATION_SCHEMA\\`.\\`VIEWS\\``\n        // const dropViewQueries: ObjectLiteral[] = await this.query(\n        //     selectViewDropsQuery,\n        // )\n        // drop table queries\n        const dropTablesQuery = `SELECT concat('DROP TABLE \\`', TABLE_NAME, '\\`') AS \\`query\\` ` +\n            `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLES\\` ` +\n            `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`TABLE_TYPE\\` = 'BASE TABLE'`;\n        const dropTableQueries = await this.query(dropTablesQuery);\n        if (!dropIndexQueries.length &&\n            !dropFKQueries.length &&\n            // !dropViewQueries.length &&\n            !dropTableQueries.length)\n            return;\n        const isAnotherTransactionActive = this.isTransactionActive;\n        if (!isAnotherTransactionActive)\n            await this.startTransaction();\n        try {\n            for (let query of dropIndexQueries) {\n                await this.updateDDL(query[\"query\"]);\n            }\n            for (let query of dropFKQueries) {\n                await this.updateDDL(query[\"query\"]);\n            }\n            // for (let query of dropViewQueries) {\n            //     await this.updateDDL(query[\"query\"])\n            // }\n            for (let query of dropTableQueries) {\n                await this.updateDDL(query[\"query\"]);\n            }\n            await this.commitTransaction();\n        }\n        catch (error) {\n            try {\n                // we throw original error even if rollback thrown an error\n                if (!isAnotherTransactionActive)\n                    await this.rollbackTransaction();\n            }\n            catch (rollbackError) { }\n            throw error;\n        }\n    }\n    // -------------------------------------------------------------------------\n    // Override Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Executes up sql queries.\n     */\n    async executeMemoryUpSql() {\n        for (const { query, parameters } of this.sqlInMemory.upQueries) {\n            if (this.isDMLQuery(query)) {\n                await this.query(query, parameters);\n            }\n            else {\n                await this.updateDDL(query, parameters);\n            }\n        }\n    }\n    /**\n     * Executes down sql queries.\n     */\n    async executeMemoryDownSql() {\n        for (const { query, parameters, } of this.sqlInMemory.downQueries.reverse()) {\n            if (this.isDMLQuery(query)) {\n                await this.query(query, parameters);\n            }\n            else {\n                await this.updateDDL(query, parameters);\n            }\n        }\n    }\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n    async loadViews(viewNames) {\n        // const hasTable = await this.hasTable(this.getTypeormMetadataTableName())\n        // if (!hasTable) {\n        //     return []\n        // }\n        //\n        // if (!viewNames) {\n        //     viewNames = []\n        // }\n        //\n        // const escapedViewNames = viewNames\n        //     .map((viewName) => `'${viewName}'`)\n        //     .join(\", \")\n        //\n        // const query =\n        //     `SELECT \\`T\\`.*, \\`V\\`.\\`VIEW_DEFINITION\\` FROM ${this.escapePath(\n        //         this.getTypeormMetadataTableName(),\n        //     )} \\`T\\` ` +\n        //     `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`VIEWS\\` \\`V\\` ON \\`V\\`.\\`TABLE_NAME\\` = \\`T\\`.\\`NAME\\` ` +\n        //     `WHERE \\`T\\`.\\`TYPE\\` = '${MetadataTableType.VIEW}' ${\n        //         viewNames.length\n        //             ? ` AND \\`T\\`.\\`NAME\\` IN (${escapedViewNames})`\n        //             : \"\"\n        //     }`\n        // const dbViews = await this.query(query)\n        // return dbViews.map((dbView: any) => {\n        //     const view = new View()\n        //     view.database = dbView[\"NAME\"]\n        //     view.name = this.driver.buildTableName(dbView[\"NAME\"])\n        //     view.expression = dbView[\"NAME\"]\n        //     return view\n        // })\n        return Promise.resolve([]);\n    }\n    /**\n     * Loads all tables (with given names) from the database and creates a Table from them.\n     */\n    async loadTables(tableNames) {\n        if (tableNames && tableNames.length === 0) {\n            return [];\n        }\n        const dbTables = [];\n        if (!tableNames || !tableNames.length) {\n            // Since we don't have any of this data we have to do a scan\n            const tablesSql = `SELECT \\`TABLE_NAME\\` ` +\n                `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLES\\` ` +\n                `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`TABLE_TYPE\\` = 'BASE TABLE'`;\n            dbTables.push(...(await this.query(tablesSql)));\n        }\n        else {\n            const tablesSql = `SELECT \\`TABLE_NAME\\` ` +\n                `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLES\\` ` +\n                `WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`TABLE_TYPE\\` = 'BASE TABLE' ` +\n                `AND \\`TABLE_NAME\\` IN (${tableNames\n                    .map((tableName) => `'${tableName}'`)\n                    .join(\", \")})`;\n            dbTables.push(...(await this.query(tablesSql)));\n        }\n        // if tables were not found in the db, no need to proceed\n        if (!dbTables.length)\n            return [];\n        const loadedTableNames = dbTables\n            .map((dbTable) => `'${dbTable.TABLE_NAME}'`)\n            .join(\", \");\n        const columnsSql = `SELECT * FROM \\`INFORMATION_SCHEMA\\`.\\`COLUMNS\\` WHERE \\`TABLE_CATALOG\\` = '' AND \\`TABLE_SCHEMA\\` = '' AND \\`TABLE_NAME\\` IN (${loadedTableNames})`;\n        const primaryKeySql = `SELECT \\`KCU\\`.\\`TABLE_NAME\\`, \\`KCU\\`.\\`COLUMN_NAME\\` ` +\n            `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLE_CONSTRAINTS\\` \\`TC\\` ` +\n            `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`KEY_COLUMN_USAGE\\` \\`KCU\\` ON \\`KCU\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` +\n            `WHERE \\`TC\\`.\\`TABLE_CATALOG\\` = '' AND \\`TC\\`.\\`TABLE_SCHEMA\\` = '' AND \\`TC\\`.\\`CONSTRAINT_TYPE\\` = 'PRIMARY KEY' ` +\n            `AND \\`TC\\`.\\`TABLE_NAME\\` IN (${loadedTableNames})`;\n        const indicesSql = `SELECT \\`I\\`.\\`TABLE_NAME\\`, \\`I\\`.\\`INDEX_NAME\\`, \\`I\\`.\\`IS_UNIQUE\\`, \\`I\\`.\\`IS_NULL_FILTERED\\`, \\`IC\\`.\\`COLUMN_NAME\\` ` +\n            `FROM \\`INFORMATION_SCHEMA\\`.\\`INDEXES\\` \\`I\\` ` +\n            `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`INDEX_COLUMNS\\` \\`IC\\` ON \\`IC\\`.\\`INDEX_NAME\\` = \\`I\\`.\\`INDEX_NAME\\` ` +\n            `AND \\`IC\\`.\\`TABLE_NAME\\` = \\`I\\`.\\`TABLE_NAME\\` ` +\n            `WHERE \\`I\\`.\\`TABLE_CATALOG\\` = '' AND \\`I\\`.\\`TABLE_SCHEMA\\` = '' AND \\`I\\`.\\`TABLE_NAME\\` IN (${loadedTableNames}) ` +\n            `AND \\`I\\`.\\`INDEX_TYPE\\` = 'INDEX' AND \\`I\\`.\\`SPANNER_IS_MANAGED\\` = false`;\n        const checksSql = `SELECT \\`TC\\`.\\`TABLE_NAME\\`, \\`TC\\`.\\`CONSTRAINT_NAME\\`, \\`CC\\`.\\`CHECK_CLAUSE\\`, \\`CCU\\`.\\`COLUMN_NAME\\`` +\n            `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLE_CONSTRAINTS\\` \\`TC\\` ` +\n            `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`CONSTRAINT_COLUMN_USAGE\\` \\`CCU\\` ON \\`CCU\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` +\n            `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`CHECK_CONSTRAINTS\\` \\`CC\\` ON \\`CC\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` +\n            `WHERE \\`TC\\`.\\`TABLE_CATALOG\\` = '' AND \\`TC\\`.\\`TABLE_SCHEMA\\` = '' AND \\`TC\\`.\\`CONSTRAINT_TYPE\\` = 'CHECK' ` +\n            `AND \\`TC\\`.\\`TABLE_NAME\\` IN (${loadedTableNames}) AND \\`TC\\`.\\`CONSTRAINT_NAME\\` NOT LIKE 'CK_IS_NOT_NULL%'`;\n        const foreignKeysSql = `SELECT \\`TC\\`.\\`TABLE_NAME\\`, \\`TC\\`.\\`CONSTRAINT_NAME\\`, \\`KCU\\`.\\`COLUMN_NAME\\`, ` +\n            `\\`CTU\\`.\\`TABLE_NAME\\` AS \\`REFERENCED_TABLE_NAME\\`, \\`CCU\\`.\\`COLUMN_NAME\\` AS \\`REFERENCED_COLUMN_NAME\\`, ` +\n            `\\`RC\\`.\\`UPDATE_RULE\\`, \\`RC\\`.\\`DELETE_RULE\\` ` +\n            `FROM \\`INFORMATION_SCHEMA\\`.\\`TABLE_CONSTRAINTS\\` \\`TC\\` ` +\n            `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`KEY_COLUMN_USAGE\\` \\`KCU\\` ON \\`KCU\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` +\n            `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`CONSTRAINT_TABLE_USAGE\\` \\`CTU\\` ON \\`CTU\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` +\n            `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`REFERENTIAL_CONSTRAINTS\\` \\`RC\\` ON \\`RC\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` +\n            `INNER JOIN \\`INFORMATION_SCHEMA\\`.\\`CONSTRAINT_COLUMN_USAGE\\` \\`CCU\\` ON \\`CCU\\`.\\`CONSTRAINT_NAME\\` = \\`TC\\`.\\`CONSTRAINT_NAME\\` ` +\n            `WHERE \\`TC\\`.\\`TABLE_CATALOG\\` = '' AND \\`TC\\`.\\`TABLE_SCHEMA\\` = '' AND \\`TC\\`.\\`CONSTRAINT_TYPE\\` = 'FOREIGN KEY' ` +\n            `AND \\`TC\\`.\\`TABLE_NAME\\` IN (${loadedTableNames})`;\n        const [dbColumns, dbPrimaryKeys, dbIndices, dbChecks, dbForeignKeys,] = await Promise.all([\n            this.query(columnsSql),\n            this.query(primaryKeySql),\n            this.query(indicesSql),\n            this.query(checksSql),\n            this.query(foreignKeysSql),\n        ]);\n        // create tables for loaded tables\n        return Promise.all(dbTables.map(async (dbTable) => {\n            const table = new Table();\n            table.name = this.driver.buildTableName(dbTable[\"TABLE_NAME\"]);\n            // create columns from the loaded columns\n            table.columns = await Promise.all(dbColumns\n                .filter((dbColumn) => dbColumn[\"TABLE_NAME\"] ===\n                dbTable[\"TABLE_NAME\"])\n                .map(async (dbColumn) => {\n                const columnUniqueIndices = dbIndices.filter((dbIndex) => {\n                    return (dbIndex[\"TABLE_NAME\"] ===\n                        dbTable[\"TABLE_NAME\"] &&\n                        dbIndex[\"COLUMN_NAME\"] ===\n                            dbColumn[\"COLUMN_NAME\"] &&\n                        dbIndex[\"IS_UNIQUE\"] === true);\n                });\n                const tableMetadata = this.connection.entityMetadatas.find((metadata) => this.getTablePath(table) ===\n                    this.getTablePath(metadata));\n                const hasIgnoredIndex = columnUniqueIndices.length > 0 &&\n                    tableMetadata &&\n                    tableMetadata.indices.some((index) => {\n                        return columnUniqueIndices.some((uniqueIndex) => {\n                            return (index.name ===\n                                uniqueIndex[\"INDEX_NAME\"] &&\n                                index.synchronize === false);\n                        });\n                    });\n                const isConstraintComposite = columnUniqueIndices.every((uniqueIndex) => {\n                    return dbIndices.some((dbIndex) => dbIndex[\"INDEX_NAME\"] ===\n                        uniqueIndex[\"INDEX_NAME\"] &&\n                        dbIndex[\"COLUMN_NAME\"] !==\n                            dbColumn[\"COLUMN_NAME\"]);\n                });\n                const tableColumn = new TableColumn();\n                tableColumn.name = dbColumn[\"COLUMN_NAME\"];\n                let fullType = dbColumn[\"SPANNER_TYPE\"].toLowerCase();\n                if (fullType.indexOf(\"array\") !== -1) {\n                    tableColumn.isArray = true;\n                    fullType = fullType.substring(fullType.indexOf(\"<\") + 1, fullType.indexOf(\">\"));\n                }\n                if (fullType.indexOf(\"(\") !== -1) {\n                    tableColumn.type = fullType.substring(0, fullType.indexOf(\"(\"));\n                }\n                else {\n                    tableColumn.type = fullType;\n                }\n                if (this.driver.withLengthColumnTypes.indexOf(tableColumn.type) !== -1) {\n                    tableColumn.length = fullType.substring(fullType.indexOf(\"(\") + 1, fullType.indexOf(\")\"));\n                }\n                if (dbColumn[\"IS_GENERATED\"] === \"ALWAYS\") {\n                    tableColumn.asExpression =\n                        dbColumn[\"GENERATION_EXPRESSION\"];\n                    tableColumn.generatedType = \"STORED\";\n                    // We cannot relay on information_schema.columns.generation_expression, because it is formatted different.\n                    const asExpressionQuery = await this.selectTypeormMetadataSql({\n                        table: dbTable[\"TABLE_NAME\"],\n                        type: MetadataTableType.GENERATED_COLUMN,\n                        name: tableColumn.name,\n                    });\n                    const results = await this.query(asExpressionQuery.query, asExpressionQuery.parameters);\n                    if (results[0] && results[0].value) {\n                        tableColumn.asExpression = results[0].value;\n                    }\n                    else {\n                        tableColumn.asExpression = \"\";\n                    }\n                }\n                tableColumn.isUnique =\n                    columnUniqueIndices.length > 0 &&\n                        !hasIgnoredIndex &&\n                        !isConstraintComposite;\n                tableColumn.isNullable =\n                    dbColumn[\"IS_NULLABLE\"] === \"YES\";\n                tableColumn.isPrimary = dbPrimaryKeys.some((dbPrimaryKey) => {\n                    return (dbPrimaryKey[\"TABLE_NAME\"] ===\n                        dbColumn[\"TABLE_NAME\"] &&\n                        dbPrimaryKey[\"COLUMN_NAME\"] ===\n                            dbColumn[\"COLUMN_NAME\"]);\n                });\n                return tableColumn;\n            }));\n            const tableForeignKeys = dbForeignKeys.filter((dbForeignKey) => {\n                return (dbForeignKey[\"TABLE_NAME\"] === dbTable[\"TABLE_NAME\"]);\n            });\n            table.foreignKeys = OrmUtils.uniq(tableForeignKeys, (dbForeignKey) => dbForeignKey[\"CONSTRAINT_NAME\"]).map((dbForeignKey) => {\n                const foreignKeys = tableForeignKeys.filter((dbFk) => dbFk[\"CONSTRAINT_NAME\"] ===\n                    dbForeignKey[\"CONSTRAINT_NAME\"]);\n                return new TableForeignKey({\n                    name: dbForeignKey[\"CONSTRAINT_NAME\"],\n                    columnNames: OrmUtils.uniq(foreignKeys.map((dbFk) => dbFk[\"COLUMN_NAME\"])),\n                    referencedDatabase: dbForeignKey[\"REFERENCED_TABLE_SCHEMA\"],\n                    referencedTableName: dbForeignKey[\"REFERENCED_TABLE_NAME\"],\n                    referencedColumnNames: OrmUtils.uniq(foreignKeys.map((dbFk) => dbFk[\"REFERENCED_COLUMN_NAME\"])),\n                    onDelete: dbForeignKey[\"DELETE_RULE\"],\n                    onUpdate: dbForeignKey[\"UPDATE_RULE\"],\n                });\n            });\n            const tableIndices = dbIndices.filter((dbIndex) => dbIndex[\"TABLE_NAME\"] === dbTable[\"TABLE_NAME\"]);\n            table.indices = OrmUtils.uniq(tableIndices, (dbIndex) => dbIndex[\"INDEX_NAME\"]).map((constraint) => {\n                const indices = tableIndices.filter((index) => {\n                    return index[\"INDEX_NAME\"] === constraint[\"INDEX_NAME\"];\n                });\n                return new TableIndex({\n                    table: table,\n                    name: constraint[\"INDEX_NAME\"],\n                    columnNames: indices.map((i) => i[\"COLUMN_NAME\"]),\n                    isUnique: constraint[\"IS_UNIQUE\"],\n                    isNullFiltered: constraint[\"IS_NULL_FILTERED\"],\n                });\n            });\n            const tableChecks = dbChecks.filter((dbCheck) => dbCheck[\"TABLE_NAME\"] === dbTable[\"TABLE_NAME\"]);\n            table.checks = OrmUtils.uniq(tableChecks, (dbIndex) => dbIndex[\"CONSTRAINT_NAME\"]).map((constraint) => {\n                const checks = tableChecks.filter((dbC) => dbC[\"CONSTRAINT_NAME\"] ===\n                    constraint[\"CONSTRAINT_NAME\"]);\n                return new TableCheck({\n                    name: constraint[\"CONSTRAINT_NAME\"],\n                    columnNames: checks.map((c) => c[\"COLUMN_NAME\"]),\n                    expression: constraint[\"CHECK_CLAUSE\"],\n                });\n            });\n            return table;\n        }));\n    }\n    /**\n     * Builds create table sql.\n     */\n    createTableSql(table, createForeignKeys) {\n        const columnDefinitions = table.columns\n            .map((column) => this.buildCreateColumnSql(column))\n            .join(\", \");\n        let sql = `CREATE TABLE ${this.escapePath(table)} (${columnDefinitions}`;\n        // we create unique indexes instead of unique constraints, because Spanner does not have unique constraints.\n        // if we mark column as Unique, it means that we create UNIQUE INDEX.\n        table.columns\n            .filter((column) => column.isUnique)\n            .forEach((column) => {\n            const isUniqueIndexExist = table.indices.some((index) => {\n                return (index.columnNames.length === 1 &&\n                    !!index.isUnique &&\n                    index.columnNames.indexOf(column.name) !== -1);\n            });\n            const isUniqueConstraintExist = table.uniques.some((unique) => {\n                return (unique.columnNames.length === 1 &&\n                    unique.columnNames.indexOf(column.name) !== -1);\n            });\n            if (!isUniqueIndexExist && !isUniqueConstraintExist)\n                table.indices.push(new TableIndex({\n                    name: this.connection.namingStrategy.uniqueConstraintName(table, [column.name]),\n                    columnNames: [column.name],\n                    isUnique: true,\n                }));\n        });\n        // as Spanner does not have unique constraints, we must create table indices from table uniques and mark them as unique.\n        if (table.uniques.length > 0) {\n            table.uniques.forEach((unique) => {\n                const uniqueExist = table.indices.some((index) => index.name === unique.name);\n                if (!uniqueExist) {\n                    table.indices.push(new TableIndex({\n                        name: unique.name,\n                        columnNames: unique.columnNames,\n                        isUnique: true,\n                    }));\n                }\n            });\n        }\n        if (table.checks.length > 0) {\n            const checksSql = table.checks\n                .map((check) => {\n                const checkName = check.name\n                    ? check.name\n                    : this.connection.namingStrategy.checkConstraintName(table, check.expression);\n                return `CONSTRAINT \\`${checkName}\\` CHECK (${check.expression})`;\n            })\n                .join(\", \");\n            sql += `, ${checksSql}`;\n        }\n        if (table.foreignKeys.length > 0 && createForeignKeys) {\n            const foreignKeysSql = table.foreignKeys\n                .map((fk) => {\n                const columnNames = fk.columnNames\n                    .map((columnName) => `\\`${columnName}\\``)\n                    .join(\", \");\n                if (!fk.name)\n                    fk.name = this.connection.namingStrategy.foreignKeyName(table, fk.columnNames, this.getTablePath(fk), fk.referencedColumnNames);\n                const referencedColumnNames = fk.referencedColumnNames\n                    .map((columnName) => `\\`${columnName}\\``)\n                    .join(\", \");\n                return `CONSTRAINT \\`${fk.name}\\` FOREIGN KEY (${columnNames}) REFERENCES ${this.escapePath(this.getTablePath(fk))} (${referencedColumnNames})`;\n            })\n                .join(\", \");\n            sql += `, ${foreignKeysSql}`;\n        }\n        sql += `)`;\n        const primaryColumns = table.columns.filter((column) => column.isPrimary);\n        if (primaryColumns.length > 0) {\n            const columnNames = primaryColumns\n                .map((column) => this.driver.escape(column.name))\n                .join(\", \");\n            sql += ` PRIMARY KEY (${columnNames})`;\n        }\n        return new Query(sql);\n    }\n    /**\n     * Builds drop table sql.\n     */\n    dropTableSql(tableOrPath) {\n        return new Query(`DROP TABLE ${this.escapePath(tableOrPath)}`);\n    }\n    createViewSql(view) {\n        const materializedClause = view.materialized ? \"MATERIALIZED \" : \"\";\n        const viewName = this.escapePath(view);\n        const expression = typeof view.expression === \"string\"\n            ? view.expression\n            : view.expression(this.connection).getQuery();\n        return new Query(`CREATE ${materializedClause}VIEW ${viewName} SQL SECURITY INVOKER AS ${expression}`);\n    }\n    async insertViewDefinitionSql(view) {\n        let { schema, tableName: name } = this.driver.parseTableName(view);\n        const type = view.materialized\n            ? MetadataTableType.MATERIALIZED_VIEW\n            : MetadataTableType.VIEW;\n        const expression = typeof view.expression === \"string\"\n            ? view.expression.trim()\n            : view.expression(this.connection).getQuery();\n        return this.insertTypeormMetadataSql({\n            type,\n            schema,\n            name,\n            value: expression,\n        });\n    }\n    /**\n     * Builds drop view sql.\n     */\n    dropViewSql(view) {\n        const materializedClause = view.materialized ? \"MATERIALIZED \" : \"\";\n        return new Query(`DROP ${materializedClause}VIEW ${this.escapePath(view)}`);\n    }\n    /**\n     * Builds remove view sql.\n     */\n    async deleteViewDefinitionSql(view) {\n        let { schema, tableName: name } = this.driver.parseTableName(view);\n        const type = view.materialized\n            ? MetadataTableType.MATERIALIZED_VIEW\n            : MetadataTableType.VIEW;\n        return this.deleteTypeormMetadataSql({ type, schema, name });\n    }\n    /**\n     * Builds create index sql.\n     */\n    createIndexSql(table, index) {\n        const columns = index.columnNames\n            .map((columnName) => this.driver.escape(columnName))\n            .join(\", \");\n        let indexType = \"\";\n        if (index.isUnique)\n            indexType += \"UNIQUE \";\n        if (index.isNullFiltered)\n            indexType += \"NULL_FILTERED \";\n        return new Query(`CREATE ${indexType}INDEX \\`${index.name}\\` ON ${this.escapePath(table)} (${columns})`);\n    }\n    /**\n     * Builds drop index sql.\n     */\n    dropIndexSql(table, indexOrName) {\n        let indexName = indexOrName instanceof TableIndex ? indexOrName.name : indexOrName;\n        return new Query(`DROP INDEX \\`${indexName}\\``);\n    }\n    /**\n     * Builds create check constraint sql.\n     */\n    createCheckConstraintSql(table, checkConstraint) {\n        return new Query(`ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \\`${checkConstraint.name}\\` CHECK (${checkConstraint.expression})`);\n    }\n    /**\n     * Builds drop check constraint sql.\n     */\n    dropCheckConstraintSql(table, checkOrName) {\n        const checkName = checkOrName instanceof TableCheck ? checkOrName.name : checkOrName;\n        return new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \\`${checkName}\\``);\n    }\n    /**\n     * Builds create foreign key sql.\n     */\n    createForeignKeySql(table, foreignKey) {\n        const columnNames = foreignKey.columnNames\n            .map((column) => this.driver.escape(column))\n            .join(\", \");\n        const referencedColumnNames = foreignKey.referencedColumnNames\n            .map((column) => this.driver.escape(column))\n            .join(\",\");\n        let sql = `ALTER TABLE ${this.escapePath(table)} ADD CONSTRAINT \\`${foreignKey.name}\\` FOREIGN KEY (${columnNames}) ` +\n            `REFERENCES ${this.escapePath(this.getTablePath(foreignKey))} (${referencedColumnNames})`;\n        return new Query(sql);\n    }\n    /**\n     * Builds drop foreign key sql.\n     */\n    dropForeignKeySql(table, foreignKeyOrName) {\n        const foreignKeyName = foreignKeyOrName instanceof TableForeignKey\n            ? foreignKeyOrName.name\n            : foreignKeyOrName;\n        return new Query(`ALTER TABLE ${this.escapePath(table)} DROP CONSTRAINT \\`${foreignKeyName}\\``);\n    }\n    /**\n     * Escapes given table or view path.\n     */\n    escapePath(target) {\n        const { tableName } = this.driver.parseTableName(target);\n        return `\\`${tableName}\\``;\n    }\n    /**\n     * Builds a part of query to create/change a column.\n     */\n    buildCreateColumnSql(column) {\n        let c = `${this.driver.escape(column.name)} ${this.connection.driver.createFullType(column)}`;\n        // Spanner supports only STORED generated column type\n        if (column.generatedType === \"STORED\" && column.asExpression) {\n            c += ` AS (${column.asExpression}) STORED`;\n        }\n        else {\n            if (!column.isNullable)\n                c += \" NOT NULL\";\n        }\n        return c;\n    }\n    /**\n     * Executes sql used special for schema build.\n     */\n    async executeQueries(upQueries, downQueries) {\n        if (upQueries instanceof Query)\n            upQueries = [upQueries];\n        if (downQueries instanceof Query)\n            downQueries = [downQueries];\n        this.sqlInMemory.upQueries.push(...upQueries);\n        this.sqlInMemory.downQueries.push(...downQueries);\n        // if sql-in-memory mode is enabled then simply store sql in memory and return\n        if (this.sqlMemoryMode === true)\n            return Promise.resolve();\n        for (const { query, parameters } of upQueries) {\n            if (this.isDMLQuery(query)) {\n                await this.query(query, parameters);\n            }\n            else {\n                await this.updateDDL(query, parameters);\n            }\n        }\n    }\n    isDMLQuery(query) {\n        return (query.startsWith(\"INSERT\") ||\n            query.startsWith(\"UPDATE\") ||\n            query.startsWith(\"DELETE\"));\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}