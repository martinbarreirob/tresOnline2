{"ast":null,"code":"import { ColumnMetadata } from \"../metadata/ColumnMetadata\";\nimport { UniqueMetadata } from \"../metadata/UniqueMetadata\";\nimport { ForeignKeyMetadata } from \"../metadata/ForeignKeyMetadata\";\nimport { TypeORMError } from \"../error\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\n/**\n * Builds join column for the many-to-one and one-to-one owner relations.\n *\n * Cases it should cover:\n * 1. when join column is set with custom name and without referenced column name\n * we need automatically set referenced column name - primary ids by default\n * @JoinColumn({ name: \"custom_name\" })\n *\n * 2. when join column is set with only referenced column name\n * we need automatically set join column name - relation name + referenced column name\n * @JoinColumn({ referencedColumnName: \"title\" })\n *\n * 3. when join column is set without both referenced column name and join column name\n * we need to automatically set both of them\n * @JoinColumn()\n *\n * 4. when join column is not set at all (as in case of @ManyToOne relation)\n * we need to create join column for it with proper referenced column name and join column name\n *\n * 5. when multiple join columns set none of referencedColumnName and name can be optional\n * both options are required\n * @JoinColumn([\n *      { name: \"category_title\", referencedColumnName: \"type\" },\n *      { name: \"category_title\", referencedColumnName: \"name\" },\n * ])\n *\n * Since for many-to-one relations having JoinColumn decorator is not required,\n * we need to go through each many-to-one relation without join column decorator set\n * and create join column metadata args for them.\n */\nexport class RelationJoinColumnBuilder {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection) {\n    this.connection = connection;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Builds a foreign key of the many-to-one or one-to-one owner relations.\n   */\n  build(joinColumns, relation) {\n    var _a;\n    const referencedColumns = this.collectReferencedColumns(joinColumns, relation);\n    const columns = this.collectColumns(joinColumns, relation, referencedColumns);\n    if (!referencedColumns.length || !relation.createForeignKeyConstraints) return {\n      foreignKey: undefined,\n      columns,\n      uniqueConstraint: undefined\n    }; // this case is possible for one-to-one non owning side and relations with createForeignKeyConstraints = false\n    const foreignKey = new ForeignKeyMetadata({\n      name: (_a = joinColumns[0]) === null || _a === void 0 ? void 0 : _a.foreignKeyConstraintName,\n      entityMetadata: relation.entityMetadata,\n      referencedEntityMetadata: relation.inverseEntityMetadata,\n      namingStrategy: this.connection.namingStrategy,\n      columns,\n      referencedColumns,\n      onDelete: relation.onDelete,\n      onUpdate: relation.onUpdate,\n      deferrable: relation.deferrable\n    });\n    // SQL requires UNIQUE/PK constraints on columns referenced by a FK\n    // Skip creating the unique constraint for the referenced columns if\n    // they are already contained in the PK of the referenced entity\n    if (columns.every(column => column.isPrimary) || !relation.isOneToOne) {\n      return {\n        foreignKey,\n        columns,\n        uniqueConstraint: undefined\n      };\n    }\n    const uniqueConstraint = new UniqueMetadata({\n      entityMetadata: relation.entityMetadata,\n      columns: foreignKey.columns,\n      args: {\n        name: this.connection.namingStrategy.relationConstraintName(relation.entityMetadata.tableName, foreignKey.columns.map(column => column.databaseName)),\n        target: relation.entityMetadata.target\n      }\n    });\n    uniqueConstraint.build(this.connection.namingStrategy);\n    return {\n      foreignKey,\n      columns,\n      uniqueConstraint\n    };\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Collects referenced columns from the given join column args.\n   */\n  collectReferencedColumns(joinColumns, relation) {\n    const hasAnyReferencedColumnName = joinColumns.find(joinColumnArgs => !!joinColumnArgs.referencedColumnName);\n    const manyToOneWithoutJoinColumn = joinColumns.length === 0 && relation.isManyToOne;\n    const hasJoinColumnWithoutAnyReferencedColumnName = joinColumns.length > 0 && !hasAnyReferencedColumnName;\n    if (manyToOneWithoutJoinColumn || hasJoinColumnWithoutAnyReferencedColumnName) {\n      // covers case3 and case1\n      return relation.inverseEntityMetadata.primaryColumns;\n    } else {\n      // cases with referenced columns defined\n      return joinColumns.map(joinColumn => {\n        const referencedColumn = relation.inverseEntityMetadata.ownColumns.find(column => column.propertyName === joinColumn.referencedColumnName); // todo: can we also search in relations?\n        if (!referencedColumn) throw new TypeORMError(`Referenced column ${joinColumn.referencedColumnName} was not found in entity ${relation.inverseEntityMetadata.name}`);\n        return referencedColumn;\n      });\n    }\n  }\n  /**\n   * Collects columns from the given join column args.\n   */\n  collectColumns(joinColumns, relation, referencedColumns) {\n    return referencedColumns.map(referencedColumn => {\n      // in the case if relation has join column with only name set we need this check\n      const joinColumnMetadataArg = joinColumns.find(joinColumn => {\n        return (!joinColumn.referencedColumnName || joinColumn.referencedColumnName === referencedColumn.propertyName) && !!joinColumn.name;\n      });\n      const joinColumnName = joinColumnMetadataArg ? joinColumnMetadataArg.name : this.connection.namingStrategy.joinColumnName(relation.propertyName, referencedColumn.propertyName);\n      const relationalColumns = relation.embeddedMetadata ? relation.embeddedMetadata.columns : relation.entityMetadata.ownColumns;\n      let relationalColumn = relationalColumns.find(column => column.databaseNameWithoutPrefixes === joinColumnName);\n      if (!relationalColumn) {\n        relationalColumn = new ColumnMetadata({\n          connection: this.connection,\n          entityMetadata: relation.entityMetadata,\n          embeddedMetadata: relation.embeddedMetadata,\n          args: {\n            target: \"\",\n            mode: \"virtual\",\n            propertyName: relation.propertyName,\n            options: {\n              name: joinColumnName,\n              type: referencedColumn.type,\n              length: !referencedColumn.length && (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === \"aurora-mysql\") &&\n              // some versions of mariadb support the column type and should not try to provide the length property\n              this.connection.driver.normalizeType(referencedColumn) !== \"uuid\" && (referencedColumn.generationStrategy === \"uuid\" || referencedColumn.type === \"uuid\") ? \"36\" : referencedColumn.length,\n              width: referencedColumn.width,\n              charset: referencedColumn.charset,\n              collation: referencedColumn.collation,\n              precision: referencedColumn.precision,\n              scale: referencedColumn.scale,\n              zerofill: referencedColumn.zerofill,\n              unsigned: referencedColumn.unsigned,\n              comment: referencedColumn.comment,\n              enum: referencedColumn.enum,\n              enumName: referencedColumn.enumName,\n              primary: relation.isPrimary,\n              nullable: relation.isNullable\n            }\n          }\n        });\n        relation.entityMetadata.registerColumn(relationalColumn);\n      }\n      relationalColumn.referencedColumn = referencedColumn; // its important to set it here because we need to set referenced column for user defined join column\n      relationalColumn.type = referencedColumn.type; // also since types of relational column and join column must be equal we override user defined column type\n      relationalColumn.relationMetadata = relation;\n      relationalColumn.build(this.connection);\n      return relationalColumn;\n    });\n  }\n}","map":{"version":3,"names":["ColumnMetadata","UniqueMetadata","ForeignKeyMetadata","TypeORMError","DriverUtils","RelationJoinColumnBuilder","constructor","connection","build","joinColumns","relation","_a","referencedColumns","collectReferencedColumns","columns","collectColumns","length","createForeignKeyConstraints","foreignKey","undefined","uniqueConstraint","name","foreignKeyConstraintName","entityMetadata","referencedEntityMetadata","inverseEntityMetadata","namingStrategy","onDelete","onUpdate","deferrable","every","column","isPrimary","isOneToOne","args","relationConstraintName","tableName","map","databaseName","target","hasAnyReferencedColumnName","find","joinColumnArgs","referencedColumnName","manyToOneWithoutJoinColumn","isManyToOne","hasJoinColumnWithoutAnyReferencedColumnName","primaryColumns","joinColumn","referencedColumn","ownColumns","propertyName","joinColumnMetadataArg","joinColumnName","relationalColumns","embeddedMetadata","relationalColumn","databaseNameWithoutPrefixes","mode","options","type","isMySQLFamily","driver","normalizeType","generationStrategy","width","charset","collation","precision","scale","zerofill","unsigned","comment","enum","enumName","primary","nullable","isNullable","registerColumn","relationMetadata"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/metadata-builder/RelationJoinColumnBuilder.js"],"sourcesContent":["import { ColumnMetadata } from \"../metadata/ColumnMetadata\";\nimport { UniqueMetadata } from \"../metadata/UniqueMetadata\";\nimport { ForeignKeyMetadata } from \"../metadata/ForeignKeyMetadata\";\nimport { TypeORMError } from \"../error\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\n/**\n * Builds join column for the many-to-one and one-to-one owner relations.\n *\n * Cases it should cover:\n * 1. when join column is set with custom name and without referenced column name\n * we need automatically set referenced column name - primary ids by default\n * @JoinColumn({ name: \"custom_name\" })\n *\n * 2. when join column is set with only referenced column name\n * we need automatically set join column name - relation name + referenced column name\n * @JoinColumn({ referencedColumnName: \"title\" })\n *\n * 3. when join column is set without both referenced column name and join column name\n * we need to automatically set both of them\n * @JoinColumn()\n *\n * 4. when join column is not set at all (as in case of @ManyToOne relation)\n * we need to create join column for it with proper referenced column name and join column name\n *\n * 5. when multiple join columns set none of referencedColumnName and name can be optional\n * both options are required\n * @JoinColumn([\n *      { name: \"category_title\", referencedColumnName: \"type\" },\n *      { name: \"category_title\", referencedColumnName: \"name\" },\n * ])\n *\n * Since for many-to-one relations having JoinColumn decorator is not required,\n * we need to go through each many-to-one relation without join column decorator set\n * and create join column metadata args for them.\n */\nexport class RelationJoinColumnBuilder {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n    constructor(connection) {\n        this.connection = connection;\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Builds a foreign key of the many-to-one or one-to-one owner relations.\n     */\n    build(joinColumns, relation) {\n        var _a;\n        const referencedColumns = this.collectReferencedColumns(joinColumns, relation);\n        const columns = this.collectColumns(joinColumns, relation, referencedColumns);\n        if (!referencedColumns.length || !relation.createForeignKeyConstraints)\n            return {\n                foreignKey: undefined,\n                columns,\n                uniqueConstraint: undefined,\n            }; // this case is possible for one-to-one non owning side and relations with createForeignKeyConstraints = false\n        const foreignKey = new ForeignKeyMetadata({\n            name: (_a = joinColumns[0]) === null || _a === void 0 ? void 0 : _a.foreignKeyConstraintName,\n            entityMetadata: relation.entityMetadata,\n            referencedEntityMetadata: relation.inverseEntityMetadata,\n            namingStrategy: this.connection.namingStrategy,\n            columns,\n            referencedColumns,\n            onDelete: relation.onDelete,\n            onUpdate: relation.onUpdate,\n            deferrable: relation.deferrable,\n        });\n        // SQL requires UNIQUE/PK constraints on columns referenced by a FK\n        // Skip creating the unique constraint for the referenced columns if\n        // they are already contained in the PK of the referenced entity\n        if (columns.every((column) => column.isPrimary) ||\n            !relation.isOneToOne) {\n            return { foreignKey, columns, uniqueConstraint: undefined };\n        }\n        const uniqueConstraint = new UniqueMetadata({\n            entityMetadata: relation.entityMetadata,\n            columns: foreignKey.columns,\n            args: {\n                name: this.connection.namingStrategy.relationConstraintName(relation.entityMetadata.tableName, foreignKey.columns.map((column) => column.databaseName)),\n                target: relation.entityMetadata.target,\n            },\n        });\n        uniqueConstraint.build(this.connection.namingStrategy);\n        return { foreignKey, columns, uniqueConstraint };\n    }\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Collects referenced columns from the given join column args.\n     */\n    collectReferencedColumns(joinColumns, relation) {\n        const hasAnyReferencedColumnName = joinColumns.find((joinColumnArgs) => !!joinColumnArgs.referencedColumnName);\n        const manyToOneWithoutJoinColumn = joinColumns.length === 0 && relation.isManyToOne;\n        const hasJoinColumnWithoutAnyReferencedColumnName = joinColumns.length > 0 && !hasAnyReferencedColumnName;\n        if (manyToOneWithoutJoinColumn ||\n            hasJoinColumnWithoutAnyReferencedColumnName) {\n            // covers case3 and case1\n            return relation.inverseEntityMetadata.primaryColumns;\n        }\n        else {\n            // cases with referenced columns defined\n            return joinColumns.map((joinColumn) => {\n                const referencedColumn = relation.inverseEntityMetadata.ownColumns.find((column) => column.propertyName ===\n                    joinColumn.referencedColumnName); // todo: can we also search in relations?\n                if (!referencedColumn)\n                    throw new TypeORMError(`Referenced column ${joinColumn.referencedColumnName} was not found in entity ${relation.inverseEntityMetadata.name}`);\n                return referencedColumn;\n            });\n        }\n    }\n    /**\n     * Collects columns from the given join column args.\n     */\n    collectColumns(joinColumns, relation, referencedColumns) {\n        return referencedColumns.map((referencedColumn) => {\n            // in the case if relation has join column with only name set we need this check\n            const joinColumnMetadataArg = joinColumns.find((joinColumn) => {\n                return ((!joinColumn.referencedColumnName ||\n                    joinColumn.referencedColumnName ===\n                        referencedColumn.propertyName) &&\n                    !!joinColumn.name);\n            });\n            const joinColumnName = joinColumnMetadataArg\n                ? joinColumnMetadataArg.name\n                : this.connection.namingStrategy.joinColumnName(relation.propertyName, referencedColumn.propertyName);\n            const relationalColumns = relation.embeddedMetadata\n                ? relation.embeddedMetadata.columns\n                : relation.entityMetadata.ownColumns;\n            let relationalColumn = relationalColumns.find((column) => column.databaseNameWithoutPrefixes === joinColumnName);\n            if (!relationalColumn) {\n                relationalColumn = new ColumnMetadata({\n                    connection: this.connection,\n                    entityMetadata: relation.entityMetadata,\n                    embeddedMetadata: relation.embeddedMetadata,\n                    args: {\n                        target: \"\",\n                        mode: \"virtual\",\n                        propertyName: relation.propertyName,\n                        options: {\n                            name: joinColumnName,\n                            type: referencedColumn.type,\n                            length: !referencedColumn.length &&\n                                (DriverUtils.isMySQLFamily(this.connection.driver) ||\n                                    this.connection.driver.options.type ===\n                                        \"aurora-mysql\") &&\n                                // some versions of mariadb support the column type and should not try to provide the length property\n                                this.connection.driver.normalizeType(referencedColumn) !== \"uuid\" &&\n                                (referencedColumn.generationStrategy ===\n                                    \"uuid\" ||\n                                    referencedColumn.type === \"uuid\")\n                                ? \"36\"\n                                : referencedColumn.length,\n                            width: referencedColumn.width,\n                            charset: referencedColumn.charset,\n                            collation: referencedColumn.collation,\n                            precision: referencedColumn.precision,\n                            scale: referencedColumn.scale,\n                            zerofill: referencedColumn.zerofill,\n                            unsigned: referencedColumn.unsigned,\n                            comment: referencedColumn.comment,\n                            enum: referencedColumn.enum,\n                            enumName: referencedColumn.enumName,\n                            primary: relation.isPrimary,\n                            nullable: relation.isNullable,\n                        },\n                    },\n                });\n                relation.entityMetadata.registerColumn(relationalColumn);\n            }\n            relationalColumn.referencedColumn = referencedColumn; // its important to set it here because we need to set referenced column for user defined join column\n            relationalColumn.type = referencedColumn.type; // also since types of relational column and join column must be equal we override user defined column type\n            relationalColumn.relationMetadata = relation;\n            relationalColumn.build(this.connection);\n            return relationalColumn;\n        });\n    }\n}\n\n"],"mappings":"AAAA,SAASA,cAAc,QAAQ,4BAA4B;AAC3D,SAASC,cAAc,QAAQ,4BAA4B;AAC3D,SAASC,kBAAkB,QAAQ,gCAAgC;AACnE,SAASC,YAAY,QAAQ,UAAU;AACvC,SAASC,WAAW,QAAQ,uBAAuB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,yBAAyB,CAAC;EACnC;EACA;EACA;EACAC,WAAWA,CAACC,UAAU,EAAE;IACpB,IAAI,CAACA,UAAU,GAAGA,UAAU;EAChC;EACA;EACA;EACA;EACA;AACJ;AACA;EACIC,KAAKA,CAACC,WAAW,EAAEC,QAAQ,EAAE;IACzB,IAAIC,EAAE;IACN,MAAMC,iBAAiB,GAAG,IAAI,CAACC,wBAAwB,CAACJ,WAAW,EAAEC,QAAQ,CAAC;IAC9E,MAAMI,OAAO,GAAG,IAAI,CAACC,cAAc,CAACN,WAAW,EAAEC,QAAQ,EAAEE,iBAAiB,CAAC;IAC7E,IAAI,CAACA,iBAAiB,CAACI,MAAM,IAAI,CAACN,QAAQ,CAACO,2BAA2B,EAClE,OAAO;MACHC,UAAU,EAAEC,SAAS;MACrBL,OAAO;MACPM,gBAAgB,EAAED;IACtB,CAAC,CAAC,CAAC;IACP,MAAMD,UAAU,GAAG,IAAIhB,kBAAkB,CAAC;MACtCmB,IAAI,EAAE,CAACV,EAAE,GAAGF,WAAW,CAAC,CAAC,CAAC,MAAM,IAAI,IAAIE,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACW,wBAAwB;MAC5FC,cAAc,EAAEb,QAAQ,CAACa,cAAc;MACvCC,wBAAwB,EAAEd,QAAQ,CAACe,qBAAqB;MACxDC,cAAc,EAAE,IAAI,CAACnB,UAAU,CAACmB,cAAc;MAC9CZ,OAAO;MACPF,iBAAiB;MACjBe,QAAQ,EAAEjB,QAAQ,CAACiB,QAAQ;MAC3BC,QAAQ,EAAElB,QAAQ,CAACkB,QAAQ;MAC3BC,UAAU,EAAEnB,QAAQ,CAACmB;IACzB,CAAC,CAAC;IACF;IACA;IACA;IACA,IAAIf,OAAO,CAACgB,KAAK,CAAEC,MAAM,IAAKA,MAAM,CAACC,SAAS,CAAC,IAC3C,CAACtB,QAAQ,CAACuB,UAAU,EAAE;MACtB,OAAO;QAAEf,UAAU;QAAEJ,OAAO;QAAEM,gBAAgB,EAAED;MAAU,CAAC;IAC/D;IACA,MAAMC,gBAAgB,GAAG,IAAInB,cAAc,CAAC;MACxCsB,cAAc,EAAEb,QAAQ,CAACa,cAAc;MACvCT,OAAO,EAAEI,UAAU,CAACJ,OAAO;MAC3BoB,IAAI,EAAE;QACFb,IAAI,EAAE,IAAI,CAACd,UAAU,CAACmB,cAAc,CAACS,sBAAsB,CAACzB,QAAQ,CAACa,cAAc,CAACa,SAAS,EAAElB,UAAU,CAACJ,OAAO,CAACuB,GAAG,CAAEN,MAAM,IAAKA,MAAM,CAACO,YAAY,CAAC,CAAC;QACvJC,MAAM,EAAE7B,QAAQ,CAACa,cAAc,CAACgB;MACpC;IACJ,CAAC,CAAC;IACFnB,gBAAgB,CAACZ,KAAK,CAAC,IAAI,CAACD,UAAU,CAACmB,cAAc,CAAC;IACtD,OAAO;MAAER,UAAU;MAAEJ,OAAO;MAAEM;IAAiB,CAAC;EACpD;EACA;EACA;EACA;EACA;AACJ;AACA;EACIP,wBAAwBA,CAACJ,WAAW,EAAEC,QAAQ,EAAE;IAC5C,MAAM8B,0BAA0B,GAAG/B,WAAW,CAACgC,IAAI,CAAEC,cAAc,IAAK,CAAC,CAACA,cAAc,CAACC,oBAAoB,CAAC;IAC9G,MAAMC,0BAA0B,GAAGnC,WAAW,CAACO,MAAM,KAAK,CAAC,IAAIN,QAAQ,CAACmC,WAAW;IACnF,MAAMC,2CAA2C,GAAGrC,WAAW,CAACO,MAAM,GAAG,CAAC,IAAI,CAACwB,0BAA0B;IACzG,IAAII,0BAA0B,IAC1BE,2CAA2C,EAAE;MAC7C;MACA,OAAOpC,QAAQ,CAACe,qBAAqB,CAACsB,cAAc;IACxD,CAAC,MACI;MACD;MACA,OAAOtC,WAAW,CAAC4B,GAAG,CAAEW,UAAU,IAAK;QACnC,MAAMC,gBAAgB,GAAGvC,QAAQ,CAACe,qBAAqB,CAACyB,UAAU,CAACT,IAAI,CAAEV,MAAM,IAAKA,MAAM,CAACoB,YAAY,KACnGH,UAAU,CAACL,oBAAoB,CAAC,CAAC,CAAC;QACtC,IAAI,CAACM,gBAAgB,EACjB,MAAM,IAAI9C,YAAY,CAAE,qBAAoB6C,UAAU,CAACL,oBAAqB,4BAA2BjC,QAAQ,CAACe,qBAAqB,CAACJ,IAAK,EAAC,CAAC;QACjJ,OAAO4B,gBAAgB;MAC3B,CAAC,CAAC;IACN;EACJ;EACA;AACJ;AACA;EACIlC,cAAcA,CAACN,WAAW,EAAEC,QAAQ,EAAEE,iBAAiB,EAAE;IACrD,OAAOA,iBAAiB,CAACyB,GAAG,CAAEY,gBAAgB,IAAK;MAC/C;MACA,MAAMG,qBAAqB,GAAG3C,WAAW,CAACgC,IAAI,CAAEO,UAAU,IAAK;QAC3D,OAAQ,CAAC,CAACA,UAAU,CAACL,oBAAoB,IACrCK,UAAU,CAACL,oBAAoB,KAC3BM,gBAAgB,CAACE,YAAY,KACjC,CAAC,CAACH,UAAU,CAAC3B,IAAI;MACzB,CAAC,CAAC;MACF,MAAMgC,cAAc,GAAGD,qBAAqB,GACtCA,qBAAqB,CAAC/B,IAAI,GAC1B,IAAI,CAACd,UAAU,CAACmB,cAAc,CAAC2B,cAAc,CAAC3C,QAAQ,CAACyC,YAAY,EAAEF,gBAAgB,CAACE,YAAY,CAAC;MACzG,MAAMG,iBAAiB,GAAG5C,QAAQ,CAAC6C,gBAAgB,GAC7C7C,QAAQ,CAAC6C,gBAAgB,CAACzC,OAAO,GACjCJ,QAAQ,CAACa,cAAc,CAAC2B,UAAU;MACxC,IAAIM,gBAAgB,GAAGF,iBAAiB,CAACb,IAAI,CAAEV,MAAM,IAAKA,MAAM,CAAC0B,2BAA2B,KAAKJ,cAAc,CAAC;MAChH,IAAI,CAACG,gBAAgB,EAAE;QACnBA,gBAAgB,GAAG,IAAIxD,cAAc,CAAC;UAClCO,UAAU,EAAE,IAAI,CAACA,UAAU;UAC3BgB,cAAc,EAAEb,QAAQ,CAACa,cAAc;UACvCgC,gBAAgB,EAAE7C,QAAQ,CAAC6C,gBAAgB;UAC3CrB,IAAI,EAAE;YACFK,MAAM,EAAE,EAAE;YACVmB,IAAI,EAAE,SAAS;YACfP,YAAY,EAAEzC,QAAQ,CAACyC,YAAY;YACnCQ,OAAO,EAAE;cACLtC,IAAI,EAAEgC,cAAc;cACpBO,IAAI,EAAEX,gBAAgB,CAACW,IAAI;cAC3B5C,MAAM,EAAE,CAACiC,gBAAgB,CAACjC,MAAM,KAC3BZ,WAAW,CAACyD,aAAa,CAAC,IAAI,CAACtD,UAAU,CAACuD,MAAM,CAAC,IAC9C,IAAI,CAACvD,UAAU,CAACuD,MAAM,CAACH,OAAO,CAACC,IAAI,KAC/B,cAAc,CAAC;cACvB;cACA,IAAI,CAACrD,UAAU,CAACuD,MAAM,CAACC,aAAa,CAACd,gBAAgB,CAAC,KAAK,MAAM,KAChEA,gBAAgB,CAACe,kBAAkB,KAChC,MAAM,IACNf,gBAAgB,CAACW,IAAI,KAAK,MAAM,CAAC,GACnC,IAAI,GACJX,gBAAgB,CAACjC,MAAM;cAC7BiD,KAAK,EAAEhB,gBAAgB,CAACgB,KAAK;cAC7BC,OAAO,EAAEjB,gBAAgB,CAACiB,OAAO;cACjCC,SAAS,EAAElB,gBAAgB,CAACkB,SAAS;cACrCC,SAAS,EAAEnB,gBAAgB,CAACmB,SAAS;cACrCC,KAAK,EAAEpB,gBAAgB,CAACoB,KAAK;cAC7BC,QAAQ,EAAErB,gBAAgB,CAACqB,QAAQ;cACnCC,QAAQ,EAAEtB,gBAAgB,CAACsB,QAAQ;cACnCC,OAAO,EAAEvB,gBAAgB,CAACuB,OAAO;cACjCC,IAAI,EAAExB,gBAAgB,CAACwB,IAAI;cAC3BC,QAAQ,EAAEzB,gBAAgB,CAACyB,QAAQ;cACnCC,OAAO,EAAEjE,QAAQ,CAACsB,SAAS;cAC3B4C,QAAQ,EAAElE,QAAQ,CAACmE;YACvB;UACJ;QACJ,CAAC,CAAC;QACFnE,QAAQ,CAACa,cAAc,CAACuD,cAAc,CAACtB,gBAAgB,CAAC;MAC5D;MACAA,gBAAgB,CAACP,gBAAgB,GAAGA,gBAAgB,CAAC,CAAC;MACtDO,gBAAgB,CAACI,IAAI,GAAGX,gBAAgB,CAACW,IAAI,CAAC,CAAC;MAC/CJ,gBAAgB,CAACuB,gBAAgB,GAAGrE,QAAQ;MAC5C8C,gBAAgB,CAAChD,KAAK,CAAC,IAAI,CAACD,UAAU,CAAC;MACvC,OAAOiD,gBAAgB;IAC3B,CAAC,CAAC;EACN;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}