{"ast":null,"code":"import { ColumnMetadata } from \"../metadata/ColumnMetadata\";\nimport { EntityMetadata } from \"../metadata/EntityMetadata\";\nimport { ForeignKeyMetadata } from \"../metadata/ForeignKeyMetadata\";\nimport { IndexMetadata } from \"../metadata/IndexMetadata\";\nimport { TypeORMError } from \"../error\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\n/**\n * Creates EntityMetadata for junction tables.\n * Junction tables are tables generated by many-to-many relations.\n */\nexport class JunctionEntityMetadataBuilder {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection) {\n    this.connection = connection;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Builds EntityMetadata for the junction of the given many-to-many relation.\n   */\n  build(relation, joinTable) {\n    var _a, _b;\n    const referencedColumns = this.collectReferencedColumns(relation, joinTable);\n    const inverseReferencedColumns = this.collectInverseReferencedColumns(relation, joinTable);\n    const joinTableName = joinTable.name || this.connection.namingStrategy.joinTableName(relation.entityMetadata.tableNameWithoutPrefix, relation.inverseEntityMetadata.tableNameWithoutPrefix, relation.propertyPath, relation.inverseRelation ? relation.inverseRelation.propertyName : \"\");\n    const entityMetadata = new EntityMetadata({\n      connection: this.connection,\n      args: {\n        target: \"\",\n        name: joinTableName,\n        type: \"junction\",\n        database: joinTable.database || relation.entityMetadata.database,\n        schema: joinTable.schema || relation.entityMetadata.schema,\n        synchronize: joinTable.synchronize\n      }\n    });\n    entityMetadata.build();\n    // create original side junction columns\n    const junctionColumns = referencedColumns.map(referencedColumn => {\n      const joinColumn = joinTable.joinColumns ? joinTable.joinColumns.find(joinColumnArgs => {\n        return (!joinColumnArgs.referencedColumnName || joinColumnArgs.referencedColumnName === referencedColumn.propertyName) && !!joinColumnArgs.name;\n      }) : undefined;\n      const columnName = joinColumn && joinColumn.name ? joinColumn.name : this.connection.namingStrategy.joinTableColumnName(relation.entityMetadata.tableNameWithoutPrefix, referencedColumn.propertyName, referencedColumn.databaseName);\n      return new ColumnMetadata({\n        connection: this.connection,\n        entityMetadata: entityMetadata,\n        referencedColumn: referencedColumn,\n        args: {\n          target: \"\",\n          mode: \"virtual\",\n          propertyName: columnName,\n          options: {\n            name: columnName,\n            length: !referencedColumn.length && (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === \"aurora-mysql\") &&\n            // some versions of mariadb support the column type and should not try to provide the length property\n            this.connection.driver.normalizeType(referencedColumn) !== \"uuid\" && (referencedColumn.generationStrategy === \"uuid\" || referencedColumn.type === \"uuid\") ? \"36\" : referencedColumn.length,\n            width: referencedColumn.width,\n            type: referencedColumn.type,\n            precision: referencedColumn.precision,\n            scale: referencedColumn.scale,\n            charset: referencedColumn.charset,\n            collation: referencedColumn.collation,\n            zerofill: referencedColumn.zerofill,\n            unsigned: referencedColumn.zerofill ? true : referencedColumn.unsigned,\n            enum: referencedColumn.enum,\n            enumName: referencedColumn.enumName,\n            foreignKeyConstraintName: joinColumn === null || joinColumn === void 0 ? void 0 : joinColumn.foreignKeyConstraintName,\n            nullable: false,\n            primary: true\n          }\n        }\n      });\n    });\n    // create inverse side junction columns\n    const inverseJunctionColumns = inverseReferencedColumns.map(inverseReferencedColumn => {\n      const joinColumn = joinTable.inverseJoinColumns ? joinTable.inverseJoinColumns.find(joinColumnArgs => {\n        return (!joinColumnArgs.referencedColumnName || joinColumnArgs.referencedColumnName === inverseReferencedColumn.propertyName) && !!joinColumnArgs.name;\n      }) : undefined;\n      const columnName = joinColumn && joinColumn.name ? joinColumn.name : this.connection.namingStrategy.joinTableInverseColumnName(relation.inverseEntityMetadata.tableNameWithoutPrefix, inverseReferencedColumn.propertyName, inverseReferencedColumn.databaseName);\n      return new ColumnMetadata({\n        connection: this.connection,\n        entityMetadata: entityMetadata,\n        referencedColumn: inverseReferencedColumn,\n        args: {\n          target: \"\",\n          mode: \"virtual\",\n          propertyName: columnName,\n          options: {\n            length: !inverseReferencedColumn.length && (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === \"aurora-mysql\") &&\n            // some versions of mariadb support the column type and should not try to provide the length property\n            this.connection.driver.normalizeType(inverseReferencedColumn) !== \"uuid\" && (inverseReferencedColumn.generationStrategy === \"uuid\" || inverseReferencedColumn.type === \"uuid\") ? \"36\" : inverseReferencedColumn.length,\n            width: inverseReferencedColumn.width,\n            type: inverseReferencedColumn.type,\n            precision: inverseReferencedColumn.precision,\n            scale: inverseReferencedColumn.scale,\n            charset: inverseReferencedColumn.charset,\n            collation: inverseReferencedColumn.collation,\n            zerofill: inverseReferencedColumn.zerofill,\n            unsigned: inverseReferencedColumn.zerofill ? true : inverseReferencedColumn.unsigned,\n            enum: inverseReferencedColumn.enum,\n            enumName: inverseReferencedColumn.enumName,\n            foreignKeyConstraintName: joinColumn === null || joinColumn === void 0 ? void 0 : joinColumn.foreignKeyConstraintName,\n            name: columnName,\n            nullable: false,\n            primary: true\n          }\n        }\n      });\n    });\n    this.changeDuplicatedColumnNames(junctionColumns, inverseJunctionColumns);\n    // set junction table columns\n    entityMetadata.ownerColumns = junctionColumns;\n    entityMetadata.inverseColumns = inverseJunctionColumns;\n    entityMetadata.ownColumns = [...junctionColumns, ...inverseJunctionColumns];\n    entityMetadata.ownColumns.forEach(column => column.relationMetadata = relation);\n    // create junction table foreign keys\n    // Note: UPDATE CASCADE clause is not supported in Oracle.\n    // Note: UPDATE/DELETE CASCADE clauses are not supported in Spanner.\n    entityMetadata.foreignKeys = relation.createForeignKeyConstraints ? [new ForeignKeyMetadata({\n      entityMetadata: entityMetadata,\n      referencedEntityMetadata: relation.entityMetadata,\n      columns: junctionColumns,\n      referencedColumns: referencedColumns,\n      name: (_a = junctionColumns[0]) === null || _a === void 0 ? void 0 : _a.foreignKeyConstraintName,\n      onDelete: this.connection.driver.options.type === \"spanner\" ? \"NO ACTION\" : relation.onDelete || \"CASCADE\",\n      onUpdate: this.connection.driver.options.type === \"oracle\" || this.connection.driver.options.type === \"spanner\" ? \"NO ACTION\" : relation.onUpdate || \"CASCADE\"\n    }), new ForeignKeyMetadata({\n      entityMetadata: entityMetadata,\n      referencedEntityMetadata: relation.inverseEntityMetadata,\n      columns: inverseJunctionColumns,\n      referencedColumns: inverseReferencedColumns,\n      name: (_b = inverseJunctionColumns[0]) === null || _b === void 0 ? void 0 : _b.foreignKeyConstraintName,\n      onDelete: this.connection.driver.options.type === \"spanner\" ? \"NO ACTION\" : relation.inverseRelation ? relation.inverseRelation.onDelete : \"CASCADE\",\n      onUpdate: this.connection.driver.options.type === \"oracle\" || this.connection.driver.options.type === \"spanner\" ? \"NO ACTION\" : relation.inverseRelation ? relation.inverseRelation.onUpdate : \"CASCADE\"\n    })] : [];\n    // create junction table indices\n    entityMetadata.ownIndices = [new IndexMetadata({\n      entityMetadata: entityMetadata,\n      columns: junctionColumns,\n      args: {\n        target: entityMetadata.target,\n        synchronize: true\n      }\n    }), new IndexMetadata({\n      entityMetadata: entityMetadata,\n      columns: inverseJunctionColumns,\n      args: {\n        target: entityMetadata.target,\n        synchronize: true\n      }\n    })];\n    // finally return entity metadata\n    return entityMetadata;\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Collects referenced columns from the given join column args.\n   */\n  collectReferencedColumns(relation, joinTable) {\n    const hasAnyReferencedColumnName = joinTable.joinColumns ? joinTable.joinColumns.find(joinColumn => !!joinColumn.referencedColumnName) : false;\n    if (!joinTable.joinColumns || joinTable.joinColumns && !hasAnyReferencedColumnName) {\n      return relation.entityMetadata.columns.filter(column => column.isPrimary);\n    } else {\n      return joinTable.joinColumns.map(joinColumn => {\n        const referencedColumn = relation.entityMetadata.columns.find(column => column.propertyName === joinColumn.referencedColumnName);\n        if (!referencedColumn) throw new TypeORMError(`Referenced column ${joinColumn.referencedColumnName} was not found in entity ${relation.entityMetadata.name}`);\n        return referencedColumn;\n      });\n    }\n  }\n  /**\n   * Collects inverse referenced columns from the given join column args.\n   */\n  collectInverseReferencedColumns(relation, joinTable) {\n    const hasInverseJoinColumns = !!joinTable.inverseJoinColumns;\n    const hasAnyInverseReferencedColumnName = hasInverseJoinColumns ? joinTable.inverseJoinColumns.find(joinColumn => !!joinColumn.referencedColumnName) : false;\n    if (!hasInverseJoinColumns || hasInverseJoinColumns && !hasAnyInverseReferencedColumnName) {\n      return relation.inverseEntityMetadata.primaryColumns;\n    } else {\n      return joinTable.inverseJoinColumns.map(joinColumn => {\n        const referencedColumn = relation.inverseEntityMetadata.ownColumns.find(column => column.propertyName === joinColumn.referencedColumnName);\n        if (!referencedColumn) throw new TypeORMError(`Referenced column ${joinColumn.referencedColumnName} was not found in entity ${relation.inverseEntityMetadata.name}`);\n        return referencedColumn;\n      });\n    }\n  }\n  changeDuplicatedColumnNames(junctionColumns, inverseJunctionColumns) {\n    junctionColumns.forEach(junctionColumn => {\n      inverseJunctionColumns.forEach(inverseJunctionColumn => {\n        if (junctionColumn.givenDatabaseName === inverseJunctionColumn.givenDatabaseName) {\n          const junctionColumnName = this.connection.namingStrategy.joinTableColumnDuplicationPrefix(junctionColumn.propertyName, 1);\n          junctionColumn.propertyName = junctionColumnName;\n          junctionColumn.givenDatabaseName = junctionColumnName;\n          const inverseJunctionColumnName = this.connection.namingStrategy.joinTableColumnDuplicationPrefix(inverseJunctionColumn.propertyName, 2);\n          inverseJunctionColumn.propertyName = inverseJunctionColumnName;\n          inverseJunctionColumn.givenDatabaseName = inverseJunctionColumnName;\n        }\n      });\n    });\n  }\n}","map":{"version":3,"names":["ColumnMetadata","EntityMetadata","ForeignKeyMetadata","IndexMetadata","TypeORMError","DriverUtils","JunctionEntityMetadataBuilder","constructor","connection","build","relation","joinTable","_a","_b","referencedColumns","collectReferencedColumns","inverseReferencedColumns","collectInverseReferencedColumns","joinTableName","name","namingStrategy","entityMetadata","tableNameWithoutPrefix","inverseEntityMetadata","propertyPath","inverseRelation","propertyName","args","target","type","database","schema","synchronize","junctionColumns","map","referencedColumn","joinColumn","joinColumns","find","joinColumnArgs","referencedColumnName","undefined","columnName","joinTableColumnName","databaseName","mode","options","length","isMySQLFamily","driver","normalizeType","generationStrategy","width","precision","scale","charset","collation","zerofill","unsigned","enum","enumName","foreignKeyConstraintName","nullable","primary","inverseJunctionColumns","inverseReferencedColumn","inverseJoinColumns","joinTableInverseColumnName","changeDuplicatedColumnNames","ownerColumns","inverseColumns","ownColumns","forEach","column","relationMetadata","foreignKeys","createForeignKeyConstraints","referencedEntityMetadata","columns","onDelete","onUpdate","ownIndices","hasAnyReferencedColumnName","filter","isPrimary","hasInverseJoinColumns","hasAnyInverseReferencedColumnName","primaryColumns","junctionColumn","inverseJunctionColumn","givenDatabaseName","junctionColumnName","joinTableColumnDuplicationPrefix","inverseJunctionColumnName"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/metadata-builder/JunctionEntityMetadataBuilder.js"],"sourcesContent":["import { ColumnMetadata } from \"../metadata/ColumnMetadata\";\nimport { EntityMetadata } from \"../metadata/EntityMetadata\";\nimport { ForeignKeyMetadata } from \"../metadata/ForeignKeyMetadata\";\nimport { IndexMetadata } from \"../metadata/IndexMetadata\";\nimport { TypeORMError } from \"../error\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\n/**\n * Creates EntityMetadata for junction tables.\n * Junction tables are tables generated by many-to-many relations.\n */\nexport class JunctionEntityMetadataBuilder {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n    constructor(connection) {\n        this.connection = connection;\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Builds EntityMetadata for the junction of the given many-to-many relation.\n     */\n    build(relation, joinTable) {\n        var _a, _b;\n        const referencedColumns = this.collectReferencedColumns(relation, joinTable);\n        const inverseReferencedColumns = this.collectInverseReferencedColumns(relation, joinTable);\n        const joinTableName = joinTable.name ||\n            this.connection.namingStrategy.joinTableName(relation.entityMetadata.tableNameWithoutPrefix, relation.inverseEntityMetadata.tableNameWithoutPrefix, relation.propertyPath, relation.inverseRelation\n                ? relation.inverseRelation.propertyName\n                : \"\");\n        const entityMetadata = new EntityMetadata({\n            connection: this.connection,\n            args: {\n                target: \"\",\n                name: joinTableName,\n                type: \"junction\",\n                database: joinTable.database || relation.entityMetadata.database,\n                schema: joinTable.schema || relation.entityMetadata.schema,\n                synchronize: joinTable.synchronize,\n            },\n        });\n        entityMetadata.build();\n        // create original side junction columns\n        const junctionColumns = referencedColumns.map((referencedColumn) => {\n            const joinColumn = joinTable.joinColumns\n                ? joinTable.joinColumns.find((joinColumnArgs) => {\n                    return ((!joinColumnArgs.referencedColumnName ||\n                        joinColumnArgs.referencedColumnName ===\n                            referencedColumn.propertyName) &&\n                        !!joinColumnArgs.name);\n                })\n                : undefined;\n            const columnName = joinColumn && joinColumn.name\n                ? joinColumn.name\n                : this.connection.namingStrategy.joinTableColumnName(relation.entityMetadata.tableNameWithoutPrefix, referencedColumn.propertyName, referencedColumn.databaseName);\n            return new ColumnMetadata({\n                connection: this.connection,\n                entityMetadata: entityMetadata,\n                referencedColumn: referencedColumn,\n                args: {\n                    target: \"\",\n                    mode: \"virtual\",\n                    propertyName: columnName,\n                    options: {\n                        name: columnName,\n                        length: !referencedColumn.length &&\n                            (DriverUtils.isMySQLFamily(this.connection.driver) ||\n                                this.connection.driver.options.type ===\n                                    \"aurora-mysql\") &&\n                            // some versions of mariadb support the column type and should not try to provide the length property\n                            this.connection.driver.normalizeType(referencedColumn) !== \"uuid\" &&\n                            (referencedColumn.generationStrategy === \"uuid\" ||\n                                referencedColumn.type === \"uuid\")\n                            ? \"36\"\n                            : referencedColumn.length,\n                        width: referencedColumn.width,\n                        type: referencedColumn.type,\n                        precision: referencedColumn.precision,\n                        scale: referencedColumn.scale,\n                        charset: referencedColumn.charset,\n                        collation: referencedColumn.collation,\n                        zerofill: referencedColumn.zerofill,\n                        unsigned: referencedColumn.zerofill\n                            ? true\n                            : referencedColumn.unsigned,\n                        enum: referencedColumn.enum,\n                        enumName: referencedColumn.enumName,\n                        foreignKeyConstraintName: joinColumn === null || joinColumn === void 0 ? void 0 : joinColumn.foreignKeyConstraintName,\n                        nullable: false,\n                        primary: true,\n                    },\n                },\n            });\n        });\n        // create inverse side junction columns\n        const inverseJunctionColumns = inverseReferencedColumns.map((inverseReferencedColumn) => {\n            const joinColumn = joinTable.inverseJoinColumns\n                ? joinTable.inverseJoinColumns.find((joinColumnArgs) => {\n                    return ((!joinColumnArgs.referencedColumnName ||\n                        joinColumnArgs.referencedColumnName ===\n                            inverseReferencedColumn.propertyName) &&\n                        !!joinColumnArgs.name);\n                })\n                : undefined;\n            const columnName = joinColumn && joinColumn.name\n                ? joinColumn.name\n                : this.connection.namingStrategy.joinTableInverseColumnName(relation.inverseEntityMetadata\n                    .tableNameWithoutPrefix, inverseReferencedColumn.propertyName, inverseReferencedColumn.databaseName);\n            return new ColumnMetadata({\n                connection: this.connection,\n                entityMetadata: entityMetadata,\n                referencedColumn: inverseReferencedColumn,\n                args: {\n                    target: \"\",\n                    mode: \"virtual\",\n                    propertyName: columnName,\n                    options: {\n                        length: !inverseReferencedColumn.length &&\n                            (DriverUtils.isMySQLFamily(this.connection.driver) ||\n                                this.connection.driver.options.type ===\n                                    \"aurora-mysql\") &&\n                            // some versions of mariadb support the column type and should not try to provide the length property\n                            this.connection.driver.normalizeType(inverseReferencedColumn) !== \"uuid\" &&\n                            (inverseReferencedColumn.generationStrategy ===\n                                \"uuid\" ||\n                                inverseReferencedColumn.type === \"uuid\")\n                            ? \"36\"\n                            : inverseReferencedColumn.length,\n                        width: inverseReferencedColumn.width,\n                        type: inverseReferencedColumn.type,\n                        precision: inverseReferencedColumn.precision,\n                        scale: inverseReferencedColumn.scale,\n                        charset: inverseReferencedColumn.charset,\n                        collation: inverseReferencedColumn.collation,\n                        zerofill: inverseReferencedColumn.zerofill,\n                        unsigned: inverseReferencedColumn.zerofill\n                            ? true\n                            : inverseReferencedColumn.unsigned,\n                        enum: inverseReferencedColumn.enum,\n                        enumName: inverseReferencedColumn.enumName,\n                        foreignKeyConstraintName: joinColumn === null || joinColumn === void 0 ? void 0 : joinColumn.foreignKeyConstraintName,\n                        name: columnName,\n                        nullable: false,\n                        primary: true,\n                    },\n                },\n            });\n        });\n        this.changeDuplicatedColumnNames(junctionColumns, inverseJunctionColumns);\n        // set junction table columns\n        entityMetadata.ownerColumns = junctionColumns;\n        entityMetadata.inverseColumns = inverseJunctionColumns;\n        entityMetadata.ownColumns = [\n            ...junctionColumns,\n            ...inverseJunctionColumns,\n        ];\n        entityMetadata.ownColumns.forEach((column) => (column.relationMetadata = relation));\n        // create junction table foreign keys\n        // Note: UPDATE CASCADE clause is not supported in Oracle.\n        // Note: UPDATE/DELETE CASCADE clauses are not supported in Spanner.\n        entityMetadata.foreignKeys = relation.createForeignKeyConstraints\n            ? [\n                new ForeignKeyMetadata({\n                    entityMetadata: entityMetadata,\n                    referencedEntityMetadata: relation.entityMetadata,\n                    columns: junctionColumns,\n                    referencedColumns: referencedColumns,\n                    name: (_a = junctionColumns[0]) === null || _a === void 0 ? void 0 : _a.foreignKeyConstraintName,\n                    onDelete: this.connection.driver.options.type === \"spanner\"\n                        ? \"NO ACTION\"\n                        : relation.onDelete || \"CASCADE\",\n                    onUpdate: this.connection.driver.options.type === \"oracle\" ||\n                        this.connection.driver.options.type === \"spanner\"\n                        ? \"NO ACTION\"\n                        : relation.onUpdate || \"CASCADE\",\n                }),\n                new ForeignKeyMetadata({\n                    entityMetadata: entityMetadata,\n                    referencedEntityMetadata: relation.inverseEntityMetadata,\n                    columns: inverseJunctionColumns,\n                    referencedColumns: inverseReferencedColumns,\n                    name: (_b = inverseJunctionColumns[0]) === null || _b === void 0 ? void 0 : _b.foreignKeyConstraintName,\n                    onDelete: this.connection.driver.options.type === \"spanner\"\n                        ? \"NO ACTION\"\n                        : relation.inverseRelation\n                            ? relation.inverseRelation.onDelete\n                            : \"CASCADE\",\n                    onUpdate: this.connection.driver.options.type === \"oracle\" ||\n                        this.connection.driver.options.type === \"spanner\"\n                        ? \"NO ACTION\"\n                        : relation.inverseRelation\n                            ? relation.inverseRelation.onUpdate\n                            : \"CASCADE\",\n                }),\n            ]\n            : [];\n        // create junction table indices\n        entityMetadata.ownIndices = [\n            new IndexMetadata({\n                entityMetadata: entityMetadata,\n                columns: junctionColumns,\n                args: {\n                    target: entityMetadata.target,\n                    synchronize: true,\n                },\n            }),\n            new IndexMetadata({\n                entityMetadata: entityMetadata,\n                columns: inverseJunctionColumns,\n                args: {\n                    target: entityMetadata.target,\n                    synchronize: true,\n                },\n            }),\n        ];\n        // finally return entity metadata\n        return entityMetadata;\n    }\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Collects referenced columns from the given join column args.\n     */\n    collectReferencedColumns(relation, joinTable) {\n        const hasAnyReferencedColumnName = joinTable.joinColumns\n            ? joinTable.joinColumns.find((joinColumn) => !!joinColumn.referencedColumnName)\n            : false;\n        if (!joinTable.joinColumns ||\n            (joinTable.joinColumns && !hasAnyReferencedColumnName)) {\n            return relation.entityMetadata.columns.filter((column) => column.isPrimary);\n        }\n        else {\n            return joinTable.joinColumns.map((joinColumn) => {\n                const referencedColumn = relation.entityMetadata.columns.find((column) => column.propertyName === joinColumn.referencedColumnName);\n                if (!referencedColumn)\n                    throw new TypeORMError(`Referenced column ${joinColumn.referencedColumnName} was not found in entity ${relation.entityMetadata.name}`);\n                return referencedColumn;\n            });\n        }\n    }\n    /**\n     * Collects inverse referenced columns from the given join column args.\n     */\n    collectInverseReferencedColumns(relation, joinTable) {\n        const hasInverseJoinColumns = !!joinTable.inverseJoinColumns;\n        const hasAnyInverseReferencedColumnName = hasInverseJoinColumns\n            ? joinTable.inverseJoinColumns.find((joinColumn) => !!joinColumn.referencedColumnName)\n            : false;\n        if (!hasInverseJoinColumns ||\n            (hasInverseJoinColumns && !hasAnyInverseReferencedColumnName)) {\n            return relation.inverseEntityMetadata.primaryColumns;\n        }\n        else {\n            return joinTable.inverseJoinColumns.map((joinColumn) => {\n                const referencedColumn = relation.inverseEntityMetadata.ownColumns.find((column) => column.propertyName ===\n                    joinColumn.referencedColumnName);\n                if (!referencedColumn)\n                    throw new TypeORMError(`Referenced column ${joinColumn.referencedColumnName} was not found in entity ${relation.inverseEntityMetadata.name}`);\n                return referencedColumn;\n            });\n        }\n    }\n    changeDuplicatedColumnNames(junctionColumns, inverseJunctionColumns) {\n        junctionColumns.forEach((junctionColumn) => {\n            inverseJunctionColumns.forEach((inverseJunctionColumn) => {\n                if (junctionColumn.givenDatabaseName ===\n                    inverseJunctionColumn.givenDatabaseName) {\n                    const junctionColumnName = this.connection.namingStrategy.joinTableColumnDuplicationPrefix(junctionColumn.propertyName, 1);\n                    junctionColumn.propertyName = junctionColumnName;\n                    junctionColumn.givenDatabaseName = junctionColumnName;\n                    const inverseJunctionColumnName = this.connection.namingStrategy.joinTableColumnDuplicationPrefix(inverseJunctionColumn.propertyName, 2);\n                    inverseJunctionColumn.propertyName =\n                        inverseJunctionColumnName;\n                    inverseJunctionColumn.givenDatabaseName =\n                        inverseJunctionColumnName;\n                }\n            });\n        });\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}