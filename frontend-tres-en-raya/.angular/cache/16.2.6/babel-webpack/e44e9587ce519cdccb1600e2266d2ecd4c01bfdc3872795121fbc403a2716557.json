{"ast":null,"code":"import { QueryBuilderUtils } from \"./QueryBuilderUtils\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\nimport { TypeORMError } from \"../error\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\n/**\n * Stores all join attributes which will be used to build a JOIN query.\n */\nexport class JoinAttribute {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection, queryExpressionMap, joinAttribute) {\n    this.connection = connection;\n    this.queryExpressionMap = queryExpressionMap;\n    this.isSelectedEvaluated = false;\n    this.relationEvaluated = false;\n    if (joinAttribute) {\n      ObjectUtils.assign(this, joinAttribute);\n    }\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  get isMany() {\n    if (this.isMappingMany !== undefined) return this.isMappingMany;\n    if (this.relation) return this.relation.isManyToMany || this.relation.isOneToMany;\n    return false;\n  }\n  /**\n   * Indicates if this join is selected.\n   */\n  get isSelected() {\n    if (!this.isSelectedEvaluated) {\n      let getValue = () => {\n        for (const select of this.queryExpressionMap.selects) {\n          if (select.selection === this.alias.name) return true;\n          if (this.metadata && !!this.metadata.columns.find(column => select.selection === this.alias.name + \".\" + column.propertyPath)) return true;\n        }\n        return false;\n      };\n      this.isSelectedCache = getValue();\n      this.isSelectedEvaluated = true;\n    }\n    return this.isSelectedCache;\n  }\n  /**\n   * Name of the table which we should join.\n   */\n  get tablePath() {\n    return this.metadata ? this.metadata.tablePath : this.entityOrProperty;\n  }\n  /**\n   * Alias of the parent of this join.\n   * For example, if we join (\"post.category\", \"categoryAlias\") then \"post\" is a parent alias.\n   * This value is extracted from entityOrProperty value.\n   * This is available when join was made using \"post.category\" syntax.\n   */\n  get parentAlias() {\n    if (!QueryBuilderUtils.isAliasProperty(this.entityOrProperty)) return undefined;\n    return this.entityOrProperty.substr(0, this.entityOrProperty.indexOf(\".\"));\n  }\n  /**\n   * Relation property name of the parent.\n   * This is used to understand what is joined.\n   * For example, if we join (\"post.category\", \"categoryAlias\") then \"category\" is a relation property.\n   * This value is extracted from entityOrProperty value.\n   * This is available when join was made using \"post.category\" syntax.\n   */\n  get relationPropertyPath() {\n    if (!QueryBuilderUtils.isAliasProperty(this.entityOrProperty)) return undefined;\n    return this.entityOrProperty.substr(this.entityOrProperty.indexOf(\".\") + 1);\n  }\n  /**\n   * Relation of the parent.\n   * This is used to understand what is joined.\n   * This is available when join was made using \"post.category\" syntax.\n   * Relation can be undefined if entityOrProperty is regular entity or custom table.\n   */\n  get relation() {\n    if (!this.relationEvaluated) {\n      let getValue = () => {\n        if (!QueryBuilderUtils.isAliasProperty(this.entityOrProperty)) return undefined;\n        const relationOwnerSelection = this.queryExpressionMap.findAliasByName(this.parentAlias);\n        let relation = relationOwnerSelection.metadata.findRelationWithPropertyPath(this.relationPropertyPath);\n        if (relation) {\n          return relation;\n        }\n        if (relationOwnerSelection.metadata.parentEntityMetadata) {\n          relation = relationOwnerSelection.metadata.parentEntityMetadata.findRelationWithPropertyPath(this.relationPropertyPath);\n          if (relation) {\n            return relation;\n          }\n        }\n        throw new TypeORMError(`Relation with property path ${this.relationPropertyPath} in entity was not found.`);\n      };\n      this.relationCache = getValue.bind(this)();\n      this.relationEvaluated = true;\n    }\n    return this.relationCache;\n  }\n  /**\n   * Metadata of the joined entity.\n   * If table without entity was joined, then it will return undefined.\n   */\n  get metadata() {\n    // entityOrProperty is relation, e.g. \"post.category\"\n    if (this.relation) return this.relation.inverseEntityMetadata;\n    // entityOrProperty is Entity class\n    if (this.connection.hasMetadata(this.entityOrProperty)) return this.connection.getMetadata(this.entityOrProperty);\n    // Overriden mapping entity provided for leftJoinAndMapOne with custom query builder\n    if (this.mapAsEntity && this.connection.hasMetadata(this.mapAsEntity)) {\n      return this.connection.getMetadata(this.mapAsEntity);\n    }\n    return undefined;\n    /*if (typeof this.entityOrProperty === \"string\") { // entityOrProperty is a custom table\n         // first try to find entity with such name, this is needed when entity does not have a target class,\n        // and its target is a string name (scenario when plain old javascript is used or entity schema is loaded from files)\n        const metadata = this.connection.entityMetadatas.find(metadata => metadata.name === this.entityOrProperty);\n        if (metadata)\n            return metadata;\n         // check if we have entity with such table name, and use its metadata if found\n        return this.connection.entityMetadatas.find(metadata => metadata.tableName === this.entityOrProperty);\n    }*/\n  }\n  /**\n   * Generates alias of junction table, whose ids we get.\n   */\n  get junctionAlias() {\n    if (!this.relation) {\n      throw new TypeORMError(`Cannot get junction table for join without relation.`);\n    }\n    if (typeof this.entityOrProperty !== \"string\") {\n      throw new TypeORMError(`Junction property is not defined.`);\n    }\n    const aliasProperty = this.entityOrProperty.substr(0, this.entityOrProperty.indexOf(\".\"));\n    if (this.relation.isOwning) {\n      return DriverUtils.buildAlias(this.connection.driver, undefined, aliasProperty, this.alias.name);\n    } else {\n      return DriverUtils.buildAlias(this.connection.driver, undefined, this.alias.name, aliasProperty);\n    }\n  }\n  get mapToPropertyParentAlias() {\n    if (!this.mapToProperty) return undefined;\n    return this.mapToProperty.split(\".\")[0];\n  }\n  get mapToPropertyPropertyName() {\n    if (!this.mapToProperty) return undefined;\n    return this.mapToProperty.split(\".\")[1];\n  }\n}","map":{"version":3,"names":["QueryBuilderUtils","ObjectUtils","TypeORMError","DriverUtils","JoinAttribute","constructor","connection","queryExpressionMap","joinAttribute","isSelectedEvaluated","relationEvaluated","assign","isMany","isMappingMany","undefined","relation","isManyToMany","isOneToMany","isSelected","getValue","select","selects","selection","alias","name","metadata","columns","find","column","propertyPath","isSelectedCache","tablePath","entityOrProperty","parentAlias","isAliasProperty","substr","indexOf","relationPropertyPath","relationOwnerSelection","findAliasByName","findRelationWithPropertyPath","parentEntityMetadata","relationCache","bind","inverseEntityMetadata","hasMetadata","getMetadata","mapAsEntity","junctionAlias","aliasProperty","isOwning","buildAlias","driver","mapToPropertyParentAlias","mapToProperty","split","mapToPropertyPropertyName"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/query-builder/JoinAttribute.js"],"sourcesContent":["import { QueryBuilderUtils } from \"./QueryBuilderUtils\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\nimport { TypeORMError } from \"../error\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\n/**\n * Stores all join attributes which will be used to build a JOIN query.\n */\nexport class JoinAttribute {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n    constructor(connection, queryExpressionMap, joinAttribute) {\n        this.connection = connection;\n        this.queryExpressionMap = queryExpressionMap;\n        this.isSelectedEvaluated = false;\n        this.relationEvaluated = false;\n        if (joinAttribute) {\n            ObjectUtils.assign(this, joinAttribute);\n        }\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    get isMany() {\n        if (this.isMappingMany !== undefined)\n            return this.isMappingMany;\n        if (this.relation)\n            return this.relation.isManyToMany || this.relation.isOneToMany;\n        return false;\n    }\n    /**\n     * Indicates if this join is selected.\n     */\n    get isSelected() {\n        if (!this.isSelectedEvaluated) {\n            let getValue = () => {\n                for (const select of this.queryExpressionMap.selects) {\n                    if (select.selection === this.alias.name)\n                        return true;\n                    if (this.metadata &&\n                        !!this.metadata.columns.find((column) => select.selection ===\n                            this.alias.name + \".\" + column.propertyPath))\n                        return true;\n                }\n                return false;\n            };\n            this.isSelectedCache = getValue();\n            this.isSelectedEvaluated = true;\n        }\n        return this.isSelectedCache;\n    }\n    /**\n     * Name of the table which we should join.\n     */\n    get tablePath() {\n        return this.metadata\n            ? this.metadata.tablePath\n            : this.entityOrProperty;\n    }\n    /**\n     * Alias of the parent of this join.\n     * For example, if we join (\"post.category\", \"categoryAlias\") then \"post\" is a parent alias.\n     * This value is extracted from entityOrProperty value.\n     * This is available when join was made using \"post.category\" syntax.\n     */\n    get parentAlias() {\n        if (!QueryBuilderUtils.isAliasProperty(this.entityOrProperty))\n            return undefined;\n        return this.entityOrProperty.substr(0, this.entityOrProperty.indexOf(\".\"));\n    }\n    /**\n     * Relation property name of the parent.\n     * This is used to understand what is joined.\n     * For example, if we join (\"post.category\", \"categoryAlias\") then \"category\" is a relation property.\n     * This value is extracted from entityOrProperty value.\n     * This is available when join was made using \"post.category\" syntax.\n     */\n    get relationPropertyPath() {\n        if (!QueryBuilderUtils.isAliasProperty(this.entityOrProperty))\n            return undefined;\n        return this.entityOrProperty.substr(this.entityOrProperty.indexOf(\".\") + 1);\n    }\n    /**\n     * Relation of the parent.\n     * This is used to understand what is joined.\n     * This is available when join was made using \"post.category\" syntax.\n     * Relation can be undefined if entityOrProperty is regular entity or custom table.\n     */\n    get relation() {\n        if (!this.relationEvaluated) {\n            let getValue = () => {\n                if (!QueryBuilderUtils.isAliasProperty(this.entityOrProperty))\n                    return undefined;\n                const relationOwnerSelection = this.queryExpressionMap.findAliasByName(this.parentAlias);\n                let relation = relationOwnerSelection.metadata.findRelationWithPropertyPath(this.relationPropertyPath);\n                if (relation) {\n                    return relation;\n                }\n                if (relationOwnerSelection.metadata.parentEntityMetadata) {\n                    relation =\n                        relationOwnerSelection.metadata.parentEntityMetadata.findRelationWithPropertyPath(this.relationPropertyPath);\n                    if (relation) {\n                        return relation;\n                    }\n                }\n                throw new TypeORMError(`Relation with property path ${this.relationPropertyPath} in entity was not found.`);\n            };\n            this.relationCache = getValue.bind(this)();\n            this.relationEvaluated = true;\n        }\n        return this.relationCache;\n    }\n    /**\n     * Metadata of the joined entity.\n     * If table without entity was joined, then it will return undefined.\n     */\n    get metadata() {\n        // entityOrProperty is relation, e.g. \"post.category\"\n        if (this.relation)\n            return this.relation.inverseEntityMetadata;\n        // entityOrProperty is Entity class\n        if (this.connection.hasMetadata(this.entityOrProperty))\n            return this.connection.getMetadata(this.entityOrProperty);\n        // Overriden mapping entity provided for leftJoinAndMapOne with custom query builder\n        if (this.mapAsEntity && this.connection.hasMetadata(this.mapAsEntity)) {\n            return this.connection.getMetadata(this.mapAsEntity);\n        }\n        return undefined;\n        /*if (typeof this.entityOrProperty === \"string\") { // entityOrProperty is a custom table\n\n            // first try to find entity with such name, this is needed when entity does not have a target class,\n            // and its target is a string name (scenario when plain old javascript is used or entity schema is loaded from files)\n            const metadata = this.connection.entityMetadatas.find(metadata => metadata.name === this.entityOrProperty);\n            if (metadata)\n                return metadata;\n\n            // check if we have entity with such table name, and use its metadata if found\n            return this.connection.entityMetadatas.find(metadata => metadata.tableName === this.entityOrProperty);\n        }*/\n    }\n    /**\n     * Generates alias of junction table, whose ids we get.\n     */\n    get junctionAlias() {\n        if (!this.relation) {\n            throw new TypeORMError(`Cannot get junction table for join without relation.`);\n        }\n        if (typeof this.entityOrProperty !== \"string\") {\n            throw new TypeORMError(`Junction property is not defined.`);\n        }\n        const aliasProperty = this.entityOrProperty.substr(0, this.entityOrProperty.indexOf(\".\"));\n        if (this.relation.isOwning) {\n            return DriverUtils.buildAlias(this.connection.driver, undefined, aliasProperty, this.alias.name);\n        }\n        else {\n            return DriverUtils.buildAlias(this.connection.driver, undefined, this.alias.name, aliasProperty);\n        }\n    }\n    get mapToPropertyParentAlias() {\n        if (!this.mapToProperty)\n            return undefined;\n        return this.mapToProperty.split(\".\")[0];\n    }\n    get mapToPropertyPropertyName() {\n        if (!this.mapToProperty)\n            return undefined;\n        return this.mapToProperty.split(\".\")[1];\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}