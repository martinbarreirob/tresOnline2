{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/practicas/Downloads/angular/tresOnline/frontend-tres-en-raya/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\n/**\n * Allows to work with entity relations and perform specific operations with those relations.\n *\n * todo: add transactions everywhere\n */\nexport class RelationRemover {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(queryBuilder, expressionMap) {\n    this.queryBuilder = queryBuilder;\n    this.expressionMap = expressionMap;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Performs remove operation on a relation.\n   */\n  remove(value) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const relation = _this.expressionMap.relationMetadata;\n      if (relation.isOneToMany) {\n        // if (this.expressionMap.of instanceof Array)\n        //     throw new TypeORMError(`You cannot update relations of multiple entities with the same related object. Provide a single entity into .of method.`);\n        // DELETE FROM post WHERE post.categoryId = of AND post.id = id\n        const ofs = Array.isArray(_this.expressionMap.of) ? _this.expressionMap.of : [_this.expressionMap.of];\n        const values = Array.isArray(value) ? value : [value];\n        const updateSet = {};\n        relation.inverseRelation.joinColumns.forEach(column => {\n          updateSet[column.propertyName] = null;\n        });\n        const parameters = {};\n        const conditions = [];\n        ofs.forEach((of, ofIndex) => {\n          conditions.push(...values.map((value, valueIndex) => {\n            return [...relation.inverseRelation.joinColumns.map((column, columnIndex) => {\n              const parameterName = \"joinColumn_\" + ofIndex + \"_\" + valueIndex + \"_\" + columnIndex;\n              parameters[parameterName] = ObjectUtils.isObject(of) ? column.referencedColumn.getEntityValue(of) : of;\n              return `${column.propertyPath} = :${parameterName}`;\n            }), ...relation.inverseRelation.entityMetadata.primaryColumns.map((column, columnIndex) => {\n              const parameterName = \"primaryColumn_\" + valueIndex + \"_\" + valueIndex + \"_\" + columnIndex;\n              parameters[parameterName] = ObjectUtils.isObject(value) ? column.getEntityValue(value) : value;\n              return `${column.propertyPath} = :${parameterName}`;\n            })].join(\" AND \");\n          }));\n        });\n        const condition = conditions.map(str => \"(\" + str + \")\").join(\" OR \");\n        if (!condition) return;\n        yield _this.queryBuilder.createQueryBuilder().update(relation.inverseEntityMetadata.target).set(updateSet).where(condition).setParameters(parameters).execute();\n      } else {\n        // many to many\n        const junctionMetadata = relation.junctionEntityMetadata;\n        const ofs = Array.isArray(_this.expressionMap.of) ? _this.expressionMap.of : [_this.expressionMap.of];\n        const values = Array.isArray(value) ? value : [value];\n        const firstColumnValues = relation.isManyToManyOwner ? ofs : values;\n        const secondColumnValues = relation.isManyToManyOwner ? values : ofs;\n        const parameters = {};\n        const conditions = [];\n        firstColumnValues.forEach((firstColumnVal, firstColumnValIndex) => {\n          conditions.push(...secondColumnValues.map((secondColumnVal, secondColumnValIndex) => {\n            return [...junctionMetadata.ownerColumns.map((column, columnIndex) => {\n              const parameterName = \"firstValue_\" + firstColumnValIndex + \"_\" + secondColumnValIndex + \"_\" + columnIndex;\n              parameters[parameterName] = ObjectUtils.isObject(firstColumnVal) ? column.referencedColumn.getEntityValue(firstColumnVal) : firstColumnVal;\n              return `${column.databaseName} = :${parameterName}`;\n            }), ...junctionMetadata.inverseColumns.map((column, columnIndex) => {\n              const parameterName = \"secondValue_\" + firstColumnValIndex + \"_\" + secondColumnValIndex + \"_\" + columnIndex;\n              parameters[parameterName] = ObjectUtils.isObject(secondColumnVal) ? column.referencedColumn.getEntityValue(secondColumnVal) : secondColumnVal;\n              return `${column.databaseName} = :${parameterName}`;\n            })].join(\" AND \");\n          }));\n        });\n        const condition = conditions.map(str => \"(\" + str + \")\").join(\" OR \");\n        yield _this.queryBuilder.createQueryBuilder().delete().from(junctionMetadata.tableName).where(condition).setParameters(parameters).execute();\n      }\n    })();\n  }\n}","map":{"version":3,"names":["ObjectUtils","RelationRemover","constructor","queryBuilder","expressionMap","remove","value","_this","_asyncToGenerator","relation","relationMetadata","isOneToMany","ofs","Array","isArray","of","values","updateSet","inverseRelation","joinColumns","forEach","column","propertyName","parameters","conditions","ofIndex","push","map","valueIndex","columnIndex","parameterName","isObject","referencedColumn","getEntityValue","propertyPath","entityMetadata","primaryColumns","join","condition","str","createQueryBuilder","update","inverseEntityMetadata","target","set","where","setParameters","execute","junctionMetadata","junctionEntityMetadata","firstColumnValues","isManyToManyOwner","secondColumnValues","firstColumnVal","firstColumnValIndex","secondColumnVal","secondColumnValIndex","ownerColumns","databaseName","inverseColumns","delete","from","tableName"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/query-builder/RelationRemover.js"],"sourcesContent":["import { ObjectUtils } from \"../util/ObjectUtils\";\n/**\n * Allows to work with entity relations and perform specific operations with those relations.\n *\n * todo: add transactions everywhere\n */\nexport class RelationRemover {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n    constructor(queryBuilder, expressionMap) {\n        this.queryBuilder = queryBuilder;\n        this.expressionMap = expressionMap;\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Performs remove operation on a relation.\n     */\n    async remove(value) {\n        const relation = this.expressionMap.relationMetadata;\n        if (relation.isOneToMany) {\n            // if (this.expressionMap.of instanceof Array)\n            //     throw new TypeORMError(`You cannot update relations of multiple entities with the same related object. Provide a single entity into .of method.`);\n            // DELETE FROM post WHERE post.categoryId = of AND post.id = id\n            const ofs = Array.isArray(this.expressionMap.of)\n                ? this.expressionMap.of\n                : [this.expressionMap.of];\n            const values = Array.isArray(value) ? value : [value];\n            const updateSet = {};\n            relation.inverseRelation.joinColumns.forEach((column) => {\n                updateSet[column.propertyName] = null;\n            });\n            const parameters = {};\n            const conditions = [];\n            ofs.forEach((of, ofIndex) => {\n                conditions.push(...values.map((value, valueIndex) => {\n                    return [\n                        ...relation.inverseRelation.joinColumns.map((column, columnIndex) => {\n                            const parameterName = \"joinColumn_\" +\n                                ofIndex +\n                                \"_\" +\n                                valueIndex +\n                                \"_\" +\n                                columnIndex;\n                            parameters[parameterName] =\n                                ObjectUtils.isObject(of)\n                                    ? column.referencedColumn.getEntityValue(of)\n                                    : of;\n                            return `${column.propertyPath} = :${parameterName}`;\n                        }),\n                        ...relation.inverseRelation.entityMetadata.primaryColumns.map((column, columnIndex) => {\n                            const parameterName = \"primaryColumn_\" +\n                                valueIndex +\n                                \"_\" +\n                                valueIndex +\n                                \"_\" +\n                                columnIndex;\n                            parameters[parameterName] =\n                                ObjectUtils.isObject(value)\n                                    ? column.getEntityValue(value)\n                                    : value;\n                            return `${column.propertyPath} = :${parameterName}`;\n                        }),\n                    ].join(\" AND \");\n                }));\n            });\n            const condition = conditions\n                .map((str) => \"(\" + str + \")\")\n                .join(\" OR \");\n            if (!condition)\n                return;\n            await this.queryBuilder\n                .createQueryBuilder()\n                .update(relation.inverseEntityMetadata.target)\n                .set(updateSet)\n                .where(condition)\n                .setParameters(parameters)\n                .execute();\n        }\n        else {\n            // many to many\n            const junctionMetadata = relation.junctionEntityMetadata;\n            const ofs = Array.isArray(this.expressionMap.of)\n                ? this.expressionMap.of\n                : [this.expressionMap.of];\n            const values = Array.isArray(value) ? value : [value];\n            const firstColumnValues = relation.isManyToManyOwner ? ofs : values;\n            const secondColumnValues = relation.isManyToManyOwner ? values : ofs;\n            const parameters = {};\n            const conditions = [];\n            firstColumnValues.forEach((firstColumnVal, firstColumnValIndex) => {\n                conditions.push(...secondColumnValues.map((secondColumnVal, secondColumnValIndex) => {\n                    return [\n                        ...junctionMetadata.ownerColumns.map((column, columnIndex) => {\n                            const parameterName = \"firstValue_\" +\n                                firstColumnValIndex +\n                                \"_\" +\n                                secondColumnValIndex +\n                                \"_\" +\n                                columnIndex;\n                            parameters[parameterName] =\n                                ObjectUtils.isObject(firstColumnVal)\n                                    ? column.referencedColumn.getEntityValue(firstColumnVal)\n                                    : firstColumnVal;\n                            return `${column.databaseName} = :${parameterName}`;\n                        }),\n                        ...junctionMetadata.inverseColumns.map((column, columnIndex) => {\n                            const parameterName = \"secondValue_\" +\n                                firstColumnValIndex +\n                                \"_\" +\n                                secondColumnValIndex +\n                                \"_\" +\n                                columnIndex;\n                            parameters[parameterName] =\n                                ObjectUtils.isObject(secondColumnVal)\n                                    ? column.referencedColumn.getEntityValue(secondColumnVal)\n                                    : secondColumnVal;\n                            return `${column.databaseName} = :${parameterName}`;\n                        }),\n                    ].join(\" AND \");\n                }));\n            });\n            const condition = conditions\n                .map((str) => \"(\" + str + \")\")\n                .join(\" OR \");\n            await this.queryBuilder\n                .createQueryBuilder()\n                .delete()\n                .from(junctionMetadata.tableName)\n                .where(condition)\n                .setParameters(parameters)\n                .execute();\n        }\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}