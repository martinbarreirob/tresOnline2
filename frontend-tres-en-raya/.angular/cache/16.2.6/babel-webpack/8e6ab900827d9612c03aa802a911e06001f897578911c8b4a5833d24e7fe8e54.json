{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/practicas/Downloads/angular/tresOnline/frontend-tres-en-raya/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { MustBeEntityError } from \"../error/MustBeEntityError\";\nimport { SubjectExecutor } from \"./SubjectExecutor\";\nimport { CannotDetermineEntityError } from \"../error/CannotDetermineEntityError\";\nimport { Subject } from \"./Subject\";\nimport { OneToManySubjectBuilder } from \"./subject-builder/OneToManySubjectBuilder\";\nimport { OneToOneInverseSideSubjectBuilder } from \"./subject-builder/OneToOneInverseSideSubjectBuilder\";\nimport { ManyToManySubjectBuilder } from \"./subject-builder/ManyToManySubjectBuilder\";\nimport { SubjectDatabaseEntityLoader } from \"./SubjectDatabaseEntityLoader\";\nimport { CascadesSubjectBuilder } from \"./subject-builder/CascadesSubjectBuilder\";\nimport { OrmUtils } from \"../util/OrmUtils\";\n/**\n * Persists a single entity or multiple entities - saves or removes them.\n */\nexport class EntityPersistExecutor {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection, queryRunner, mode, target, entity, options) {\n    this.connection = connection;\n    this.queryRunner = queryRunner;\n    this.mode = mode;\n    this.target = target;\n    this.entity = entity;\n    this.options = options;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Executes persistence operation ob given entity or entities.\n   */\n  execute() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      // check if entity we are going to save is valid and is an object\n      if (!_this.entity || typeof _this.entity !== \"object\") return Promise.reject(new MustBeEntityError(_this.mode, _this.entity));\n      // we MUST call \"fake\" resolve here to make sure all properties of lazily loaded relations are resolved\n      yield Promise.resolve();\n      // if query runner is already defined in this class, it means this entity manager was already created for a single connection\n      // if its not defined we create a new query runner - single connection where we'll execute all our operations\n      const queryRunner = _this.queryRunner || _this.connection.createQueryRunner();\n      // save data in the query runner - this is useful functionality to share data from outside of the world\n      // with third classes - like subscribers and listener methods\n      let oldQueryRunnerData = queryRunner.data;\n      if (_this.options && _this.options.data) {\n        queryRunner.data = _this.options.data;\n      }\n      try {\n        // collect all operate subjects\n        const entities = Array.isArray(_this.entity) ? _this.entity : [_this.entity];\n        const entitiesInChunks = _this.options && _this.options.chunk && _this.options.chunk > 0 ? OrmUtils.chunk(entities, _this.options.chunk) : [entities];\n        // console.time(\"building subject executors...\");\n        const executors = yield Promise.all(entitiesInChunks.map( /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* (entities) {\n            const subjects = [];\n            // create subjects for all entities we received for the persistence\n            entities.forEach(entity => {\n              const entityTarget = _this.target ? _this.target : entity.constructor;\n              if (entityTarget === Object) throw new CannotDetermineEntityError(_this.mode);\n              let metadata = _this.connection.getMetadata(entityTarget).findInheritanceMetadata(entity);\n              subjects.push(new Subject({\n                metadata,\n                entity: entity,\n                canBeInserted: _this.mode === \"save\",\n                canBeUpdated: _this.mode === \"save\",\n                mustBeRemoved: _this.mode === \"remove\",\n                canBeSoftRemoved: _this.mode === \"soft-remove\",\n                canBeRecovered: _this.mode === \"recover\"\n              }));\n            });\n            // console.time(\"building cascades...\");\n            // go through each entity with metadata and create subjects and subjects by cascades for them\n            const cascadesSubjectBuilder = new CascadesSubjectBuilder(subjects);\n            subjects.forEach(subject => {\n              // next step we build list of subjects we will operate with\n              // these subjects are subjects that we need to insert or update alongside with main persisted entity\n              cascadesSubjectBuilder.build(subject, _this.mode);\n            });\n            // console.timeEnd(\"building cascades...\");\n            // load database entities for all subjects we have\n            // next step is to load database entities for all operate subjects\n            // console.time(\"loading...\");\n            yield new SubjectDatabaseEntityLoader(queryRunner, subjects).load(_this.mode);\n            // console.timeEnd(\"loading...\");\n            // console.time(\"other subjects...\");\n            // build all related subjects and change maps\n            if (_this.mode === \"save\" || _this.mode === \"soft-remove\" || _this.mode === \"recover\") {\n              new OneToManySubjectBuilder(subjects).build();\n              new OneToOneInverseSideSubjectBuilder(subjects).build();\n              new ManyToManySubjectBuilder(subjects).build();\n            } else {\n              subjects.forEach(subject => {\n                if (subject.mustBeRemoved) {\n                  new ManyToManySubjectBuilder(subjects).buildForAllRemoval(subject);\n                }\n              });\n            }\n            // console.timeEnd(\"other subjects...\");\n            // console.timeEnd(\"building subjects...\");\n            // console.log(\"subjects\", subjects);\n            // create a subject executor\n            return new SubjectExecutor(queryRunner, subjects, _this.options);\n          });\n          return function (_x) {\n            return _ref.apply(this, arguments);\n          };\n        }()));\n        // console.timeEnd(\"building subject executors...\");\n        // make sure we have at least one executable operation before we create a transaction and proceed\n        // if we don't have operations it means we don't really need to update or remove something\n        const executorsWithExecutableOperations = executors.filter(executor => executor.hasExecutableOperations);\n        if (executorsWithExecutableOperations.length === 0) return;\n        // start execute queries in a transaction\n        // if transaction is already opened in this query runner then we don't touch it\n        // if its not opened yet then we open it here, and once we finish - we close it\n        let isTransactionStartedByUs = false;\n        try {\n          // open transaction if its not opened yet\n          if (!queryRunner.isTransactionActive) {\n            if (_this.connection.driver.transactionSupport !== \"none\" && (!_this.options || _this.options.transaction !== false)) {\n              // start transaction until it was not explicitly disabled\n              isTransactionStartedByUs = true;\n              yield queryRunner.startTransaction();\n            }\n          }\n          // execute all persistence operations for all entities we have\n          // console.time(\"executing subject executors...\");\n          for (const executor of executorsWithExecutableOperations) {\n            yield executor.execute();\n          }\n          // console.timeEnd(\"executing subject executors...\");\n          // commit transaction if it was started by us\n          // console.time(\"commit\");\n          if (isTransactionStartedByUs === true) yield queryRunner.commitTransaction();\n          // console.timeEnd(\"commit\");\n        } catch (error) {\n          // rollback transaction if it was started by us\n          if (isTransactionStartedByUs) {\n            try {\n              yield queryRunner.rollbackTransaction();\n            } catch (rollbackError) {}\n          }\n          throw error;\n        }\n      } finally {\n        queryRunner.data = oldQueryRunnerData;\n        // release query runner only if its created by us\n        if (!_this.queryRunner) yield queryRunner.release();\n      }\n    })();\n  }\n}","map":{"version":3,"names":["MustBeEntityError","SubjectExecutor","CannotDetermineEntityError","Subject","OneToManySubjectBuilder","OneToOneInverseSideSubjectBuilder","ManyToManySubjectBuilder","SubjectDatabaseEntityLoader","CascadesSubjectBuilder","OrmUtils","EntityPersistExecutor","constructor","connection","queryRunner","mode","target","entity","options","execute","_this","_asyncToGenerator","Promise","reject","resolve","createQueryRunner","oldQueryRunnerData","data","entities","Array","isArray","entitiesInChunks","chunk","executors","all","map","_ref","subjects","forEach","entityTarget","Object","metadata","getMetadata","findInheritanceMetadata","push","canBeInserted","canBeUpdated","mustBeRemoved","canBeSoftRemoved","canBeRecovered","cascadesSubjectBuilder","subject","build","load","buildForAllRemoval","_x","apply","arguments","executorsWithExecutableOperations","filter","executor","hasExecutableOperations","length","isTransactionStartedByUs","isTransactionActive","driver","transactionSupport","transaction","startTransaction","commitTransaction","error","rollbackTransaction","rollbackError","release"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/persistence/EntityPersistExecutor.js"],"sourcesContent":["import { MustBeEntityError } from \"../error/MustBeEntityError\";\nimport { SubjectExecutor } from \"./SubjectExecutor\";\nimport { CannotDetermineEntityError } from \"../error/CannotDetermineEntityError\";\nimport { Subject } from \"./Subject\";\nimport { OneToManySubjectBuilder } from \"./subject-builder/OneToManySubjectBuilder\";\nimport { OneToOneInverseSideSubjectBuilder } from \"./subject-builder/OneToOneInverseSideSubjectBuilder\";\nimport { ManyToManySubjectBuilder } from \"./subject-builder/ManyToManySubjectBuilder\";\nimport { SubjectDatabaseEntityLoader } from \"./SubjectDatabaseEntityLoader\";\nimport { CascadesSubjectBuilder } from \"./subject-builder/CascadesSubjectBuilder\";\nimport { OrmUtils } from \"../util/OrmUtils\";\n/**\n * Persists a single entity or multiple entities - saves or removes them.\n */\nexport class EntityPersistExecutor {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n    constructor(connection, queryRunner, mode, target, entity, options) {\n        this.connection = connection;\n        this.queryRunner = queryRunner;\n        this.mode = mode;\n        this.target = target;\n        this.entity = entity;\n        this.options = options;\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Executes persistence operation ob given entity or entities.\n     */\n    async execute() {\n        // check if entity we are going to save is valid and is an object\n        if (!this.entity || typeof this.entity !== \"object\")\n            return Promise.reject(new MustBeEntityError(this.mode, this.entity));\n        // we MUST call \"fake\" resolve here to make sure all properties of lazily loaded relations are resolved\n        await Promise.resolve();\n        // if query runner is already defined in this class, it means this entity manager was already created for a single connection\n        // if its not defined we create a new query runner - single connection where we'll execute all our operations\n        const queryRunner = this.queryRunner || this.connection.createQueryRunner();\n        // save data in the query runner - this is useful functionality to share data from outside of the world\n        // with third classes - like subscribers and listener methods\n        let oldQueryRunnerData = queryRunner.data;\n        if (this.options && this.options.data) {\n            queryRunner.data = this.options.data;\n        }\n        try {\n            // collect all operate subjects\n            const entities = Array.isArray(this.entity)\n                ? this.entity\n                : [this.entity];\n            const entitiesInChunks = this.options && this.options.chunk && this.options.chunk > 0\n                ? OrmUtils.chunk(entities, this.options.chunk)\n                : [entities];\n            // console.time(\"building subject executors...\");\n            const executors = await Promise.all(entitiesInChunks.map(async (entities) => {\n                const subjects = [];\n                // create subjects for all entities we received for the persistence\n                entities.forEach((entity) => {\n                    const entityTarget = this.target\n                        ? this.target\n                        : entity.constructor;\n                    if (entityTarget === Object)\n                        throw new CannotDetermineEntityError(this.mode);\n                    let metadata = this.connection\n                        .getMetadata(entityTarget)\n                        .findInheritanceMetadata(entity);\n                    subjects.push(new Subject({\n                        metadata,\n                        entity: entity,\n                        canBeInserted: this.mode === \"save\",\n                        canBeUpdated: this.mode === \"save\",\n                        mustBeRemoved: this.mode === \"remove\",\n                        canBeSoftRemoved: this.mode === \"soft-remove\",\n                        canBeRecovered: this.mode === \"recover\",\n                    }));\n                });\n                // console.time(\"building cascades...\");\n                // go through each entity with metadata and create subjects and subjects by cascades for them\n                const cascadesSubjectBuilder = new CascadesSubjectBuilder(subjects);\n                subjects.forEach((subject) => {\n                    // next step we build list of subjects we will operate with\n                    // these subjects are subjects that we need to insert or update alongside with main persisted entity\n                    cascadesSubjectBuilder.build(subject, this.mode);\n                });\n                // console.timeEnd(\"building cascades...\");\n                // load database entities for all subjects we have\n                // next step is to load database entities for all operate subjects\n                // console.time(\"loading...\");\n                await new SubjectDatabaseEntityLoader(queryRunner, subjects).load(this.mode);\n                // console.timeEnd(\"loading...\");\n                // console.time(\"other subjects...\");\n                // build all related subjects and change maps\n                if (this.mode === \"save\" ||\n                    this.mode === \"soft-remove\" ||\n                    this.mode === \"recover\") {\n                    new OneToManySubjectBuilder(subjects).build();\n                    new OneToOneInverseSideSubjectBuilder(subjects).build();\n                    new ManyToManySubjectBuilder(subjects).build();\n                }\n                else {\n                    subjects.forEach((subject) => {\n                        if (subject.mustBeRemoved) {\n                            new ManyToManySubjectBuilder(subjects).buildForAllRemoval(subject);\n                        }\n                    });\n                }\n                // console.timeEnd(\"other subjects...\");\n                // console.timeEnd(\"building subjects...\");\n                // console.log(\"subjects\", subjects);\n                // create a subject executor\n                return new SubjectExecutor(queryRunner, subjects, this.options);\n            }));\n            // console.timeEnd(\"building subject executors...\");\n            // make sure we have at least one executable operation before we create a transaction and proceed\n            // if we don't have operations it means we don't really need to update or remove something\n            const executorsWithExecutableOperations = executors.filter((executor) => executor.hasExecutableOperations);\n            if (executorsWithExecutableOperations.length === 0)\n                return;\n            // start execute queries in a transaction\n            // if transaction is already opened in this query runner then we don't touch it\n            // if its not opened yet then we open it here, and once we finish - we close it\n            let isTransactionStartedByUs = false;\n            try {\n                // open transaction if its not opened yet\n                if (!queryRunner.isTransactionActive) {\n                    if (this.connection.driver.transactionSupport !== \"none\" &&\n                        (!this.options || this.options.transaction !== false)) {\n                        // start transaction until it was not explicitly disabled\n                        isTransactionStartedByUs = true;\n                        await queryRunner.startTransaction();\n                    }\n                }\n                // execute all persistence operations for all entities we have\n                // console.time(\"executing subject executors...\");\n                for (const executor of executorsWithExecutableOperations) {\n                    await executor.execute();\n                }\n                // console.timeEnd(\"executing subject executors...\");\n                // commit transaction if it was started by us\n                // console.time(\"commit\");\n                if (isTransactionStartedByUs === true)\n                    await queryRunner.commitTransaction();\n                // console.timeEnd(\"commit\");\n            }\n            catch (error) {\n                // rollback transaction if it was started by us\n                if (isTransactionStartedByUs) {\n                    try {\n                        await queryRunner.rollbackTransaction();\n                    }\n                    catch (rollbackError) { }\n                }\n                throw error;\n            }\n        }\n        finally {\n            queryRunner.data = oldQueryRunnerData;\n            // release query runner only if its created by us\n            if (!this.queryRunner)\n                await queryRunner.release();\n        }\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}