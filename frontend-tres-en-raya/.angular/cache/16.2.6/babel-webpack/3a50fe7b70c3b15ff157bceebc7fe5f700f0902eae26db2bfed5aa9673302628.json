{"ast":null,"code":"import { getMetadataArgsStorage } from \"../../globals\";\nimport { ColumnTypeUndefinedError } from \"../../error/ColumnTypeUndefinedError\";\nimport { PrimaryColumnCannotBeNullableError } from \"../../error/PrimaryColumnCannotBeNullableError\";\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n * Primary columns also creates a PRIMARY KEY for this column in a db.\n */\nexport function PrimaryColumn(typeOrOptions, options) {\n  return function (object, propertyName) {\n    // normalize parameters\n    let type;\n    if (typeof typeOrOptions === \"string\" || typeOrOptions === String || typeOrOptions === Boolean || typeOrOptions === Number) {\n      type = typeOrOptions;\n    } else {\n      options = Object.assign({}, typeOrOptions);\n    }\n    if (!options) options = {};\n    // if type is not given explicitly then try to guess it\n    const reflectMetadataType = Reflect && Reflect.getMetadata ? Reflect.getMetadata(\"design:type\", object, propertyName) : undefined;\n    if (!type && reflectMetadataType) type = reflectMetadataType;\n    // check if there is no type in column options then set type from first function argument, or guessed one\n    if (!options.type && type) options.type = type;\n    // if we still don't have a type then we need to give error to user that type is required\n    if (!options.type) throw new ColumnTypeUndefinedError(object, propertyName);\n    // check if column is not nullable, because we cannot allow a primary key to be nullable\n    if (options.nullable) throw new PrimaryColumnCannotBeNullableError(object, propertyName);\n    // explicitly set a primary to column options\n    options.primary = true;\n    // create and register a new column metadata\n    getMetadataArgsStorage().columns.push({\n      target: object.constructor,\n      propertyName: propertyName,\n      mode: \"regular\",\n      options: options\n    });\n    if (options.generated) {\n      getMetadataArgsStorage().generations.push({\n        target: object.constructor,\n        propertyName: propertyName,\n        strategy: typeof options.generated === \"string\" ? options.generated : \"increment\"\n      });\n    }\n  };\n}","map":{"version":3,"names":["getMetadataArgsStorage","ColumnTypeUndefinedError","PrimaryColumnCannotBeNullableError","PrimaryColumn","typeOrOptions","options","object","propertyName","type","String","Boolean","Number","Object","assign","reflectMetadataType","Reflect","getMetadata","undefined","nullable","primary","columns","push","target","constructor","mode","generated","generations","strategy"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/decorator/columns/PrimaryColumn.js"],"sourcesContent":["import { getMetadataArgsStorage } from \"../../globals\";\nimport { ColumnTypeUndefinedError } from \"../../error/ColumnTypeUndefinedError\";\nimport { PrimaryColumnCannotBeNullableError } from \"../../error/PrimaryColumnCannotBeNullableError\";\n/**\n * Column decorator is used to mark a specific class property as a table column.\n * Only properties decorated with this decorator will be persisted to the database when entity be saved.\n * Primary columns also creates a PRIMARY KEY for this column in a db.\n */\nexport function PrimaryColumn(typeOrOptions, options) {\n    return function (object, propertyName) {\n        // normalize parameters\n        let type;\n        if (typeof typeOrOptions === \"string\" ||\n            typeOrOptions === String ||\n            typeOrOptions === Boolean ||\n            typeOrOptions === Number) {\n            type = typeOrOptions;\n        }\n        else {\n            options = Object.assign({}, typeOrOptions);\n        }\n        if (!options)\n            options = {};\n        // if type is not given explicitly then try to guess it\n        const reflectMetadataType = Reflect && Reflect.getMetadata\n            ? Reflect.getMetadata(\"design:type\", object, propertyName)\n            : undefined;\n        if (!type && reflectMetadataType)\n            type = reflectMetadataType;\n        // check if there is no type in column options then set type from first function argument, or guessed one\n        if (!options.type && type)\n            options.type = type;\n        // if we still don't have a type then we need to give error to user that type is required\n        if (!options.type)\n            throw new ColumnTypeUndefinedError(object, propertyName);\n        // check if column is not nullable, because we cannot allow a primary key to be nullable\n        if (options.nullable)\n            throw new PrimaryColumnCannotBeNullableError(object, propertyName);\n        // explicitly set a primary to column options\n        options.primary = true;\n        // create and register a new column metadata\n        getMetadataArgsStorage().columns.push({\n            target: object.constructor,\n            propertyName: propertyName,\n            mode: \"regular\",\n            options: options,\n        });\n        if (options.generated) {\n            getMetadataArgsStorage().generations.push({\n                target: object.constructor,\n                propertyName: propertyName,\n                strategy: typeof options.generated === \"string\"\n                    ? options.generated\n                    : \"increment\",\n            });\n        }\n    };\n}\n\n"],"mappings":"AAAA,SAASA,sBAAsB,QAAQ,eAAe;AACtD,SAASC,wBAAwB,QAAQ,sCAAsC;AAC/E,SAASC,kCAAkC,QAAQ,gDAAgD;AACnG;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,aAAaA,CAACC,aAAa,EAAEC,OAAO,EAAE;EAClD,OAAO,UAAUC,MAAM,EAAEC,YAAY,EAAE;IACnC;IACA,IAAIC,IAAI;IACR,IAAI,OAAOJ,aAAa,KAAK,QAAQ,IACjCA,aAAa,KAAKK,MAAM,IACxBL,aAAa,KAAKM,OAAO,IACzBN,aAAa,KAAKO,MAAM,EAAE;MAC1BH,IAAI,GAAGJ,aAAa;IACxB,CAAC,MACI;MACDC,OAAO,GAAGO,MAAM,CAACC,MAAM,CAAC,CAAC,CAAC,EAAET,aAAa,CAAC;IAC9C;IACA,IAAI,CAACC,OAAO,EACRA,OAAO,GAAG,CAAC,CAAC;IAChB;IACA,MAAMS,mBAAmB,GAAGC,OAAO,IAAIA,OAAO,CAACC,WAAW,GACpDD,OAAO,CAACC,WAAW,CAAC,aAAa,EAAEV,MAAM,EAAEC,YAAY,CAAC,GACxDU,SAAS;IACf,IAAI,CAACT,IAAI,IAAIM,mBAAmB,EAC5BN,IAAI,GAAGM,mBAAmB;IAC9B;IACA,IAAI,CAACT,OAAO,CAACG,IAAI,IAAIA,IAAI,EACrBH,OAAO,CAACG,IAAI,GAAGA,IAAI;IACvB;IACA,IAAI,CAACH,OAAO,CAACG,IAAI,EACb,MAAM,IAAIP,wBAAwB,CAACK,MAAM,EAAEC,YAAY,CAAC;IAC5D;IACA,IAAIF,OAAO,CAACa,QAAQ,EAChB,MAAM,IAAIhB,kCAAkC,CAACI,MAAM,EAAEC,YAAY,CAAC;IACtE;IACAF,OAAO,CAACc,OAAO,GAAG,IAAI;IACtB;IACAnB,sBAAsB,CAAC,CAAC,CAACoB,OAAO,CAACC,IAAI,CAAC;MAClCC,MAAM,EAAEhB,MAAM,CAACiB,WAAW;MAC1BhB,YAAY,EAAEA,YAAY;MAC1BiB,IAAI,EAAE,SAAS;MACfnB,OAAO,EAAEA;IACb,CAAC,CAAC;IACF,IAAIA,OAAO,CAACoB,SAAS,EAAE;MACnBzB,sBAAsB,CAAC,CAAC,CAAC0B,WAAW,CAACL,IAAI,CAAC;QACtCC,MAAM,EAAEhB,MAAM,CAACiB,WAAW;QAC1BhB,YAAY,EAAEA,YAAY;QAC1BoB,QAAQ,EAAE,OAAOtB,OAAO,CAACoB,SAAS,KAAK,QAAQ,GACzCpB,OAAO,CAACoB,SAAS,GACjB;MACV,CAAC,CAAC;IACN;EACJ,CAAC;AACL"},"metadata":{},"sourceType":"module","externalDependencies":[]}