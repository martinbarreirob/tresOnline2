{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/practicas/Downloads/angular/tresOnline/frontend-tres-en-raya/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { RawSqlResultsToEntityTransformer } from \"./transformer/RawSqlResultsToEntityTransformer\";\nimport { PessimisticLockTransactionRequiredError } from \"../error/PessimisticLockTransactionRequiredError\";\nimport { NoVersionOrUpdateDateColumnError } from \"../error/NoVersionOrUpdateDateColumnError\";\nimport { OptimisticLockVersionMismatchError } from \"../error/OptimisticLockVersionMismatchError\";\nimport { OptimisticLockCanNotBeUsedError } from \"../error/OptimisticLockCanNotBeUsedError\";\nimport { JoinAttribute } from \"./JoinAttribute\";\nimport { RelationIdAttribute } from \"./relation-id/RelationIdAttribute\";\nimport { RelationCountAttribute } from \"./relation-count/RelationCountAttribute\";\nimport { RelationIdLoader } from \"./relation-id/RelationIdLoader\";\nimport { RelationIdLoader as QueryStrategyRelationIdLoader } from \"./RelationIdLoader\";\nimport { RelationIdMetadataToAttributeTransformer } from \"./relation-id/RelationIdMetadataToAttributeTransformer\";\nimport { RelationCountLoader } from \"./relation-count/RelationCountLoader\";\nimport { RelationCountMetadataToAttributeTransformer } from \"./relation-count/RelationCountMetadataToAttributeTransformer\";\nimport { QueryBuilder } from \"./QueryBuilder\";\nimport { LockNotSupportedOnGivenDriverError } from \"../error/LockNotSupportedOnGivenDriverError\";\nimport { OffsetWithoutLimitNotSupportedError } from \"../error/OffsetWithoutLimitNotSupportedError\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\nimport { EntityNotFoundError } from \"../error/EntityNotFoundError\";\nimport { TypeORMError } from \"../error\";\nimport { FindOptionsUtils } from \"../find-options/FindOptionsUtils\";\nimport { OrmUtils } from \"../util/OrmUtils\";\nimport { EntityPropertyNotFoundError } from \"../error/EntityPropertyNotFoundError\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\nimport { FindOperator } from \"../find-options/FindOperator\";\nimport { ApplyValueTransformers } from \"../util/ApplyValueTransformers\";\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\nexport class SelectQueryBuilder extends QueryBuilder {\n  constructor() {\n    super(...arguments);\n    this[\"@instanceof\"] = Symbol.for(\"SelectQueryBuilder\");\n    this.findOptions = {};\n    this.selects = [];\n    this.joins = [];\n    this.conditions = \"\";\n    this.orderBys = [];\n    this.relationMetadatas = [];\n  }\n  // -------------------------------------------------------------------------\n  // Public Implemented Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Gets generated SQL query without parameters being replaced.\n   */\n  getQuery() {\n    let sql = this.createComment();\n    sql += this.createCteExpression();\n    sql += this.createSelectExpression();\n    sql += this.createJoinExpression();\n    sql += this.createWhereExpression();\n    sql += this.createGroupByExpression();\n    sql += this.createHavingExpression();\n    sql += this.createOrderByExpression();\n    sql += this.createLimitOffsetExpression();\n    sql += this.createLockExpression();\n    sql = sql.trim();\n    if (this.expressionMap.subQuery) sql = \"(\" + sql + \")\";\n    return this.replacePropertyNamesForTheWholeQuery(sql);\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  setFindOptions(findOptions) {\n    this.findOptions = findOptions;\n    this.applyFindOptions();\n    return this;\n  }\n  /**\n   * Creates a subquery - query that can be used inside other queries.\n   */\n  subQuery() {\n    const qb = this.createQueryBuilder();\n    qb.expressionMap.subQuery = true;\n    qb.parentQueryBuilder = this;\n    return qb;\n  }\n  /**\n   * Creates SELECT query and selects given data.\n   * Replaces all previous selections if they exist.\n   */\n  select(selection, selectionAliasName) {\n    this.expressionMap.queryType = \"select\";\n    if (Array.isArray(selection)) {\n      this.expressionMap.selects = selection.map(selection => ({\n        selection: selection\n      }));\n    } else if (typeof selection === \"function\") {\n      const subQueryBuilder = selection(this.subQuery());\n      this.setParameters(subQueryBuilder.getParameters());\n      this.expressionMap.selects.push({\n        selection: subQueryBuilder.getQuery(),\n        aliasName: selectionAliasName\n      });\n    } else if (selection) {\n      this.expressionMap.selects = [{\n        selection: selection,\n        aliasName: selectionAliasName\n      }];\n    }\n    return this;\n  }\n  /**\n   * Adds new selection to the SELECT query.\n   */\n  addSelect(selection, selectionAliasName) {\n    if (!selection) return this;\n    if (Array.isArray(selection)) {\n      this.expressionMap.selects = this.expressionMap.selects.concat(selection.map(selection => ({\n        selection: selection\n      })));\n    } else if (typeof selection === \"function\") {\n      const subQueryBuilder = selection(this.subQuery());\n      this.setParameters(subQueryBuilder.getParameters());\n      this.expressionMap.selects.push({\n        selection: subQueryBuilder.getQuery(),\n        aliasName: selectionAliasName\n      });\n    } else if (selection) {\n      this.expressionMap.selects.push({\n        selection: selection,\n        aliasName: selectionAliasName\n      });\n    }\n    return this;\n  }\n  /**\n   * Set max execution time.\n   * @param milliseconds\n   */\n  maxExecutionTime(milliseconds) {\n    this.expressionMap.maxExecutionTime = milliseconds;\n    return this;\n  }\n  /**\n   * Sets whether the selection is DISTINCT.\n   */\n  distinct(distinct = true) {\n    this.expressionMap.selectDistinct = distinct;\n    return this;\n  }\n  /**\n   * Sets the distinct on clause for Postgres.\n   */\n  distinctOn(distinctOn) {\n    this.expressionMap.selectDistinctOn = distinctOn;\n    return this;\n  }\n  fromDummy() {\n    var _a;\n    return this.from((_a = this.connection.driver.dummyTableName) !== null && _a !== void 0 ? _a : \"(SELECT 1 AS dummy_column)\", \"dummy_table\");\n  }\n  /**\n   * Specifies FROM which entity's table select/update/delete will be executed.\n   * Also sets a main string alias of the selection data.\n   * Removes all previously set from-s.\n   */\n  from(entityTarget, aliasName) {\n    const mainAlias = this.createFromAlias(entityTarget, aliasName);\n    this.expressionMap.setMainAlias(mainAlias);\n    return this;\n  }\n  /**\n   * Specifies FROM which entity's table select/update/delete will be executed.\n   * Also sets a main string alias of the selection data.\n   */\n  addFrom(entityTarget, aliasName) {\n    const alias = this.createFromAlias(entityTarget, aliasName);\n    if (!this.expressionMap.mainAlias) this.expressionMap.setMainAlias(alias);\n    return this;\n  }\n  /**\n   * INNER JOINs (without selection).\n   * You also need to specify an alias of the joined data.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n  innerJoin(entityOrProperty, alias, condition, parameters) {\n    this.join(\"INNER\", entityOrProperty, alias, condition, parameters);\n    return this;\n  }\n  /**\n   * LEFT JOINs (without selection).\n   * You also need to specify an alias of the joined data.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n  leftJoin(entityOrProperty, alias, condition, parameters) {\n    this.join(\"LEFT\", entityOrProperty, alias, condition, parameters);\n    return this;\n  }\n  /**\n   * INNER JOINs and adds all selection properties to SELECT.\n   * You also need to specify an alias of the joined data.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n  innerJoinAndSelect(entityOrProperty, alias, condition, parameters) {\n    this.addSelect(alias);\n    this.innerJoin(entityOrProperty, alias, condition, parameters);\n    return this;\n  }\n  /**\n   * LEFT JOINs and adds all selection properties to SELECT.\n   * You also need to specify an alias of the joined data.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n  leftJoinAndSelect(entityOrProperty, alias, condition, parameters) {\n    this.addSelect(alias);\n    this.leftJoin(entityOrProperty, alias, condition, parameters);\n    return this;\n  }\n  /**\n   * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n   * This is extremely useful when you want to select some data and map it to some virtual property.\n   * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n   * You also need to specify an alias of the joined data.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n  innerJoinAndMapMany(mapToProperty, entityOrProperty, alias, condition, parameters) {\n    this.addSelect(alias);\n    this.join(\"INNER\", entityOrProperty, alias, condition, parameters, mapToProperty, true);\n    return this;\n  }\n  /**\n   * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n   * This is extremely useful when you want to select some data and map it to some virtual property.\n   * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n   * You also need to specify an alias of the joined data.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n  innerJoinAndMapOne(mapToProperty, entityOrProperty, alias, condition, parameters, mapAsEntity) {\n    this.addSelect(alias);\n    this.join(\"INNER\", entityOrProperty, alias, condition, parameters, mapToProperty, false, mapAsEntity);\n    return this;\n  }\n  /**\n   * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n   * This is extremely useful when you want to select some data and map it to some virtual property.\n   * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n   * You also need to specify an alias of the joined data.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n  leftJoinAndMapMany(mapToProperty, entityOrProperty, alias, condition, parameters) {\n    this.addSelect(alias);\n    this.join(\"LEFT\", entityOrProperty, alias, condition, parameters, mapToProperty, true);\n    return this;\n  }\n  /**\n   * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n   * This is extremely useful when you want to select some data and map it to some virtual property.\n   * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n   * You also need to specify an alias of the joined data.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n  leftJoinAndMapOne(mapToProperty, entityOrProperty, alias, condition, parameters, mapAsEntity) {\n    this.addSelect(alias);\n    this.join(\"LEFT\", entityOrProperty, alias, condition, parameters, mapToProperty, false, mapAsEntity);\n    return this;\n  }\n  /**\n   * LEFT JOINs relation id and maps it into some entity's property.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n  loadRelationIdAndMap(mapToProperty, relationName, aliasNameOrOptions, queryBuilderFactory) {\n    const relationIdAttribute = new RelationIdAttribute(this.expressionMap);\n    relationIdAttribute.mapToProperty = mapToProperty;\n    relationIdAttribute.relationName = relationName;\n    if (typeof aliasNameOrOptions === \"string\") relationIdAttribute.alias = aliasNameOrOptions;\n    if (typeof aliasNameOrOptions === \"object\" && aliasNameOrOptions.disableMixedMap) relationIdAttribute.disableMixedMap = true;\n    relationIdAttribute.queryBuilderFactory = queryBuilderFactory;\n    this.expressionMap.relationIdAttributes.push(relationIdAttribute);\n    if (relationIdAttribute.relation.junctionEntityMetadata) {\n      this.expressionMap.createAlias({\n        type: \"other\",\n        name: relationIdAttribute.junctionAlias,\n        metadata: relationIdAttribute.relation.junctionEntityMetadata\n      });\n    }\n    return this;\n  }\n  /**\n   * Counts number of entities of entity's relation and maps the value into some entity's property.\n   * Optionally, you can add condition and parameters used in condition.\n   */\n  loadRelationCountAndMap(mapToProperty, relationName, aliasName, queryBuilderFactory) {\n    const relationCountAttribute = new RelationCountAttribute(this.expressionMap);\n    relationCountAttribute.mapToProperty = mapToProperty;\n    relationCountAttribute.relationName = relationName;\n    relationCountAttribute.alias = aliasName;\n    relationCountAttribute.queryBuilderFactory = queryBuilderFactory;\n    this.expressionMap.relationCountAttributes.push(relationCountAttribute);\n    this.expressionMap.createAlias({\n      type: \"other\",\n      name: relationCountAttribute.junctionAlias\n    });\n    if (relationCountAttribute.relation.junctionEntityMetadata) {\n      this.expressionMap.createAlias({\n        type: \"other\",\n        name: relationCountAttribute.junctionAlias,\n        metadata: relationCountAttribute.relation.junctionEntityMetadata\n      });\n    }\n    return this;\n  }\n  /**\n   * Loads all relation ids for all relations of the selected entity.\n   * All relation ids will be mapped to relation property themself.\n   * If array of strings is given then loads only relation ids of the given properties.\n   */\n  loadAllRelationIds(options) {\n    // todo: add skip relations\n    this.expressionMap.mainAlias.metadata.relations.forEach(relation => {\n      if (options !== undefined && options.relations !== undefined && options.relations.indexOf(relation.propertyPath) === -1) return;\n      this.loadRelationIdAndMap(this.expressionMap.mainAlias.name + \".\" + relation.propertyPath, this.expressionMap.mainAlias.name + \".\" + relation.propertyPath, options);\n    });\n    return this;\n  }\n  /**\n   * Sets WHERE condition in the query builder.\n   * If you had previously WHERE expression defined,\n   * calling this function will override previously set WHERE conditions.\n   * Additionally you can add parameters used in where expression.\n   */\n  where(where, parameters) {\n    this.expressionMap.wheres = []; // don't move this block below since computeWhereParameter can add where expressions\n    const condition = this.getWhereCondition(where);\n    if (condition) {\n      this.expressionMap.wheres = [{\n        type: \"simple\",\n        condition: condition\n      }];\n    }\n    if (parameters) this.setParameters(parameters);\n    return this;\n  }\n  /**\n   * Adds new AND WHERE condition in the query builder.\n   * Additionally you can add parameters used in where expression.\n   */\n  andWhere(where, parameters) {\n    this.expressionMap.wheres.push({\n      type: \"and\",\n      condition: this.getWhereCondition(where)\n    });\n    if (parameters) this.setParameters(parameters);\n    return this;\n  }\n  /**\n   * Adds new OR WHERE condition in the query builder.\n   * Additionally you can add parameters used in where expression.\n   */\n  orWhere(where, parameters) {\n    this.expressionMap.wheres.push({\n      type: \"or\",\n      condition: this.getWhereCondition(where)\n    });\n    if (parameters) this.setParameters(parameters);\n    return this;\n  }\n  /**\n   * Sets a new where EXISTS clause\n   */\n  whereExists(subQuery) {\n    return this.where(...this.getExistsCondition(subQuery));\n  }\n  /**\n   * Adds a new AND where EXISTS clause\n   */\n  andWhereExists(subQuery) {\n    return this.andWhere(...this.getExistsCondition(subQuery));\n  }\n  /**\n   * Adds a new OR where EXISTS clause\n   */\n  orWhereExists(subQuery) {\n    return this.orWhere(...this.getExistsCondition(subQuery));\n  }\n  /**\n   * Adds new AND WHERE with conditions for the given ids.\n   *\n   * Ids are mixed.\n   * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\n   * If you have multiple primary keys you need to pass object with property names and values specified,\n   * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\n   */\n  whereInIds(ids) {\n    return this.where(this.getWhereInIdsCondition(ids));\n  }\n  /**\n   * Adds new AND WHERE with conditions for the given ids.\n   *\n   * Ids are mixed.\n   * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\n   * If you have multiple primary keys you need to pass object with property names and values specified,\n   * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\n   */\n  andWhereInIds(ids) {\n    return this.andWhere(this.getWhereInIdsCondition(ids));\n  }\n  /**\n   * Adds new OR WHERE with conditions for the given ids.\n   *\n   * Ids are mixed.\n   * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\n   * If you have multiple primary keys you need to pass object with property names and values specified,\n   * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\n   */\n  orWhereInIds(ids) {\n    return this.orWhere(this.getWhereInIdsCondition(ids));\n  }\n  /**\n   * Sets HAVING condition in the query builder.\n   * If you had previously HAVING expression defined,\n   * calling this function will override previously set HAVING conditions.\n   * Additionally you can add parameters used in where expression.\n   */\n  having(having, parameters) {\n    this.expressionMap.havings.push({\n      type: \"simple\",\n      condition: having\n    });\n    if (parameters) this.setParameters(parameters);\n    return this;\n  }\n  /**\n   * Adds new AND HAVING condition in the query builder.\n   * Additionally you can add parameters used in where expression.\n   */\n  andHaving(having, parameters) {\n    this.expressionMap.havings.push({\n      type: \"and\",\n      condition: having\n    });\n    if (parameters) this.setParameters(parameters);\n    return this;\n  }\n  /**\n   * Adds new OR HAVING condition in the query builder.\n   * Additionally you can add parameters used in where expression.\n   */\n  orHaving(having, parameters) {\n    this.expressionMap.havings.push({\n      type: \"or\",\n      condition: having\n    });\n    if (parameters) this.setParameters(parameters);\n    return this;\n  }\n  /**\n   * Sets GROUP BY condition in the query builder.\n   * If you had previously GROUP BY expression defined,\n   * calling this function will override previously set GROUP BY conditions.\n   */\n  groupBy(groupBy) {\n    if (groupBy) {\n      this.expressionMap.groupBys = [groupBy];\n    } else {\n      this.expressionMap.groupBys = [];\n    }\n    return this;\n  }\n  /**\n   * Adds GROUP BY condition in the query builder.\n   */\n  addGroupBy(groupBy) {\n    this.expressionMap.groupBys.push(groupBy);\n    return this;\n  }\n  /**\n   * Enables time travelling for the current query (only supported by cockroach currently)\n   */\n  timeTravelQuery(timeTravelFn) {\n    if (this.connection.driver.options.type === \"cockroachdb\") {\n      if (timeTravelFn === undefined) {\n        this.expressionMap.timeTravel = \"follower_read_timestamp()\";\n      } else {\n        this.expressionMap.timeTravel = timeTravelFn;\n      }\n    }\n    return this;\n  }\n  /**\n   * Sets ORDER BY condition in the query builder.\n   * If you had previously ORDER BY expression defined,\n   * calling this function will override previously set ORDER BY conditions.\n   */\n  orderBy(sort, order = \"ASC\", nulls) {\n    if (order !== undefined && order !== \"ASC\" && order !== \"DESC\") throw new TypeORMError(`SelectQueryBuilder.addOrderBy \"order\" can accept only \"ASC\" and \"DESC\" values.`);\n    if (nulls !== undefined && nulls !== \"NULLS FIRST\" && nulls !== \"NULLS LAST\") throw new TypeORMError(`SelectQueryBuilder.addOrderBy \"nulls\" can accept only \"NULLS FIRST\" and \"NULLS LAST\" values.`);\n    if (sort) {\n      if (typeof sort === \"object\") {\n        this.expressionMap.orderBys = sort;\n      } else {\n        if (nulls) {\n          this.expressionMap.orderBys = {\n            [sort]: {\n              order,\n              nulls\n            }\n          };\n        } else {\n          this.expressionMap.orderBys = {\n            [sort]: order\n          };\n        }\n      }\n    } else {\n      this.expressionMap.orderBys = {};\n    }\n    return this;\n  }\n  /**\n   * Adds ORDER BY condition in the query builder.\n   */\n  addOrderBy(sort, order = \"ASC\", nulls) {\n    if (order !== undefined && order !== \"ASC\" && order !== \"DESC\") throw new TypeORMError(`SelectQueryBuilder.addOrderBy \"order\" can accept only \"ASC\" and \"DESC\" values.`);\n    if (nulls !== undefined && nulls !== \"NULLS FIRST\" && nulls !== \"NULLS LAST\") throw new TypeORMError(`SelectQueryBuilder.addOrderBy \"nulls\" can accept only \"NULLS FIRST\" and \"NULLS LAST\" values.`);\n    if (nulls) {\n      this.expressionMap.orderBys[sort] = {\n        order,\n        nulls\n      };\n    } else {\n      this.expressionMap.orderBys[sort] = order;\n    }\n    return this;\n  }\n  /**\n   * Set's LIMIT - maximum number of rows to be selected.\n   * NOTE that it may not work as you expect if you are using joins.\n   * If you want to implement pagination, and you are having join in your query,\n   * then use instead take method instead.\n   */\n  limit(limit) {\n    this.expressionMap.limit = this.normalizeNumber(limit);\n    if (this.expressionMap.limit !== undefined && isNaN(this.expressionMap.limit)) throw new TypeORMError(`Provided \"limit\" value is not a number. Please provide a numeric value.`);\n    return this;\n  }\n  /**\n   * Set's OFFSET - selection offset.\n   * NOTE that it may not work as you expect if you are using joins.\n   * If you want to implement pagination, and you are having join in your query,\n   * then use instead skip method instead.\n   */\n  offset(offset) {\n    this.expressionMap.offset = this.normalizeNumber(offset);\n    if (this.expressionMap.offset !== undefined && isNaN(this.expressionMap.offset)) throw new TypeORMError(`Provided \"offset\" value is not a number. Please provide a numeric value.`);\n    return this;\n  }\n  /**\n   * Sets maximal number of entities to take.\n   */\n  take(take) {\n    this.expressionMap.take = this.normalizeNumber(take);\n    if (this.expressionMap.take !== undefined && isNaN(this.expressionMap.take)) throw new TypeORMError(`Provided \"take\" value is not a number. Please provide a numeric value.`);\n    return this;\n  }\n  /**\n   * Sets number of entities to skip.\n   */\n  skip(skip) {\n    this.expressionMap.skip = this.normalizeNumber(skip);\n    if (this.expressionMap.skip !== undefined && isNaN(this.expressionMap.skip)) throw new TypeORMError(`Provided \"skip\" value is not a number. Please provide a numeric value.`);\n    return this;\n  }\n  /**\n   * Set certain index to be used by the query.\n   *\n   * @param index Name of index to be used.\n   */\n  useIndex(index) {\n    this.expressionMap.useIndex = index;\n    return this;\n  }\n  /**\n   * Sets locking mode.\n   */\n  setLock(lockMode, lockVersion, lockTables) {\n    this.expressionMap.lockMode = lockMode;\n    this.expressionMap.lockVersion = lockVersion;\n    this.expressionMap.lockTables = lockTables;\n    return this;\n  }\n  /**\n   * Sets lock handling by adding NO WAIT or SKIP LOCKED.\n   */\n  setOnLocked(onLocked) {\n    this.expressionMap.onLocked = onLocked;\n    return this;\n  }\n  /**\n   * Disables the global condition of \"non-deleted\" for the entity with delete date columns.\n   */\n  withDeleted() {\n    this.expressionMap.withDeleted = true;\n    return this;\n  }\n  /**\n   * Gets first raw result returned by execution of generated query builder sql.\n   */\n  getRawOne() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      return (yield _this.getRawMany())[0];\n    })();\n  }\n  /**\n   * Gets all raw results returned by execution of generated query builder sql.\n   */\n  getRawMany() {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (_this2.expressionMap.lockMode === \"optimistic\") throw new OptimisticLockCanNotBeUsedError();\n      _this2.expressionMap.queryEntity = false;\n      const queryRunner = _this2.obtainQueryRunner();\n      let transactionStartedByUs = false;\n      try {\n        // start transaction if it was enabled\n        if (_this2.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {\n          yield queryRunner.startTransaction();\n          transactionStartedByUs = true;\n        }\n        const results = yield _this2.loadRawResults(queryRunner);\n        // close transaction if we started it\n        if (transactionStartedByUs) {\n          yield queryRunner.commitTransaction();\n        }\n        return results;\n      } catch (error) {\n        // rollback transaction if we started it\n        if (transactionStartedByUs) {\n          try {\n            yield queryRunner.rollbackTransaction();\n          } catch (rollbackError) {}\n        }\n        throw error;\n      } finally {\n        if (queryRunner !== _this2.queryRunner) {\n          // means we created our own query runner\n          yield queryRunner.release();\n        }\n      }\n    })();\n  }\n  /**\n   * Executes sql generated by query builder and returns object with raw results and entities created from them.\n   */\n  getRawAndEntities() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      const queryRunner = _this3.obtainQueryRunner();\n      let transactionStartedByUs = false;\n      try {\n        // start transaction if it was enabled\n        if (_this3.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {\n          yield queryRunner.startTransaction();\n          transactionStartedByUs = true;\n        }\n        _this3.expressionMap.queryEntity = true;\n        const results = yield _this3.executeEntitiesAndRawResults(queryRunner);\n        // close transaction if we started it\n        if (transactionStartedByUs) {\n          yield queryRunner.commitTransaction();\n        }\n        return results;\n      } catch (error) {\n        // rollback transaction if we started it\n        if (transactionStartedByUs) {\n          try {\n            yield queryRunner.rollbackTransaction();\n          } catch (rollbackError) {}\n        }\n        throw error;\n      } finally {\n        if (queryRunner !== _this3.queryRunner)\n          // means we created our own query runner\n          yield queryRunner.release();\n      }\n    })();\n  }\n  /**\n   * Gets single entity returned by execution of generated query builder sql.\n   */\n  getOne() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      const results = yield _this4.getRawAndEntities();\n      const result = results.entities[0];\n      if (result && _this4.expressionMap.lockMode === \"optimistic\" && _this4.expressionMap.lockVersion) {\n        const metadata = _this4.expressionMap.mainAlias.metadata;\n        if (_this4.expressionMap.lockVersion instanceof Date) {\n          const actualVersion = metadata.updateDateColumn.getEntityValue(result); // what if columns arent set?\n          if (actualVersion.getTime() !== _this4.expressionMap.lockVersion.getTime()) throw new OptimisticLockVersionMismatchError(metadata.name, _this4.expressionMap.lockVersion, actualVersion);\n        } else {\n          const actualVersion = metadata.versionColumn.getEntityValue(result); // what if columns arent set?\n          if (actualVersion !== _this4.expressionMap.lockVersion) throw new OptimisticLockVersionMismatchError(metadata.name, _this4.expressionMap.lockVersion, actualVersion);\n        }\n      }\n      if (result === undefined) {\n        return null;\n      }\n      return result;\n    })();\n  }\n  /**\n   * Gets the first entity returned by execution of generated query builder sql or rejects the returned promise on error.\n   */\n  getOneOrFail() {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      const entity = yield _this5.getOne();\n      if (!entity) {\n        throw new EntityNotFoundError(_this5.expressionMap.mainAlias.target, _this5.expressionMap.parameters);\n      }\n      return entity;\n    })();\n  }\n  /**\n   * Gets entities returned by execution of generated query builder sql.\n   */\n  getMany() {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      if (_this6.expressionMap.lockMode === \"optimistic\") throw new OptimisticLockCanNotBeUsedError();\n      const results = yield _this6.getRawAndEntities();\n      return results.entities;\n    })();\n  }\n  /**\n   * Gets count - number of entities selected by sql generated by this query builder.\n   * Count excludes all limitations set by offset, limit, skip, and take.\n   */\n  getCount() {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      if (_this7.expressionMap.lockMode === \"optimistic\") throw new OptimisticLockCanNotBeUsedError();\n      const queryRunner = _this7.obtainQueryRunner();\n      let transactionStartedByUs = false;\n      try {\n        // start transaction if it was enabled\n        if (_this7.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {\n          yield queryRunner.startTransaction();\n          transactionStartedByUs = true;\n        }\n        _this7.expressionMap.queryEntity = false;\n        const results = yield _this7.executeCountQuery(queryRunner);\n        // close transaction if we started it\n        if (transactionStartedByUs) {\n          yield queryRunner.commitTransaction();\n        }\n        return results;\n      } catch (error) {\n        // rollback transaction if we started it\n        if (transactionStartedByUs) {\n          try {\n            yield queryRunner.rollbackTransaction();\n          } catch (rollbackError) {}\n        }\n        throw error;\n      } finally {\n        if (queryRunner !== _this7.queryRunner)\n          // means we created our own query runner\n          yield queryRunner.release();\n      }\n    })();\n  }\n  /**\n   * Gets exists\n   * Returns whether any rows exists matching current query.\n   */\n  getExists() {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      if (_this8.expressionMap.lockMode === \"optimistic\") throw new OptimisticLockCanNotBeUsedError();\n      const queryRunner = _this8.obtainQueryRunner();\n      let transactionStartedByUs = false;\n      try {\n        // start transaction if it was enabled\n        if (_this8.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {\n          yield queryRunner.startTransaction();\n          transactionStartedByUs = true;\n        }\n        _this8.expressionMap.queryEntity = false;\n        const results = yield _this8.executeExistsQuery(queryRunner);\n        // close transaction if we started it\n        if (transactionStartedByUs) {\n          yield queryRunner.commitTransaction();\n        }\n        return results;\n      } catch (error) {\n        // rollback transaction if we started it\n        if (transactionStartedByUs) {\n          try {\n            yield queryRunner.rollbackTransaction();\n          } catch (rollbackError) {}\n        }\n        throw error;\n      } finally {\n        if (queryRunner !== _this8.queryRunner)\n          // means we created our own query runner\n          yield queryRunner.release();\n      }\n    })();\n  }\n  /**\n   * Executes built SQL query and returns entities and overall entities count (without limitation).\n   * This method is useful to build pagination.\n   */\n  getManyAndCount() {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      if (_this9.expressionMap.lockMode === \"optimistic\") throw new OptimisticLockCanNotBeUsedError();\n      const queryRunner = _this9.obtainQueryRunner();\n      let transactionStartedByUs = false;\n      try {\n        // start transaction if it was enabled\n        if (_this9.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {\n          yield queryRunner.startTransaction();\n          transactionStartedByUs = true;\n        }\n        _this9.expressionMap.queryEntity = true;\n        const entitiesAndRaw = yield _this9.executeEntitiesAndRawResults(queryRunner);\n        _this9.expressionMap.queryEntity = false;\n        const cacheId = _this9.expressionMap.cacheId;\n        // Creates a new cacheId for the count query, or it will retreive the above query results\n        // and count will return 0.\n        _this9.expressionMap.cacheId = cacheId ? `${cacheId}-count` : cacheId;\n        const count = yield _this9.executeCountQuery(queryRunner);\n        const results = [entitiesAndRaw.entities, count];\n        // close transaction if we started it\n        if (transactionStartedByUs) {\n          yield queryRunner.commitTransaction();\n        }\n        return results;\n      } catch (error) {\n        // rollback transaction if we started it\n        if (transactionStartedByUs) {\n          try {\n            yield queryRunner.rollbackTransaction();\n          } catch (rollbackError) {}\n        }\n        throw error;\n      } finally {\n        if (queryRunner !== _this9.queryRunner)\n          // means we created our own query runner\n          yield queryRunner.release();\n      }\n    })();\n  }\n  /**\n   * Executes built SQL query and returns raw data stream.\n   */\n  stream() {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      _this10.expressionMap.queryEntity = false;\n      const [sql, parameters] = _this10.getQueryAndParameters();\n      const queryRunner = _this10.obtainQueryRunner();\n      let transactionStartedByUs = false;\n      try {\n        // start transaction if it was enabled\n        if (_this10.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {\n          yield queryRunner.startTransaction();\n          transactionStartedByUs = true;\n        }\n        const releaseFn = () => {\n          if (queryRunner !== _this10.queryRunner)\n            // means we created our own query runner\n            return queryRunner.release();\n          return;\n        };\n        const results = queryRunner.stream(sql, parameters, releaseFn, releaseFn);\n        // close transaction if we started it\n        if (transactionStartedByUs) {\n          yield queryRunner.commitTransaction();\n        }\n        return results;\n      } catch (error) {\n        // rollback transaction if we started it\n        if (transactionStartedByUs) {\n          try {\n            yield queryRunner.rollbackTransaction();\n          } catch (rollbackError) {}\n        }\n        throw error;\n      }\n    })();\n  }\n  /**\n   * Enables or disables query result caching.\n   */\n  cache(enabledOrMillisecondsOrId, maybeMilliseconds) {\n    if (typeof enabledOrMillisecondsOrId === \"boolean\") {\n      this.expressionMap.cache = enabledOrMillisecondsOrId;\n    } else if (typeof enabledOrMillisecondsOrId === \"number\") {\n      this.expressionMap.cache = true;\n      this.expressionMap.cacheDuration = enabledOrMillisecondsOrId;\n    } else if (typeof enabledOrMillisecondsOrId === \"string\" || typeof enabledOrMillisecondsOrId === \"number\") {\n      this.expressionMap.cache = true;\n      this.expressionMap.cacheId = enabledOrMillisecondsOrId;\n    }\n    if (maybeMilliseconds) {\n      this.expressionMap.cacheDuration = maybeMilliseconds;\n    }\n    return this;\n  }\n  /**\n   * Sets extra options that can be used to configure how query builder works.\n   */\n  setOption(option) {\n    this.expressionMap.options.push(option);\n    return this;\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  join(direction, entityOrProperty, aliasName, condition, parameters, mapToProperty, isMappingMany, mapAsEntity) {\n    if (parameters) {\n      this.setParameters(parameters);\n    }\n    const joinAttribute = new JoinAttribute(this.connection, this.expressionMap);\n    joinAttribute.direction = direction;\n    joinAttribute.mapAsEntity = mapAsEntity;\n    joinAttribute.mapToProperty = mapToProperty;\n    joinAttribute.isMappingMany = isMappingMany;\n    joinAttribute.entityOrProperty = entityOrProperty; // relationName\n    joinAttribute.condition = condition; // joinInverseSideCondition\n    // joinAttribute.junctionAlias = joinAttribute.relation.isOwning ? parentAlias + \"_\" + destinationTableAlias : destinationTableAlias + \"_\" + parentAlias;\n    this.expressionMap.joinAttributes.push(joinAttribute);\n    const joinAttributeMetadata = joinAttribute.metadata;\n    if (joinAttributeMetadata) {\n      if (joinAttributeMetadata.deleteDateColumn && !this.expressionMap.withDeleted) {\n        const conditionDeleteColumn = `${aliasName}.${joinAttributeMetadata.deleteDateColumn.propertyName} IS NULL`;\n        joinAttribute.condition = joinAttribute.condition ? ` ${joinAttribute.condition} AND ${conditionDeleteColumn}` : `${conditionDeleteColumn}`;\n      }\n      // todo: find and set metadata right there?\n      joinAttribute.alias = this.expressionMap.createAlias({\n        type: \"join\",\n        name: aliasName,\n        metadata: joinAttributeMetadata\n      });\n      if (joinAttribute.relation && joinAttribute.relation.junctionEntityMetadata) {\n        this.expressionMap.createAlias({\n          type: \"join\",\n          name: joinAttribute.junctionAlias,\n          metadata: joinAttribute.relation.junctionEntityMetadata\n        });\n      }\n    } else {\n      let subQuery = \"\";\n      if (typeof entityOrProperty === \"function\") {\n        const subQueryBuilder = entityOrProperty(this.subQuery());\n        this.setParameters(subQueryBuilder.getParameters());\n        subQuery = subQueryBuilder.getQuery();\n      } else {\n        subQuery = entityOrProperty;\n      }\n      const isSubQuery = typeof entityOrProperty === \"function\" || entityOrProperty.substr(0, 1) === \"(\" && entityOrProperty.substr(-1) === \")\";\n      joinAttribute.alias = this.expressionMap.createAlias({\n        type: \"join\",\n        name: aliasName,\n        tablePath: isSubQuery === false ? entityOrProperty : undefined,\n        subQuery: isSubQuery === true ? subQuery : undefined\n      });\n    }\n  }\n  /**\n   * Creates \"SELECT FROM\" part of SQL query.\n   */\n  createSelectExpression() {\n    if (!this.expressionMap.mainAlias) throw new TypeORMError(\"Cannot build query because main alias is not set (call qb#from method)\");\n    // todo throw exception if selects or from is missing\n    const allSelects = [];\n    const excludedSelects = [];\n    if (this.expressionMap.mainAlias.hasMetadata) {\n      const metadata = this.expressionMap.mainAlias.metadata;\n      allSelects.push(...this.buildEscapedEntityColumnSelects(this.expressionMap.mainAlias.name, metadata));\n      excludedSelects.push(...this.findEntityColumnSelects(this.expressionMap.mainAlias.name, metadata));\n    }\n    // add selects from joins\n    this.expressionMap.joinAttributes.forEach(join => {\n      if (join.metadata) {\n        allSelects.push(...this.buildEscapedEntityColumnSelects(join.alias.name, join.metadata));\n        excludedSelects.push(...this.findEntityColumnSelects(join.alias.name, join.metadata));\n      } else {\n        const hasMainAlias = this.expressionMap.selects.some(select => select.selection === join.alias.name);\n        if (hasMainAlias) {\n          allSelects.push({\n            selection: this.escape(join.alias.name) + \".*\"\n          });\n          const excludedSelect = this.expressionMap.selects.find(select => select.selection === join.alias.name);\n          excludedSelects.push(excludedSelect);\n        }\n      }\n    });\n    // add all other selects\n    this.expressionMap.selects.filter(select => excludedSelects.indexOf(select) === -1).forEach(select => allSelects.push({\n      selection: this.replacePropertyNames(select.selection),\n      aliasName: select.aliasName\n    }));\n    // if still selection is empty, then simply set it to all (*)\n    if (allSelects.length === 0) allSelects.push({\n      selection: \"*\"\n    });\n    // Use certain index\n    let useIndex = \"\";\n    if (this.expressionMap.useIndex) {\n      if (DriverUtils.isMySQLFamily(this.connection.driver)) {\n        useIndex = ` USE INDEX (${this.expressionMap.useIndex})`;\n      }\n    }\n    // create a selection query\n    const froms = this.expressionMap.aliases.filter(alias => alias.type === \"from\" && (alias.tablePath || alias.subQuery)).map(alias => {\n      if (alias.subQuery) return alias.subQuery + \" \" + this.escape(alias.name);\n      return this.getTableName(alias.tablePath) + \" \" + this.escape(alias.name);\n    });\n    const select = this.createSelectDistinctExpression();\n    const selection = allSelects.map(select => select.selection + (select.aliasName ? \" AS \" + this.escape(select.aliasName) : \"\")).join(\", \");\n    return select + selection + \" FROM \" + froms.join(\", \") + this.createTableLockExpression() + useIndex;\n  }\n  /**\n   * Creates select | select distinct part of SQL query.\n   */\n  createSelectDistinctExpression() {\n    const {\n      selectDistinct,\n      selectDistinctOn,\n      maxExecutionTime\n    } = this.expressionMap;\n    const {\n      driver\n    } = this.connection;\n    let select = \"SELECT \";\n    if (maxExecutionTime > 0) {\n      if (DriverUtils.isMySQLFamily(driver)) {\n        select += `/*+ MAX_EXECUTION_TIME(${this.expressionMap.maxExecutionTime}) */ `;\n      }\n    }\n    if (DriverUtils.isPostgresFamily(driver) && selectDistinctOn.length > 0) {\n      const selectDistinctOnMap = selectDistinctOn.map(on => this.replacePropertyNames(on)).join(\", \");\n      select = `SELECT DISTINCT ON (${selectDistinctOnMap}) `;\n    } else if (selectDistinct) {\n      select = \"SELECT DISTINCT \";\n    }\n    return select;\n  }\n  /**\n   * Creates \"JOIN\" part of SQL query.\n   */\n  createJoinExpression() {\n    // examples:\n    // select from owning side\n    // qb.select(\"post\")\n    //     .leftJoinAndSelect(\"post.category\", \"category\");\n    // select from non-owning side\n    // qb.select(\"category\")\n    //     .leftJoinAndSelect(\"category.post\", \"post\");\n    const joins = this.expressionMap.joinAttributes.map(joinAttr => {\n      const relation = joinAttr.relation;\n      const destinationTableName = joinAttr.tablePath;\n      const destinationTableAlias = joinAttr.alias.name;\n      let appendedCondition = joinAttr.condition ? \" AND (\" + joinAttr.condition + \")\" : \"\";\n      const parentAlias = joinAttr.parentAlias;\n      // if join was build without relation (e.g. without \"post.category\") then it means that we have direct\n      // table to join, without junction table involved. This means we simply join direct table.\n      if (!parentAlias || !relation) {\n        const destinationJoin = joinAttr.alias.subQuery ? joinAttr.alias.subQuery : this.getTableName(destinationTableName);\n        return \" \" + joinAttr.direction + \" JOIN \" + destinationJoin + \" \" + this.escape(destinationTableAlias) + this.createTableLockExpression() + (joinAttr.condition ? \" ON \" + this.replacePropertyNames(joinAttr.condition) : \"\");\n      }\n      // if real entity relation is involved\n      if (relation.isManyToOne || relation.isOneToOneOwner) {\n        // JOIN `category` `category` ON `category`.`id` = `post`.`categoryId`\n        const condition = relation.joinColumns.map(joinColumn => {\n          return destinationTableAlias + \".\" + joinColumn.referencedColumn.propertyPath + \"=\" + parentAlias + \".\" + relation.propertyPath + \".\" + joinColumn.referencedColumn.propertyPath;\n        }).join(\" AND \");\n        return \" \" + joinAttr.direction + \" JOIN \" + this.getTableName(destinationTableName) + \" \" + this.escape(destinationTableAlias) + this.createTableLockExpression() + \" ON \" + this.replacePropertyNames(condition + appendedCondition);\n      } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n        // JOIN `post` `post` ON `post`.`categoryId` = `category`.`id`\n        const condition = relation.inverseRelation.joinColumns.map(joinColumn => {\n          if (relation.inverseEntityMetadata.tableType === \"entity-child\" && relation.inverseEntityMetadata.discriminatorColumn) {\n            appendedCondition += \" AND \" + destinationTableAlias + \".\" + relation.inverseEntityMetadata.discriminatorColumn.databaseName + \"='\" + relation.inverseEntityMetadata.discriminatorValue + \"'\";\n          }\n          return destinationTableAlias + \".\" + relation.inverseRelation.propertyPath + \".\" + joinColumn.referencedColumn.propertyPath + \"=\" + parentAlias + \".\" + joinColumn.referencedColumn.propertyPath;\n        }).join(\" AND \");\n        return \" \" + joinAttr.direction + \" JOIN \" + this.getTableName(destinationTableName) + \" \" + this.escape(destinationTableAlias) + this.createTableLockExpression() + \" ON \" + this.replacePropertyNames(condition + appendedCondition);\n      } else {\n        // means many-to-many\n        const junctionTableName = relation.junctionEntityMetadata.tablePath;\n        const junctionAlias = joinAttr.junctionAlias;\n        let junctionCondition = \"\",\n          destinationCondition = \"\";\n        if (relation.isOwning) {\n          junctionCondition = relation.joinColumns.map(joinColumn => {\n            // `post_category`.`postId` = `post`.`id`\n            return junctionAlias + \".\" + joinColumn.propertyPath + \"=\" + parentAlias + \".\" + joinColumn.referencedColumn.propertyPath;\n          }).join(\" AND \");\n          destinationCondition = relation.inverseJoinColumns.map(joinColumn => {\n            // `category`.`id` = `post_category`.`categoryId`\n            return destinationTableAlias + \".\" + joinColumn.referencedColumn.propertyPath + \"=\" + junctionAlias + \".\" + joinColumn.propertyPath;\n          }).join(\" AND \");\n        } else {\n          junctionCondition = relation.inverseRelation.inverseJoinColumns.map(joinColumn => {\n            // `post_category`.`categoryId` = `category`.`id`\n            return junctionAlias + \".\" + joinColumn.propertyPath + \"=\" + parentAlias + \".\" + joinColumn.referencedColumn.propertyPath;\n          }).join(\" AND \");\n          destinationCondition = relation.inverseRelation.joinColumns.map(joinColumn => {\n            // `post`.`id` = `post_category`.`postId`\n            return destinationTableAlias + \".\" + joinColumn.referencedColumn.propertyPath + \"=\" + junctionAlias + \".\" + joinColumn.propertyPath;\n          }).join(\" AND \");\n        }\n        return \" \" + joinAttr.direction + \" JOIN \" + this.getTableName(junctionTableName) + \" \" + this.escape(junctionAlias) + this.createTableLockExpression() + \" ON \" + this.replacePropertyNames(junctionCondition) + \" \" + joinAttr.direction + \" JOIN \" + this.getTableName(destinationTableName) + \" \" + this.escape(destinationTableAlias) + this.createTableLockExpression() + \" ON \" + this.replacePropertyNames(destinationCondition + appendedCondition);\n      }\n    });\n    return joins.join(\" \");\n  }\n  /**\n   * Creates \"GROUP BY\" part of SQL query.\n   */\n  createGroupByExpression() {\n    if (!this.expressionMap.groupBys || !this.expressionMap.groupBys.length) return \"\";\n    return \" GROUP BY \" + this.replacePropertyNames(this.expressionMap.groupBys.join(\", \"));\n  }\n  /**\n   * Creates \"ORDER BY\" part of SQL query.\n   */\n  createOrderByExpression() {\n    const orderBys = this.expressionMap.allOrderBys;\n    if (Object.keys(orderBys).length === 0) return \"\";\n    return \" ORDER BY \" + Object.keys(orderBys).map(columnName => {\n      const orderValue = typeof orderBys[columnName] === \"string\" ? orderBys[columnName] : orderBys[columnName].order + \" \" + orderBys[columnName].nulls;\n      const selection = this.expressionMap.selects.find(s => s.selection === columnName);\n      if (selection && !selection.aliasName && columnName.indexOf(\".\") !== -1) {\n        const criteriaParts = columnName.split(\".\");\n        const aliasName = criteriaParts[0];\n        const propertyPath = criteriaParts.slice(1).join(\".\");\n        const alias = this.expressionMap.aliases.find(alias => alias.name === aliasName);\n        if (alias) {\n          const column = alias.metadata.findColumnWithPropertyPath(propertyPath);\n          if (column) {\n            const orderAlias = DriverUtils.buildAlias(this.connection.driver, undefined, aliasName, column.databaseName);\n            return this.escape(orderAlias) + \" \" + orderValue;\n          }\n        }\n      }\n      return this.replacePropertyNames(columnName) + \" \" + orderValue;\n    }).join(\", \");\n  }\n  /**\n   * Creates \"LIMIT\" and \"OFFSET\" parts of SQL query.\n   */\n  createLimitOffsetExpression() {\n    // in the case if nothing is joined in the query builder we don't need to make two requests to get paginated results\n    // we can use regular limit / offset, that's why we add offset and limit construction here based on skip and take values\n    let offset = this.expressionMap.offset,\n      limit = this.expressionMap.limit;\n    if (!offset && !limit && this.expressionMap.joinAttributes.length === 0) {\n      offset = this.expressionMap.skip;\n      limit = this.expressionMap.take;\n    }\n    if (this.connection.driver.options.type === \"mssql\") {\n      // Due to a limitation in SQL Server's parser implementation it does not support using\n      // OFFSET or FETCH NEXT without an ORDER BY clause being provided. In cases where the\n      // user does not request one we insert a dummy ORDER BY that does nothing and should\n      // have no effect on the query planner or on the order of the results returned.\n      // https://dba.stackexchange.com/a/193799\n      let prefix = \"\";\n      if ((limit || offset) && Object.keys(this.expressionMap.allOrderBys).length <= 0) {\n        prefix = \" ORDER BY (SELECT NULL)\";\n      }\n      if (limit && offset) return prefix + \" OFFSET \" + offset + \" ROWS FETCH NEXT \" + limit + \" ROWS ONLY\";\n      if (limit) return prefix + \" OFFSET 0 ROWS FETCH NEXT \" + limit + \" ROWS ONLY\";\n      if (offset) return prefix + \" OFFSET \" + offset + \" ROWS\";\n    } else if (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === \"aurora-mysql\" || this.connection.driver.options.type === \"sap\" || this.connection.driver.options.type === \"spanner\") {\n      if (limit && offset) return \" LIMIT \" + limit + \" OFFSET \" + offset;\n      if (limit) return \" LIMIT \" + limit;\n      if (offset) throw new OffsetWithoutLimitNotSupportedError();\n    } else if (DriverUtils.isSQLiteFamily(this.connection.driver)) {\n      if (limit && offset) return \" LIMIT \" + limit + \" OFFSET \" + offset;\n      if (limit) return \" LIMIT \" + limit;\n      if (offset) return \" LIMIT -1 OFFSET \" + offset;\n    } else if (this.connection.driver.options.type === \"oracle\") {\n      if (limit && offset) return \" OFFSET \" + offset + \" ROWS FETCH NEXT \" + limit + \" ROWS ONLY\";\n      if (limit) return \" FETCH NEXT \" + limit + \" ROWS ONLY\";\n      if (offset) return \" OFFSET \" + offset + \" ROWS\";\n    } else {\n      if (limit && offset) return \" LIMIT \" + limit + \" OFFSET \" + offset;\n      if (limit) return \" LIMIT \" + limit;\n      if (offset) return \" OFFSET \" + offset;\n    }\n    return \"\";\n  }\n  /**\n   * Creates \"LOCK\" part of SELECT Query after table Clause\n   * ex.\n   *  SELECT 1\n   *  FROM USER U WITH (NOLOCK)\n   *  JOIN ORDER O WITH (NOLOCK)\n   *      ON U.ID=O.OrderID\n   */\n  createTableLockExpression() {\n    if (this.connection.driver.options.type === \"mssql\") {\n      switch (this.expressionMap.lockMode) {\n        case \"pessimistic_read\":\n          return \" WITH (HOLDLOCK, ROWLOCK)\";\n        case \"pessimistic_write\":\n          return \" WITH (UPDLOCK, ROWLOCK)\";\n        case \"dirty_read\":\n          return \" WITH (NOLOCK)\";\n      }\n    }\n    return \"\";\n  }\n  /**\n   * Creates \"LOCK\" part of SQL query.\n   */\n  createLockExpression() {\n    const driver = this.connection.driver;\n    let lockTablesClause = \"\";\n    if (this.expressionMap.lockTables) {\n      if (!(DriverUtils.isPostgresFamily(driver) || driver.options.type === \"cockroachdb\")) {\n        throw new TypeORMError(\"Lock tables not supported in selected driver\");\n      }\n      if (this.expressionMap.lockTables.length < 1) {\n        throw new TypeORMError(\"lockTables cannot be an empty array\");\n      }\n      lockTablesClause = \" OF \" + this.expressionMap.lockTables.join(\", \");\n    }\n    let onLockExpression = \"\";\n    if (this.expressionMap.onLocked === \"nowait\") {\n      onLockExpression = \" NOWAIT\";\n    } else if (this.expressionMap.onLocked === \"skip_locked\") {\n      onLockExpression = \" SKIP LOCKED\";\n    }\n    switch (this.expressionMap.lockMode) {\n      case \"pessimistic_read\":\n        if (driver.options.type === \"mysql\" || driver.options.type === \"aurora-mysql\") {\n          if (DriverUtils.isReleaseVersionOrGreater(driver, \"8.0.0\")) {\n            return \" FOR SHARE\" + lockTablesClause + onLockExpression;\n          } else {\n            return \" LOCK IN SHARE MODE\";\n          }\n        } else if (driver.options.type === \"mariadb\") {\n          return \" LOCK IN SHARE MODE\";\n        } else if (DriverUtils.isPostgresFamily(driver)) {\n          return \" FOR SHARE\" + lockTablesClause + onLockExpression;\n        } else if (driver.options.type === \"oracle\") {\n          return \" FOR UPDATE\";\n        } else if (driver.options.type === \"mssql\") {\n          return \"\";\n        } else {\n          throw new LockNotSupportedOnGivenDriverError();\n        }\n      case \"pessimistic_write\":\n        if (DriverUtils.isMySQLFamily(driver) || driver.options.type === \"aurora-mysql\" || driver.options.type === \"oracle\") {\n          return \" FOR UPDATE\" + onLockExpression;\n        } else if (DriverUtils.isPostgresFamily(driver) || driver.options.type === \"cockroachdb\") {\n          return \" FOR UPDATE\" + lockTablesClause + onLockExpression;\n        } else if (driver.options.type === \"mssql\") {\n          return \"\";\n        } else {\n          throw new LockNotSupportedOnGivenDriverError();\n        }\n      case \"pessimistic_partial_write\":\n        if (DriverUtils.isPostgresFamily(driver)) {\n          return \" FOR UPDATE\" + lockTablesClause + \" SKIP LOCKED\";\n        } else if (DriverUtils.isMySQLFamily(driver)) {\n          return \" FOR UPDATE SKIP LOCKED\";\n        } else {\n          throw new LockNotSupportedOnGivenDriverError();\n        }\n      case \"pessimistic_write_or_fail\":\n        if (DriverUtils.isPostgresFamily(driver) || driver.options.type === \"cockroachdb\") {\n          return \" FOR UPDATE\" + lockTablesClause + \" NOWAIT\";\n        } else if (DriverUtils.isMySQLFamily(driver)) {\n          return \" FOR UPDATE NOWAIT\";\n        } else {\n          throw new LockNotSupportedOnGivenDriverError();\n        }\n      case \"for_no_key_update\":\n        if (DriverUtils.isPostgresFamily(driver) || driver.options.type === \"cockroachdb\") {\n          return \" FOR NO KEY UPDATE\" + lockTablesClause + onLockExpression;\n        } else {\n          throw new LockNotSupportedOnGivenDriverError();\n        }\n      case \"for_key_share\":\n        if (DriverUtils.isPostgresFamily(driver)) {\n          return \" FOR KEY SHARE\" + lockTablesClause + onLockExpression;\n        } else {\n          throw new LockNotSupportedOnGivenDriverError();\n        }\n      default:\n        return \"\";\n    }\n  }\n  /**\n   * Creates \"HAVING\" part of SQL query.\n   */\n  createHavingExpression() {\n    if (!this.expressionMap.havings || !this.expressionMap.havings.length) return \"\";\n    const conditions = this.expressionMap.havings.map((having, index) => {\n      switch (having.type) {\n        case \"and\":\n          return (index > 0 ? \"AND \" : \"\") + this.replacePropertyNames(having.condition);\n        case \"or\":\n          return (index > 0 ? \"OR \" : \"\") + this.replacePropertyNames(having.condition);\n        default:\n          return this.replacePropertyNames(having.condition);\n      }\n    }).join(\" \");\n    if (!conditions.length) return \"\";\n    return \" HAVING \" + conditions;\n  }\n  buildEscapedEntityColumnSelects(aliasName, metadata) {\n    const hasMainAlias = this.expressionMap.selects.some(select => select.selection === aliasName);\n    const columns = [];\n    if (hasMainAlias) {\n      columns.push(...metadata.columns.filter(column => column.isSelect === true));\n    }\n    columns.push(...metadata.columns.filter(column => {\n      return this.expressionMap.selects.some(select => select.selection === aliasName + \".\" + column.propertyPath);\n    }));\n    // if user used partial selection and did not select some primary columns which are required to be selected\n    // we select those primary columns and mark them as \"virtual\". Later virtual column values will be removed from final entity\n    // to make entity contain exactly what user selected\n    if (columns.length === 0)\n      // however not in the case when nothing (even partial) was selected from this target (for example joins without selection)\n      return [];\n    const nonSelectedPrimaryColumns = this.expressionMap.queryEntity ? metadata.primaryColumns.filter(primaryColumn => columns.indexOf(primaryColumn) === -1) : [];\n    const allColumns = [...columns, ...nonSelectedPrimaryColumns];\n    const finalSelects = [];\n    const escapedAliasName = this.escape(aliasName);\n    allColumns.forEach(column => {\n      let selectionPath = escapedAliasName + \".\" + this.escape(column.databaseName);\n      if (column.isVirtualProperty && column.query) {\n        selectionPath = `(${column.query(escapedAliasName)})`;\n      }\n      if (this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {\n        if (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === \"aurora-mysql\") {\n          const useLegacy = this.connection.driver.options.legacySpatialSupport;\n          const asText = useLegacy ? \"AsText\" : \"ST_AsText\";\n          selectionPath = `${asText}(${selectionPath})`;\n        }\n        if (DriverUtils.isPostgresFamily(this.connection.driver)) if (column.precision) {\n          // cast to JSON to trigger parsing in the driver\n          selectionPath = `ST_AsGeoJSON(${selectionPath}, ${column.precision})::json`;\n        } else {\n          selectionPath = `ST_AsGeoJSON(${selectionPath})::json`;\n        }\n        if (this.connection.driver.options.type === \"mssql\") selectionPath = `${selectionPath}.ToString()`;\n      }\n      const selections = this.expressionMap.selects.filter(select => select.selection === aliasName + \".\" + column.propertyPath);\n      if (selections.length) {\n        selections.forEach(selection => {\n          finalSelects.push({\n            selection: selectionPath,\n            aliasName: selection.aliasName ? selection.aliasName : DriverUtils.buildAlias(this.connection.driver, undefined, aliasName, column.databaseName),\n            // todo: need to keep in mind that custom selection.aliasName breaks hydrator. fix it later!\n            virtual: selection.virtual\n          });\n        });\n      } else {\n        finalSelects.push({\n          selection: selectionPath,\n          aliasName: DriverUtils.buildAlias(this.connection.driver, undefined, aliasName, column.databaseName),\n          // todo: need to keep in mind that custom selection.aliasName breaks hydrator. fix it later!\n          virtual: hasMainAlias\n        });\n      }\n    });\n    return finalSelects;\n  }\n  findEntityColumnSelects(aliasName, metadata) {\n    const mainSelect = this.expressionMap.selects.find(select => select.selection === aliasName);\n    if (mainSelect) return [mainSelect];\n    return this.expressionMap.selects.filter(select => {\n      return metadata.columns.some(column => select.selection === aliasName + \".\" + column.propertyPath);\n    });\n  }\n  computeCountExpression() {\n    const mainAlias = this.expressionMap.mainAlias.name; // todo: will this work with \"fromTableName\"?\n    const metadata = this.expressionMap.mainAlias.metadata;\n    const primaryColumns = metadata.primaryColumns;\n    const distinctAlias = this.escape(mainAlias);\n    // If we aren't doing anything that will create a join, we can use a simpler `COUNT` instead\n    // so we prevent poor query patterns in the most likely cases\n    if (this.expressionMap.joinAttributes.length === 0 && this.expressionMap.relationIdAttributes.length === 0 && this.expressionMap.relationCountAttributes.length === 0) {\n      return \"COUNT(1)\";\n    }\n    // For everything else, we'll need to do some hackery to get the correct count values.\n    if (this.connection.driver.options.type === \"cockroachdb\" || DriverUtils.isPostgresFamily(this.connection.driver)) {\n      // Postgres and CockroachDB can pass multiple parameters to the `DISTINCT` function\n      // https://www.postgresql.org/docs/9.5/sql-select.html#SQL-DISTINCT\n      return \"COUNT(DISTINCT(\" + primaryColumns.map(c => `${distinctAlias}.${this.escape(c.databaseName)}`).join(\", \") + \"))\";\n    }\n    if (DriverUtils.isMySQLFamily(this.connection.driver)) {\n      // MySQL & MariaDB can pass multiple parameters to the `DISTINCT` language construct\n      // https://mariadb.com/kb/en/count-distinct/\n      return \"COUNT(DISTINCT \" + primaryColumns.map(c => `${distinctAlias}.${this.escape(c.databaseName)}`).join(\", \") + \")\";\n    }\n    if (this.connection.driver.options.type === \"mssql\") {\n      // SQL Server has gotta be different from everyone else.  They don't support\n      // distinct counting multiple columns & they don't have the same operator\n      // characteristic for concatenating, so we gotta use the `CONCAT` function.\n      // However, If it's exactly 1 column we can omit the `CONCAT` for better performance.\n      const columnsExpression = primaryColumns.map(primaryColumn => `${distinctAlias}.${this.escape(primaryColumn.databaseName)}`).join(\", '|;|', \");\n      if (primaryColumns.length === 1) {\n        return `COUNT(DISTINCT(${columnsExpression}))`;\n      }\n      return `COUNT(DISTINCT(CONCAT(${columnsExpression})))`;\n    }\n    if (this.connection.driver.options.type === \"spanner\") {\n      // spanner also has gotta be different from everyone else.\n      // they do not support concatenation of different column types without casting them to string\n      if (primaryColumns.length === 1) {\n        return `COUNT(DISTINCT(${distinctAlias}.${this.escape(primaryColumns[0].databaseName)}))`;\n      }\n      const columnsExpression = primaryColumns.map(primaryColumn => `CAST(${distinctAlias}.${this.escape(primaryColumn.databaseName)} AS STRING)`).join(\", '|;|', \");\n      return `COUNT(DISTINCT(CONCAT(${columnsExpression})))`;\n    }\n    // If all else fails, fall back to a `COUNT` and `DISTINCT` across all the primary columns concatenated.\n    // Per the SQL spec, this is the canonical string concatenation mechanism which is most\n    // likely to work across servers implementing the SQL standard.\n    // Please note, if there is only one primary column that the concatenation does not occur in this\n    // query and the query is a standard `COUNT DISTINCT` in that case.\n    return `COUNT(DISTINCT(` + primaryColumns.map(c => `${distinctAlias}.${this.escape(c.databaseName)}`).join(\" || '|;|' || \") + \"))\";\n  }\n  executeCountQuery(queryRunner) {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      const countSql = _this11.computeCountExpression();\n      const results = yield _this11.clone().orderBy().groupBy().offset(undefined).limit(undefined).skip(undefined).take(undefined).select(countSql, \"cnt\").setOption(\"disable-global-order\").loadRawResults(queryRunner);\n      if (!results || !results[0] || !results[0][\"cnt\"]) return 0;\n      return parseInt(results[0][\"cnt\"]);\n    })();\n  }\n  executeExistsQuery(queryRunner) {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      const results = yield _this12.connection.createQueryBuilder().fromDummy().select(\"1\", \"row_exists\").whereExists(_this12).limit(1).loadRawResults(queryRunner);\n      return results.length > 0;\n    })();\n  }\n  applyFindOptions() {\n    // todo: convert relations: string[] to object map to simplify code\n    // todo: same with selects\n    if (this.expressionMap.mainAlias.metadata) {\n      if (this.findOptions.relationLoadStrategy) {\n        this.expressionMap.relationLoadStrategy = this.findOptions.relationLoadStrategy;\n      }\n      if (this.findOptions.comment) {\n        this.comment(this.findOptions.comment);\n      }\n      if (this.findOptions.withDeleted) {\n        this.withDeleted();\n      }\n      if (this.findOptions.select) {\n        const select = Array.isArray(this.findOptions.select) ? OrmUtils.propertyPathsToTruthyObject(this.findOptions.select) : this.findOptions.select;\n        this.buildSelect(select, this.expressionMap.mainAlias.metadata, this.expressionMap.mainAlias.name);\n      }\n      if (this.selects.length) {\n        this.select(this.selects);\n      }\n      this.selects = [];\n      if (this.findOptions.relations) {\n        const relations = Array.isArray(this.findOptions.relations) ? OrmUtils.propertyPathsToTruthyObject(this.findOptions.relations) : this.findOptions.relations;\n        this.buildRelations(relations, typeof this.findOptions.select === \"object\" ? this.findOptions.select : undefined, this.expressionMap.mainAlias.metadata, this.expressionMap.mainAlias.name);\n        if (this.findOptions.loadEagerRelations !== false && this.expressionMap.relationLoadStrategy === \"join\") {\n          this.buildEagerRelations(relations, typeof this.findOptions.select === \"object\" ? this.findOptions.select : undefined, this.expressionMap.mainAlias.metadata, this.expressionMap.mainAlias.name);\n        }\n      }\n      if (this.selects.length) {\n        this.addSelect(this.selects);\n      }\n      if (this.findOptions.where) {\n        this.conditions = this.buildWhere(this.findOptions.where, this.expressionMap.mainAlias.metadata, this.expressionMap.mainAlias.name);\n        if (this.conditions.length) this.andWhere(this.conditions.substr(0, 1) !== \"(\" ? \"(\" + this.conditions + \")\" : this.conditions); // temporary and where and braces\n      }\n\n      if (this.findOptions.order) {\n        this.buildOrder(this.findOptions.order, this.expressionMap.mainAlias.metadata, this.expressionMap.mainAlias.name);\n      }\n      // apply joins\n      if (this.joins.length) {\n        this.joins.forEach(join => {\n          if (join.select && !join.selection) {\n            // if (join.selection) {\n            //\n            // } else {\n            if (join.type === \"inner\") {\n              this.innerJoinAndSelect(`${join.parentAlias}.${join.relationMetadata.propertyPath}`, join.alias);\n            } else {\n              this.leftJoinAndSelect(`${join.parentAlias}.${join.relationMetadata.propertyPath}`, join.alias);\n            }\n            // }\n          } else {\n            if (join.type === \"inner\") {\n              this.innerJoin(`${join.parentAlias}.${join.relationMetadata.propertyPath}`, join.alias);\n            } else {\n              this.leftJoin(`${join.parentAlias}.${join.relationMetadata.propertyPath}`, join.alias);\n            }\n          }\n          // if (join.select) {\n          //     if (this.findOptions.loadEagerRelations !== false) {\n          //         FindOptionsUtils.joinEagerRelations(\n          //             this,\n          //             join.alias,\n          //             join.relationMetadata.inverseEntityMetadata\n          //         );\n          //     }\n          // }\n        });\n      }\n      // if (this.conditions.length) {\n      //     this.where(this.conditions.join(\" AND \"));\n      // }\n      // apply offset\n      if (this.findOptions.skip !== undefined) {\n        // if (this.findOptions.options && this.findOptions.options.pagination === false) {\n        //     this.offset(this.findOptions.skip);\n        // } else {\n        this.skip(this.findOptions.skip);\n        // }\n      }\n      // apply limit\n      if (this.findOptions.take !== undefined) {\n        // if (this.findOptions.options && this.findOptions.options.pagination === false) {\n        //     this.limit(this.findOptions.take);\n        // } else {\n        this.take(this.findOptions.take);\n        // }\n      }\n      // apply caching options\n      if (typeof this.findOptions.cache === \"number\") {\n        this.cache(this.findOptions.cache);\n      } else if (typeof this.findOptions.cache === \"boolean\") {\n        this.cache(this.findOptions.cache);\n      } else if (typeof this.findOptions.cache === \"object\") {\n        this.cache(this.findOptions.cache.id, this.findOptions.cache.milliseconds);\n      }\n      if (this.findOptions.join) {\n        if (this.findOptions.join.leftJoin) Object.keys(this.findOptions.join.leftJoin).forEach(key => {\n          this.leftJoin(this.findOptions.join.leftJoin[key], key);\n        });\n        if (this.findOptions.join.innerJoin) Object.keys(this.findOptions.join.innerJoin).forEach(key => {\n          this.innerJoin(this.findOptions.join.innerJoin[key], key);\n        });\n        if (this.findOptions.join.leftJoinAndSelect) Object.keys(this.findOptions.join.leftJoinAndSelect).forEach(key => {\n          this.leftJoinAndSelect(this.findOptions.join.leftJoinAndSelect[key], key);\n        });\n        if (this.findOptions.join.innerJoinAndSelect) Object.keys(this.findOptions.join.innerJoinAndSelect).forEach(key => {\n          this.innerJoinAndSelect(this.findOptions.join.innerJoinAndSelect[key], key);\n        });\n      }\n      if (this.findOptions.lock) {\n        if (this.findOptions.lock.mode === \"optimistic\") {\n          this.setLock(this.findOptions.lock.mode, this.findOptions.lock.version);\n        } else if (this.findOptions.lock.mode === \"pessimistic_read\" || this.findOptions.lock.mode === \"pessimistic_write\" || this.findOptions.lock.mode === \"dirty_read\" || this.findOptions.lock.mode === \"pessimistic_partial_write\" || this.findOptions.lock.mode === \"pessimistic_write_or_fail\" || this.findOptions.lock.mode === \"for_no_key_update\" || this.findOptions.lock.mode === \"for_key_share\") {\n          const tableNames = this.findOptions.lock.tables ? this.findOptions.lock.tables.map(table => {\n            const tableAlias = this.expressionMap.aliases.find(alias => {\n              return alias.metadata.tableNameWithoutPrefix === table;\n            });\n            if (!tableAlias) {\n              throw new TypeORMError(`\"${table}\" is not part of this query`);\n            }\n            return this.escape(tableAlias.name);\n          }) : undefined;\n          this.setLock(this.findOptions.lock.mode, undefined, tableNames);\n          if (this.findOptions.lock.onLocked) {\n            this.setOnLocked(this.findOptions.lock.onLocked);\n          }\n        }\n      }\n      if (this.findOptions.loadRelationIds === true) {\n        this.loadAllRelationIds();\n      } else if (typeof this.findOptions.loadRelationIds === \"object\") {\n        this.loadAllRelationIds(this.findOptions.loadRelationIds);\n      }\n      if (this.findOptions.loadEagerRelations !== false) {\n        FindOptionsUtils.joinEagerRelations(this, this.expressionMap.mainAlias.name, this.expressionMap.mainAlias.metadata);\n      }\n      if (this.findOptions.transaction === true) {\n        this.expressionMap.useTransaction = true;\n      }\n      // if (this.orderBys.length) {\n      //     this.orderBys.forEach(orderBy => {\n      //         this.addOrderBy(orderBy.alias, orderBy.direction, orderBy.nulls);\n      //     });\n      // }\n      // todo\n      // if (this.options.options && this.options.options.eagerRelations) {\n      //     this.queryBuilder\n      // }\n      // todo\n      // if (this.findOptions.options && this.findOptions.listeners === false) {\n      //     this.callListeners(false);\n      // }\n    }\n  }\n\n  concatRelationMetadata(relationMetadata) {\n    this.relationMetadatas.push(relationMetadata);\n  }\n  /**\n   * Executes sql generated by query builder and returns object with raw results and entities created from them.\n   */\n  executeEntitiesAndRawResults(queryRunner) {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      if (!_this13.expressionMap.mainAlias) throw new TypeORMError(`Alias is not set. Use \"from\" method to set an alias.`);\n      if ((_this13.expressionMap.lockMode === \"pessimistic_read\" || _this13.expressionMap.lockMode === \"pessimistic_write\" || _this13.expressionMap.lockMode === \"pessimistic_partial_write\" || _this13.expressionMap.lockMode === \"pessimistic_write_or_fail\" || _this13.expressionMap.lockMode === \"for_no_key_update\" || _this13.expressionMap.lockMode === \"for_key_share\") && !queryRunner.isTransactionActive) throw new PessimisticLockTransactionRequiredError();\n      if (_this13.expressionMap.lockMode === \"optimistic\") {\n        const metadata = _this13.expressionMap.mainAlias.metadata;\n        if (!metadata.versionColumn && !metadata.updateDateColumn) throw new NoVersionOrUpdateDateColumnError(metadata.name);\n      }\n      const relationIdLoader = new RelationIdLoader(_this13.connection, queryRunner, _this13.expressionMap.relationIdAttributes);\n      const relationCountLoader = new RelationCountLoader(_this13.connection, queryRunner, _this13.expressionMap.relationCountAttributes);\n      const relationIdMetadataTransformer = new RelationIdMetadataToAttributeTransformer(_this13.expressionMap);\n      relationIdMetadataTransformer.transform();\n      const relationCountMetadataTransformer = new RelationCountMetadataToAttributeTransformer(_this13.expressionMap);\n      relationCountMetadataTransformer.transform();\n      let rawResults = [],\n        entities = [];\n      // for pagination enabled (e.g. skip and take) its much more complicated - its a special process\n      // where we make two queries to find the data we need\n      // first query find ids in skip and take range\n      // and second query loads the actual data in given ids range\n      if ((_this13.expressionMap.skip || _this13.expressionMap.take) && _this13.expressionMap.joinAttributes.length > 0) {\n        // we are skipping order by here because its not working in subqueries anyway\n        // to make order by working we need to apply it on a distinct query\n        const [selects, orderBys] = _this13.createOrderByCombinedWithSelectExpression(\"distinctAlias\");\n        const metadata = _this13.expressionMap.mainAlias.metadata;\n        const mainAliasName = _this13.expressionMap.mainAlias.name;\n        const querySelects = metadata.primaryColumns.map(primaryColumn => {\n          const distinctAlias = _this13.escape(\"distinctAlias\");\n          const columnAlias = _this13.escape(DriverUtils.buildAlias(_this13.connection.driver, undefined, mainAliasName, primaryColumn.databaseName));\n          if (!orderBys[columnAlias])\n            // make sure we aren't overriding user-defined order in inverse direction\n            orderBys[columnAlias] = \"ASC\";\n          const alias = DriverUtils.buildAlias(_this13.connection.driver, undefined, \"ids_\" + mainAliasName, primaryColumn.databaseName);\n          return `${distinctAlias}.${columnAlias} AS ${_this13.escape(alias)}`;\n        });\n        const originalQuery = _this13.clone();\n        // preserve original timeTravel value since we set it to \"false\" in subquery\n        const originalQueryTimeTravel = originalQuery.expressionMap.timeTravel;\n        rawResults = yield new SelectQueryBuilder(_this13.connection, queryRunner).select(`DISTINCT ${querySelects.join(\", \")}`).addSelect(selects).from(`(${originalQuery.orderBy().timeTravelQuery(false) // set it to \"false\" since time travel clause must appear at the very end and applies to the entire SELECT clause.\n        .getQuery()})`, \"distinctAlias\").timeTravelQuery(originalQueryTimeTravel).offset(_this13.expressionMap.skip).limit(_this13.expressionMap.take).orderBy(orderBys).cache(_this13.expressionMap.cache && _this13.expressionMap.cacheId ? `${_this13.expressionMap.cacheId}-pagination` : _this13.expressionMap.cache, _this13.expressionMap.cacheDuration).setParameters(_this13.getParameters()).setNativeParameters(_this13.expressionMap.nativeParameters).getRawMany();\n        if (rawResults.length > 0) {\n          let condition = \"\";\n          const parameters = {};\n          if (metadata.hasMultiplePrimaryKeys) {\n            condition = rawResults.map((result, index) => {\n              return metadata.primaryColumns.map(primaryColumn => {\n                const paramKey = `orm_distinct_ids_${index}_${primaryColumn.databaseName}`;\n                const paramKeyResult = DriverUtils.buildAlias(_this13.connection.driver, undefined, \"ids_\" + mainAliasName, primaryColumn.databaseName);\n                parameters[paramKey] = result[paramKeyResult];\n                return `${mainAliasName}.${primaryColumn.propertyPath}=:${paramKey}`;\n              }).join(\" AND \");\n            }).join(\" OR \");\n          } else {\n            const alias = DriverUtils.buildAlias(_this13.connection.driver, undefined, \"ids_\" + mainAliasName, metadata.primaryColumns[0].databaseName);\n            const ids = rawResults.map(result => result[alias]);\n            const areAllNumbers = ids.every(id => typeof id === \"number\");\n            if (areAllNumbers) {\n              // fixes #190. if all numbers then its safe to perform query without parameter\n              condition = `${mainAliasName}.${metadata.primaryColumns[0].propertyPath} IN (${ids.join(\", \")})`;\n            } else {\n              parameters[\"orm_distinct_ids\"] = ids;\n              condition = mainAliasName + \".\" + metadata.primaryColumns[0].propertyPath + \" IN (:...orm_distinct_ids)\";\n            }\n          }\n          rawResults = yield _this13.clone().mergeExpressionMap({\n            extraAppendedAndWhereCondition: condition\n          }).setParameters(parameters).loadRawResults(queryRunner);\n        }\n      } else {\n        rawResults = yield _this13.loadRawResults(queryRunner);\n      }\n      if (rawResults.length > 0) {\n        // transform raw results into entities\n        const rawRelationIdResults = yield relationIdLoader.load(rawResults);\n        const rawRelationCountResults = yield relationCountLoader.load(rawResults);\n        const transformer = new RawSqlResultsToEntityTransformer(_this13.expressionMap, _this13.connection.driver, rawRelationIdResults, rawRelationCountResults, _this13.queryRunner);\n        entities = transformer.transform(rawResults, _this13.expressionMap.mainAlias);\n        // broadcast all \"after load\" events\n        if (_this13.expressionMap.callListeners === true && _this13.expressionMap.mainAlias.hasMetadata) {\n          yield queryRunner.broadcaster.broadcast(\"Load\", _this13.expressionMap.mainAlias.metadata, entities);\n        }\n      }\n      if (_this13.expressionMap.relationLoadStrategy === \"query\") {\n        const queryStrategyRelationIdLoader = new QueryStrategyRelationIdLoader(_this13.connection, queryRunner);\n        yield Promise.all(_this13.relationMetadatas.map( /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* (relation) {\n            const relationTarget = relation.inverseEntityMetadata.target;\n            const relationAlias = relation.inverseEntityMetadata.targetName;\n            const select = Array.isArray(_this13.findOptions.select) ? OrmUtils.propertyPathsToTruthyObject(_this13.findOptions.select) : _this13.findOptions.select;\n            const relations = Array.isArray(_this13.findOptions.relations) ? OrmUtils.propertyPathsToTruthyObject(_this13.findOptions.relations) : _this13.findOptions.relations;\n            const queryBuilder = _this13.createQueryBuilder().select(relationAlias).from(relationTarget, relationAlias).setFindOptions({\n              select: select ? OrmUtils.deepValue(select, relation.propertyPath) : undefined,\n              order: _this13.findOptions.order ? OrmUtils.deepValue(_this13.findOptions.order, relation.propertyPath) : undefined,\n              relations: relations ? OrmUtils.deepValue(relations, relation.propertyPath) : undefined,\n              withDeleted: _this13.findOptions.withDeleted,\n              relationLoadStrategy: _this13.findOptions.relationLoadStrategy\n            });\n            if (entities.length > 0) {\n              const relatedEntityGroups = yield queryStrategyRelationIdLoader.loadManyToManyRelationIdsAndGroup(relation, entities, undefined, queryBuilder);\n              entities.forEach(entity => {\n                const relatedEntityGroup = relatedEntityGroups.find(group => group.entity === entity);\n                if (relatedEntityGroup) {\n                  const value = relatedEntityGroup.related === undefined ? null : relatedEntityGroup.related;\n                  relation.setEntityValue(entity, value);\n                }\n              });\n            }\n          });\n          return function (_x) {\n            return _ref.apply(this, arguments);\n          };\n        }()));\n      }\n      return {\n        raw: rawResults,\n        entities: entities\n      };\n    })();\n  }\n  createOrderByCombinedWithSelectExpression(parentAlias) {\n    // if table has a default order then apply it\n    const orderBys = this.expressionMap.allOrderBys;\n    const selectString = Object.keys(orderBys).map(orderCriteria => {\n      if (orderCriteria.indexOf(\".\") !== -1) {\n        const criteriaParts = orderCriteria.split(\".\");\n        const aliasName = criteriaParts[0];\n        const propertyPath = criteriaParts.slice(1).join(\".\");\n        const alias = this.expressionMap.findAliasByName(aliasName);\n        const column = alias.metadata.findColumnWithPropertyPath(propertyPath);\n        return this.escape(parentAlias) + \".\" + this.escape(DriverUtils.buildAlias(this.connection.driver, undefined, aliasName, column.databaseName));\n      } else {\n        if (this.expressionMap.selects.find(select => select.selection === orderCriteria || select.aliasName === orderCriteria)) return this.escape(parentAlias) + \".\" + this.escape(orderCriteria);\n        return \"\";\n      }\n    }).join(\", \");\n    const orderByObject = {};\n    Object.keys(orderBys).forEach(orderCriteria => {\n      if (orderCriteria.indexOf(\".\") !== -1) {\n        const criteriaParts = orderCriteria.split(\".\");\n        const aliasName = criteriaParts[0];\n        const propertyPath = criteriaParts.slice(1).join(\".\");\n        const alias = this.expressionMap.findAliasByName(aliasName);\n        const column = alias.metadata.findColumnWithPropertyPath(propertyPath);\n        orderByObject[this.escape(parentAlias) + \".\" + this.escape(DriverUtils.buildAlias(this.connection.driver, undefined, aliasName, column.databaseName))] = orderBys[orderCriteria];\n      } else {\n        if (this.expressionMap.selects.find(select => select.selection === orderCriteria || select.aliasName === orderCriteria)) {\n          orderByObject[this.escape(parentAlias) + \".\" + this.escape(orderCriteria)] = orderBys[orderCriteria];\n        } else {\n          orderByObject[orderCriteria] = orderBys[orderCriteria];\n        }\n      }\n    });\n    return [selectString, orderByObject];\n  }\n  /**\n   * Loads raw results from the database.\n   */\n  loadRawResults(queryRunner) {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      const [sql, parameters] = _this14.getQueryAndParameters();\n      const queryId = sql + \" -- PARAMETERS: \" + JSON.stringify(parameters);\n      const cacheOptions = typeof _this14.connection.options.cache === \"object\" ? _this14.connection.options.cache : {};\n      let savedQueryResultCacheOptions = undefined;\n      const isCachingEnabled =\n      // Caching is enabled globally and isn't disabled locally.\n      cacheOptions.alwaysEnabled && _this14.expressionMap.cache ||\n      // ...or it's enabled locally explicitly.\n      _this14.expressionMap.cache;\n      let cacheError = false;\n      if (_this14.connection.queryResultCache && isCachingEnabled) {\n        try {\n          savedQueryResultCacheOptions = yield _this14.connection.queryResultCache.getFromCache({\n            identifier: _this14.expressionMap.cacheId,\n            query: queryId,\n            duration: _this14.expressionMap.cacheDuration || cacheOptions.duration || 1000\n          }, queryRunner);\n          if (savedQueryResultCacheOptions && !_this14.connection.queryResultCache.isExpired(savedQueryResultCacheOptions)) {\n            return JSON.parse(savedQueryResultCacheOptions.result);\n          }\n        } catch (error) {\n          if (!cacheOptions.ignoreErrors) {\n            throw error;\n          }\n          cacheError = true;\n        }\n      }\n      const results = yield queryRunner.query(sql, parameters, true);\n      if (!cacheError && _this14.connection.queryResultCache && isCachingEnabled) {\n        try {\n          yield _this14.connection.queryResultCache.storeInCache({\n            identifier: _this14.expressionMap.cacheId,\n            query: queryId,\n            time: new Date().getTime(),\n            duration: _this14.expressionMap.cacheDuration || cacheOptions.duration || 1000,\n            result: JSON.stringify(results.records)\n          }, savedQueryResultCacheOptions, queryRunner);\n        } catch (error) {\n          if (!cacheOptions.ignoreErrors) {\n            throw error;\n          }\n        }\n      }\n      return results.records;\n    })();\n  }\n  /**\n   * Merges into expression map given expression map properties.\n   */\n  mergeExpressionMap(expressionMap) {\n    ObjectUtils.assign(this.expressionMap, expressionMap);\n    return this;\n  }\n  /**\n   * Normalizes a give number - converts to int if possible.\n   */\n  normalizeNumber(num) {\n    if (typeof num === \"number\" || num === undefined || num === null) return num;\n    return Number(num);\n  }\n  /**\n   * Creates a query builder used to execute sql queries inside this query builder.\n   */\n  obtainQueryRunner() {\n    return this.queryRunner || this.connection.createQueryRunner(\"slave\");\n  }\n  buildSelect(select, metadata, alias, embedPrefix) {\n    for (let key in select) {\n      if (select[key] === undefined || select[key] === false) continue;\n      const propertyPath = embedPrefix ? embedPrefix + \".\" + key : key;\n      const column = metadata.findColumnWithPropertyPathStrict(propertyPath);\n      const embed = metadata.findEmbeddedWithPropertyPath(propertyPath);\n      const relation = metadata.findRelationWithPropertyPath(propertyPath);\n      if (!embed && !column && !relation) throw new EntityPropertyNotFoundError(propertyPath, metadata);\n      if (column) {\n        this.selects.push(alias + \".\" + propertyPath);\n        // this.addSelect(alias + \".\" + propertyPath);\n      } else if (embed) {\n        this.buildSelect(select[key], metadata, alias, propertyPath);\n        // } else if (relation) {\n        //     const joinAlias = alias + \"_\" + relation.propertyName;\n        //     const existJoin = this.joins.find(join => join.alias === joinAlias);\n        //     if (!existJoin) {\n        //         this.joins.push({\n        //             type: \"left\",\n        //             select: false,\n        //             alias: joinAlias,\n        //             parentAlias: alias,\n        //             relationMetadata: relation\n        //         });\n        //     }\n        //     this.buildOrder(select[key] as FindOptionsOrder<any>, relation.inverseEntityMetadata, joinAlias);\n      }\n    }\n  }\n\n  buildRelations(relations, selection, metadata, alias, embedPrefix) {\n    if (!relations) return;\n    Object.keys(relations).forEach(relationName => {\n      const relationValue = relations[relationName];\n      const propertyPath = embedPrefix ? embedPrefix + \".\" + relationName : relationName;\n      const embed = metadata.findEmbeddedWithPropertyPath(propertyPath);\n      const relation = metadata.findRelationWithPropertyPath(propertyPath);\n      if (!embed && !relation) throw new EntityPropertyNotFoundError(propertyPath, metadata);\n      if (embed) {\n        this.buildRelations(relationValue, typeof selection === \"object\" ? OrmUtils.deepValue(selection, embed.propertyPath) : undefined, metadata, alias, propertyPath);\n      } else if (relation) {\n        let joinAlias = alias + \"_\" + propertyPath.replace(\".\", \"_\");\n        joinAlias = DriverUtils.buildAlias(this.connection.driver, {\n          joiner: \"__\"\n        }, alias, joinAlias);\n        if (relationValue === true || typeof relationValue === \"object\") {\n          if (this.expressionMap.relationLoadStrategy === \"query\") {\n            this.concatRelationMetadata(relation);\n          } else {\n            // join\n            this.joins.push({\n              type: \"left\",\n              select: true,\n              selection: selection && typeof selection[relationName] === \"object\" ? selection[relationName] : undefined,\n              alias: joinAlias,\n              parentAlias: alias,\n              relationMetadata: relation\n            });\n            if (selection && typeof selection[relationName] === \"object\") {\n              this.buildSelect(selection[relationName], relation.inverseEntityMetadata, joinAlias);\n            }\n          }\n        }\n        if (typeof relationValue === \"object\" && this.expressionMap.relationLoadStrategy === \"join\") {\n          this.buildRelations(relationValue, typeof selection === \"object\" ? OrmUtils.deepValue(selection, relation.propertyPath) : undefined, relation.inverseEntityMetadata, joinAlias, undefined);\n        }\n      }\n    });\n  }\n  buildEagerRelations(relations, selection, metadata, alias, embedPrefix) {\n    if (!relations) return;\n    Object.keys(relations).forEach(relationName => {\n      const relationValue = relations[relationName];\n      const propertyPath = embedPrefix ? embedPrefix + \".\" + relationName : relationName;\n      const embed = metadata.findEmbeddedWithPropertyPath(propertyPath);\n      const relation = metadata.findRelationWithPropertyPath(propertyPath);\n      if (!embed && !relation) throw new EntityPropertyNotFoundError(propertyPath, metadata);\n      if (embed) {\n        this.buildEagerRelations(relationValue, typeof selection === \"object\" ? OrmUtils.deepValue(selection, embed.propertyPath) : undefined, metadata, alias, propertyPath);\n      } else if (relation) {\n        let joinAlias = alias + \"_\" + propertyPath.replace(\".\", \"_\");\n        joinAlias = DriverUtils.buildAlias(this.connection.driver, {\n          joiner: \"__\"\n        }, alias, joinAlias);\n        if (relationValue === true || typeof relationValue === \"object\") {\n          relation.inverseEntityMetadata.eagerRelations.forEach(eagerRelation => {\n            let eagerRelationJoinAlias = joinAlias + \"_\" + eagerRelation.propertyPath.replace(\".\", \"_\");\n            eagerRelationJoinAlias = DriverUtils.buildAlias(this.connection.driver, {\n              joiner: \"__\"\n            }, joinAlias, eagerRelationJoinAlias);\n            const existJoin = this.joins.find(join => join.alias === eagerRelationJoinAlias);\n            if (!existJoin) {\n              this.joins.push({\n                type: \"left\",\n                select: true,\n                alias: eagerRelationJoinAlias,\n                parentAlias: joinAlias,\n                selection: undefined,\n                relationMetadata: eagerRelation\n              });\n            }\n            if (selection && typeof selection[relationName] === \"object\") {\n              this.buildSelect(selection[relationName], relation.inverseEntityMetadata, joinAlias);\n            }\n          });\n        }\n        if (typeof relationValue === \"object\") {\n          this.buildEagerRelations(relationValue, typeof selection === \"object\" ? OrmUtils.deepValue(selection, relation.propertyPath) : undefined, relation.inverseEntityMetadata, joinAlias, undefined);\n        }\n      }\n    });\n  }\n  buildOrder(order, metadata, alias, embedPrefix) {\n    for (let key in order) {\n      if (order[key] === undefined) continue;\n      const propertyPath = embedPrefix ? embedPrefix + \".\" + key : key;\n      const column = metadata.findColumnWithPropertyPathStrict(propertyPath);\n      const embed = metadata.findEmbeddedWithPropertyPath(propertyPath);\n      const relation = metadata.findRelationWithPropertyPath(propertyPath);\n      if (!embed && !column && !relation) throw new EntityPropertyNotFoundError(propertyPath, metadata);\n      if (column) {\n        let direction = typeof order[key] === \"object\" ? order[key].direction : order[key];\n        direction = direction === \"DESC\" || direction === \"desc\" || direction === -1 ? \"DESC\" : \"ASC\";\n        let nulls = typeof order[key] === \"object\" ? order[key].nulls : undefined;\n        nulls = (nulls === null || nulls === void 0 ? void 0 : nulls.toLowerCase()) === \"first\" ? \"NULLS FIRST\" : (nulls === null || nulls === void 0 ? void 0 : nulls.toLowerCase()) === \"last\" ? \"NULLS LAST\" : undefined;\n        let aliasPath = `${alias}.${propertyPath}`;\n        // const selection = this.expressionMap.selects.find(\n        //     (s) => s.selection === aliasPath,\n        // )\n        // if (selection) {\n        //     // this is not building correctly now???\n        //     aliasPath = this.escape(\n        //         DriverUtils.buildAlias(\n        //             this.connection.driver,\n        //             undefined,\n        //             alias,\n        //             column.databaseName,\n        //         ),\n        //     )\n        //     // selection.aliasName = aliasPath\n        // } else {\n        //     if (column.isVirtualProperty && column.query) {\n        //         aliasPath = `(${column.query(alias)})`\n        //     }\n        // }\n        // console.log(\"add sort\", selection, aliasPath, direction, nulls)\n        this.addOrderBy(aliasPath, direction, nulls);\n        // this.orderBys.push({ alias: alias + \".\" + propertyPath, direction, nulls });\n      } else if (embed) {\n        this.buildOrder(order[key], metadata, alias, propertyPath);\n      } else if (relation) {\n        let joinAlias = alias + \"_\" + propertyPath.replace(\".\", \"_\");\n        joinAlias = DriverUtils.buildAlias(this.connection.driver, {\n          joiner: \"__\"\n        }, alias, joinAlias);\n        // console.log(\"joinAlias\", joinAlias, joinAlias.length, this.connection.driver.maxAliasLength)\n        // todo: use expressionMap.joinAttributes, and create a new one using\n        //  const joinAttribute = new JoinAttribute(this.connection, this.expressionMap);\n        const existJoin = this.joins.find(join => join.alias === joinAlias);\n        if (!existJoin) {\n          this.joins.push({\n            type: \"left\",\n            select: false,\n            alias: joinAlias,\n            parentAlias: alias,\n            selection: undefined,\n            relationMetadata: relation\n          });\n        }\n        this.buildOrder(order[key], relation.inverseEntityMetadata, joinAlias);\n      }\n    }\n  }\n  buildWhere(where, metadata, alias, embedPrefix) {\n    let condition = \"\";\n    // let parameterIndex = Object.keys(this.expressionMap.nativeParameters).length;\n    if (Array.isArray(where) && where.length) {\n      condition = \"(\" + where.map(whereItem => {\n        return this.buildWhere(whereItem, metadata, alias, embedPrefix);\n      }).filter(condition => !!condition).map(condition => \"(\" + condition + \")\").join(\" OR \") + \")\";\n    } else {\n      let andConditions = [];\n      for (let key in where) {\n        if (where[key] === undefined || where[key] === null) continue;\n        const propertyPath = embedPrefix ? embedPrefix + \".\" + key : key;\n        const column = metadata.findColumnWithPropertyPathStrict(propertyPath);\n        const embed = metadata.findEmbeddedWithPropertyPath(propertyPath);\n        const relation = metadata.findRelationWithPropertyPath(propertyPath);\n        if (!embed && !column && !relation) throw new EntityPropertyNotFoundError(propertyPath, metadata);\n        if (column) {\n          let aliasPath = `${alias}.${propertyPath}`;\n          if (column.isVirtualProperty && column.query) {\n            aliasPath = `(${column.query(alias)})`;\n          }\n          // const parameterName = alias + \"_\" + propertyPath.split(\".\").join(\"_\") + \"_\" + parameterIndex;\n          // todo: we need to handle other operators as well?\n          let parameterValue = where[key];\n          if (InstanceChecker.isEqualOperator(where[key])) {\n            parameterValue = where[key].value;\n          }\n          if (column.transformer) {\n            parameterValue instanceof FindOperator ? parameterValue.transformValue(column.transformer) : parameterValue = ApplyValueTransformers.transformTo(column.transformer, parameterValue);\n          }\n          // if (parameterValue === null) {\n          //     andConditions.push(`${aliasPath} IS NULL`);\n          //\n          // } else if (parameterValue instanceof FindOperator) {\n          //     // let parameters: any[] = [];\n          //     // if (parameterValue.useParameter) {\n          //     //     const realParameterValues: any[] = parameterValue.multipleParameters ? parameterValue.value : [parameterValue.value];\n          //     //     realParameterValues.forEach((realParameterValue, realParameterValueIndex) => {\n          //     //\n          //     //         // don't create parameters for number to prevent max number of variables issues as much as possible\n          //     //         if (typeof realParameterValue === \"number\") {\n          //     //             parameters.push(realParameterValue);\n          //     //\n          //     //         } else {\n          //     //             this.expressionMap.nativeParameters[parameterName + realParameterValueIndex] = realParameterValue;\n          //     //             parameterIndex++;\n          //     //             parameters.push(this.connection.driver.createParameter(parameterName + realParameterValueIndex, parameterIndex - 1));\n          //     //         }\n          //     //     });\n          //     // }\n          //     andConditions.push(\n          //         this.createWhereConditionExpression(this.getWherePredicateCondition(aliasPath, parameterValue))\n          //         // parameterValue.toSql(this.connection, aliasPath, parameters));\n          //     )\n          //\n          // } else {\n          //     this.expressionMap.nativeParameters[parameterName] = parameterValue;\n          //     parameterIndex++;\n          //     const parameter = this.connection.driver.createParameter(parameterName, parameterIndex - 1);\n          //     andConditions.push(`${aliasPath} = ${parameter}`);\n          // }\n          andConditions.push(this.createWhereConditionExpression(this.getWherePredicateCondition(aliasPath, parameterValue)));\n          // this.conditions.push(`${alias}.${propertyPath} = :${paramName}`);\n          // this.expressionMap.parameters[paramName] = where[key]; // todo: handle functions and other edge cases\n        } else if (embed) {\n          const condition = this.buildWhere(where[key], metadata, alias, propertyPath);\n          if (condition) andConditions.push(condition);\n        } else if (relation) {\n          // if all properties of where are undefined we don't need to join anything\n          // this can happen when user defines map with conditional queries inside\n          if (typeof where[key] === \"object\") {\n            const allAllUndefined = Object.keys(where[key]).every(k => where[key][k] === undefined);\n            if (allAllUndefined) {\n              continue;\n            }\n          }\n          if (InstanceChecker.isFindOperator(where[key])) {\n            if (where[key].type === \"moreThan\" || where[key].type === \"lessThan\" || where[key].type === \"moreThanOrEqual\" || where[key].type === \"lessThanOrEqual\") {\n              let sqlOperator = \"\";\n              if (where[key].type === \"moreThan\") {\n                sqlOperator = \">\";\n              } else if (where[key].type === \"lessThan\") {\n                sqlOperator = \"<\";\n              } else if (where[key].type === \"moreThanOrEqual\") {\n                sqlOperator = \">=\";\n              } else if (where[key].type === \"lessThanOrEqual\") {\n                sqlOperator = \"<=\";\n              }\n              // basically relation count functionality\n              const qb = this.subQuery();\n              if (relation.isManyToManyOwner) {\n                qb.select(\"COUNT(*)\").from(relation.joinTableName, relation.joinTableName).where(relation.joinColumns.map(column => {\n                  return `${relation.joinTableName}.${column.propertyName} = ${alias}.${column.referencedColumn.propertyName}`;\n                }).join(\" AND \"));\n              } else if (relation.isManyToManyNotOwner) {\n                qb.select(\"COUNT(*)\").from(relation.inverseRelation.joinTableName, relation.inverseRelation.joinTableName).where(relation.inverseRelation.inverseJoinColumns.map(column => {\n                  return `${relation.inverseRelation.joinTableName}.${column.propertyName} = ${alias}.${column.referencedColumn.propertyName}`;\n                }).join(\" AND \"));\n              } else if (relation.isOneToMany) {\n                qb.select(\"COUNT(*)\").from(relation.inverseEntityMetadata.target, relation.inverseEntityMetadata.tableName).where(relation.inverseRelation.joinColumns.map(column => {\n                  return `${relation.inverseEntityMetadata.tableName}.${column.propertyName} = ${alias}.${column.referencedColumn.propertyName}`;\n                }).join(\" AND \"));\n              } else {\n                throw new Error(`This relation isn't supported by given find operator`);\n              }\n              // this\n              //     .addSelect(qb.getSql(), relation.propertyAliasName + \"_cnt\")\n              //     .andWhere(this.escape(relation.propertyAliasName + \"_cnt\") + \" \" + sqlOperator + \" \" + parseInt(where[key].value));\n              this.andWhere(qb.getSql() + \" \" + sqlOperator + \" \" + parseInt(where[key].value));\n            } else {\n              if (relation.isManyToOne || relation.isOneToOne && relation.isOneToOneOwner) {\n                const aliasPath = `${alias}.${propertyPath}`;\n                andConditions.push(this.createWhereConditionExpression(this.getWherePredicateCondition(aliasPath, where[key])));\n              } else {\n                throw new Error(`This relation isn't supported by given find operator`);\n              }\n            }\n          } else {\n            // const joinAlias = alias + \"_\" + relation.propertyName;\n            let joinAlias = alias + \"_\" + relation.propertyPath.replace(\".\", \"_\");\n            joinAlias = DriverUtils.buildAlias(this.connection.driver, {\n              joiner: \"__\"\n            }, alias, joinAlias);\n            const existJoin = this.joins.find(join => join.alias === joinAlias);\n            if (!existJoin) {\n              this.joins.push({\n                type: \"left\",\n                select: false,\n                selection: undefined,\n                alias: joinAlias,\n                parentAlias: alias,\n                relationMetadata: relation\n              });\n            }\n            const condition = this.buildWhere(where[key], relation.inverseEntityMetadata, joinAlias);\n            if (condition) {\n              andConditions.push(condition);\n              // parameterIndex = Object.keys(this.expressionMap.nativeParameters).length;\n            }\n          }\n        }\n      }\n\n      condition = andConditions.join(\" AND \");\n    }\n    return condition;\n  }\n}","map":{"version":3,"names":["RawSqlResultsToEntityTransformer","PessimisticLockTransactionRequiredError","NoVersionOrUpdateDateColumnError","OptimisticLockVersionMismatchError","OptimisticLockCanNotBeUsedError","JoinAttribute","RelationIdAttribute","RelationCountAttribute","RelationIdLoader","QueryStrategyRelationIdLoader","RelationIdMetadataToAttributeTransformer","RelationCountLoader","RelationCountMetadataToAttributeTransformer","QueryBuilder","LockNotSupportedOnGivenDriverError","OffsetWithoutLimitNotSupportedError","ObjectUtils","DriverUtils","EntityNotFoundError","TypeORMError","FindOptionsUtils","OrmUtils","EntityPropertyNotFoundError","InstanceChecker","FindOperator","ApplyValueTransformers","SelectQueryBuilder","constructor","arguments","Symbol","for","findOptions","selects","joins","conditions","orderBys","relationMetadatas","getQuery","sql","createComment","createCteExpression","createSelectExpression","createJoinExpression","createWhereExpression","createGroupByExpression","createHavingExpression","createOrderByExpression","createLimitOffsetExpression","createLockExpression","trim","expressionMap","subQuery","replacePropertyNamesForTheWholeQuery","setFindOptions","applyFindOptions","qb","createQueryBuilder","parentQueryBuilder","select","selection","selectionAliasName","queryType","Array","isArray","map","subQueryBuilder","setParameters","getParameters","push","aliasName","addSelect","concat","maxExecutionTime","milliseconds","distinct","selectDistinct","distinctOn","selectDistinctOn","fromDummy","_a","from","connection","driver","dummyTableName","entityTarget","mainAlias","createFromAlias","setMainAlias","addFrom","alias","innerJoin","entityOrProperty","condition","parameters","join","leftJoin","innerJoinAndSelect","leftJoinAndSelect","innerJoinAndMapMany","mapToProperty","innerJoinAndMapOne","mapAsEntity","leftJoinAndMapMany","leftJoinAndMapOne","loadRelationIdAndMap","relationName","aliasNameOrOptions","queryBuilderFactory","relationIdAttribute","disableMixedMap","relationIdAttributes","relation","junctionEntityMetadata","createAlias","type","name","junctionAlias","metadata","loadRelationCountAndMap","relationCountAttribute","relationCountAttributes","loadAllRelationIds","options","relations","forEach","undefined","indexOf","propertyPath","where","wheres","getWhereCondition","andWhere","orWhere","whereExists","getExistsCondition","andWhereExists","orWhereExists","whereInIds","ids","getWhereInIdsCondition","andWhereInIds","orWhereInIds","having","havings","andHaving","orHaving","groupBy","groupBys","addGroupBy","timeTravelQuery","timeTravelFn","timeTravel","orderBy","sort","order","nulls","addOrderBy","limit","normalizeNumber","isNaN","offset","take","skip","useIndex","index","setLock","lockMode","lockVersion","lockTables","setOnLocked","onLocked","withDeleted","getRawOne","_this","_asyncToGenerator","getRawMany","_this2","queryEntity","queryRunner","obtainQueryRunner","transactionStartedByUs","useTransaction","isTransactionActive","startTransaction","results","loadRawResults","commitTransaction","error","rollbackTransaction","rollbackError","release","getRawAndEntities","_this3","executeEntitiesAndRawResults","getOne","_this4","result","entities","Date","actualVersion","updateDateColumn","getEntityValue","getTime","versionColumn","getOneOrFail","_this5","entity","target","getMany","_this6","getCount","_this7","executeCountQuery","getExists","_this8","executeExistsQuery","getManyAndCount","_this9","entitiesAndRaw","cacheId","count","stream","_this10","getQueryAndParameters","releaseFn","cache","enabledOrMillisecondsOrId","maybeMilliseconds","cacheDuration","setOption","option","direction","isMappingMany","joinAttribute","joinAttributes","joinAttributeMetadata","deleteDateColumn","conditionDeleteColumn","propertyName","isSubQuery","substr","tablePath","allSelects","excludedSelects","hasMetadata","buildEscapedEntityColumnSelects","findEntityColumnSelects","hasMainAlias","some","escape","excludedSelect","find","filter","replacePropertyNames","length","isMySQLFamily","froms","aliases","getTableName","createSelectDistinctExpression","createTableLockExpression","isPostgresFamily","selectDistinctOnMap","on","joinAttr","destinationTableName","destinationTableAlias","appendedCondition","parentAlias","destinationJoin","isManyToOne","isOneToOneOwner","joinColumns","joinColumn","referencedColumn","isOneToMany","isOneToOneNotOwner","inverseRelation","inverseEntityMetadata","tableType","discriminatorColumn","databaseName","discriminatorValue","junctionTableName","junctionCondition","destinationCondition","isOwning","inverseJoinColumns","allOrderBys","Object","keys","columnName","orderValue","s","criteriaParts","split","slice","column","findColumnWithPropertyPath","orderAlias","buildAlias","prefix","isSQLiteFamily","lockTablesClause","onLockExpression","isReleaseVersionOrGreater","columns","isSelect","nonSelectedPrimaryColumns","primaryColumns","primaryColumn","allColumns","finalSelects","escapedAliasName","selectionPath","isVirtualProperty","query","spatialTypes","useLegacy","legacySpatialSupport","asText","precision","selections","virtual","mainSelect","computeCountExpression","distinctAlias","c","columnsExpression","_this11","countSql","clone","parseInt","_this12","relationLoadStrategy","comment","propertyPathsToTruthyObject","buildSelect","buildRelations","loadEagerRelations","buildEagerRelations","buildWhere","buildOrder","relationMetadata","id","key","lock","mode","version","tableNames","tables","table","tableAlias","tableNameWithoutPrefix","loadRelationIds","joinEagerRelations","transaction","concatRelationMetadata","_this13","relationIdLoader","relationCountLoader","relationIdMetadataTransformer","transform","relationCountMetadataTransformer","rawResults","createOrderByCombinedWithSelectExpression","mainAliasName","querySelects","columnAlias","originalQuery","originalQueryTimeTravel","setNativeParameters","nativeParameters","hasMultiplePrimaryKeys","paramKey","paramKeyResult","areAllNumbers","every","mergeExpressionMap","extraAppendedAndWhereCondition","rawRelationIdResults","load","rawRelationCountResults","transformer","callListeners","broadcaster","broadcast","queryStrategyRelationIdLoader","Promise","all","_ref","relationTarget","relationAlias","targetName","queryBuilder","deepValue","relatedEntityGroups","loadManyToManyRelationIdsAndGroup","relatedEntityGroup","group","value","related","setEntityValue","_x","apply","raw","selectString","orderCriteria","findAliasByName","orderByObject","_this14","queryId","JSON","stringify","cacheOptions","savedQueryResultCacheOptions","isCachingEnabled","alwaysEnabled","cacheError","queryResultCache","getFromCache","identifier","duration","isExpired","parse","ignoreErrors","storeInCache","time","records","assign","num","Number","createQueryRunner","embedPrefix","findColumnWithPropertyPathStrict","embed","findEmbeddedWithPropertyPath","findRelationWithPropertyPath","relationValue","joinAlias","replace","joiner","eagerRelations","eagerRelation","eagerRelationJoinAlias","existJoin","toLowerCase","aliasPath","whereItem","andConditions","parameterValue","isEqualOperator","transformValue","transformTo","createWhereConditionExpression","getWherePredicateCondition","allAllUndefined","k","isFindOperator","sqlOperator","isManyToManyOwner","joinTableName","isManyToManyNotOwner","tableName","Error","getSql","isOneToOne"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/query-builder/SelectQueryBuilder.js"],"sourcesContent":["import { RawSqlResultsToEntityTransformer } from \"./transformer/RawSqlResultsToEntityTransformer\";\nimport { PessimisticLockTransactionRequiredError } from \"../error/PessimisticLockTransactionRequiredError\";\nimport { NoVersionOrUpdateDateColumnError } from \"../error/NoVersionOrUpdateDateColumnError\";\nimport { OptimisticLockVersionMismatchError } from \"../error/OptimisticLockVersionMismatchError\";\nimport { OptimisticLockCanNotBeUsedError } from \"../error/OptimisticLockCanNotBeUsedError\";\nimport { JoinAttribute } from \"./JoinAttribute\";\nimport { RelationIdAttribute } from \"./relation-id/RelationIdAttribute\";\nimport { RelationCountAttribute } from \"./relation-count/RelationCountAttribute\";\nimport { RelationIdLoader } from \"./relation-id/RelationIdLoader\";\nimport { RelationIdLoader as QueryStrategyRelationIdLoader } from \"./RelationIdLoader\";\nimport { RelationIdMetadataToAttributeTransformer } from \"./relation-id/RelationIdMetadataToAttributeTransformer\";\nimport { RelationCountLoader } from \"./relation-count/RelationCountLoader\";\nimport { RelationCountMetadataToAttributeTransformer } from \"./relation-count/RelationCountMetadataToAttributeTransformer\";\nimport { QueryBuilder } from \"./QueryBuilder\";\nimport { LockNotSupportedOnGivenDriverError } from \"../error/LockNotSupportedOnGivenDriverError\";\nimport { OffsetWithoutLimitNotSupportedError } from \"../error/OffsetWithoutLimitNotSupportedError\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\nimport { EntityNotFoundError } from \"../error/EntityNotFoundError\";\nimport { TypeORMError } from \"../error\";\nimport { FindOptionsUtils } from \"../find-options/FindOptionsUtils\";\nimport { OrmUtils } from \"../util/OrmUtils\";\nimport { EntityPropertyNotFoundError } from \"../error/EntityPropertyNotFoundError\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\nimport { FindOperator } from \"../find-options/FindOperator\";\nimport { ApplyValueTransformers } from \"../util/ApplyValueTransformers\";\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\nexport class SelectQueryBuilder extends QueryBuilder {\n    constructor() {\n        super(...arguments);\n        this[\"@instanceof\"] = Symbol.for(\"SelectQueryBuilder\");\n        this.findOptions = {};\n        this.selects = [];\n        this.joins = [];\n        this.conditions = \"\";\n        this.orderBys = [];\n        this.relationMetadatas = [];\n    }\n    // -------------------------------------------------------------------------\n    // Public Implemented Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Gets generated SQL query without parameters being replaced.\n     */\n    getQuery() {\n        let sql = this.createComment();\n        sql += this.createCteExpression();\n        sql += this.createSelectExpression();\n        sql += this.createJoinExpression();\n        sql += this.createWhereExpression();\n        sql += this.createGroupByExpression();\n        sql += this.createHavingExpression();\n        sql += this.createOrderByExpression();\n        sql += this.createLimitOffsetExpression();\n        sql += this.createLockExpression();\n        sql = sql.trim();\n        if (this.expressionMap.subQuery)\n            sql = \"(\" + sql + \")\";\n        return this.replacePropertyNamesForTheWholeQuery(sql);\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    setFindOptions(findOptions) {\n        this.findOptions = findOptions;\n        this.applyFindOptions();\n        return this;\n    }\n    /**\n     * Creates a subquery - query that can be used inside other queries.\n     */\n    subQuery() {\n        const qb = this.createQueryBuilder();\n        qb.expressionMap.subQuery = true;\n        qb.parentQueryBuilder = this;\n        return qb;\n    }\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all previous selections if they exist.\n     */\n    select(selection, selectionAliasName) {\n        this.expressionMap.queryType = \"select\";\n        if (Array.isArray(selection)) {\n            this.expressionMap.selects = selection.map((selection) => ({\n                selection: selection,\n            }));\n        }\n        else if (typeof selection === \"function\") {\n            const subQueryBuilder = selection(this.subQuery());\n            this.setParameters(subQueryBuilder.getParameters());\n            this.expressionMap.selects.push({\n                selection: subQueryBuilder.getQuery(),\n                aliasName: selectionAliasName,\n            });\n        }\n        else if (selection) {\n            this.expressionMap.selects = [\n                { selection: selection, aliasName: selectionAliasName },\n            ];\n        }\n        return this;\n    }\n    /**\n     * Adds new selection to the SELECT query.\n     */\n    addSelect(selection, selectionAliasName) {\n        if (!selection)\n            return this;\n        if (Array.isArray(selection)) {\n            this.expressionMap.selects = this.expressionMap.selects.concat(selection.map((selection) => ({ selection: selection })));\n        }\n        else if (typeof selection === \"function\") {\n            const subQueryBuilder = selection(this.subQuery());\n            this.setParameters(subQueryBuilder.getParameters());\n            this.expressionMap.selects.push({\n                selection: subQueryBuilder.getQuery(),\n                aliasName: selectionAliasName,\n            });\n        }\n        else if (selection) {\n            this.expressionMap.selects.push({\n                selection: selection,\n                aliasName: selectionAliasName,\n            });\n        }\n        return this;\n    }\n    /**\n     * Set max execution time.\n     * @param milliseconds\n     */\n    maxExecutionTime(milliseconds) {\n        this.expressionMap.maxExecutionTime = milliseconds;\n        return this;\n    }\n    /**\n     * Sets whether the selection is DISTINCT.\n     */\n    distinct(distinct = true) {\n        this.expressionMap.selectDistinct = distinct;\n        return this;\n    }\n    /**\n     * Sets the distinct on clause for Postgres.\n     */\n    distinctOn(distinctOn) {\n        this.expressionMap.selectDistinctOn = distinctOn;\n        return this;\n    }\n    fromDummy() {\n        var _a;\n        return this.from((_a = this.connection.driver.dummyTableName) !== null && _a !== void 0 ? _a : \"(SELECT 1 AS dummy_column)\", \"dummy_table\");\n    }\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     * Removes all previously set from-s.\n     */\n    from(entityTarget, aliasName) {\n        const mainAlias = this.createFromAlias(entityTarget, aliasName);\n        this.expressionMap.setMainAlias(mainAlias);\n        return this;\n    }\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     */\n    addFrom(entityTarget, aliasName) {\n        const alias = this.createFromAlias(entityTarget, aliasName);\n        if (!this.expressionMap.mainAlias)\n            this.expressionMap.setMainAlias(alias);\n        return this;\n    }\n    /**\n     * INNER JOINs (without selection).\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoin(entityOrProperty, alias, condition, parameters) {\n        this.join(\"INNER\", entityOrProperty, alias, condition, parameters);\n        return this;\n    }\n    /**\n     * LEFT JOINs (without selection).\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoin(entityOrProperty, alias, condition, parameters) {\n        this.join(\"LEFT\", entityOrProperty, alias, condition, parameters);\n        return this;\n    }\n    /**\n     * INNER JOINs and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndSelect(entityOrProperty, alias, condition, parameters) {\n        this.addSelect(alias);\n        this.innerJoin(entityOrProperty, alias, condition, parameters);\n        return this;\n    }\n    /**\n     * LEFT JOINs and adds all selection properties to SELECT.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndSelect(entityOrProperty, alias, condition, parameters) {\n        this.addSelect(alias);\n        this.leftJoin(entityOrProperty, alias, condition, parameters);\n        return this;\n    }\n    /**\n     * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapMany(mapToProperty, entityOrProperty, alias, condition, parameters) {\n        this.addSelect(alias);\n        this.join(\"INNER\", entityOrProperty, alias, condition, parameters, mapToProperty, true);\n        return this;\n    }\n    /**\n     * INNER JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    innerJoinAndMapOne(mapToProperty, entityOrProperty, alias, condition, parameters, mapAsEntity) {\n        this.addSelect(alias);\n        this.join(\"INNER\", entityOrProperty, alias, condition, parameters, mapToProperty, false, mapAsEntity);\n        return this;\n    }\n    /**\n     * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there are multiple rows of selecting data, and mapped result will be an array.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapMany(mapToProperty, entityOrProperty, alias, condition, parameters) {\n        this.addSelect(alias);\n        this.join(\"LEFT\", entityOrProperty, alias, condition, parameters, mapToProperty, true);\n        return this;\n    }\n    /**\n     * LEFT JOINs, SELECTs the data returned by a join and MAPs all that data to some entity's property.\n     * This is extremely useful when you want to select some data and map it to some virtual property.\n     * It will assume that there is a single row of selecting data, and mapped result will be a single selected value.\n     * You also need to specify an alias of the joined data.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    leftJoinAndMapOne(mapToProperty, entityOrProperty, alias, condition, parameters, mapAsEntity) {\n        this.addSelect(alias);\n        this.join(\"LEFT\", entityOrProperty, alias, condition, parameters, mapToProperty, false, mapAsEntity);\n        return this;\n    }\n    /**\n     * LEFT JOINs relation id and maps it into some entity's property.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    loadRelationIdAndMap(mapToProperty, relationName, aliasNameOrOptions, queryBuilderFactory) {\n        const relationIdAttribute = new RelationIdAttribute(this.expressionMap);\n        relationIdAttribute.mapToProperty = mapToProperty;\n        relationIdAttribute.relationName = relationName;\n        if (typeof aliasNameOrOptions === \"string\")\n            relationIdAttribute.alias = aliasNameOrOptions;\n        if (typeof aliasNameOrOptions === \"object\" &&\n            aliasNameOrOptions.disableMixedMap)\n            relationIdAttribute.disableMixedMap = true;\n        relationIdAttribute.queryBuilderFactory = queryBuilderFactory;\n        this.expressionMap.relationIdAttributes.push(relationIdAttribute);\n        if (relationIdAttribute.relation.junctionEntityMetadata) {\n            this.expressionMap.createAlias({\n                type: \"other\",\n                name: relationIdAttribute.junctionAlias,\n                metadata: relationIdAttribute.relation.junctionEntityMetadata,\n            });\n        }\n        return this;\n    }\n    /**\n     * Counts number of entities of entity's relation and maps the value into some entity's property.\n     * Optionally, you can add condition and parameters used in condition.\n     */\n    loadRelationCountAndMap(mapToProperty, relationName, aliasName, queryBuilderFactory) {\n        const relationCountAttribute = new RelationCountAttribute(this.expressionMap);\n        relationCountAttribute.mapToProperty = mapToProperty;\n        relationCountAttribute.relationName = relationName;\n        relationCountAttribute.alias = aliasName;\n        relationCountAttribute.queryBuilderFactory = queryBuilderFactory;\n        this.expressionMap.relationCountAttributes.push(relationCountAttribute);\n        this.expressionMap.createAlias({\n            type: \"other\",\n            name: relationCountAttribute.junctionAlias,\n        });\n        if (relationCountAttribute.relation.junctionEntityMetadata) {\n            this.expressionMap.createAlias({\n                type: \"other\",\n                name: relationCountAttribute.junctionAlias,\n                metadata: relationCountAttribute.relation.junctionEntityMetadata,\n            });\n        }\n        return this;\n    }\n    /**\n     * Loads all relation ids for all relations of the selected entity.\n     * All relation ids will be mapped to relation property themself.\n     * If array of strings is given then loads only relation ids of the given properties.\n     */\n    loadAllRelationIds(options) {\n        // todo: add skip relations\n        this.expressionMap.mainAlias.metadata.relations.forEach((relation) => {\n            if (options !== undefined &&\n                options.relations !== undefined &&\n                options.relations.indexOf(relation.propertyPath) === -1)\n                return;\n            this.loadRelationIdAndMap(this.expressionMap.mainAlias.name +\n                \".\" +\n                relation.propertyPath, this.expressionMap.mainAlias.name +\n                \".\" +\n                relation.propertyPath, options);\n        });\n        return this;\n    }\n    /**\n     * Sets WHERE condition in the query builder.\n     * If you had previously WHERE expression defined,\n     * calling this function will override previously set WHERE conditions.\n     * Additionally you can add parameters used in where expression.\n     */\n    where(where, parameters) {\n        this.expressionMap.wheres = []; // don't move this block below since computeWhereParameter can add where expressions\n        const condition = this.getWhereCondition(where);\n        if (condition) {\n            this.expressionMap.wheres = [\n                { type: \"simple\", condition: condition },\n            ];\n        }\n        if (parameters)\n            this.setParameters(parameters);\n        return this;\n    }\n    /**\n     * Adds new AND WHERE condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    andWhere(where, parameters) {\n        this.expressionMap.wheres.push({\n            type: \"and\",\n            condition: this.getWhereCondition(where),\n        });\n        if (parameters)\n            this.setParameters(parameters);\n        return this;\n    }\n    /**\n     * Adds new OR WHERE condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    orWhere(where, parameters) {\n        this.expressionMap.wheres.push({\n            type: \"or\",\n            condition: this.getWhereCondition(where),\n        });\n        if (parameters)\n            this.setParameters(parameters);\n        return this;\n    }\n    /**\n     * Sets a new where EXISTS clause\n     */\n    whereExists(subQuery) {\n        return this.where(...this.getExistsCondition(subQuery));\n    }\n    /**\n     * Adds a new AND where EXISTS clause\n     */\n    andWhereExists(subQuery) {\n        return this.andWhere(...this.getExistsCondition(subQuery));\n    }\n    /**\n     * Adds a new OR where EXISTS clause\n     */\n    orWhereExists(subQuery) {\n        return this.orWhere(...this.getExistsCondition(subQuery));\n    }\n    /**\n     * Adds new AND WHERE with conditions for the given ids.\n     *\n     * Ids are mixed.\n     * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\n     * If you have multiple primary keys you need to pass object with property names and values specified,\n     * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\n     */\n    whereInIds(ids) {\n        return this.where(this.getWhereInIdsCondition(ids));\n    }\n    /**\n     * Adds new AND WHERE with conditions for the given ids.\n     *\n     * Ids are mixed.\n     * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\n     * If you have multiple primary keys you need to pass object with property names and values specified,\n     * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\n     */\n    andWhereInIds(ids) {\n        return this.andWhere(this.getWhereInIdsCondition(ids));\n    }\n    /**\n     * Adds new OR WHERE with conditions for the given ids.\n     *\n     * Ids are mixed.\n     * It means if you have single primary key you can pass a simple id values, for example [1, 2, 3].\n     * If you have multiple primary keys you need to pass object with property names and values specified,\n     * for example [{ firstId: 1, secondId: 2 }, { firstId: 2, secondId: 3 }, ...]\n     */\n    orWhereInIds(ids) {\n        return this.orWhere(this.getWhereInIdsCondition(ids));\n    }\n    /**\n     * Sets HAVING condition in the query builder.\n     * If you had previously HAVING expression defined,\n     * calling this function will override previously set HAVING conditions.\n     * Additionally you can add parameters used in where expression.\n     */\n    having(having, parameters) {\n        this.expressionMap.havings.push({ type: \"simple\", condition: having });\n        if (parameters)\n            this.setParameters(parameters);\n        return this;\n    }\n    /**\n     * Adds new AND HAVING condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    andHaving(having, parameters) {\n        this.expressionMap.havings.push({ type: \"and\", condition: having });\n        if (parameters)\n            this.setParameters(parameters);\n        return this;\n    }\n    /**\n     * Adds new OR HAVING condition in the query builder.\n     * Additionally you can add parameters used in where expression.\n     */\n    orHaving(having, parameters) {\n        this.expressionMap.havings.push({ type: \"or\", condition: having });\n        if (parameters)\n            this.setParameters(parameters);\n        return this;\n    }\n    /**\n     * Sets GROUP BY condition in the query builder.\n     * If you had previously GROUP BY expression defined,\n     * calling this function will override previously set GROUP BY conditions.\n     */\n    groupBy(groupBy) {\n        if (groupBy) {\n            this.expressionMap.groupBys = [groupBy];\n        }\n        else {\n            this.expressionMap.groupBys = [];\n        }\n        return this;\n    }\n    /**\n     * Adds GROUP BY condition in the query builder.\n     */\n    addGroupBy(groupBy) {\n        this.expressionMap.groupBys.push(groupBy);\n        return this;\n    }\n    /**\n     * Enables time travelling for the current query (only supported by cockroach currently)\n     */\n    timeTravelQuery(timeTravelFn) {\n        if (this.connection.driver.options.type === \"cockroachdb\") {\n            if (timeTravelFn === undefined) {\n                this.expressionMap.timeTravel = \"follower_read_timestamp()\";\n            }\n            else {\n                this.expressionMap.timeTravel = timeTravelFn;\n            }\n        }\n        return this;\n    }\n    /**\n     * Sets ORDER BY condition in the query builder.\n     * If you had previously ORDER BY expression defined,\n     * calling this function will override previously set ORDER BY conditions.\n     */\n    orderBy(sort, order = \"ASC\", nulls) {\n        if (order !== undefined && order !== \"ASC\" && order !== \"DESC\")\n            throw new TypeORMError(`SelectQueryBuilder.addOrderBy \"order\" can accept only \"ASC\" and \"DESC\" values.`);\n        if (nulls !== undefined &&\n            nulls !== \"NULLS FIRST\" &&\n            nulls !== \"NULLS LAST\")\n            throw new TypeORMError(`SelectQueryBuilder.addOrderBy \"nulls\" can accept only \"NULLS FIRST\" and \"NULLS LAST\" values.`);\n        if (sort) {\n            if (typeof sort === \"object\") {\n                this.expressionMap.orderBys = sort;\n            }\n            else {\n                if (nulls) {\n                    this.expressionMap.orderBys = {\n                        [sort]: { order, nulls },\n                    };\n                }\n                else {\n                    this.expressionMap.orderBys = { [sort]: order };\n                }\n            }\n        }\n        else {\n            this.expressionMap.orderBys = {};\n        }\n        return this;\n    }\n    /**\n     * Adds ORDER BY condition in the query builder.\n     */\n    addOrderBy(sort, order = \"ASC\", nulls) {\n        if (order !== undefined && order !== \"ASC\" && order !== \"DESC\")\n            throw new TypeORMError(`SelectQueryBuilder.addOrderBy \"order\" can accept only \"ASC\" and \"DESC\" values.`);\n        if (nulls !== undefined &&\n            nulls !== \"NULLS FIRST\" &&\n            nulls !== \"NULLS LAST\")\n            throw new TypeORMError(`SelectQueryBuilder.addOrderBy \"nulls\" can accept only \"NULLS FIRST\" and \"NULLS LAST\" values.`);\n        if (nulls) {\n            this.expressionMap.orderBys[sort] = { order, nulls };\n        }\n        else {\n            this.expressionMap.orderBys[sort] = order;\n        }\n        return this;\n    }\n    /**\n     * Set's LIMIT - maximum number of rows to be selected.\n     * NOTE that it may not work as you expect if you are using joins.\n     * If you want to implement pagination, and you are having join in your query,\n     * then use instead take method instead.\n     */\n    limit(limit) {\n        this.expressionMap.limit = this.normalizeNumber(limit);\n        if (this.expressionMap.limit !== undefined &&\n            isNaN(this.expressionMap.limit))\n            throw new TypeORMError(`Provided \"limit\" value is not a number. Please provide a numeric value.`);\n        return this;\n    }\n    /**\n     * Set's OFFSET - selection offset.\n     * NOTE that it may not work as you expect if you are using joins.\n     * If you want to implement pagination, and you are having join in your query,\n     * then use instead skip method instead.\n     */\n    offset(offset) {\n        this.expressionMap.offset = this.normalizeNumber(offset);\n        if (this.expressionMap.offset !== undefined &&\n            isNaN(this.expressionMap.offset))\n            throw new TypeORMError(`Provided \"offset\" value is not a number. Please provide a numeric value.`);\n        return this;\n    }\n    /**\n     * Sets maximal number of entities to take.\n     */\n    take(take) {\n        this.expressionMap.take = this.normalizeNumber(take);\n        if (this.expressionMap.take !== undefined &&\n            isNaN(this.expressionMap.take))\n            throw new TypeORMError(`Provided \"take\" value is not a number. Please provide a numeric value.`);\n        return this;\n    }\n    /**\n     * Sets number of entities to skip.\n     */\n    skip(skip) {\n        this.expressionMap.skip = this.normalizeNumber(skip);\n        if (this.expressionMap.skip !== undefined &&\n            isNaN(this.expressionMap.skip))\n            throw new TypeORMError(`Provided \"skip\" value is not a number. Please provide a numeric value.`);\n        return this;\n    }\n    /**\n     * Set certain index to be used by the query.\n     *\n     * @param index Name of index to be used.\n     */\n    useIndex(index) {\n        this.expressionMap.useIndex = index;\n        return this;\n    }\n    /**\n     * Sets locking mode.\n     */\n    setLock(lockMode, lockVersion, lockTables) {\n        this.expressionMap.lockMode = lockMode;\n        this.expressionMap.lockVersion = lockVersion;\n        this.expressionMap.lockTables = lockTables;\n        return this;\n    }\n    /**\n     * Sets lock handling by adding NO WAIT or SKIP LOCKED.\n     */\n    setOnLocked(onLocked) {\n        this.expressionMap.onLocked = onLocked;\n        return this;\n    }\n    /**\n     * Disables the global condition of \"non-deleted\" for the entity with delete date columns.\n     */\n    withDeleted() {\n        this.expressionMap.withDeleted = true;\n        return this;\n    }\n    /**\n     * Gets first raw result returned by execution of generated query builder sql.\n     */\n    async getRawOne() {\n        return (await this.getRawMany())[0];\n    }\n    /**\n     * Gets all raw results returned by execution of generated query builder sql.\n     */\n    async getRawMany() {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError();\n        this.expressionMap.queryEntity = false;\n        const queryRunner = this.obtainQueryRunner();\n        let transactionStartedByUs = false;\n        try {\n            // start transaction if it was enabled\n            if (this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false) {\n                await queryRunner.startTransaction();\n                transactionStartedByUs = true;\n            }\n            const results = await this.loadRawResults(queryRunner);\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction();\n            }\n            return results;\n        }\n        catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction();\n                }\n                catch (rollbackError) { }\n            }\n            throw error;\n        }\n        finally {\n            if (queryRunner !== this.queryRunner) {\n                // means we created our own query runner\n                await queryRunner.release();\n            }\n        }\n    }\n    /**\n     * Executes sql generated by query builder and returns object with raw results and entities created from them.\n     */\n    async getRawAndEntities() {\n        const queryRunner = this.obtainQueryRunner();\n        let transactionStartedByUs = false;\n        try {\n            // start transaction if it was enabled\n            if (this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false) {\n                await queryRunner.startTransaction();\n                transactionStartedByUs = true;\n            }\n            this.expressionMap.queryEntity = true;\n            const results = await this.executeEntitiesAndRawResults(queryRunner);\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction();\n            }\n            return results;\n        }\n        catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction();\n                }\n                catch (rollbackError) { }\n            }\n            throw error;\n        }\n        finally {\n            if (queryRunner !== this.queryRunner)\n                // means we created our own query runner\n                await queryRunner.release();\n        }\n    }\n    /**\n     * Gets single entity returned by execution of generated query builder sql.\n     */\n    async getOne() {\n        const results = await this.getRawAndEntities();\n        const result = results.entities[0];\n        if (result &&\n            this.expressionMap.lockMode === \"optimistic\" &&\n            this.expressionMap.lockVersion) {\n            const metadata = this.expressionMap.mainAlias.metadata;\n            if (this.expressionMap.lockVersion instanceof Date) {\n                const actualVersion = metadata.updateDateColumn.getEntityValue(result); // what if columns arent set?\n                if (actualVersion.getTime() !==\n                    this.expressionMap.lockVersion.getTime())\n                    throw new OptimisticLockVersionMismatchError(metadata.name, this.expressionMap.lockVersion, actualVersion);\n            }\n            else {\n                const actualVersion = metadata.versionColumn.getEntityValue(result); // what if columns arent set?\n                if (actualVersion !== this.expressionMap.lockVersion)\n                    throw new OptimisticLockVersionMismatchError(metadata.name, this.expressionMap.lockVersion, actualVersion);\n            }\n        }\n        if (result === undefined) {\n            return null;\n        }\n        return result;\n    }\n    /**\n     * Gets the first entity returned by execution of generated query builder sql or rejects the returned promise on error.\n     */\n    async getOneOrFail() {\n        const entity = await this.getOne();\n        if (!entity) {\n            throw new EntityNotFoundError(this.expressionMap.mainAlias.target, this.expressionMap.parameters);\n        }\n        return entity;\n    }\n    /**\n     * Gets entities returned by execution of generated query builder sql.\n     */\n    async getMany() {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError();\n        const results = await this.getRawAndEntities();\n        return results.entities;\n    }\n    /**\n     * Gets count - number of entities selected by sql generated by this query builder.\n     * Count excludes all limitations set by offset, limit, skip, and take.\n     */\n    async getCount() {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError();\n        const queryRunner = this.obtainQueryRunner();\n        let transactionStartedByUs = false;\n        try {\n            // start transaction if it was enabled\n            if (this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false) {\n                await queryRunner.startTransaction();\n                transactionStartedByUs = true;\n            }\n            this.expressionMap.queryEntity = false;\n            const results = await this.executeCountQuery(queryRunner);\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction();\n            }\n            return results;\n        }\n        catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction();\n                }\n                catch (rollbackError) { }\n            }\n            throw error;\n        }\n        finally {\n            if (queryRunner !== this.queryRunner)\n                // means we created our own query runner\n                await queryRunner.release();\n        }\n    }\n    /**\n     * Gets exists\n     * Returns whether any rows exists matching current query.\n     */\n    async getExists() {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError();\n        const queryRunner = this.obtainQueryRunner();\n        let transactionStartedByUs = false;\n        try {\n            // start transaction if it was enabled\n            if (this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false) {\n                await queryRunner.startTransaction();\n                transactionStartedByUs = true;\n            }\n            this.expressionMap.queryEntity = false;\n            const results = await this.executeExistsQuery(queryRunner);\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction();\n            }\n            return results;\n        }\n        catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction();\n                }\n                catch (rollbackError) { }\n            }\n            throw error;\n        }\n        finally {\n            if (queryRunner !== this.queryRunner)\n                // means we created our own query runner\n                await queryRunner.release();\n        }\n    }\n    /**\n     * Executes built SQL query and returns entities and overall entities count (without limitation).\n     * This method is useful to build pagination.\n     */\n    async getManyAndCount() {\n        if (this.expressionMap.lockMode === \"optimistic\")\n            throw new OptimisticLockCanNotBeUsedError();\n        const queryRunner = this.obtainQueryRunner();\n        let transactionStartedByUs = false;\n        try {\n            // start transaction if it was enabled\n            if (this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false) {\n                await queryRunner.startTransaction();\n                transactionStartedByUs = true;\n            }\n            this.expressionMap.queryEntity = true;\n            const entitiesAndRaw = await this.executeEntitiesAndRawResults(queryRunner);\n            this.expressionMap.queryEntity = false;\n            const cacheId = this.expressionMap.cacheId;\n            // Creates a new cacheId for the count query, or it will retreive the above query results\n            // and count will return 0.\n            this.expressionMap.cacheId = cacheId ? `${cacheId}-count` : cacheId;\n            const count = await this.executeCountQuery(queryRunner);\n            const results = [entitiesAndRaw.entities, count];\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction();\n            }\n            return results;\n        }\n        catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction();\n                }\n                catch (rollbackError) { }\n            }\n            throw error;\n        }\n        finally {\n            if (queryRunner !== this.queryRunner)\n                // means we created our own query runner\n                await queryRunner.release();\n        }\n    }\n    /**\n     * Executes built SQL query and returns raw data stream.\n     */\n    async stream() {\n        this.expressionMap.queryEntity = false;\n        const [sql, parameters] = this.getQueryAndParameters();\n        const queryRunner = this.obtainQueryRunner();\n        let transactionStartedByUs = false;\n        try {\n            // start transaction if it was enabled\n            if (this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false) {\n                await queryRunner.startTransaction();\n                transactionStartedByUs = true;\n            }\n            const releaseFn = () => {\n                if (queryRunner !== this.queryRunner)\n                    // means we created our own query runner\n                    return queryRunner.release();\n                return;\n            };\n            const results = queryRunner.stream(sql, parameters, releaseFn, releaseFn);\n            // close transaction if we started it\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction();\n            }\n            return results;\n        }\n        catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction();\n                }\n                catch (rollbackError) { }\n            }\n            throw error;\n        }\n    }\n    /**\n     * Enables or disables query result caching.\n     */\n    cache(enabledOrMillisecondsOrId, maybeMilliseconds) {\n        if (typeof enabledOrMillisecondsOrId === \"boolean\") {\n            this.expressionMap.cache = enabledOrMillisecondsOrId;\n        }\n        else if (typeof enabledOrMillisecondsOrId === \"number\") {\n            this.expressionMap.cache = true;\n            this.expressionMap.cacheDuration = enabledOrMillisecondsOrId;\n        }\n        else if (typeof enabledOrMillisecondsOrId === \"string\" ||\n            typeof enabledOrMillisecondsOrId === \"number\") {\n            this.expressionMap.cache = true;\n            this.expressionMap.cacheId = enabledOrMillisecondsOrId;\n        }\n        if (maybeMilliseconds) {\n            this.expressionMap.cacheDuration = maybeMilliseconds;\n        }\n        return this;\n    }\n    /**\n     * Sets extra options that can be used to configure how query builder works.\n     */\n    setOption(option) {\n        this.expressionMap.options.push(option);\n        return this;\n    }\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n    join(direction, entityOrProperty, aliasName, condition, parameters, mapToProperty, isMappingMany, mapAsEntity) {\n        if (parameters) {\n            this.setParameters(parameters);\n        }\n        const joinAttribute = new JoinAttribute(this.connection, this.expressionMap);\n        joinAttribute.direction = direction;\n        joinAttribute.mapAsEntity = mapAsEntity;\n        joinAttribute.mapToProperty = mapToProperty;\n        joinAttribute.isMappingMany = isMappingMany;\n        joinAttribute.entityOrProperty = entityOrProperty; // relationName\n        joinAttribute.condition = condition; // joinInverseSideCondition\n        // joinAttribute.junctionAlias = joinAttribute.relation.isOwning ? parentAlias + \"_\" + destinationTableAlias : destinationTableAlias + \"_\" + parentAlias;\n        this.expressionMap.joinAttributes.push(joinAttribute);\n        const joinAttributeMetadata = joinAttribute.metadata;\n        if (joinAttributeMetadata) {\n            if (joinAttributeMetadata.deleteDateColumn &&\n                !this.expressionMap.withDeleted) {\n                const conditionDeleteColumn = `${aliasName}.${joinAttributeMetadata.deleteDateColumn.propertyName} IS NULL`;\n                joinAttribute.condition = joinAttribute.condition\n                    ? ` ${joinAttribute.condition} AND ${conditionDeleteColumn}`\n                    : `${conditionDeleteColumn}`;\n            }\n            // todo: find and set metadata right there?\n            joinAttribute.alias = this.expressionMap.createAlias({\n                type: \"join\",\n                name: aliasName,\n                metadata: joinAttributeMetadata,\n            });\n            if (joinAttribute.relation &&\n                joinAttribute.relation.junctionEntityMetadata) {\n                this.expressionMap.createAlias({\n                    type: \"join\",\n                    name: joinAttribute.junctionAlias,\n                    metadata: joinAttribute.relation.junctionEntityMetadata,\n                });\n            }\n        }\n        else {\n            let subQuery = \"\";\n            if (typeof entityOrProperty === \"function\") {\n                const subQueryBuilder = entityOrProperty(this.subQuery());\n                this.setParameters(subQueryBuilder.getParameters());\n                subQuery = subQueryBuilder.getQuery();\n            }\n            else {\n                subQuery = entityOrProperty;\n            }\n            const isSubQuery = typeof entityOrProperty === \"function\" ||\n                (entityOrProperty.substr(0, 1) === \"(\" &&\n                    entityOrProperty.substr(-1) === \")\");\n            joinAttribute.alias = this.expressionMap.createAlias({\n                type: \"join\",\n                name: aliasName,\n                tablePath: isSubQuery === false\n                    ? entityOrProperty\n                    : undefined,\n                subQuery: isSubQuery === true ? subQuery : undefined,\n            });\n        }\n    }\n    /**\n     * Creates \"SELECT FROM\" part of SQL query.\n     */\n    createSelectExpression() {\n        if (!this.expressionMap.mainAlias)\n            throw new TypeORMError(\"Cannot build query because main alias is not set (call qb#from method)\");\n        // todo throw exception if selects or from is missing\n        const allSelects = [];\n        const excludedSelects = [];\n        if (this.expressionMap.mainAlias.hasMetadata) {\n            const metadata = this.expressionMap.mainAlias.metadata;\n            allSelects.push(...this.buildEscapedEntityColumnSelects(this.expressionMap.mainAlias.name, metadata));\n            excludedSelects.push(...this.findEntityColumnSelects(this.expressionMap.mainAlias.name, metadata));\n        }\n        // add selects from joins\n        this.expressionMap.joinAttributes.forEach((join) => {\n            if (join.metadata) {\n                allSelects.push(...this.buildEscapedEntityColumnSelects(join.alias.name, join.metadata));\n                excludedSelects.push(...this.findEntityColumnSelects(join.alias.name, join.metadata));\n            }\n            else {\n                const hasMainAlias = this.expressionMap.selects.some((select) => select.selection === join.alias.name);\n                if (hasMainAlias) {\n                    allSelects.push({\n                        selection: this.escape(join.alias.name) + \".*\",\n                    });\n                    const excludedSelect = this.expressionMap.selects.find((select) => select.selection === join.alias.name);\n                    excludedSelects.push(excludedSelect);\n                }\n            }\n        });\n        // add all other selects\n        this.expressionMap.selects\n            .filter((select) => excludedSelects.indexOf(select) === -1)\n            .forEach((select) => allSelects.push({\n            selection: this.replacePropertyNames(select.selection),\n            aliasName: select.aliasName,\n        }));\n        // if still selection is empty, then simply set it to all (*)\n        if (allSelects.length === 0)\n            allSelects.push({ selection: \"*\" });\n        // Use certain index\n        let useIndex = \"\";\n        if (this.expressionMap.useIndex) {\n            if (DriverUtils.isMySQLFamily(this.connection.driver)) {\n                useIndex = ` USE INDEX (${this.expressionMap.useIndex})`;\n            }\n        }\n        // create a selection query\n        const froms = this.expressionMap.aliases\n            .filter((alias) => alias.type === \"from\" &&\n            (alias.tablePath || alias.subQuery))\n            .map((alias) => {\n            if (alias.subQuery)\n                return alias.subQuery + \" \" + this.escape(alias.name);\n            return (this.getTableName(alias.tablePath) +\n                \" \" +\n                this.escape(alias.name));\n        });\n        const select = this.createSelectDistinctExpression();\n        const selection = allSelects\n            .map((select) => select.selection +\n            (select.aliasName\n                ? \" AS \" + this.escape(select.aliasName)\n                : \"\"))\n            .join(\", \");\n        return (select +\n            selection +\n            \" FROM \" +\n            froms.join(\", \") +\n            this.createTableLockExpression() +\n            useIndex);\n    }\n    /**\n     * Creates select | select distinct part of SQL query.\n     */\n    createSelectDistinctExpression() {\n        const { selectDistinct, selectDistinctOn, maxExecutionTime } = this.expressionMap;\n        const { driver } = this.connection;\n        let select = \"SELECT \";\n        if (maxExecutionTime > 0) {\n            if (DriverUtils.isMySQLFamily(driver)) {\n                select += `/*+ MAX_EXECUTION_TIME(${this.expressionMap.maxExecutionTime}) */ `;\n            }\n        }\n        if (DriverUtils.isPostgresFamily(driver) &&\n            selectDistinctOn.length > 0) {\n            const selectDistinctOnMap = selectDistinctOn\n                .map((on) => this.replacePropertyNames(on))\n                .join(\", \");\n            select = `SELECT DISTINCT ON (${selectDistinctOnMap}) `;\n        }\n        else if (selectDistinct) {\n            select = \"SELECT DISTINCT \";\n        }\n        return select;\n    }\n    /**\n     * Creates \"JOIN\" part of SQL query.\n     */\n    createJoinExpression() {\n        // examples:\n        // select from owning side\n        // qb.select(\"post\")\n        //     .leftJoinAndSelect(\"post.category\", \"category\");\n        // select from non-owning side\n        // qb.select(\"category\")\n        //     .leftJoinAndSelect(\"category.post\", \"post\");\n        const joins = this.expressionMap.joinAttributes.map((joinAttr) => {\n            const relation = joinAttr.relation;\n            const destinationTableName = joinAttr.tablePath;\n            const destinationTableAlias = joinAttr.alias.name;\n            let appendedCondition = joinAttr.condition\n                ? \" AND (\" + joinAttr.condition + \")\"\n                : \"\";\n            const parentAlias = joinAttr.parentAlias;\n            // if join was build without relation (e.g. without \"post.category\") then it means that we have direct\n            // table to join, without junction table involved. This means we simply join direct table.\n            if (!parentAlias || !relation) {\n                const destinationJoin = joinAttr.alias.subQuery\n                    ? joinAttr.alias.subQuery\n                    : this.getTableName(destinationTableName);\n                return (\" \" +\n                    joinAttr.direction +\n                    \" JOIN \" +\n                    destinationJoin +\n                    \" \" +\n                    this.escape(destinationTableAlias) +\n                    this.createTableLockExpression() +\n                    (joinAttr.condition\n                        ? \" ON \" + this.replacePropertyNames(joinAttr.condition)\n                        : \"\"));\n            }\n            // if real entity relation is involved\n            if (relation.isManyToOne || relation.isOneToOneOwner) {\n                // JOIN `category` `category` ON `category`.`id` = `post`.`categoryId`\n                const condition = relation.joinColumns\n                    .map((joinColumn) => {\n                    return (destinationTableAlias +\n                        \".\" +\n                        joinColumn.referencedColumn.propertyPath +\n                        \"=\" +\n                        parentAlias +\n                        \".\" +\n                        relation.propertyPath +\n                        \".\" +\n                        joinColumn.referencedColumn.propertyPath);\n                })\n                    .join(\" AND \");\n                return (\" \" +\n                    joinAttr.direction +\n                    \" JOIN \" +\n                    this.getTableName(destinationTableName) +\n                    \" \" +\n                    this.escape(destinationTableAlias) +\n                    this.createTableLockExpression() +\n                    \" ON \" +\n                    this.replacePropertyNames(condition + appendedCondition));\n            }\n            else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n                // JOIN `post` `post` ON `post`.`categoryId` = `category`.`id`\n                const condition = relation\n                    .inverseRelation.joinColumns.map((joinColumn) => {\n                    if (relation.inverseEntityMetadata.tableType ===\n                        \"entity-child\" &&\n                        relation.inverseEntityMetadata.discriminatorColumn) {\n                        appendedCondition +=\n                            \" AND \" +\n                                destinationTableAlias +\n                                \".\" +\n                                relation.inverseEntityMetadata\n                                    .discriminatorColumn.databaseName +\n                                \"='\" +\n                                relation.inverseEntityMetadata\n                                    .discriminatorValue +\n                                \"'\";\n                    }\n                    return (destinationTableAlias +\n                        \".\" +\n                        relation.inverseRelation.propertyPath +\n                        \".\" +\n                        joinColumn.referencedColumn.propertyPath +\n                        \"=\" +\n                        parentAlias +\n                        \".\" +\n                        joinColumn.referencedColumn.propertyPath);\n                })\n                    .join(\" AND \");\n                return (\" \" +\n                    joinAttr.direction +\n                    \" JOIN \" +\n                    this.getTableName(destinationTableName) +\n                    \" \" +\n                    this.escape(destinationTableAlias) +\n                    this.createTableLockExpression() +\n                    \" ON \" +\n                    this.replacePropertyNames(condition + appendedCondition));\n            }\n            else {\n                // means many-to-many\n                const junctionTableName = relation.junctionEntityMetadata.tablePath;\n                const junctionAlias = joinAttr.junctionAlias;\n                let junctionCondition = \"\", destinationCondition = \"\";\n                if (relation.isOwning) {\n                    junctionCondition = relation.joinColumns\n                        .map((joinColumn) => {\n                        // `post_category`.`postId` = `post`.`id`\n                        return (junctionAlias +\n                            \".\" +\n                            joinColumn.propertyPath +\n                            \"=\" +\n                            parentAlias +\n                            \".\" +\n                            joinColumn.referencedColumn.propertyPath);\n                    })\n                        .join(\" AND \");\n                    destinationCondition = relation.inverseJoinColumns\n                        .map((joinColumn) => {\n                        // `category`.`id` = `post_category`.`categoryId`\n                        return (destinationTableAlias +\n                            \".\" +\n                            joinColumn.referencedColumn.propertyPath +\n                            \"=\" +\n                            junctionAlias +\n                            \".\" +\n                            joinColumn.propertyPath);\n                    })\n                        .join(\" AND \");\n                }\n                else {\n                    junctionCondition = relation\n                        .inverseRelation.inverseJoinColumns.map((joinColumn) => {\n                        // `post_category`.`categoryId` = `category`.`id`\n                        return (junctionAlias +\n                            \".\" +\n                            joinColumn.propertyPath +\n                            \"=\" +\n                            parentAlias +\n                            \".\" +\n                            joinColumn.referencedColumn.propertyPath);\n                    })\n                        .join(\" AND \");\n                    destinationCondition = relation\n                        .inverseRelation.joinColumns.map((joinColumn) => {\n                        // `post`.`id` = `post_category`.`postId`\n                        return (destinationTableAlias +\n                            \".\" +\n                            joinColumn.referencedColumn.propertyPath +\n                            \"=\" +\n                            junctionAlias +\n                            \".\" +\n                            joinColumn.propertyPath);\n                    })\n                        .join(\" AND \");\n                }\n                return (\" \" +\n                    joinAttr.direction +\n                    \" JOIN \" +\n                    this.getTableName(junctionTableName) +\n                    \" \" +\n                    this.escape(junctionAlias) +\n                    this.createTableLockExpression() +\n                    \" ON \" +\n                    this.replacePropertyNames(junctionCondition) +\n                    \" \" +\n                    joinAttr.direction +\n                    \" JOIN \" +\n                    this.getTableName(destinationTableName) +\n                    \" \" +\n                    this.escape(destinationTableAlias) +\n                    this.createTableLockExpression() +\n                    \" ON \" +\n                    this.replacePropertyNames(destinationCondition + appendedCondition));\n            }\n        });\n        return joins.join(\" \");\n    }\n    /**\n     * Creates \"GROUP BY\" part of SQL query.\n     */\n    createGroupByExpression() {\n        if (!this.expressionMap.groupBys || !this.expressionMap.groupBys.length)\n            return \"\";\n        return (\" GROUP BY \" +\n            this.replacePropertyNames(this.expressionMap.groupBys.join(\", \")));\n    }\n    /**\n     * Creates \"ORDER BY\" part of SQL query.\n     */\n    createOrderByExpression() {\n        const orderBys = this.expressionMap.allOrderBys;\n        if (Object.keys(orderBys).length === 0)\n            return \"\";\n        return (\" ORDER BY \" +\n            Object.keys(orderBys)\n                .map((columnName) => {\n                const orderValue = typeof orderBys[columnName] === \"string\"\n                    ? orderBys[columnName]\n                    : orderBys[columnName].order +\n                        \" \" +\n                        orderBys[columnName].nulls;\n                const selection = this.expressionMap.selects.find((s) => s.selection === columnName);\n                if (selection &&\n                    !selection.aliasName &&\n                    columnName.indexOf(\".\") !== -1) {\n                    const criteriaParts = columnName.split(\".\");\n                    const aliasName = criteriaParts[0];\n                    const propertyPath = criteriaParts.slice(1).join(\".\");\n                    const alias = this.expressionMap.aliases.find((alias) => alias.name === aliasName);\n                    if (alias) {\n                        const column = alias.metadata.findColumnWithPropertyPath(propertyPath);\n                        if (column) {\n                            const orderAlias = DriverUtils.buildAlias(this.connection.driver, undefined, aliasName, column.databaseName);\n                            return (this.escape(orderAlias) + \" \" + orderValue);\n                        }\n                    }\n                }\n                return (this.replacePropertyNames(columnName) + \" \" + orderValue);\n            })\n                .join(\", \"));\n    }\n    /**\n     * Creates \"LIMIT\" and \"OFFSET\" parts of SQL query.\n     */\n    createLimitOffsetExpression() {\n        // in the case if nothing is joined in the query builder we don't need to make two requests to get paginated results\n        // we can use regular limit / offset, that's why we add offset and limit construction here based on skip and take values\n        let offset = this.expressionMap.offset, limit = this.expressionMap.limit;\n        if (!offset &&\n            !limit &&\n            this.expressionMap.joinAttributes.length === 0) {\n            offset = this.expressionMap.skip;\n            limit = this.expressionMap.take;\n        }\n        if (this.connection.driver.options.type === \"mssql\") {\n            // Due to a limitation in SQL Server's parser implementation it does not support using\n            // OFFSET or FETCH NEXT without an ORDER BY clause being provided. In cases where the\n            // user does not request one we insert a dummy ORDER BY that does nothing and should\n            // have no effect on the query planner or on the order of the results returned.\n            // https://dba.stackexchange.com/a/193799\n            let prefix = \"\";\n            if ((limit || offset) &&\n                Object.keys(this.expressionMap.allOrderBys).length <= 0) {\n                prefix = \" ORDER BY (SELECT NULL)\";\n            }\n            if (limit && offset)\n                return (prefix +\n                    \" OFFSET \" +\n                    offset +\n                    \" ROWS FETCH NEXT \" +\n                    limit +\n                    \" ROWS ONLY\");\n            if (limit)\n                return (prefix + \" OFFSET 0 ROWS FETCH NEXT \" + limit + \" ROWS ONLY\");\n            if (offset)\n                return prefix + \" OFFSET \" + offset + \" ROWS\";\n        }\n        else if (DriverUtils.isMySQLFamily(this.connection.driver) ||\n            this.connection.driver.options.type === \"aurora-mysql\" ||\n            this.connection.driver.options.type === \"sap\" ||\n            this.connection.driver.options.type === \"spanner\") {\n            if (limit && offset)\n                return \" LIMIT \" + limit + \" OFFSET \" + offset;\n            if (limit)\n                return \" LIMIT \" + limit;\n            if (offset)\n                throw new OffsetWithoutLimitNotSupportedError();\n        }\n        else if (DriverUtils.isSQLiteFamily(this.connection.driver)) {\n            if (limit && offset)\n                return \" LIMIT \" + limit + \" OFFSET \" + offset;\n            if (limit)\n                return \" LIMIT \" + limit;\n            if (offset)\n                return \" LIMIT -1 OFFSET \" + offset;\n        }\n        else if (this.connection.driver.options.type === \"oracle\") {\n            if (limit && offset)\n                return (\" OFFSET \" +\n                    offset +\n                    \" ROWS FETCH NEXT \" +\n                    limit +\n                    \" ROWS ONLY\");\n            if (limit)\n                return \" FETCH NEXT \" + limit + \" ROWS ONLY\";\n            if (offset)\n                return \" OFFSET \" + offset + \" ROWS\";\n        }\n        else {\n            if (limit && offset)\n                return \" LIMIT \" + limit + \" OFFSET \" + offset;\n            if (limit)\n                return \" LIMIT \" + limit;\n            if (offset)\n                return \" OFFSET \" + offset;\n        }\n        return \"\";\n    }\n    /**\n     * Creates \"LOCK\" part of SELECT Query after table Clause\n     * ex.\n     *  SELECT 1\n     *  FROM USER U WITH (NOLOCK)\n     *  JOIN ORDER O WITH (NOLOCK)\n     *      ON U.ID=O.OrderID\n     */\n    createTableLockExpression() {\n        if (this.connection.driver.options.type === \"mssql\") {\n            switch (this.expressionMap.lockMode) {\n                case \"pessimistic_read\":\n                    return \" WITH (HOLDLOCK, ROWLOCK)\";\n                case \"pessimistic_write\":\n                    return \" WITH (UPDLOCK, ROWLOCK)\";\n                case \"dirty_read\":\n                    return \" WITH (NOLOCK)\";\n            }\n        }\n        return \"\";\n    }\n    /**\n     * Creates \"LOCK\" part of SQL query.\n     */\n    createLockExpression() {\n        const driver = this.connection.driver;\n        let lockTablesClause = \"\";\n        if (this.expressionMap.lockTables) {\n            if (!(DriverUtils.isPostgresFamily(driver) ||\n                driver.options.type === \"cockroachdb\")) {\n                throw new TypeORMError(\"Lock tables not supported in selected driver\");\n            }\n            if (this.expressionMap.lockTables.length < 1) {\n                throw new TypeORMError(\"lockTables cannot be an empty array\");\n            }\n            lockTablesClause = \" OF \" + this.expressionMap.lockTables.join(\", \");\n        }\n        let onLockExpression = \"\";\n        if (this.expressionMap.onLocked === \"nowait\") {\n            onLockExpression = \" NOWAIT\";\n        }\n        else if (this.expressionMap.onLocked === \"skip_locked\") {\n            onLockExpression = \" SKIP LOCKED\";\n        }\n        switch (this.expressionMap.lockMode) {\n            case \"pessimistic_read\":\n                if (driver.options.type === \"mysql\" ||\n                    driver.options.type === \"aurora-mysql\") {\n                    if (DriverUtils.isReleaseVersionOrGreater(driver, \"8.0.0\")) {\n                        return (\" FOR SHARE\" + lockTablesClause + onLockExpression);\n                    }\n                    else {\n                        return \" LOCK IN SHARE MODE\";\n                    }\n                }\n                else if (driver.options.type === \"mariadb\") {\n                    return \" LOCK IN SHARE MODE\";\n                }\n                else if (DriverUtils.isPostgresFamily(driver)) {\n                    return \" FOR SHARE\" + lockTablesClause + onLockExpression;\n                }\n                else if (driver.options.type === \"oracle\") {\n                    return \" FOR UPDATE\";\n                }\n                else if (driver.options.type === \"mssql\") {\n                    return \"\";\n                }\n                else {\n                    throw new LockNotSupportedOnGivenDriverError();\n                }\n            case \"pessimistic_write\":\n                if (DriverUtils.isMySQLFamily(driver) ||\n                    driver.options.type === \"aurora-mysql\" ||\n                    driver.options.type === \"oracle\") {\n                    return \" FOR UPDATE\" + onLockExpression;\n                }\n                else if (DriverUtils.isPostgresFamily(driver) ||\n                    driver.options.type === \"cockroachdb\") {\n                    return \" FOR UPDATE\" + lockTablesClause + onLockExpression;\n                }\n                else if (driver.options.type === \"mssql\") {\n                    return \"\";\n                }\n                else {\n                    throw new LockNotSupportedOnGivenDriverError();\n                }\n            case \"pessimistic_partial_write\":\n                if (DriverUtils.isPostgresFamily(driver)) {\n                    return \" FOR UPDATE\" + lockTablesClause + \" SKIP LOCKED\";\n                }\n                else if (DriverUtils.isMySQLFamily(driver)) {\n                    return \" FOR UPDATE SKIP LOCKED\";\n                }\n                else {\n                    throw new LockNotSupportedOnGivenDriverError();\n                }\n            case \"pessimistic_write_or_fail\":\n                if (DriverUtils.isPostgresFamily(driver) ||\n                    driver.options.type === \"cockroachdb\") {\n                    return \" FOR UPDATE\" + lockTablesClause + \" NOWAIT\";\n                }\n                else if (DriverUtils.isMySQLFamily(driver)) {\n                    return \" FOR UPDATE NOWAIT\";\n                }\n                else {\n                    throw new LockNotSupportedOnGivenDriverError();\n                }\n            case \"for_no_key_update\":\n                if (DriverUtils.isPostgresFamily(driver) ||\n                    driver.options.type === \"cockroachdb\") {\n                    return (\" FOR NO KEY UPDATE\" +\n                        lockTablesClause +\n                        onLockExpression);\n                }\n                else {\n                    throw new LockNotSupportedOnGivenDriverError();\n                }\n            case \"for_key_share\":\n                if (DriverUtils.isPostgresFamily(driver)) {\n                    return (\" FOR KEY SHARE\" + lockTablesClause + onLockExpression);\n                }\n                else {\n                    throw new LockNotSupportedOnGivenDriverError();\n                }\n            default:\n                return \"\";\n        }\n    }\n    /**\n     * Creates \"HAVING\" part of SQL query.\n     */\n    createHavingExpression() {\n        if (!this.expressionMap.havings || !this.expressionMap.havings.length)\n            return \"\";\n        const conditions = this.expressionMap.havings\n            .map((having, index) => {\n            switch (having.type) {\n                case \"and\":\n                    return ((index > 0 ? \"AND \" : \"\") +\n                        this.replacePropertyNames(having.condition));\n                case \"or\":\n                    return ((index > 0 ? \"OR \" : \"\") +\n                        this.replacePropertyNames(having.condition));\n                default:\n                    return this.replacePropertyNames(having.condition);\n            }\n        })\n            .join(\" \");\n        if (!conditions.length)\n            return \"\";\n        return \" HAVING \" + conditions;\n    }\n    buildEscapedEntityColumnSelects(aliasName, metadata) {\n        const hasMainAlias = this.expressionMap.selects.some((select) => select.selection === aliasName);\n        const columns = [];\n        if (hasMainAlias) {\n            columns.push(...metadata.columns.filter((column) => column.isSelect === true));\n        }\n        columns.push(...metadata.columns.filter((column) => {\n            return this.expressionMap.selects.some((select) => select.selection ===\n                aliasName + \".\" + column.propertyPath);\n        }));\n        // if user used partial selection and did not select some primary columns which are required to be selected\n        // we select those primary columns and mark them as \"virtual\". Later virtual column values will be removed from final entity\n        // to make entity contain exactly what user selected\n        if (columns.length === 0)\n            // however not in the case when nothing (even partial) was selected from this target (for example joins without selection)\n            return [];\n        const nonSelectedPrimaryColumns = this.expressionMap.queryEntity\n            ? metadata.primaryColumns.filter((primaryColumn) => columns.indexOf(primaryColumn) === -1)\n            : [];\n        const allColumns = [...columns, ...nonSelectedPrimaryColumns];\n        const finalSelects = [];\n        const escapedAliasName = this.escape(aliasName);\n        allColumns.forEach((column) => {\n            let selectionPath = escapedAliasName + \".\" + this.escape(column.databaseName);\n            if (column.isVirtualProperty && column.query) {\n                selectionPath = `(${column.query(escapedAliasName)})`;\n            }\n            if (this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {\n                if (DriverUtils.isMySQLFamily(this.connection.driver) ||\n                    this.connection.driver.options.type === \"aurora-mysql\") {\n                    const useLegacy = this.connection.driver.options.legacySpatialSupport;\n                    const asText = useLegacy ? \"AsText\" : \"ST_AsText\";\n                    selectionPath = `${asText}(${selectionPath})`;\n                }\n                if (DriverUtils.isPostgresFamily(this.connection.driver))\n                    if (column.precision) {\n                        // cast to JSON to trigger parsing in the driver\n                        selectionPath = `ST_AsGeoJSON(${selectionPath}, ${column.precision})::json`;\n                    }\n                    else {\n                        selectionPath = `ST_AsGeoJSON(${selectionPath})::json`;\n                    }\n                if (this.connection.driver.options.type === \"mssql\")\n                    selectionPath = `${selectionPath}.ToString()`;\n            }\n            const selections = this.expressionMap.selects.filter((select) => select.selection === aliasName + \".\" + column.propertyPath);\n            if (selections.length) {\n                selections.forEach((selection) => {\n                    finalSelects.push({\n                        selection: selectionPath,\n                        aliasName: selection.aliasName\n                            ? selection.aliasName\n                            : DriverUtils.buildAlias(this.connection.driver, undefined, aliasName, column.databaseName),\n                        // todo: need to keep in mind that custom selection.aliasName breaks hydrator. fix it later!\n                        virtual: selection.virtual,\n                    });\n                });\n            }\n            else {\n                finalSelects.push({\n                    selection: selectionPath,\n                    aliasName: DriverUtils.buildAlias(this.connection.driver, undefined, aliasName, column.databaseName),\n                    // todo: need to keep in mind that custom selection.aliasName breaks hydrator. fix it later!\n                    virtual: hasMainAlias,\n                });\n            }\n        });\n        return finalSelects;\n    }\n    findEntityColumnSelects(aliasName, metadata) {\n        const mainSelect = this.expressionMap.selects.find((select) => select.selection === aliasName);\n        if (mainSelect)\n            return [mainSelect];\n        return this.expressionMap.selects.filter((select) => {\n            return metadata.columns.some((column) => select.selection === aliasName + \".\" + column.propertyPath);\n        });\n    }\n    computeCountExpression() {\n        const mainAlias = this.expressionMap.mainAlias.name; // todo: will this work with \"fromTableName\"?\n        const metadata = this.expressionMap.mainAlias.metadata;\n        const primaryColumns = metadata.primaryColumns;\n        const distinctAlias = this.escape(mainAlias);\n        // If we aren't doing anything that will create a join, we can use a simpler `COUNT` instead\n        // so we prevent poor query patterns in the most likely cases\n        if (this.expressionMap.joinAttributes.length === 0 &&\n            this.expressionMap.relationIdAttributes.length === 0 &&\n            this.expressionMap.relationCountAttributes.length === 0) {\n            return \"COUNT(1)\";\n        }\n        // For everything else, we'll need to do some hackery to get the correct count values.\n        if (this.connection.driver.options.type === \"cockroachdb\" ||\n            DriverUtils.isPostgresFamily(this.connection.driver)) {\n            // Postgres and CockroachDB can pass multiple parameters to the `DISTINCT` function\n            // https://www.postgresql.org/docs/9.5/sql-select.html#SQL-DISTINCT\n            return (\"COUNT(DISTINCT(\" +\n                primaryColumns\n                    .map((c) => `${distinctAlias}.${this.escape(c.databaseName)}`)\n                    .join(\", \") +\n                \"))\");\n        }\n        if (DriverUtils.isMySQLFamily(this.connection.driver)) {\n            // MySQL & MariaDB can pass multiple parameters to the `DISTINCT` language construct\n            // https://mariadb.com/kb/en/count-distinct/\n            return (\"COUNT(DISTINCT \" +\n                primaryColumns\n                    .map((c) => `${distinctAlias}.${this.escape(c.databaseName)}`)\n                    .join(\", \") +\n                \")\");\n        }\n        if (this.connection.driver.options.type === \"mssql\") {\n            // SQL Server has gotta be different from everyone else.  They don't support\n            // distinct counting multiple columns & they don't have the same operator\n            // characteristic for concatenating, so we gotta use the `CONCAT` function.\n            // However, If it's exactly 1 column we can omit the `CONCAT` for better performance.\n            const columnsExpression = primaryColumns\n                .map((primaryColumn) => `${distinctAlias}.${this.escape(primaryColumn.databaseName)}`)\n                .join(\", '|;|', \");\n            if (primaryColumns.length === 1) {\n                return `COUNT(DISTINCT(${columnsExpression}))`;\n            }\n            return `COUNT(DISTINCT(CONCAT(${columnsExpression})))`;\n        }\n        if (this.connection.driver.options.type === \"spanner\") {\n            // spanner also has gotta be different from everyone else.\n            // they do not support concatenation of different column types without casting them to string\n            if (primaryColumns.length === 1) {\n                return `COUNT(DISTINCT(${distinctAlias}.${this.escape(primaryColumns[0].databaseName)}))`;\n            }\n            const columnsExpression = primaryColumns\n                .map((primaryColumn) => `CAST(${distinctAlias}.${this.escape(primaryColumn.databaseName)} AS STRING)`)\n                .join(\", '|;|', \");\n            return `COUNT(DISTINCT(CONCAT(${columnsExpression})))`;\n        }\n        // If all else fails, fall back to a `COUNT` and `DISTINCT` across all the primary columns concatenated.\n        // Per the SQL spec, this is the canonical string concatenation mechanism which is most\n        // likely to work across servers implementing the SQL standard.\n        // Please note, if there is only one primary column that the concatenation does not occur in this\n        // query and the query is a standard `COUNT DISTINCT` in that case.\n        return (`COUNT(DISTINCT(` +\n            primaryColumns\n                .map((c) => `${distinctAlias}.${this.escape(c.databaseName)}`)\n                .join(\" || '|;|' || \") +\n            \"))\");\n    }\n    async executeCountQuery(queryRunner) {\n        const countSql = this.computeCountExpression();\n        const results = await this.clone()\n            .orderBy()\n            .groupBy()\n            .offset(undefined)\n            .limit(undefined)\n            .skip(undefined)\n            .take(undefined)\n            .select(countSql, \"cnt\")\n            .setOption(\"disable-global-order\")\n            .loadRawResults(queryRunner);\n        if (!results || !results[0] || !results[0][\"cnt\"])\n            return 0;\n        return parseInt(results[0][\"cnt\"]);\n    }\n    async executeExistsQuery(queryRunner) {\n        const results = await this.connection\n            .createQueryBuilder()\n            .fromDummy()\n            .select(\"1\", \"row_exists\")\n            .whereExists(this)\n            .limit(1)\n            .loadRawResults(queryRunner);\n        return results.length > 0;\n    }\n    applyFindOptions() {\n        // todo: convert relations: string[] to object map to simplify code\n        // todo: same with selects\n        if (this.expressionMap.mainAlias.metadata) {\n            if (this.findOptions.relationLoadStrategy) {\n                this.expressionMap.relationLoadStrategy =\n                    this.findOptions.relationLoadStrategy;\n            }\n            if (this.findOptions.comment) {\n                this.comment(this.findOptions.comment);\n            }\n            if (this.findOptions.withDeleted) {\n                this.withDeleted();\n            }\n            if (this.findOptions.select) {\n                const select = Array.isArray(this.findOptions.select)\n                    ? OrmUtils.propertyPathsToTruthyObject(this.findOptions.select)\n                    : this.findOptions.select;\n                this.buildSelect(select, this.expressionMap.mainAlias.metadata, this.expressionMap.mainAlias.name);\n            }\n            if (this.selects.length) {\n                this.select(this.selects);\n            }\n            this.selects = [];\n            if (this.findOptions.relations) {\n                const relations = Array.isArray(this.findOptions.relations)\n                    ? OrmUtils.propertyPathsToTruthyObject(this.findOptions.relations)\n                    : this.findOptions.relations;\n                this.buildRelations(relations, typeof this.findOptions.select === \"object\"\n                    ? this.findOptions.select\n                    : undefined, this.expressionMap.mainAlias.metadata, this.expressionMap.mainAlias.name);\n                if (this.findOptions.loadEagerRelations !== false &&\n                    this.expressionMap.relationLoadStrategy === \"join\") {\n                    this.buildEagerRelations(relations, typeof this.findOptions.select === \"object\"\n                        ? this.findOptions\n                            .select\n                        : undefined, this.expressionMap.mainAlias.metadata, this.expressionMap.mainAlias.name);\n                }\n            }\n            if (this.selects.length) {\n                this.addSelect(this.selects);\n            }\n            if (this.findOptions.where) {\n                this.conditions = this.buildWhere(this.findOptions.where, this.expressionMap.mainAlias.metadata, this.expressionMap.mainAlias.name);\n                if (this.conditions.length)\n                    this.andWhere(this.conditions.substr(0, 1) !== \"(\"\n                        ? \"(\" + this.conditions + \")\"\n                        : this.conditions); // temporary and where and braces\n            }\n            if (this.findOptions.order) {\n                this.buildOrder(this.findOptions.order, this.expressionMap.mainAlias.metadata, this.expressionMap.mainAlias.name);\n            }\n            // apply joins\n            if (this.joins.length) {\n                this.joins.forEach((join) => {\n                    if (join.select && !join.selection) {\n                        // if (join.selection) {\n                        //\n                        // } else {\n                        if (join.type === \"inner\") {\n                            this.innerJoinAndSelect(`${join.parentAlias}.${join.relationMetadata.propertyPath}`, join.alias);\n                        }\n                        else {\n                            this.leftJoinAndSelect(`${join.parentAlias}.${join.relationMetadata.propertyPath}`, join.alias);\n                        }\n                        // }\n                    }\n                    else {\n                        if (join.type === \"inner\") {\n                            this.innerJoin(`${join.parentAlias}.${join.relationMetadata.propertyPath}`, join.alias);\n                        }\n                        else {\n                            this.leftJoin(`${join.parentAlias}.${join.relationMetadata.propertyPath}`, join.alias);\n                        }\n                    }\n                    // if (join.select) {\n                    //     if (this.findOptions.loadEagerRelations !== false) {\n                    //         FindOptionsUtils.joinEagerRelations(\n                    //             this,\n                    //             join.alias,\n                    //             join.relationMetadata.inverseEntityMetadata\n                    //         );\n                    //     }\n                    // }\n                });\n            }\n            // if (this.conditions.length) {\n            //     this.where(this.conditions.join(\" AND \"));\n            // }\n            // apply offset\n            if (this.findOptions.skip !== undefined) {\n                // if (this.findOptions.options && this.findOptions.options.pagination === false) {\n                //     this.offset(this.findOptions.skip);\n                // } else {\n                this.skip(this.findOptions.skip);\n                // }\n            }\n            // apply limit\n            if (this.findOptions.take !== undefined) {\n                // if (this.findOptions.options && this.findOptions.options.pagination === false) {\n                //     this.limit(this.findOptions.take);\n                // } else {\n                this.take(this.findOptions.take);\n                // }\n            }\n            // apply caching options\n            if (typeof this.findOptions.cache === \"number\") {\n                this.cache(this.findOptions.cache);\n            }\n            else if (typeof this.findOptions.cache === \"boolean\") {\n                this.cache(this.findOptions.cache);\n            }\n            else if (typeof this.findOptions.cache === \"object\") {\n                this.cache(this.findOptions.cache.id, this.findOptions.cache.milliseconds);\n            }\n            if (this.findOptions.join) {\n                if (this.findOptions.join.leftJoin)\n                    Object.keys(this.findOptions.join.leftJoin).forEach((key) => {\n                        this.leftJoin(this.findOptions.join.leftJoin[key], key);\n                    });\n                if (this.findOptions.join.innerJoin)\n                    Object.keys(this.findOptions.join.innerJoin).forEach((key) => {\n                        this.innerJoin(this.findOptions.join.innerJoin[key], key);\n                    });\n                if (this.findOptions.join.leftJoinAndSelect)\n                    Object.keys(this.findOptions.join.leftJoinAndSelect).forEach((key) => {\n                        this.leftJoinAndSelect(this.findOptions.join.leftJoinAndSelect[key], key);\n                    });\n                if (this.findOptions.join.innerJoinAndSelect)\n                    Object.keys(this.findOptions.join.innerJoinAndSelect).forEach((key) => {\n                        this.innerJoinAndSelect(this.findOptions.join.innerJoinAndSelect[key], key);\n                    });\n            }\n            if (this.findOptions.lock) {\n                if (this.findOptions.lock.mode === \"optimistic\") {\n                    this.setLock(this.findOptions.lock.mode, this.findOptions.lock.version);\n                }\n                else if (this.findOptions.lock.mode === \"pessimistic_read\" ||\n                    this.findOptions.lock.mode === \"pessimistic_write\" ||\n                    this.findOptions.lock.mode === \"dirty_read\" ||\n                    this.findOptions.lock.mode ===\n                        \"pessimistic_partial_write\" ||\n                    this.findOptions.lock.mode ===\n                        \"pessimistic_write_or_fail\" ||\n                    this.findOptions.lock.mode === \"for_no_key_update\" ||\n                    this.findOptions.lock.mode === \"for_key_share\") {\n                    const tableNames = this.findOptions.lock.tables\n                        ? this.findOptions.lock.tables.map((table) => {\n                            const tableAlias = this.expressionMap.aliases.find((alias) => {\n                                return (alias.metadata\n                                    .tableNameWithoutPrefix === table);\n                            });\n                            if (!tableAlias) {\n                                throw new TypeORMError(`\"${table}\" is not part of this query`);\n                            }\n                            return this.escape(tableAlias.name);\n                        })\n                        : undefined;\n                    this.setLock(this.findOptions.lock.mode, undefined, tableNames);\n                    if (this.findOptions.lock.onLocked) {\n                        this.setOnLocked(this.findOptions.lock.onLocked);\n                    }\n                }\n            }\n            if (this.findOptions.loadRelationIds === true) {\n                this.loadAllRelationIds();\n            }\n            else if (typeof this.findOptions.loadRelationIds === \"object\") {\n                this.loadAllRelationIds(this.findOptions.loadRelationIds);\n            }\n            if (this.findOptions.loadEagerRelations !== false) {\n                FindOptionsUtils.joinEagerRelations(this, this.expressionMap.mainAlias.name, this.expressionMap.mainAlias.metadata);\n            }\n            if (this.findOptions.transaction === true) {\n                this.expressionMap.useTransaction = true;\n            }\n            // if (this.orderBys.length) {\n            //     this.orderBys.forEach(orderBy => {\n            //         this.addOrderBy(orderBy.alias, orderBy.direction, orderBy.nulls);\n            //     });\n            // }\n            // todo\n            // if (this.options.options && this.options.options.eagerRelations) {\n            //     this.queryBuilder\n            // }\n            // todo\n            // if (this.findOptions.options && this.findOptions.listeners === false) {\n            //     this.callListeners(false);\n            // }\n        }\n    }\n    concatRelationMetadata(relationMetadata) {\n        this.relationMetadatas.push(relationMetadata);\n    }\n    /**\n     * Executes sql generated by query builder and returns object with raw results and entities created from them.\n     */\n    async executeEntitiesAndRawResults(queryRunner) {\n        if (!this.expressionMap.mainAlias)\n            throw new TypeORMError(`Alias is not set. Use \"from\" method to set an alias.`);\n        if ((this.expressionMap.lockMode === \"pessimistic_read\" ||\n            this.expressionMap.lockMode === \"pessimistic_write\" ||\n            this.expressionMap.lockMode === \"pessimistic_partial_write\" ||\n            this.expressionMap.lockMode === \"pessimistic_write_or_fail\" ||\n            this.expressionMap.lockMode === \"for_no_key_update\" ||\n            this.expressionMap.lockMode === \"for_key_share\") &&\n            !queryRunner.isTransactionActive)\n            throw new PessimisticLockTransactionRequiredError();\n        if (this.expressionMap.lockMode === \"optimistic\") {\n            const metadata = this.expressionMap.mainAlias.metadata;\n            if (!metadata.versionColumn && !metadata.updateDateColumn)\n                throw new NoVersionOrUpdateDateColumnError(metadata.name);\n        }\n        const relationIdLoader = new RelationIdLoader(this.connection, queryRunner, this.expressionMap.relationIdAttributes);\n        const relationCountLoader = new RelationCountLoader(this.connection, queryRunner, this.expressionMap.relationCountAttributes);\n        const relationIdMetadataTransformer = new RelationIdMetadataToAttributeTransformer(this.expressionMap);\n        relationIdMetadataTransformer.transform();\n        const relationCountMetadataTransformer = new RelationCountMetadataToAttributeTransformer(this.expressionMap);\n        relationCountMetadataTransformer.transform();\n        let rawResults = [], entities = [];\n        // for pagination enabled (e.g. skip and take) its much more complicated - its a special process\n        // where we make two queries to find the data we need\n        // first query find ids in skip and take range\n        // and second query loads the actual data in given ids range\n        if ((this.expressionMap.skip || this.expressionMap.take) &&\n            this.expressionMap.joinAttributes.length > 0) {\n            // we are skipping order by here because its not working in subqueries anyway\n            // to make order by working we need to apply it on a distinct query\n            const [selects, orderBys] = this.createOrderByCombinedWithSelectExpression(\"distinctAlias\");\n            const metadata = this.expressionMap.mainAlias.metadata;\n            const mainAliasName = this.expressionMap.mainAlias.name;\n            const querySelects = metadata.primaryColumns.map((primaryColumn) => {\n                const distinctAlias = this.escape(\"distinctAlias\");\n                const columnAlias = this.escape(DriverUtils.buildAlias(this.connection.driver, undefined, mainAliasName, primaryColumn.databaseName));\n                if (!orderBys[columnAlias])\n                    // make sure we aren't overriding user-defined order in inverse direction\n                    orderBys[columnAlias] = \"ASC\";\n                const alias = DriverUtils.buildAlias(this.connection.driver, undefined, \"ids_\" + mainAliasName, primaryColumn.databaseName);\n                return `${distinctAlias}.${columnAlias} AS ${this.escape(alias)}`;\n            });\n            const originalQuery = this.clone();\n            // preserve original timeTravel value since we set it to \"false\" in subquery\n            const originalQueryTimeTravel = originalQuery.expressionMap.timeTravel;\n            rawResults = await new SelectQueryBuilder(this.connection, queryRunner)\n                .select(`DISTINCT ${querySelects.join(\", \")}`)\n                .addSelect(selects)\n                .from(`(${originalQuery\n                .orderBy()\n                .timeTravelQuery(false) // set it to \"false\" since time travel clause must appear at the very end and applies to the entire SELECT clause.\n                .getQuery()})`, \"distinctAlias\")\n                .timeTravelQuery(originalQueryTimeTravel)\n                .offset(this.expressionMap.skip)\n                .limit(this.expressionMap.take)\n                .orderBy(orderBys)\n                .cache(this.expressionMap.cache && this.expressionMap.cacheId\n                ? `${this.expressionMap.cacheId}-pagination`\n                : this.expressionMap.cache, this.expressionMap.cacheDuration)\n                .setParameters(this.getParameters())\n                .setNativeParameters(this.expressionMap.nativeParameters)\n                .getRawMany();\n            if (rawResults.length > 0) {\n                let condition = \"\";\n                const parameters = {};\n                if (metadata.hasMultiplePrimaryKeys) {\n                    condition = rawResults\n                        .map((result, index) => {\n                        return metadata.primaryColumns\n                            .map((primaryColumn) => {\n                            const paramKey = `orm_distinct_ids_${index}_${primaryColumn.databaseName}`;\n                            const paramKeyResult = DriverUtils.buildAlias(this.connection.driver, undefined, \"ids_\" + mainAliasName, primaryColumn.databaseName);\n                            parameters[paramKey] =\n                                result[paramKeyResult];\n                            return `${mainAliasName}.${primaryColumn.propertyPath}=:${paramKey}`;\n                        })\n                            .join(\" AND \");\n                    })\n                        .join(\" OR \");\n                }\n                else {\n                    const alias = DriverUtils.buildAlias(this.connection.driver, undefined, \"ids_\" + mainAliasName, metadata.primaryColumns[0].databaseName);\n                    const ids = rawResults.map((result) => result[alias]);\n                    const areAllNumbers = ids.every((id) => typeof id === \"number\");\n                    if (areAllNumbers) {\n                        // fixes #190. if all numbers then its safe to perform query without parameter\n                        condition = `${mainAliasName}.${metadata.primaryColumns[0].propertyPath} IN (${ids.join(\", \")})`;\n                    }\n                    else {\n                        parameters[\"orm_distinct_ids\"] = ids;\n                        condition =\n                            mainAliasName +\n                                \".\" +\n                                metadata.primaryColumns[0].propertyPath +\n                                \" IN (:...orm_distinct_ids)\";\n                    }\n                }\n                rawResults = await this.clone()\n                    .mergeExpressionMap({\n                    extraAppendedAndWhereCondition: condition,\n                })\n                    .setParameters(parameters)\n                    .loadRawResults(queryRunner);\n            }\n        }\n        else {\n            rawResults = await this.loadRawResults(queryRunner);\n        }\n        if (rawResults.length > 0) {\n            // transform raw results into entities\n            const rawRelationIdResults = await relationIdLoader.load(rawResults);\n            const rawRelationCountResults = await relationCountLoader.load(rawResults);\n            const transformer = new RawSqlResultsToEntityTransformer(this.expressionMap, this.connection.driver, rawRelationIdResults, rawRelationCountResults, this.queryRunner);\n            entities = transformer.transform(rawResults, this.expressionMap.mainAlias);\n            // broadcast all \"after load\" events\n            if (this.expressionMap.callListeners === true &&\n                this.expressionMap.mainAlias.hasMetadata) {\n                await queryRunner.broadcaster.broadcast(\"Load\", this.expressionMap.mainAlias.metadata, entities);\n            }\n        }\n        if (this.expressionMap.relationLoadStrategy === \"query\") {\n            const queryStrategyRelationIdLoader = new QueryStrategyRelationIdLoader(this.connection, queryRunner);\n            await Promise.all(this.relationMetadatas.map(async (relation) => {\n                const relationTarget = relation.inverseEntityMetadata.target;\n                const relationAlias = relation.inverseEntityMetadata.targetName;\n                const select = Array.isArray(this.findOptions.select)\n                    ? OrmUtils.propertyPathsToTruthyObject(this.findOptions.select)\n                    : this.findOptions.select;\n                const relations = Array.isArray(this.findOptions.relations)\n                    ? OrmUtils.propertyPathsToTruthyObject(this.findOptions.relations)\n                    : this.findOptions.relations;\n                const queryBuilder = this.createQueryBuilder()\n                    .select(relationAlias)\n                    .from(relationTarget, relationAlias)\n                    .setFindOptions({\n                    select: select\n                        ? OrmUtils.deepValue(select, relation.propertyPath)\n                        : undefined,\n                    order: this.findOptions.order\n                        ? OrmUtils.deepValue(this.findOptions.order, relation.propertyPath)\n                        : undefined,\n                    relations: relations\n                        ? OrmUtils.deepValue(relations, relation.propertyPath)\n                        : undefined,\n                    withDeleted: this.findOptions.withDeleted,\n                    relationLoadStrategy: this.findOptions.relationLoadStrategy,\n                });\n                if (entities.length > 0) {\n                    const relatedEntityGroups = await queryStrategyRelationIdLoader.loadManyToManyRelationIdsAndGroup(relation, entities, undefined, queryBuilder);\n                    entities.forEach((entity) => {\n                        const relatedEntityGroup = relatedEntityGroups.find((group) => group.entity === entity);\n                        if (relatedEntityGroup) {\n                            const value = relatedEntityGroup.related === undefined\n                                ? null\n                                : relatedEntityGroup.related;\n                            relation.setEntityValue(entity, value);\n                        }\n                    });\n                }\n            }));\n        }\n        return {\n            raw: rawResults,\n            entities: entities,\n        };\n    }\n    createOrderByCombinedWithSelectExpression(parentAlias) {\n        // if table has a default order then apply it\n        const orderBys = this.expressionMap.allOrderBys;\n        const selectString = Object.keys(orderBys)\n            .map((orderCriteria) => {\n            if (orderCriteria.indexOf(\".\") !== -1) {\n                const criteriaParts = orderCriteria.split(\".\");\n                const aliasName = criteriaParts[0];\n                const propertyPath = criteriaParts.slice(1).join(\".\");\n                const alias = this.expressionMap.findAliasByName(aliasName);\n                const column = alias.metadata.findColumnWithPropertyPath(propertyPath);\n                return (this.escape(parentAlias) +\n                    \".\" +\n                    this.escape(DriverUtils.buildAlias(this.connection.driver, undefined, aliasName, column.databaseName)));\n            }\n            else {\n                if (this.expressionMap.selects.find((select) => select.selection === orderCriteria ||\n                    select.aliasName === orderCriteria))\n                    return (this.escape(parentAlias) +\n                        \".\" +\n                        this.escape(orderCriteria));\n                return \"\";\n            }\n        })\n            .join(\", \");\n        const orderByObject = {};\n        Object.keys(orderBys).forEach((orderCriteria) => {\n            if (orderCriteria.indexOf(\".\") !== -1) {\n                const criteriaParts = orderCriteria.split(\".\");\n                const aliasName = criteriaParts[0];\n                const propertyPath = criteriaParts.slice(1).join(\".\");\n                const alias = this.expressionMap.findAliasByName(aliasName);\n                const column = alias.metadata.findColumnWithPropertyPath(propertyPath);\n                orderByObject[this.escape(parentAlias) +\n                    \".\" +\n                    this.escape(DriverUtils.buildAlias(this.connection.driver, undefined, aliasName, column.databaseName))] = orderBys[orderCriteria];\n            }\n            else {\n                if (this.expressionMap.selects.find((select) => select.selection === orderCriteria ||\n                    select.aliasName === orderCriteria)) {\n                    orderByObject[this.escape(parentAlias) +\n                        \".\" +\n                        this.escape(orderCriteria)] = orderBys[orderCriteria];\n                }\n                else {\n                    orderByObject[orderCriteria] = orderBys[orderCriteria];\n                }\n            }\n        });\n        return [selectString, orderByObject];\n    }\n    /**\n     * Loads raw results from the database.\n     */\n    async loadRawResults(queryRunner) {\n        const [sql, parameters] = this.getQueryAndParameters();\n        const queryId = sql + \" -- PARAMETERS: \" + JSON.stringify(parameters);\n        const cacheOptions = typeof this.connection.options.cache === \"object\"\n            ? this.connection.options.cache\n            : {};\n        let savedQueryResultCacheOptions = undefined;\n        const isCachingEnabled = \n        // Caching is enabled globally and isn't disabled locally.\n        (cacheOptions.alwaysEnabled && this.expressionMap.cache) ||\n            // ...or it's enabled locally explicitly.\n            this.expressionMap.cache;\n        let cacheError = false;\n        if (this.connection.queryResultCache && isCachingEnabled) {\n            try {\n                savedQueryResultCacheOptions =\n                    await this.connection.queryResultCache.getFromCache({\n                        identifier: this.expressionMap.cacheId,\n                        query: queryId,\n                        duration: this.expressionMap.cacheDuration ||\n                            cacheOptions.duration ||\n                            1000,\n                    }, queryRunner);\n                if (savedQueryResultCacheOptions &&\n                    !this.connection.queryResultCache.isExpired(savedQueryResultCacheOptions)) {\n                    return JSON.parse(savedQueryResultCacheOptions.result);\n                }\n            }\n            catch (error) {\n                if (!cacheOptions.ignoreErrors) {\n                    throw error;\n                }\n                cacheError = true;\n            }\n        }\n        const results = await queryRunner.query(sql, parameters, true);\n        if (!cacheError &&\n            this.connection.queryResultCache &&\n            isCachingEnabled) {\n            try {\n                await this.connection.queryResultCache.storeInCache({\n                    identifier: this.expressionMap.cacheId,\n                    query: queryId,\n                    time: new Date().getTime(),\n                    duration: this.expressionMap.cacheDuration ||\n                        cacheOptions.duration ||\n                        1000,\n                    result: JSON.stringify(results.records),\n                }, savedQueryResultCacheOptions, queryRunner);\n            }\n            catch (error) {\n                if (!cacheOptions.ignoreErrors) {\n                    throw error;\n                }\n            }\n        }\n        return results.records;\n    }\n    /**\n     * Merges into expression map given expression map properties.\n     */\n    mergeExpressionMap(expressionMap) {\n        ObjectUtils.assign(this.expressionMap, expressionMap);\n        return this;\n    }\n    /**\n     * Normalizes a give number - converts to int if possible.\n     */\n    normalizeNumber(num) {\n        if (typeof num === \"number\" || num === undefined || num === null)\n            return num;\n        return Number(num);\n    }\n    /**\n     * Creates a query builder used to execute sql queries inside this query builder.\n     */\n    obtainQueryRunner() {\n        return this.queryRunner || this.connection.createQueryRunner(\"slave\");\n    }\n    buildSelect(select, metadata, alias, embedPrefix) {\n        for (let key in select) {\n            if (select[key] === undefined || select[key] === false)\n                continue;\n            const propertyPath = embedPrefix ? embedPrefix + \".\" + key : key;\n            const column = metadata.findColumnWithPropertyPathStrict(propertyPath);\n            const embed = metadata.findEmbeddedWithPropertyPath(propertyPath);\n            const relation = metadata.findRelationWithPropertyPath(propertyPath);\n            if (!embed && !column && !relation)\n                throw new EntityPropertyNotFoundError(propertyPath, metadata);\n            if (column) {\n                this.selects.push(alias + \".\" + propertyPath);\n                // this.addSelect(alias + \".\" + propertyPath);\n            }\n            else if (embed) {\n                this.buildSelect(select[key], metadata, alias, propertyPath);\n                // } else if (relation) {\n                //     const joinAlias = alias + \"_\" + relation.propertyName;\n                //     const existJoin = this.joins.find(join => join.alias === joinAlias);\n                //     if (!existJoin) {\n                //         this.joins.push({\n                //             type: \"left\",\n                //             select: false,\n                //             alias: joinAlias,\n                //             parentAlias: alias,\n                //             relationMetadata: relation\n                //         });\n                //     }\n                //     this.buildOrder(select[key] as FindOptionsOrder<any>, relation.inverseEntityMetadata, joinAlias);\n            }\n        }\n    }\n    buildRelations(relations, selection, metadata, alias, embedPrefix) {\n        if (!relations)\n            return;\n        Object.keys(relations).forEach((relationName) => {\n            const relationValue = relations[relationName];\n            const propertyPath = embedPrefix\n                ? embedPrefix + \".\" + relationName\n                : relationName;\n            const embed = metadata.findEmbeddedWithPropertyPath(propertyPath);\n            const relation = metadata.findRelationWithPropertyPath(propertyPath);\n            if (!embed && !relation)\n                throw new EntityPropertyNotFoundError(propertyPath, metadata);\n            if (embed) {\n                this.buildRelations(relationValue, typeof selection === \"object\"\n                    ? OrmUtils.deepValue(selection, embed.propertyPath)\n                    : undefined, metadata, alias, propertyPath);\n            }\n            else if (relation) {\n                let joinAlias = alias + \"_\" + propertyPath.replace(\".\", \"_\");\n                joinAlias = DriverUtils.buildAlias(this.connection.driver, { joiner: \"__\" }, alias, joinAlias);\n                if (relationValue === true ||\n                    typeof relationValue === \"object\") {\n                    if (this.expressionMap.relationLoadStrategy === \"query\") {\n                        this.concatRelationMetadata(relation);\n                    }\n                    else {\n                        // join\n                        this.joins.push({\n                            type: \"left\",\n                            select: true,\n                            selection: selection &&\n                                typeof selection[relationName] === \"object\"\n                                ? selection[relationName]\n                                : undefined,\n                            alias: joinAlias,\n                            parentAlias: alias,\n                            relationMetadata: relation,\n                        });\n                        if (selection &&\n                            typeof selection[relationName] === \"object\") {\n                            this.buildSelect(selection[relationName], relation.inverseEntityMetadata, joinAlias);\n                        }\n                    }\n                }\n                if (typeof relationValue === \"object\" &&\n                    this.expressionMap.relationLoadStrategy === \"join\") {\n                    this.buildRelations(relationValue, typeof selection === \"object\"\n                        ? OrmUtils.deepValue(selection, relation.propertyPath)\n                        : undefined, relation.inverseEntityMetadata, joinAlias, undefined);\n                }\n            }\n        });\n    }\n    buildEagerRelations(relations, selection, metadata, alias, embedPrefix) {\n        if (!relations)\n            return;\n        Object.keys(relations).forEach((relationName) => {\n            const relationValue = relations[relationName];\n            const propertyPath = embedPrefix\n                ? embedPrefix + \".\" + relationName\n                : relationName;\n            const embed = metadata.findEmbeddedWithPropertyPath(propertyPath);\n            const relation = metadata.findRelationWithPropertyPath(propertyPath);\n            if (!embed && !relation)\n                throw new EntityPropertyNotFoundError(propertyPath, metadata);\n            if (embed) {\n                this.buildEagerRelations(relationValue, typeof selection === \"object\"\n                    ? OrmUtils.deepValue(selection, embed.propertyPath)\n                    : undefined, metadata, alias, propertyPath);\n            }\n            else if (relation) {\n                let joinAlias = alias + \"_\" + propertyPath.replace(\".\", \"_\");\n                joinAlias = DriverUtils.buildAlias(this.connection.driver, { joiner: \"__\" }, alias, joinAlias);\n                if (relationValue === true ||\n                    typeof relationValue === \"object\") {\n                    relation.inverseEntityMetadata.eagerRelations.forEach((eagerRelation) => {\n                        let eagerRelationJoinAlias = joinAlias +\n                            \"_\" +\n                            eagerRelation.propertyPath.replace(\".\", \"_\");\n                        eagerRelationJoinAlias = DriverUtils.buildAlias(this.connection.driver, { joiner: \"__\" }, joinAlias, eagerRelationJoinAlias);\n                        const existJoin = this.joins.find((join) => join.alias === eagerRelationJoinAlias);\n                        if (!existJoin) {\n                            this.joins.push({\n                                type: \"left\",\n                                select: true,\n                                alias: eagerRelationJoinAlias,\n                                parentAlias: joinAlias,\n                                selection: undefined,\n                                relationMetadata: eagerRelation,\n                            });\n                        }\n                        if (selection &&\n                            typeof selection[relationName] === \"object\") {\n                            this.buildSelect(selection[relationName], relation.inverseEntityMetadata, joinAlias);\n                        }\n                    });\n                }\n                if (typeof relationValue === \"object\") {\n                    this.buildEagerRelations(relationValue, typeof selection === \"object\"\n                        ? OrmUtils.deepValue(selection, relation.propertyPath)\n                        : undefined, relation.inverseEntityMetadata, joinAlias, undefined);\n                }\n            }\n        });\n    }\n    buildOrder(order, metadata, alias, embedPrefix) {\n        for (let key in order) {\n            if (order[key] === undefined)\n                continue;\n            const propertyPath = embedPrefix ? embedPrefix + \".\" + key : key;\n            const column = metadata.findColumnWithPropertyPathStrict(propertyPath);\n            const embed = metadata.findEmbeddedWithPropertyPath(propertyPath);\n            const relation = metadata.findRelationWithPropertyPath(propertyPath);\n            if (!embed && !column && !relation)\n                throw new EntityPropertyNotFoundError(propertyPath, metadata);\n            if (column) {\n                let direction = typeof order[key] === \"object\"\n                    ? order[key].direction\n                    : order[key];\n                direction =\n                    direction === \"DESC\" ||\n                        direction === \"desc\" ||\n                        direction === -1\n                        ? \"DESC\"\n                        : \"ASC\";\n                let nulls = typeof order[key] === \"object\"\n                    ? order[key].nulls\n                    : undefined;\n                nulls =\n                    (nulls === null || nulls === void 0 ? void 0 : nulls.toLowerCase()) === \"first\"\n                        ? \"NULLS FIRST\"\n                        : (nulls === null || nulls === void 0 ? void 0 : nulls.toLowerCase()) === \"last\"\n                            ? \"NULLS LAST\"\n                            : undefined;\n                let aliasPath = `${alias}.${propertyPath}`;\n                // const selection = this.expressionMap.selects.find(\n                //     (s) => s.selection === aliasPath,\n                // )\n                // if (selection) {\n                //     // this is not building correctly now???\n                //     aliasPath = this.escape(\n                //         DriverUtils.buildAlias(\n                //             this.connection.driver,\n                //             undefined,\n                //             alias,\n                //             column.databaseName,\n                //         ),\n                //     )\n                //     // selection.aliasName = aliasPath\n                // } else {\n                //     if (column.isVirtualProperty && column.query) {\n                //         aliasPath = `(${column.query(alias)})`\n                //     }\n                // }\n                // console.log(\"add sort\", selection, aliasPath, direction, nulls)\n                this.addOrderBy(aliasPath, direction, nulls);\n                // this.orderBys.push({ alias: alias + \".\" + propertyPath, direction, nulls });\n            }\n            else if (embed) {\n                this.buildOrder(order[key], metadata, alias, propertyPath);\n            }\n            else if (relation) {\n                let joinAlias = alias + \"_\" + propertyPath.replace(\".\", \"_\");\n                joinAlias = DriverUtils.buildAlias(this.connection.driver, { joiner: \"__\" }, alias, joinAlias);\n                // console.log(\"joinAlias\", joinAlias, joinAlias.length, this.connection.driver.maxAliasLength)\n                // todo: use expressionMap.joinAttributes, and create a new one using\n                //  const joinAttribute = new JoinAttribute(this.connection, this.expressionMap);\n                const existJoin = this.joins.find((join) => join.alias === joinAlias);\n                if (!existJoin) {\n                    this.joins.push({\n                        type: \"left\",\n                        select: false,\n                        alias: joinAlias,\n                        parentAlias: alias,\n                        selection: undefined,\n                        relationMetadata: relation,\n                    });\n                }\n                this.buildOrder(order[key], relation.inverseEntityMetadata, joinAlias);\n            }\n        }\n    }\n    buildWhere(where, metadata, alias, embedPrefix) {\n        let condition = \"\";\n        // let parameterIndex = Object.keys(this.expressionMap.nativeParameters).length;\n        if (Array.isArray(where) && where.length) {\n            condition =\n                \"(\" +\n                    where\n                        .map((whereItem) => {\n                        return this.buildWhere(whereItem, metadata, alias, embedPrefix);\n                    })\n                        .filter((condition) => !!condition)\n                        .map((condition) => \"(\" + condition + \")\")\n                        .join(\" OR \") +\n                    \")\";\n        }\n        else {\n            let andConditions = [];\n            for (let key in where) {\n                if (where[key] === undefined || where[key] === null)\n                    continue;\n                const propertyPath = embedPrefix ? embedPrefix + \".\" + key : key;\n                const column = metadata.findColumnWithPropertyPathStrict(propertyPath);\n                const embed = metadata.findEmbeddedWithPropertyPath(propertyPath);\n                const relation = metadata.findRelationWithPropertyPath(propertyPath);\n                if (!embed && !column && !relation)\n                    throw new EntityPropertyNotFoundError(propertyPath, metadata);\n                if (column) {\n                    let aliasPath = `${alias}.${propertyPath}`;\n                    if (column.isVirtualProperty && column.query) {\n                        aliasPath = `(${column.query(alias)})`;\n                    }\n                    // const parameterName = alias + \"_\" + propertyPath.split(\".\").join(\"_\") + \"_\" + parameterIndex;\n                    // todo: we need to handle other operators as well?\n                    let parameterValue = where[key];\n                    if (InstanceChecker.isEqualOperator(where[key])) {\n                        parameterValue = where[key].value;\n                    }\n                    if (column.transformer) {\n                        parameterValue instanceof FindOperator\n                            ? parameterValue.transformValue(column.transformer)\n                            : (parameterValue =\n                                ApplyValueTransformers.transformTo(column.transformer, parameterValue));\n                    }\n                    // if (parameterValue === null) {\n                    //     andConditions.push(`${aliasPath} IS NULL`);\n                    //\n                    // } else if (parameterValue instanceof FindOperator) {\n                    //     // let parameters: any[] = [];\n                    //     // if (parameterValue.useParameter) {\n                    //     //     const realParameterValues: any[] = parameterValue.multipleParameters ? parameterValue.value : [parameterValue.value];\n                    //     //     realParameterValues.forEach((realParameterValue, realParameterValueIndex) => {\n                    //     //\n                    //     //         // don't create parameters for number to prevent max number of variables issues as much as possible\n                    //     //         if (typeof realParameterValue === \"number\") {\n                    //     //             parameters.push(realParameterValue);\n                    //     //\n                    //     //         } else {\n                    //     //             this.expressionMap.nativeParameters[parameterName + realParameterValueIndex] = realParameterValue;\n                    //     //             parameterIndex++;\n                    //     //             parameters.push(this.connection.driver.createParameter(parameterName + realParameterValueIndex, parameterIndex - 1));\n                    //     //         }\n                    //     //     });\n                    //     // }\n                    //     andConditions.push(\n                    //         this.createWhereConditionExpression(this.getWherePredicateCondition(aliasPath, parameterValue))\n                    //         // parameterValue.toSql(this.connection, aliasPath, parameters));\n                    //     )\n                    //\n                    // } else {\n                    //     this.expressionMap.nativeParameters[parameterName] = parameterValue;\n                    //     parameterIndex++;\n                    //     const parameter = this.connection.driver.createParameter(parameterName, parameterIndex - 1);\n                    //     andConditions.push(`${aliasPath} = ${parameter}`);\n                    // }\n                    andConditions.push(this.createWhereConditionExpression(this.getWherePredicateCondition(aliasPath, parameterValue)));\n                    // this.conditions.push(`${alias}.${propertyPath} = :${paramName}`);\n                    // this.expressionMap.parameters[paramName] = where[key]; // todo: handle functions and other edge cases\n                }\n                else if (embed) {\n                    const condition = this.buildWhere(where[key], metadata, alias, propertyPath);\n                    if (condition)\n                        andConditions.push(condition);\n                }\n                else if (relation) {\n                    // if all properties of where are undefined we don't need to join anything\n                    // this can happen when user defines map with conditional queries inside\n                    if (typeof where[key] === \"object\") {\n                        const allAllUndefined = Object.keys(where[key]).every((k) => where[key][k] === undefined);\n                        if (allAllUndefined) {\n                            continue;\n                        }\n                    }\n                    if (InstanceChecker.isFindOperator(where[key])) {\n                        if (where[key].type === \"moreThan\" ||\n                            where[key].type === \"lessThan\" ||\n                            where[key].type === \"moreThanOrEqual\" ||\n                            where[key].type === \"lessThanOrEqual\") {\n                            let sqlOperator = \"\";\n                            if (where[key].type === \"moreThan\") {\n                                sqlOperator = \">\";\n                            }\n                            else if (where[key].type === \"lessThan\") {\n                                sqlOperator = \"<\";\n                            }\n                            else if (where[key].type === \"moreThanOrEqual\") {\n                                sqlOperator = \">=\";\n                            }\n                            else if (where[key].type === \"lessThanOrEqual\") {\n                                sqlOperator = \"<=\";\n                            }\n                            // basically relation count functionality\n                            const qb = this.subQuery();\n                            if (relation.isManyToManyOwner) {\n                                qb.select(\"COUNT(*)\")\n                                    .from(relation.joinTableName, relation.joinTableName)\n                                    .where(relation.joinColumns\n                                    .map((column) => {\n                                    return `${relation.joinTableName}.${column.propertyName} = ${alias}.${column.referencedColumn\n                                        .propertyName}`;\n                                })\n                                    .join(\" AND \"));\n                            }\n                            else if (relation.isManyToManyNotOwner) {\n                                qb.select(\"COUNT(*)\")\n                                    .from(relation.inverseRelation.joinTableName, relation.inverseRelation.joinTableName)\n                                    .where(relation\n                                    .inverseRelation.inverseJoinColumns.map((column) => {\n                                    return `${relation.inverseRelation\n                                        .joinTableName}.${column.propertyName} = ${alias}.${column.referencedColumn\n                                        .propertyName}`;\n                                })\n                                    .join(\" AND \"));\n                            }\n                            else if (relation.isOneToMany) {\n                                qb.select(\"COUNT(*)\")\n                                    .from(relation.inverseEntityMetadata.target, relation.inverseEntityMetadata\n                                    .tableName)\n                                    .where(relation\n                                    .inverseRelation.joinColumns.map((column) => {\n                                    return `${relation\n                                        .inverseEntityMetadata\n                                        .tableName}.${column.propertyName} = ${alias}.${column.referencedColumn\n                                        .propertyName}`;\n                                })\n                                    .join(\" AND \"));\n                            }\n                            else {\n                                throw new Error(`This relation isn't supported by given find operator`);\n                            }\n                            // this\n                            //     .addSelect(qb.getSql(), relation.propertyAliasName + \"_cnt\")\n                            //     .andWhere(this.escape(relation.propertyAliasName + \"_cnt\") + \" \" + sqlOperator + \" \" + parseInt(where[key].value));\n                            this.andWhere(qb.getSql() +\n                                \" \" +\n                                sqlOperator +\n                                \" \" +\n                                parseInt(where[key].value));\n                        }\n                        else {\n                            if (relation.isManyToOne ||\n                                (relation.isOneToOne &&\n                                    relation.isOneToOneOwner)) {\n                                const aliasPath = `${alias}.${propertyPath}`;\n                                andConditions.push(this.createWhereConditionExpression(this.getWherePredicateCondition(aliasPath, where[key])));\n                            }\n                            else {\n                                throw new Error(`This relation isn't supported by given find operator`);\n                            }\n                        }\n                    }\n                    else {\n                        // const joinAlias = alias + \"_\" + relation.propertyName;\n                        let joinAlias = alias +\n                            \"_\" +\n                            relation.propertyPath.replace(\".\", \"_\");\n                        joinAlias = DriverUtils.buildAlias(this.connection.driver, { joiner: \"__\" }, alias, joinAlias);\n                        const existJoin = this.joins.find((join) => join.alias === joinAlias);\n                        if (!existJoin) {\n                            this.joins.push({\n                                type: \"left\",\n                                select: false,\n                                selection: undefined,\n                                alias: joinAlias,\n                                parentAlias: alias,\n                                relationMetadata: relation,\n                            });\n                        }\n                        const condition = this.buildWhere(where[key], relation.inverseEntityMetadata, joinAlias);\n                        if (condition) {\n                            andConditions.push(condition);\n                            // parameterIndex = Object.keys(this.expressionMap.nativeParameters).length;\n                        }\n                    }\n                }\n            }\n            condition = andConditions.join(\" AND \");\n        }\n        return condition;\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}