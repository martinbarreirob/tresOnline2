{"ast":null,"code":"import { OrmUtils } from \"../util/OrmUtils\";\nimport { ApplyValueTransformers } from \"../util/ApplyValueTransformers\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\n/**\n * This metadata contains all information about entity's column.\n */\nexport class ColumnMetadata {\n  // ---------------------------------------------------------------------\n  // Constructor\n  // ---------------------------------------------------------------------\n  constructor(options) {\n    this[\"@instanceof\"] = Symbol.for(\"ColumnMetadata\");\n    /**\n     * Type's length in the database.\n     */\n    this.length = \"\";\n    /**\n     * Indicates if this column is a primary key.\n     */\n    this.isPrimary = false;\n    /**\n     * Indicates if this column is generated (auto increment or generated other way).\n     */\n    this.isGenerated = false;\n    /**\n     * Indicates if column can contain nulls or not.\n     */\n    this.isNullable = false;\n    /**\n     * Indicates if column is selected by query builder or not.\n     */\n    this.isSelect = true;\n    /**\n     * Indicates if column is inserted by default or not.\n     */\n    this.isInsert = true;\n    /**\n     * Indicates if column allows updates or not.\n     */\n    this.isUpdate = true;\n    /**\n     * Puts ZEROFILL attribute on to numeric column. Works only for MySQL.\n     * If you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to the column\n     */\n    this.zerofill = false;\n    /**\n     * Puts UNSIGNED attribute on to numeric column. Works only for MySQL.\n     */\n    this.unsigned = false;\n    /**\n     * Indicates if this column is an array.\n     */\n    this.isArray = false;\n    /**\n     * Indicates if column is virtual. Virtual columns are not mapped to the entity.\n     */\n    this.isVirtual = false;\n    /**\n     * Indicates if column is a virtual property. Virtual properties are not mapped to the entity.\n     * This property is used in tandem the virtual column decorator.\n     * @See https://typeorm.io/decorator-reference#virtualcolumn for more details.\n     */\n    this.isVirtualProperty = false;\n    /**\n     * Indicates if column is discriminator. Discriminator columns are not mapped to the entity.\n     */\n    this.isDiscriminator = false;\n    /**\n     * Indicates if column is tree-level column. Tree-level columns are used in closure entities.\n     */\n    this.isTreeLevel = false;\n    /**\n     * Indicates if this column contains an entity creation date.\n     */\n    this.isCreateDate = false;\n    /**\n     * Indicates if this column contains an entity update date.\n     */\n    this.isUpdateDate = false;\n    /**\n     * Indicates if this column contains an entity delete date.\n     */\n    this.isDeleteDate = false;\n    /**\n     * Indicates if this column contains an entity version.\n     */\n    this.isVersion = false;\n    /**\n     * Indicates if this column contains an object id.\n     */\n    this.isObjectId = false;\n    /**\n     * Indicates if this column is nested set's left column.\n     * Used only in tree entities with nested-set type.\n     */\n    this.isNestedSetLeft = false;\n    /**\n     * Indicates if this column is nested set's right column.\n     * Used only in tree entities with nested-set type.\n     */\n    this.isNestedSetRight = false;\n    /**\n     * Indicates if this column is materialized path's path column.\n     * Used only in tree entities with materialized path type.\n     */\n    this.isMaterializedPath = false;\n    this.entityMetadata = options.entityMetadata;\n    this.embeddedMetadata = options.embeddedMetadata;\n    this.referencedColumn = options.referencedColumn;\n    if (options.args.target) this.target = options.args.target;\n    if (options.args.propertyName) this.propertyName = options.args.propertyName;\n    if (options.args.options.name) this.givenDatabaseName = options.args.options.name;\n    if (options.args.options.type) this.type = options.args.options.type;\n    if (options.args.options.length) this.length = options.args.options.length ? options.args.options.length.toString() : \"\";\n    if (options.args.options.width) this.width = options.args.options.width;\n    if (options.args.options.charset) this.charset = options.args.options.charset;\n    if (options.args.options.collation) this.collation = options.args.options.collation;\n    if (options.args.options.primary) this.isPrimary = options.args.options.primary;\n    if (options.args.options.default === null)\n      // to make sure default: null is the same as nullable: true\n      this.isNullable = true;\n    if (options.args.options.nullable !== undefined) this.isNullable = options.args.options.nullable;\n    if (options.args.options.select !== undefined) this.isSelect = options.args.options.select;\n    if (options.args.options.insert !== undefined) this.isInsert = options.args.options.insert;\n    if (options.args.options.update !== undefined) this.isUpdate = options.args.options.update;\n    if (options.args.options.readonly !== undefined) this.isUpdate = !options.args.options.readonly;\n    if (options.args.options.comment) this.comment = options.args.options.comment;\n    if (options.args.options.default !== undefined) this.default = options.args.options.default;\n    if (options.args.options.onUpdate) this.onUpdate = options.args.options.onUpdate;\n    if (options.args.options.generatedIdentity) this.generatedIdentity = options.args.options.generatedIdentity;\n    if (options.args.options.scale !== null && options.args.options.scale !== undefined) this.scale = options.args.options.scale;\n    if (options.args.options.zerofill) {\n      this.zerofill = options.args.options.zerofill;\n      this.unsigned = true; // if you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to the column\n    }\n\n    if (options.args.options.unsigned) this.unsigned = options.args.options.unsigned;\n    if (options.args.options.precision !== null) this.precision = options.args.options.precision;\n    if (options.args.options.enum) {\n      if (ObjectUtils.isObject(options.args.options.enum) && !Array.isArray(options.args.options.enum)) {\n        this.enum = Object.keys(options.args.options.enum)\n        // remove numeric keys - typescript numeric enum types generate them\n        // From the documentation: “declaration merging” means that the compiler merges two separate declarations\n        // declared with the same name into a single definition. This concept is often used to merge enum with namespace\n        // where in namespace we define e.g. utility methods for creating enum. This is well known in other languages\n        // like Java (enum methods). Here in case if enum have function, we need to remove it from metadata, otherwise\n        // generated SQL statements contains string representation of that function which leads into syntax error\n        // at database side.\n        .filter(key => isNaN(+key) && typeof options.args.options.enum[key] !== \"function\").map(key => options.args.options.enum[key]);\n      } else {\n        this.enum = options.args.options.enum;\n      }\n    }\n    if (options.args.options.enumName) {\n      this.enumName = options.args.options.enumName;\n    }\n    if (options.args.options.primaryKeyConstraintName) {\n      this.primaryKeyConstraintName = options.args.options.primaryKeyConstraintName;\n    }\n    if (options.args.options.foreignKeyConstraintName) {\n      this.foreignKeyConstraintName = options.args.options.foreignKeyConstraintName;\n    }\n    if (options.args.options.asExpression) {\n      this.asExpression = options.args.options.asExpression;\n      this.generatedType = options.args.options.generatedType ? options.args.options.generatedType : \"VIRTUAL\";\n    }\n    if (options.args.options.hstoreType) this.hstoreType = options.args.options.hstoreType;\n    if (options.args.options.array) this.isArray = options.args.options.array;\n    if (options.args.mode) {\n      this.isVirtualProperty = options.args.mode === \"virtual-property\";\n      this.isVirtual = options.args.mode === \"virtual\";\n      this.isTreeLevel = options.args.mode === \"treeLevel\";\n      this.isCreateDate = options.args.mode === \"createDate\";\n      this.isUpdateDate = options.args.mode === \"updateDate\";\n      this.isDeleteDate = options.args.mode === \"deleteDate\";\n      this.isVersion = options.args.mode === \"version\";\n      this.isObjectId = options.args.mode === \"objectId\";\n    }\n    if (this.isVirtualProperty) {\n      this.isInsert = false;\n      this.isUpdate = false;\n    }\n    if (options.args.options.transformer) this.transformer = options.args.options.transformer;\n    if (options.args.options.spatialFeatureType) this.spatialFeatureType = options.args.options.spatialFeatureType;\n    if (options.args.options.srid !== undefined) this.srid = options.args.options.srid;\n    if (options.args.options.query) this.query = options.args.options.query;\n    if (this.isTreeLevel) this.type = options.connection.driver.mappedDataTypes.treeLevel;\n    if (this.isCreateDate) {\n      if (!this.type) this.type = options.connection.driver.mappedDataTypes.createDate;\n      if (!this.default) this.default = () => options.connection.driver.mappedDataTypes.createDateDefault;\n      // skip precision if it was explicitly set to \"null\" in column options. Otherwise use default precision if it exist.\n      if (this.precision === undefined && options.args.options.precision === undefined && options.connection.driver.mappedDataTypes.createDatePrecision) this.precision = options.connection.driver.mappedDataTypes.createDatePrecision;\n    }\n    if (this.isUpdateDate) {\n      if (!this.type) this.type = options.connection.driver.mappedDataTypes.updateDate;\n      if (!this.default) this.default = () => options.connection.driver.mappedDataTypes.updateDateDefault;\n      if (!this.onUpdate) this.onUpdate = options.connection.driver.mappedDataTypes.updateDateDefault;\n      // skip precision if it was explicitly set to \"null\" in column options. Otherwise use default precision if it exist.\n      if (this.precision === undefined && options.args.options.precision === undefined && options.connection.driver.mappedDataTypes.updateDatePrecision) this.precision = options.connection.driver.mappedDataTypes.updateDatePrecision;\n    }\n    if (this.isDeleteDate) {\n      if (!this.type) this.type = options.connection.driver.mappedDataTypes.deleteDate;\n      if (!this.isNullable) this.isNullable = options.connection.driver.mappedDataTypes.deleteDateNullable;\n      // skip precision if it was explicitly set to \"null\" in column options. Otherwise use default precision if it exist.\n      if (this.precision === undefined && options.args.options.precision === undefined && options.connection.driver.mappedDataTypes.deleteDatePrecision) this.precision = options.connection.driver.mappedDataTypes.deleteDatePrecision;\n    }\n    if (this.isVersion) this.type = options.connection.driver.mappedDataTypes.version;\n    if (options.closureType) this.closureType = options.closureType;\n    if (options.nestedSetLeft) this.isNestedSetLeft = options.nestedSetLeft;\n    if (options.nestedSetRight) this.isNestedSetRight = options.nestedSetRight;\n    if (options.materializedPath) this.isMaterializedPath = options.materializedPath;\n  }\n  // ---------------------------------------------------------------------\n  // Public Methods\n  // ---------------------------------------------------------------------\n  /**\n   * Creates entity id map from the given entity ids array.\n   */\n  createValueMap(value, useDatabaseName = false) {\n    // extract column value from embeds of entity if column is in embedded\n    if (this.embeddedMetadata) {\n      // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n      // we need to get value of \"id\" column from the post real entity object and return it in a\n      // { data: { information: { counters: { id: ... } } } } format\n      // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n      const propertyNames = [...this.embeddedMetadata.parentPropertyNames];\n      // now need to access post[data][information][counters] to get column value from the counters\n      // and on each step we need to create complex literal object, e.g. first { data },\n      // then { data: { information } }, then { data: { information: { counters } } },\n      // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }\n      // this recursive function helps doing that\n      const extractEmbeddedColumnValue = (propertyNames, map) => {\n        const propertyName = propertyNames.shift();\n        if (propertyName) {\n          map[propertyName] = {};\n          extractEmbeddedColumnValue(propertyNames, map[propertyName]);\n          return map;\n        }\n        // this is bugfix for #720 when increment number is bigint we need to make sure its a string\n        if ((this.generationStrategy === \"increment\" || this.generationStrategy === \"rowid\") && this.type === \"bigint\" && value !== null) value = String(value);\n        map[useDatabaseName ? this.databaseName : this.propertyName] = value;\n        return map;\n      };\n      return extractEmbeddedColumnValue(propertyNames, {});\n    } else {\n      // no embeds - no problems. Simply return column property name and its value of the entity\n      // this is bugfix for #720 when increment number is bigint we need to make sure its a string\n      if ((this.generationStrategy === \"increment\" || this.generationStrategy === \"rowid\") && this.type === \"bigint\" && value !== null) value = String(value);\n      return {\n        [useDatabaseName ? this.databaseName : this.propertyName]: value\n      };\n    }\n  }\n  /**\n   * Extracts column value and returns its column name with this value in a literal object.\n   * If column is in embedded (or recursive embedded) it returns complex literal object.\n   *\n   * Examples what this method can return depend if this column is in embeds.\n   * { id: 1 } or { title: \"hello\" }, { counters: { code: 1 } }, { data: { information: { counters: { code: 1 } } } }\n   */\n  getEntityValueMap(entity, options) {\n    var _a;\n    const returnNulls = false; // options && options.skipNulls === false ? false : true; // todo: remove if current will not bring problems, uncomment if it will.\n    // extract column value from embeds of entity if column is in embedded\n    if (this.embeddedMetadata) {\n      // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n      // we need to get value of \"id\" column from the post real entity object and return it in a\n      // { data: { information: { counters: { id: ... } } } } format\n      // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n      const propertyNames = [...this.embeddedMetadata.parentPropertyNames];\n      const isEmbeddedArray = this.embeddedMetadata.isArray;\n      // now need to access post[data][information][counters] to get column value from the counters\n      // and on each step we need to create complex literal object, e.g. first { data },\n      // then { data: { information } }, then { data: { information: { counters } } },\n      // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }\n      // this recursive function helps doing that\n      const extractEmbeddedColumnValue = (propertyNames, value) => {\n        if (value === undefined) {\n          return {};\n        }\n        const propertyName = propertyNames.shift();\n        if (propertyName) {\n          const submap = extractEmbeddedColumnValue(propertyNames, value[propertyName]);\n          if (Object.keys(submap).length > 0) {\n            return {\n              [propertyName]: submap\n            };\n          }\n          return {};\n        }\n        if (isEmbeddedArray && Array.isArray(value)) {\n          return value.map(v => ({\n            [this.propertyName]: v[this.propertyName]\n          }));\n        }\n        if (value[this.propertyName] !== undefined && (returnNulls === false || value[this.propertyName] !== null)) {\n          return {\n            [this.propertyName]: value[this.propertyName]\n          };\n        }\n        return {};\n      };\n      const map = extractEmbeddedColumnValue(propertyNames, entity);\n      return Object.keys(map).length > 0 ? map : undefined;\n    } else {\n      // no embeds - no problems. Simply return column property name and its value of the entity\n      /**\n       * Object.getOwnPropertyDescriptor checks if the relation is lazy, in which case value is a Promise\n       * DO NOT use `entity[\n          this.relationMetadata.propertyName] instanceof Promise`, which will invoke property getter and make unwanted DB request\n       * refer: https://github.com/typeorm/typeorm/pull/8676#issuecomment-1049906331\n       */\n      if (this.relationMetadata && !((_a = Object.getOwnPropertyDescriptor(entity, this.relationMetadata.propertyName)) === null || _a === void 0 ? void 0 : _a.get) && entity[this.relationMetadata.propertyName] && ObjectUtils.isObject(entity[this.relationMetadata.propertyName])) {\n        const map = this.relationMetadata.joinColumns.reduce((map, joinColumn) => {\n          const value = joinColumn.referencedColumn.getEntityValueMap(entity[this.relationMetadata.propertyName]);\n          if (value === undefined) return map;\n          return OrmUtils.mergeDeep(map, value);\n        }, {});\n        if (Object.keys(map).length > 0) return {\n          [this.propertyName]: map\n        };\n        return undefined;\n      } else {\n        if (entity[this.propertyName] !== undefined && (returnNulls === false || entity[this.propertyName] !== null)) return {\n          [this.propertyName]: entity[this.propertyName]\n        };\n        return undefined;\n      }\n    }\n  }\n  /**\n   * Extracts column value from the given entity.\n   * If column is in embedded (or recursive embedded) it extracts its value from there.\n   */\n  getEntityValue(entity, transform = false) {\n    if (entity === undefined || entity === null) return undefined;\n    // extract column value from embeddeds of entity if column is in embedded\n    let value = undefined;\n    if (this.embeddedMetadata) {\n      // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n      // we need to get value of \"id\" column from the post real entity object\n      // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n      const propertyNames = [...this.embeddedMetadata.parentPropertyNames];\n      const isEmbeddedArray = this.embeddedMetadata.isArray;\n      // next we need to access post[data][information][counters][this.propertyName] to get column value from the counters\n      // this recursive function takes array of generated property names and gets the post[data][information][counters] embed\n      const extractEmbeddedColumnValue = (propertyNames, value) => {\n        const propertyName = propertyNames.shift();\n        return propertyName && value ? extractEmbeddedColumnValue(propertyNames, value[propertyName]) : value;\n      };\n      // once we get nested embed object we get its column, e.g. post[data][information][counters][this.propertyName]\n      const embeddedObject = extractEmbeddedColumnValue(propertyNames, entity);\n      if (embeddedObject) {\n        if (this.relationMetadata && this.referencedColumn) {\n          const relatedEntity = this.relationMetadata.getEntityValue(embeddedObject);\n          if (relatedEntity && ObjectUtils.isObject(relatedEntity) && !InstanceChecker.isFindOperator(relatedEntity) && !Buffer.isBuffer(relatedEntity)) {\n            value = this.referencedColumn.getEntityValue(relatedEntity);\n          } else if (embeddedObject[this.propertyName] && ObjectUtils.isObject(embeddedObject[this.propertyName]) && !InstanceChecker.isFindOperator(embeddedObject[this.propertyName]) && !Buffer.isBuffer(embeddedObject[this.propertyName]) && !(embeddedObject[this.propertyName] instanceof Date)) {\n            value = this.referencedColumn.getEntityValue(embeddedObject[this.propertyName]);\n          } else {\n            value = embeddedObject[this.propertyName];\n          }\n        } else if (this.referencedColumn) {\n          value = this.referencedColumn.getEntityValue(embeddedObject[this.propertyName]);\n        } else if (isEmbeddedArray && Array.isArray(embeddedObject)) {\n          value = embeddedObject.map(o => o[this.propertyName]);\n        } else {\n          value = embeddedObject[this.propertyName];\n        }\n      }\n    } else {\n      // no embeds - no problems. Simply return column name by property name of the entity\n      if (this.relationMetadata && this.referencedColumn) {\n        const relatedEntity = this.relationMetadata.getEntityValue(entity);\n        if (relatedEntity && ObjectUtils.isObject(relatedEntity) && !InstanceChecker.isFindOperator(relatedEntity) && !(typeof relatedEntity === \"function\") && !Buffer.isBuffer(relatedEntity)) {\n          value = this.referencedColumn.getEntityValue(relatedEntity);\n        } else if (entity[this.propertyName] && ObjectUtils.isObject(entity[this.propertyName]) && !InstanceChecker.isFindOperator(entity[this.propertyName]) && !(typeof entity[this.propertyName] === \"function\") && !Buffer.isBuffer(entity[this.propertyName]) && !(entity[this.propertyName] instanceof Date)) {\n          value = this.referencedColumn.getEntityValue(entity[this.propertyName]);\n        } else {\n          value = entity[this.propertyName];\n        }\n      } else if (this.referencedColumn) {\n        value = this.referencedColumn.getEntityValue(entity[this.propertyName]);\n      } else {\n        value = entity[this.propertyName];\n      }\n    }\n    if (transform && this.transformer) value = ApplyValueTransformers.transformTo(this.transformer, value);\n    return value;\n  }\n  /**\n   * Sets given entity's column value.\n   * Using of this method helps to set entity relation's value of the lazy and non-lazy relations.\n   */\n  setEntityValue(entity, value) {\n    if (this.embeddedMetadata) {\n      // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n      const extractEmbeddedColumnValue = (embeddedMetadatas, map) => {\n        // if (!object[embeddedMetadata.propertyName])\n        //     object[embeddedMetadata.propertyName] = embeddedMetadata.create();\n        const embeddedMetadata = embeddedMetadatas.shift();\n        if (embeddedMetadata) {\n          if (!map[embeddedMetadata.propertyName]) map[embeddedMetadata.propertyName] = embeddedMetadata.create();\n          extractEmbeddedColumnValue(embeddedMetadatas, map[embeddedMetadata.propertyName]);\n          return map;\n        }\n        map[this.propertyName] = value;\n        return map;\n      };\n      return extractEmbeddedColumnValue([...this.embeddedMetadata.embeddedMetadataTree], entity);\n    } else {\n      // we write a deep object in this entity only if the column is virtual\n      // because if its not virtual it means the user defined a real column for this relation\n      // also we don't do it if column is inside a junction table\n      if (!this.entityMetadata.isJunction && this.isVirtual && this.referencedColumn && this.referencedColumn.propertyName !== this.propertyName) {\n        if (!(this.propertyName in entity)) {\n          entity[this.propertyName] = {};\n        }\n        entity[this.propertyName][this.referencedColumn.propertyName] = value;\n      } else {\n        entity[this.propertyName] = value;\n      }\n    }\n  }\n  /**\n   * Compares given entity's column value with a given value.\n   */\n  compareEntityValue(entity, valueToCompareWith) {\n    const columnValue = this.getEntityValue(entity);\n    if (ObjectUtils.isObject(columnValue)) {\n      return columnValue.equals(valueToCompareWith);\n    }\n    return columnValue === valueToCompareWith;\n  }\n  // ---------------------------------------------------------------------\n  // Builder Methods\n  // ---------------------------------------------------------------------\n  build(connection) {\n    this.propertyPath = this.buildPropertyPath();\n    this.propertyAliasName = this.propertyPath.replace(\".\", \"_\");\n    this.databaseName = this.buildDatabaseName(connection);\n    this.databasePath = this.buildDatabasePath();\n    this.databaseNameWithoutPrefixes = connection.namingStrategy.columnName(this.propertyName, this.givenDatabaseName, []);\n    return this;\n  }\n  buildPropertyPath() {\n    let path = \"\";\n    if (this.embeddedMetadata && this.embeddedMetadata.parentPropertyNames.length) path = this.embeddedMetadata.parentPropertyNames.join(\".\") + \".\";\n    path += this.propertyName;\n    // we add reference column to property path only if this column is virtual\n    // because if its not virtual it means user defined a real column for this relation\n    // also we don't do it if column is inside a junction table\n    if (!this.entityMetadata.isJunction && this.isVirtual && this.referencedColumn && this.referencedColumn.propertyName !== this.propertyName) path += \".\" + this.referencedColumn.propertyName;\n    return path;\n  }\n  buildDatabasePath() {\n    let path = \"\";\n    if (this.embeddedMetadata && this.embeddedMetadata.parentPropertyNames.length) path = this.embeddedMetadata.parentPropertyNames.join(\".\") + \".\";\n    path += this.databaseName;\n    // we add reference column to property path only if this column is virtual\n    // because if its not virtual it means user defined a real column for this relation\n    // also we don't do it if column is inside a junction table\n    if (!this.entityMetadata.isJunction && this.isVirtual && this.referencedColumn && this.referencedColumn.databaseName !== this.databaseName) path += \".\" + this.referencedColumn.databaseName;\n    return path;\n  }\n  buildDatabaseName(connection) {\n    let propertyNames = this.embeddedMetadata ? this.embeddedMetadata.parentPrefixes : [];\n    if (connection.driver.options.type === \"mongodb\")\n      // we don't need to include embedded name for the mongodb column names\n      propertyNames = [];\n    return connection.namingStrategy.columnName(this.propertyName, this.givenDatabaseName, propertyNames);\n  }\n}","map":{"version":3,"names":["OrmUtils","ApplyValueTransformers","ObjectUtils","InstanceChecker","ColumnMetadata","constructor","options","Symbol","for","length","isPrimary","isGenerated","isNullable","isSelect","isInsert","isUpdate","zerofill","unsigned","isArray","isVirtual","isVirtualProperty","isDiscriminator","isTreeLevel","isCreateDate","isUpdateDate","isDeleteDate","isVersion","isObjectId","isNestedSetLeft","isNestedSetRight","isMaterializedPath","entityMetadata","embeddedMetadata","referencedColumn","args","target","propertyName","name","givenDatabaseName","type","toString","width","charset","collation","primary","default","nullable","undefined","select","insert","update","readonly","comment","onUpdate","generatedIdentity","scale","precision","enum","isObject","Array","Object","keys","filter","key","isNaN","map","enumName","primaryKeyConstraintName","foreignKeyConstraintName","asExpression","generatedType","hstoreType","array","mode","transformer","spatialFeatureType","srid","query","connection","driver","mappedDataTypes","treeLevel","createDate","createDateDefault","createDatePrecision","updateDate","updateDateDefault","updateDatePrecision","deleteDate","deleteDateNullable","deleteDatePrecision","version","closureType","nestedSetLeft","nestedSetRight","materializedPath","createValueMap","value","useDatabaseName","propertyNames","parentPropertyNames","extractEmbeddedColumnValue","shift","generationStrategy","String","databaseName","getEntityValueMap","entity","_a","returnNulls","isEmbeddedArray","submap","v","relationMetadata","getOwnPropertyDescriptor","get","joinColumns","reduce","joinColumn","mergeDeep","getEntityValue","transform","embeddedObject","relatedEntity","isFindOperator","Buffer","isBuffer","Date","o","transformTo","setEntityValue","embeddedMetadatas","create","embeddedMetadataTree","isJunction","compareEntityValue","valueToCompareWith","columnValue","equals","build","propertyPath","buildPropertyPath","propertyAliasName","replace","buildDatabaseName","databasePath","buildDatabasePath","databaseNameWithoutPrefixes","namingStrategy","columnName","path","join","parentPrefixes"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/metadata/ColumnMetadata.js"],"sourcesContent":["import { OrmUtils } from \"../util/OrmUtils\";\nimport { ApplyValueTransformers } from \"../util/ApplyValueTransformers\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\n/**\n * This metadata contains all information about entity's column.\n */\nexport class ColumnMetadata {\n    // ---------------------------------------------------------------------\n    // Constructor\n    // ---------------------------------------------------------------------\n    constructor(options) {\n        this[\"@instanceof\"] = Symbol.for(\"ColumnMetadata\");\n        /**\n         * Type's length in the database.\n         */\n        this.length = \"\";\n        /**\n         * Indicates if this column is a primary key.\n         */\n        this.isPrimary = false;\n        /**\n         * Indicates if this column is generated (auto increment or generated other way).\n         */\n        this.isGenerated = false;\n        /**\n         * Indicates if column can contain nulls or not.\n         */\n        this.isNullable = false;\n        /**\n         * Indicates if column is selected by query builder or not.\n         */\n        this.isSelect = true;\n        /**\n         * Indicates if column is inserted by default or not.\n         */\n        this.isInsert = true;\n        /**\n         * Indicates if column allows updates or not.\n         */\n        this.isUpdate = true;\n        /**\n         * Puts ZEROFILL attribute on to numeric column. Works only for MySQL.\n         * If you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to the column\n         */\n        this.zerofill = false;\n        /**\n         * Puts UNSIGNED attribute on to numeric column. Works only for MySQL.\n         */\n        this.unsigned = false;\n        /**\n         * Indicates if this column is an array.\n         */\n        this.isArray = false;\n        /**\n         * Indicates if column is virtual. Virtual columns are not mapped to the entity.\n         */\n        this.isVirtual = false;\n        /**\n         * Indicates if column is a virtual property. Virtual properties are not mapped to the entity.\n         * This property is used in tandem the virtual column decorator.\n         * @See https://typeorm.io/decorator-reference#virtualcolumn for more details.\n         */\n        this.isVirtualProperty = false;\n        /**\n         * Indicates if column is discriminator. Discriminator columns are not mapped to the entity.\n         */\n        this.isDiscriminator = false;\n        /**\n         * Indicates if column is tree-level column. Tree-level columns are used in closure entities.\n         */\n        this.isTreeLevel = false;\n        /**\n         * Indicates if this column contains an entity creation date.\n         */\n        this.isCreateDate = false;\n        /**\n         * Indicates if this column contains an entity update date.\n         */\n        this.isUpdateDate = false;\n        /**\n         * Indicates if this column contains an entity delete date.\n         */\n        this.isDeleteDate = false;\n        /**\n         * Indicates if this column contains an entity version.\n         */\n        this.isVersion = false;\n        /**\n         * Indicates if this column contains an object id.\n         */\n        this.isObjectId = false;\n        /**\n         * Indicates if this column is nested set's left column.\n         * Used only in tree entities with nested-set type.\n         */\n        this.isNestedSetLeft = false;\n        /**\n         * Indicates if this column is nested set's right column.\n         * Used only in tree entities with nested-set type.\n         */\n        this.isNestedSetRight = false;\n        /**\n         * Indicates if this column is materialized path's path column.\n         * Used only in tree entities with materialized path type.\n         */\n        this.isMaterializedPath = false;\n        this.entityMetadata = options.entityMetadata;\n        this.embeddedMetadata = options.embeddedMetadata;\n        this.referencedColumn = options.referencedColumn;\n        if (options.args.target)\n            this.target = options.args.target;\n        if (options.args.propertyName)\n            this.propertyName = options.args.propertyName;\n        if (options.args.options.name)\n            this.givenDatabaseName = options.args.options.name;\n        if (options.args.options.type)\n            this.type = options.args.options.type;\n        if (options.args.options.length)\n            this.length = options.args.options.length\n                ? options.args.options.length.toString()\n                : \"\";\n        if (options.args.options.width)\n            this.width = options.args.options.width;\n        if (options.args.options.charset)\n            this.charset = options.args.options.charset;\n        if (options.args.options.collation)\n            this.collation = options.args.options.collation;\n        if (options.args.options.primary)\n            this.isPrimary = options.args.options.primary;\n        if (options.args.options.default === null)\n            // to make sure default: null is the same as nullable: true\n            this.isNullable = true;\n        if (options.args.options.nullable !== undefined)\n            this.isNullable = options.args.options.nullable;\n        if (options.args.options.select !== undefined)\n            this.isSelect = options.args.options.select;\n        if (options.args.options.insert !== undefined)\n            this.isInsert = options.args.options.insert;\n        if (options.args.options.update !== undefined)\n            this.isUpdate = options.args.options.update;\n        if (options.args.options.readonly !== undefined)\n            this.isUpdate = !options.args.options.readonly;\n        if (options.args.options.comment)\n            this.comment = options.args.options.comment;\n        if (options.args.options.default !== undefined)\n            this.default = options.args.options.default;\n        if (options.args.options.onUpdate)\n            this.onUpdate = options.args.options.onUpdate;\n        if (options.args.options.generatedIdentity)\n            this.generatedIdentity = options.args.options.generatedIdentity;\n        if (options.args.options.scale !== null &&\n            options.args.options.scale !== undefined)\n            this.scale = options.args.options.scale;\n        if (options.args.options.zerofill) {\n            this.zerofill = options.args.options.zerofill;\n            this.unsigned = true; // if you specify ZEROFILL for a numeric column, MySQL automatically adds the UNSIGNED attribute to the column\n        }\n        if (options.args.options.unsigned)\n            this.unsigned = options.args.options.unsigned;\n        if (options.args.options.precision !== null)\n            this.precision = options.args.options.precision;\n        if (options.args.options.enum) {\n            if (ObjectUtils.isObject(options.args.options.enum) &&\n                !Array.isArray(options.args.options.enum)) {\n                this.enum = Object.keys(options.args.options.enum)\n                    // remove numeric keys - typescript numeric enum types generate them\n                    // From the documentation: “declaration merging” means that the compiler merges two separate declarations\n                    // declared with the same name into a single definition. This concept is often used to merge enum with namespace\n                    // where in namespace we define e.g. utility methods for creating enum. This is well known in other languages\n                    // like Java (enum methods). Here in case if enum have function, we need to remove it from metadata, otherwise\n                    // generated SQL statements contains string representation of that function which leads into syntax error\n                    // at database side.\n                    .filter((key) => isNaN(+key) &&\n                    typeof options.args.options.enum[key] !== \"function\")\n                    .map((key) => options.args.options.enum[key]);\n            }\n            else {\n                this.enum = options.args.options.enum;\n            }\n        }\n        if (options.args.options.enumName) {\n            this.enumName = options.args.options.enumName;\n        }\n        if (options.args.options.primaryKeyConstraintName) {\n            this.primaryKeyConstraintName =\n                options.args.options.primaryKeyConstraintName;\n        }\n        if (options.args.options.foreignKeyConstraintName) {\n            this.foreignKeyConstraintName =\n                options.args.options.foreignKeyConstraintName;\n        }\n        if (options.args.options.asExpression) {\n            this.asExpression = options.args.options.asExpression;\n            this.generatedType = options.args.options.generatedType\n                ? options.args.options.generatedType\n                : \"VIRTUAL\";\n        }\n        if (options.args.options.hstoreType)\n            this.hstoreType = options.args.options.hstoreType;\n        if (options.args.options.array)\n            this.isArray = options.args.options.array;\n        if (options.args.mode) {\n            this.isVirtualProperty = options.args.mode === \"virtual-property\";\n            this.isVirtual = options.args.mode === \"virtual\";\n            this.isTreeLevel = options.args.mode === \"treeLevel\";\n            this.isCreateDate = options.args.mode === \"createDate\";\n            this.isUpdateDate = options.args.mode === \"updateDate\";\n            this.isDeleteDate = options.args.mode === \"deleteDate\";\n            this.isVersion = options.args.mode === \"version\";\n            this.isObjectId = options.args.mode === \"objectId\";\n        }\n        if (this.isVirtualProperty) {\n            this.isInsert = false;\n            this.isUpdate = false;\n        }\n        if (options.args.options.transformer)\n            this.transformer = options.args.options.transformer;\n        if (options.args.options.spatialFeatureType)\n            this.spatialFeatureType = options.args.options.spatialFeatureType;\n        if (options.args.options.srid !== undefined)\n            this.srid = options.args.options.srid;\n        if (options.args.options.query)\n            this.query = options.args.options.query;\n        if (this.isTreeLevel)\n            this.type = options.connection.driver.mappedDataTypes.treeLevel;\n        if (this.isCreateDate) {\n            if (!this.type)\n                this.type = options.connection.driver.mappedDataTypes.createDate;\n            if (!this.default)\n                this.default = () => options.connection.driver.mappedDataTypes.createDateDefault;\n            // skip precision if it was explicitly set to \"null\" in column options. Otherwise use default precision if it exist.\n            if (this.precision === undefined &&\n                options.args.options.precision === undefined &&\n                options.connection.driver.mappedDataTypes.createDatePrecision)\n                this.precision =\n                    options.connection.driver.mappedDataTypes.createDatePrecision;\n        }\n        if (this.isUpdateDate) {\n            if (!this.type)\n                this.type = options.connection.driver.mappedDataTypes.updateDate;\n            if (!this.default)\n                this.default = () => options.connection.driver.mappedDataTypes.updateDateDefault;\n            if (!this.onUpdate)\n                this.onUpdate =\n                    options.connection.driver.mappedDataTypes.updateDateDefault;\n            // skip precision if it was explicitly set to \"null\" in column options. Otherwise use default precision if it exist.\n            if (this.precision === undefined &&\n                options.args.options.precision === undefined &&\n                options.connection.driver.mappedDataTypes.updateDatePrecision)\n                this.precision =\n                    options.connection.driver.mappedDataTypes.updateDatePrecision;\n        }\n        if (this.isDeleteDate) {\n            if (!this.type)\n                this.type = options.connection.driver.mappedDataTypes.deleteDate;\n            if (!this.isNullable)\n                this.isNullable =\n                    options.connection.driver.mappedDataTypes.deleteDateNullable;\n            // skip precision if it was explicitly set to \"null\" in column options. Otherwise use default precision if it exist.\n            if (this.precision === undefined &&\n                options.args.options.precision === undefined &&\n                options.connection.driver.mappedDataTypes.deleteDatePrecision)\n                this.precision =\n                    options.connection.driver.mappedDataTypes.deleteDatePrecision;\n        }\n        if (this.isVersion)\n            this.type = options.connection.driver.mappedDataTypes.version;\n        if (options.closureType)\n            this.closureType = options.closureType;\n        if (options.nestedSetLeft)\n            this.isNestedSetLeft = options.nestedSetLeft;\n        if (options.nestedSetRight)\n            this.isNestedSetRight = options.nestedSetRight;\n        if (options.materializedPath)\n            this.isMaterializedPath = options.materializedPath;\n    }\n    // ---------------------------------------------------------------------\n    // Public Methods\n    // ---------------------------------------------------------------------\n    /**\n     * Creates entity id map from the given entity ids array.\n     */\n    createValueMap(value, useDatabaseName = false) {\n        // extract column value from embeds of entity if column is in embedded\n        if (this.embeddedMetadata) {\n            // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n            // we need to get value of \"id\" column from the post real entity object and return it in a\n            // { data: { information: { counters: { id: ... } } } } format\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const propertyNames = [...this.embeddedMetadata.parentPropertyNames];\n            // now need to access post[data][information][counters] to get column value from the counters\n            // and on each step we need to create complex literal object, e.g. first { data },\n            // then { data: { information } }, then { data: { information: { counters } } },\n            // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }\n            // this recursive function helps doing that\n            const extractEmbeddedColumnValue = (propertyNames, map) => {\n                const propertyName = propertyNames.shift();\n                if (propertyName) {\n                    map[propertyName] = {};\n                    extractEmbeddedColumnValue(propertyNames, map[propertyName]);\n                    return map;\n                }\n                // this is bugfix for #720 when increment number is bigint we need to make sure its a string\n                if ((this.generationStrategy === \"increment\" ||\n                    this.generationStrategy === \"rowid\") &&\n                    this.type === \"bigint\" &&\n                    value !== null)\n                    value = String(value);\n                map[useDatabaseName ? this.databaseName : this.propertyName] =\n                    value;\n                return map;\n            };\n            return extractEmbeddedColumnValue(propertyNames, {});\n        }\n        else {\n            // no embeds - no problems. Simply return column property name and its value of the entity\n            // this is bugfix for #720 when increment number is bigint we need to make sure its a string\n            if ((this.generationStrategy === \"increment\" ||\n                this.generationStrategy === \"rowid\") &&\n                this.type === \"bigint\" &&\n                value !== null)\n                value = String(value);\n            return {\n                [useDatabaseName ? this.databaseName : this.propertyName]: value,\n            };\n        }\n    }\n    /**\n     * Extracts column value and returns its column name with this value in a literal object.\n     * If column is in embedded (or recursive embedded) it returns complex literal object.\n     *\n     * Examples what this method can return depend if this column is in embeds.\n     * { id: 1 } or { title: \"hello\" }, { counters: { code: 1 } }, { data: { information: { counters: { code: 1 } } } }\n     */\n    getEntityValueMap(entity, options) {\n        var _a;\n        const returnNulls = false; // options && options.skipNulls === false ? false : true; // todo: remove if current will not bring problems, uncomment if it will.\n        // extract column value from embeds of entity if column is in embedded\n        if (this.embeddedMetadata) {\n            // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n            // we need to get value of \"id\" column from the post real entity object and return it in a\n            // { data: { information: { counters: { id: ... } } } } format\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const propertyNames = [...this.embeddedMetadata.parentPropertyNames];\n            const isEmbeddedArray = this.embeddedMetadata.isArray;\n            // now need to access post[data][information][counters] to get column value from the counters\n            // and on each step we need to create complex literal object, e.g. first { data },\n            // then { data: { information } }, then { data: { information: { counters } } },\n            // then { data: { information: { counters: [this.propertyName]: entity[data][information][counters][this.propertyName] } } }\n            // this recursive function helps doing that\n            const extractEmbeddedColumnValue = (propertyNames, value) => {\n                if (value === undefined) {\n                    return {};\n                }\n                const propertyName = propertyNames.shift();\n                if (propertyName) {\n                    const submap = extractEmbeddedColumnValue(propertyNames, value[propertyName]);\n                    if (Object.keys(submap).length > 0) {\n                        return { [propertyName]: submap };\n                    }\n                    return {};\n                }\n                if (isEmbeddedArray && Array.isArray(value)) {\n                    return value.map((v) => ({\n                        [this.propertyName]: v[this.propertyName],\n                    }));\n                }\n                if (value[this.propertyName] !== undefined &&\n                    (returnNulls === false || value[this.propertyName] !== null)) {\n                    return { [this.propertyName]: value[this.propertyName] };\n                }\n                return {};\n            };\n            const map = extractEmbeddedColumnValue(propertyNames, entity);\n            return Object.keys(map).length > 0 ? map : undefined;\n        }\n        else {\n            // no embeds - no problems. Simply return column property name and its value of the entity\n            /**\n             * Object.getOwnPropertyDescriptor checks if the relation is lazy, in which case value is a Promise\n             * DO NOT use `entity[\n                this.relationMetadata.propertyName] instanceof Promise`, which will invoke property getter and make unwanted DB request\n             * refer: https://github.com/typeorm/typeorm/pull/8676#issuecomment-1049906331\n             */\n            if (this.relationMetadata &&\n                !((_a = Object.getOwnPropertyDescriptor(entity, this.relationMetadata.propertyName)) === null || _a === void 0 ? void 0 : _a.get) &&\n                entity[this.relationMetadata.propertyName] &&\n                ObjectUtils.isObject(entity[this.relationMetadata.propertyName])) {\n                const map = this.relationMetadata.joinColumns.reduce((map, joinColumn) => {\n                    const value = joinColumn.referencedColumn.getEntityValueMap(entity[this.relationMetadata.propertyName]);\n                    if (value === undefined)\n                        return map;\n                    return OrmUtils.mergeDeep(map, value);\n                }, {});\n                if (Object.keys(map).length > 0)\n                    return { [this.propertyName]: map };\n                return undefined;\n            }\n            else {\n                if (entity[this.propertyName] !== undefined &&\n                    (returnNulls === false ||\n                        entity[this.propertyName] !== null))\n                    return { [this.propertyName]: entity[this.propertyName] };\n                return undefined;\n            }\n        }\n    }\n    /**\n     * Extracts column value from the given entity.\n     * If column is in embedded (or recursive embedded) it extracts its value from there.\n     */\n    getEntityValue(entity, transform = false) {\n        if (entity === undefined || entity === null)\n            return undefined;\n        // extract column value from embeddeds of entity if column is in embedded\n        let value = undefined;\n        if (this.embeddedMetadata) {\n            // example: post[data][information][counters].id where \"data\", \"information\" and \"counters\" are embeddeds\n            // we need to get value of \"id\" column from the post real entity object\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const propertyNames = [...this.embeddedMetadata.parentPropertyNames];\n            const isEmbeddedArray = this.embeddedMetadata.isArray;\n            // next we need to access post[data][information][counters][this.propertyName] to get column value from the counters\n            // this recursive function takes array of generated property names and gets the post[data][information][counters] embed\n            const extractEmbeddedColumnValue = (propertyNames, value) => {\n                const propertyName = propertyNames.shift();\n                return propertyName && value\n                    ? extractEmbeddedColumnValue(propertyNames, value[propertyName])\n                    : value;\n            };\n            // once we get nested embed object we get its column, e.g. post[data][information][counters][this.propertyName]\n            const embeddedObject = extractEmbeddedColumnValue(propertyNames, entity);\n            if (embeddedObject) {\n                if (this.relationMetadata && this.referencedColumn) {\n                    const relatedEntity = this.relationMetadata.getEntityValue(embeddedObject);\n                    if (relatedEntity &&\n                        ObjectUtils.isObject(relatedEntity) &&\n                        !InstanceChecker.isFindOperator(relatedEntity) &&\n                        !Buffer.isBuffer(relatedEntity)) {\n                        value =\n                            this.referencedColumn.getEntityValue(relatedEntity);\n                    }\n                    else if (embeddedObject[this.propertyName] &&\n                        ObjectUtils.isObject(embeddedObject[this.propertyName]) &&\n                        !InstanceChecker.isFindOperator(embeddedObject[this.propertyName]) &&\n                        !Buffer.isBuffer(embeddedObject[this.propertyName]) &&\n                        !(embeddedObject[this.propertyName] instanceof Date)) {\n                        value = this.referencedColumn.getEntityValue(embeddedObject[this.propertyName]);\n                    }\n                    else {\n                        value = embeddedObject[this.propertyName];\n                    }\n                }\n                else if (this.referencedColumn) {\n                    value = this.referencedColumn.getEntityValue(embeddedObject[this.propertyName]);\n                }\n                else if (isEmbeddedArray && Array.isArray(embeddedObject)) {\n                    value = embeddedObject.map((o) => o[this.propertyName]);\n                }\n                else {\n                    value = embeddedObject[this.propertyName];\n                }\n            }\n        }\n        else {\n            // no embeds - no problems. Simply return column name by property name of the entity\n            if (this.relationMetadata && this.referencedColumn) {\n                const relatedEntity = this.relationMetadata.getEntityValue(entity);\n                if (relatedEntity &&\n                    ObjectUtils.isObject(relatedEntity) &&\n                    !InstanceChecker.isFindOperator(relatedEntity) &&\n                    !(typeof relatedEntity === \"function\") &&\n                    !Buffer.isBuffer(relatedEntity)) {\n                    value = this.referencedColumn.getEntityValue(relatedEntity);\n                }\n                else if (entity[this.propertyName] &&\n                    ObjectUtils.isObject(entity[this.propertyName]) &&\n                    !InstanceChecker.isFindOperator(entity[this.propertyName]) &&\n                    !(typeof entity[this.propertyName] === \"function\") &&\n                    !Buffer.isBuffer(entity[this.propertyName]) &&\n                    !(entity[this.propertyName] instanceof Date)) {\n                    value = this.referencedColumn.getEntityValue(entity[this.propertyName]);\n                }\n                else {\n                    value = entity[this.propertyName];\n                }\n            }\n            else if (this.referencedColumn) {\n                value = this.referencedColumn.getEntityValue(entity[this.propertyName]);\n            }\n            else {\n                value = entity[this.propertyName];\n            }\n        }\n        if (transform && this.transformer)\n            value = ApplyValueTransformers.transformTo(this.transformer, value);\n        return value;\n    }\n    /**\n     * Sets given entity's column value.\n     * Using of this method helps to set entity relation's value of the lazy and non-lazy relations.\n     */\n    setEntityValue(entity, value) {\n        if (this.embeddedMetadata) {\n            // first step - we extract all parent properties of the entity relative to this column, e.g. [data, information, counters]\n            const extractEmbeddedColumnValue = (embeddedMetadatas, map) => {\n                // if (!object[embeddedMetadata.propertyName])\n                //     object[embeddedMetadata.propertyName] = embeddedMetadata.create();\n                const embeddedMetadata = embeddedMetadatas.shift();\n                if (embeddedMetadata) {\n                    if (!map[embeddedMetadata.propertyName])\n                        map[embeddedMetadata.propertyName] =\n                            embeddedMetadata.create();\n                    extractEmbeddedColumnValue(embeddedMetadatas, map[embeddedMetadata.propertyName]);\n                    return map;\n                }\n                map[this.propertyName] = value;\n                return map;\n            };\n            return extractEmbeddedColumnValue([...this.embeddedMetadata.embeddedMetadataTree], entity);\n        }\n        else {\n            // we write a deep object in this entity only if the column is virtual\n            // because if its not virtual it means the user defined a real column for this relation\n            // also we don't do it if column is inside a junction table\n            if (!this.entityMetadata.isJunction &&\n                this.isVirtual &&\n                this.referencedColumn &&\n                this.referencedColumn.propertyName !== this.propertyName) {\n                if (!(this.propertyName in entity)) {\n                    entity[this.propertyName] = {};\n                }\n                entity[this.propertyName][this.referencedColumn.propertyName] =\n                    value;\n            }\n            else {\n                entity[this.propertyName] = value;\n            }\n        }\n    }\n    /**\n     * Compares given entity's column value with a given value.\n     */\n    compareEntityValue(entity, valueToCompareWith) {\n        const columnValue = this.getEntityValue(entity);\n        if (ObjectUtils.isObject(columnValue)) {\n            return columnValue.equals(valueToCompareWith);\n        }\n        return columnValue === valueToCompareWith;\n    }\n    // ---------------------------------------------------------------------\n    // Builder Methods\n    // ---------------------------------------------------------------------\n    build(connection) {\n        this.propertyPath = this.buildPropertyPath();\n        this.propertyAliasName = this.propertyPath.replace(\".\", \"_\");\n        this.databaseName = this.buildDatabaseName(connection);\n        this.databasePath = this.buildDatabasePath();\n        this.databaseNameWithoutPrefixes = connection.namingStrategy.columnName(this.propertyName, this.givenDatabaseName, []);\n        return this;\n    }\n    buildPropertyPath() {\n        let path = \"\";\n        if (this.embeddedMetadata &&\n            this.embeddedMetadata.parentPropertyNames.length)\n            path = this.embeddedMetadata.parentPropertyNames.join(\".\") + \".\";\n        path += this.propertyName;\n        // we add reference column to property path only if this column is virtual\n        // because if its not virtual it means user defined a real column for this relation\n        // also we don't do it if column is inside a junction table\n        if (!this.entityMetadata.isJunction &&\n            this.isVirtual &&\n            this.referencedColumn &&\n            this.referencedColumn.propertyName !== this.propertyName)\n            path += \".\" + this.referencedColumn.propertyName;\n        return path;\n    }\n    buildDatabasePath() {\n        let path = \"\";\n        if (this.embeddedMetadata &&\n            this.embeddedMetadata.parentPropertyNames.length)\n            path = this.embeddedMetadata.parentPropertyNames.join(\".\") + \".\";\n        path += this.databaseName;\n        // we add reference column to property path only if this column is virtual\n        // because if its not virtual it means user defined a real column for this relation\n        // also we don't do it if column is inside a junction table\n        if (!this.entityMetadata.isJunction &&\n            this.isVirtual &&\n            this.referencedColumn &&\n            this.referencedColumn.databaseName !== this.databaseName)\n            path += \".\" + this.referencedColumn.databaseName;\n        return path;\n    }\n    buildDatabaseName(connection) {\n        let propertyNames = this.embeddedMetadata\n            ? this.embeddedMetadata.parentPrefixes\n            : [];\n        if (connection.driver.options.type === \"mongodb\")\n            // we don't need to include embedded name for the mongodb column names\n            propertyNames = [];\n        return connection.namingStrategy.columnName(this.propertyName, this.givenDatabaseName, propertyNames);\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}