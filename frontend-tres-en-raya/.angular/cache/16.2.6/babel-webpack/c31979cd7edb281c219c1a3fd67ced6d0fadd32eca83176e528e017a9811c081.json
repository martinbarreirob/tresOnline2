{"ast":null,"code":"import { getMetadataArgsStorage } from \"../../globals\";\nimport { ObjectUtils } from \"../../util/ObjectUtils\";\n/**\n * A many-to-one relation allows creating the type of relation where Entity1 can have a single instance of Entity2, but\n * Entity2 can have multiple instances of Entity1. Entity1 is the owner of the relationship, and stores the id of\n * Entity2 on its side of the relation.\n */\nexport function ManyToOne(typeFunctionOrTarget, inverseSideOrOptions, options) {\n  // Normalize parameters.\n  let inverseSideProperty;\n  if (ObjectUtils.isObject(inverseSideOrOptions)) {\n    options = inverseSideOrOptions;\n  } else {\n    inverseSideProperty = inverseSideOrOptions;\n  }\n  return function (object, propertyName) {\n    if (!options) options = {};\n    // Now try to determine if it is a lazy relation.\n    let isLazy = options && options.lazy === true;\n    if (!isLazy && Reflect && Reflect.getMetadata) {\n      // automatic determination\n      const reflectedType = Reflect.getMetadata(\"design:type\", object, propertyName);\n      if (reflectedType && typeof reflectedType.name === \"string\" && reflectedType.name.toLowerCase() === \"promise\") isLazy = true;\n    }\n    getMetadataArgsStorage().relations.push({\n      target: object.constructor,\n      propertyName: propertyName,\n      // propertyType: reflectedType,\n      relationType: \"many-to-one\",\n      isLazy: isLazy,\n      type: typeFunctionOrTarget,\n      inverseSideProperty: inverseSideProperty,\n      options: options\n    });\n  };\n}","map":{"version":3,"names":["getMetadataArgsStorage","ObjectUtils","ManyToOne","typeFunctionOrTarget","inverseSideOrOptions","options","inverseSideProperty","isObject","object","propertyName","isLazy","lazy","Reflect","getMetadata","reflectedType","name","toLowerCase","relations","push","target","constructor","relationType","type"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/decorator/relations/ManyToOne.js"],"sourcesContent":["import { getMetadataArgsStorage } from \"../../globals\";\nimport { ObjectUtils } from \"../../util/ObjectUtils\";\n/**\n * A many-to-one relation allows creating the type of relation where Entity1 can have a single instance of Entity2, but\n * Entity2 can have multiple instances of Entity1. Entity1 is the owner of the relationship, and stores the id of\n * Entity2 on its side of the relation.\n */\nexport function ManyToOne(typeFunctionOrTarget, inverseSideOrOptions, options) {\n    // Normalize parameters.\n    let inverseSideProperty;\n    if (ObjectUtils.isObject(inverseSideOrOptions)) {\n        options = inverseSideOrOptions;\n    }\n    else {\n        inverseSideProperty = inverseSideOrOptions;\n    }\n    return function (object, propertyName) {\n        if (!options)\n            options = {};\n        // Now try to determine if it is a lazy relation.\n        let isLazy = options && options.lazy === true;\n        if (!isLazy && Reflect && Reflect.getMetadata) {\n            // automatic determination\n            const reflectedType = Reflect.getMetadata(\"design:type\", object, propertyName);\n            if (reflectedType &&\n                typeof reflectedType.name === \"string\" &&\n                reflectedType.name.toLowerCase() === \"promise\")\n                isLazy = true;\n        }\n        getMetadataArgsStorage().relations.push({\n            target: object.constructor,\n            propertyName: propertyName,\n            // propertyType: reflectedType,\n            relationType: \"many-to-one\",\n            isLazy: isLazy,\n            type: typeFunctionOrTarget,\n            inverseSideProperty: inverseSideProperty,\n            options: options,\n        });\n    };\n}\n\n"],"mappings":"AAAA,SAASA,sBAAsB,QAAQ,eAAe;AACtD,SAASC,WAAW,QAAQ,wBAAwB;AACpD;AACA;AACA;AACA;AACA;AACA,OAAO,SAASC,SAASA,CAACC,oBAAoB,EAAEC,oBAAoB,EAAEC,OAAO,EAAE;EAC3E;EACA,IAAIC,mBAAmB;EACvB,IAAIL,WAAW,CAACM,QAAQ,CAACH,oBAAoB,CAAC,EAAE;IAC5CC,OAAO,GAAGD,oBAAoB;EAClC,CAAC,MACI;IACDE,mBAAmB,GAAGF,oBAAoB;EAC9C;EACA,OAAO,UAAUI,MAAM,EAAEC,YAAY,EAAE;IACnC,IAAI,CAACJ,OAAO,EACRA,OAAO,GAAG,CAAC,CAAC;IAChB;IACA,IAAIK,MAAM,GAAGL,OAAO,IAAIA,OAAO,CAACM,IAAI,KAAK,IAAI;IAC7C,IAAI,CAACD,MAAM,IAAIE,OAAO,IAAIA,OAAO,CAACC,WAAW,EAAE;MAC3C;MACA,MAAMC,aAAa,GAAGF,OAAO,CAACC,WAAW,CAAC,aAAa,EAAEL,MAAM,EAAEC,YAAY,CAAC;MAC9E,IAAIK,aAAa,IACb,OAAOA,aAAa,CAACC,IAAI,KAAK,QAAQ,IACtCD,aAAa,CAACC,IAAI,CAACC,WAAW,CAAC,CAAC,KAAK,SAAS,EAC9CN,MAAM,GAAG,IAAI;IACrB;IACAV,sBAAsB,CAAC,CAAC,CAACiB,SAAS,CAACC,IAAI,CAAC;MACpCC,MAAM,EAAEX,MAAM,CAACY,WAAW;MAC1BX,YAAY,EAAEA,YAAY;MAC1B;MACAY,YAAY,EAAE,aAAa;MAC3BX,MAAM,EAAEA,MAAM;MACdY,IAAI,EAAEnB,oBAAoB;MAC1BG,mBAAmB,EAAEA,mBAAmB;MACxCD,OAAO,EAAEA;IACb,CAAC,CAAC;EACN,CAAC;AACL"},"metadata":{},"sourceType":"module","externalDependencies":[]}