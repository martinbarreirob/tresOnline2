{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/practicas/Downloads/angular/tresOnline/frontend-tres-en-raya/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { v4 as uuidv4 } from \"uuid\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\nimport { TypeORMError } from \"../error\";\nimport { InsertValuesMissingError } from \"../error/InsertValuesMissingError\";\nimport { ReturningStatementNotSupportedError } from \"../error/ReturningStatementNotSupportedError\";\nimport { BroadcasterResult } from \"../subscriber/BroadcasterResult\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\nimport { QueryBuilder } from \"./QueryBuilder\";\nimport { InsertResult } from \"./result/InsertResult\";\nimport { ReturningResultsEntityUpdator } from \"./ReturningResultsEntityUpdator\";\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\nexport class InsertQueryBuilder extends QueryBuilder {\n  constructor() {\n    super(...arguments);\n    this[\"@instanceof\"] = Symbol.for(\"InsertQueryBuilder\");\n  }\n  // -------------------------------------------------------------------------\n  // Public Implemented Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Gets generated SQL query without parameters being replaced.\n   */\n  getQuery() {\n    let sql = this.createComment();\n    sql += this.createCteExpression();\n    sql += this.createInsertExpression();\n    return this.replacePropertyNamesForTheWholeQuery(sql.trim());\n  }\n  /**\n   * Executes sql generated by query builder and returns raw database results.\n   */\n  execute() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      // console.time(\".value sets\");\n      const valueSets = _this.getValueSets();\n      // console.timeEnd(\".value sets\");\n      // If user passed empty array of entities then we don't need to do\n      // anything.\n      //\n      // Fixes GitHub issues #3111 and #5734. If we were to let this through\n      // we would run into problems downstream, like subscribers getting\n      // invoked with the empty array where they expect an entity, and SQL\n      // queries with an empty VALUES clause.\n      if (valueSets.length === 0) return new InsertResult();\n      // console.time(\"QueryBuilder.execute\");\n      // console.time(\".database stuff\");\n      const queryRunner = _this.obtainQueryRunner();\n      let transactionStartedByUs = false;\n      try {\n        // start transaction if it was enabled\n        if (_this.expressionMap.useTransaction === true && queryRunner.isTransactionActive === false) {\n          yield queryRunner.startTransaction();\n          transactionStartedByUs = true;\n        }\n        // console.timeEnd(\".database stuff\");\n        // call before insertion methods in listeners and subscribers\n        if (_this.expressionMap.callListeners === true && _this.expressionMap.mainAlias.hasMetadata) {\n          const broadcastResult = new BroadcasterResult();\n          valueSets.forEach(valueSet => {\n            queryRunner.broadcaster.broadcastBeforeInsertEvent(broadcastResult, _this.expressionMap.mainAlias.metadata, valueSet);\n          });\n          yield broadcastResult.wait();\n        }\n        let declareSql = null;\n        let selectOutputSql = null;\n        // if update entity mode is enabled we may need extra columns for the returning statement\n        // console.time(\".prepare returning statement\");\n        const returningResultsEntityUpdator = new ReturningResultsEntityUpdator(queryRunner, _this.expressionMap);\n        const returningColumns = [];\n        if (Array.isArray(_this.expressionMap.returning) && _this.expressionMap.mainAlias.hasMetadata) {\n          for (const columnPath of _this.expressionMap.returning) {\n            returningColumns.push(..._this.expressionMap.mainAlias.metadata.findColumnsWithPropertyPath(columnPath));\n          }\n        }\n        if (_this.expressionMap.updateEntity === true && _this.expressionMap.mainAlias.hasMetadata) {\n          if (!(valueSets.length > 1 && _this.connection.driver.options.type === \"oracle\")) {\n            _this.expressionMap.extraReturningColumns = _this.expressionMap.mainAlias.metadata.getInsertionReturningColumns();\n          }\n          returningColumns.push(..._this.expressionMap.extraReturningColumns.filter(c => !returningColumns.includes(c)));\n        }\n        if (returningColumns.length > 0 && _this.connection.driver.options.type === \"mssql\") {\n          declareSql = _this.connection.driver.buildTableVariableDeclaration(\"@OutputTable\", returningColumns);\n          selectOutputSql = `SELECT * FROM @OutputTable`;\n        }\n        // console.timeEnd(\".prepare returning statement\");\n        // execute query\n        // console.time(\".getting query and parameters\");\n        const [insertSql, parameters] = _this.getQueryAndParameters();\n        // console.timeEnd(\".getting query and parameters\");\n        // console.time(\".query execution by database\");\n        const statements = [declareSql, insertSql, selectOutputSql];\n        const sql = statements.filter(s => s != null).join(\";\\n\\n\");\n        const queryResult = yield queryRunner.query(sql, parameters, true);\n        const insertResult = InsertResult.from(queryResult);\n        // console.timeEnd(\".query execution by database\");\n        // load returning results and set them to the entity if entity updation is enabled\n        if (_this.expressionMap.updateEntity === true && _this.expressionMap.mainAlias.hasMetadata) {\n          // console.time(\".updating entity\");\n          yield returningResultsEntityUpdator.insert(insertResult, valueSets);\n          // console.timeEnd(\".updating entity\");\n        }\n        // call after insertion methods in listeners and subscribers\n        if (_this.expressionMap.callListeners === true && _this.expressionMap.mainAlias.hasMetadata) {\n          const broadcastResult = new BroadcasterResult();\n          valueSets.forEach(valueSet => {\n            queryRunner.broadcaster.broadcastAfterInsertEvent(broadcastResult, _this.expressionMap.mainAlias.metadata, valueSet);\n          });\n          yield broadcastResult.wait();\n        }\n        // close transaction if we started it\n        // console.time(\".commit\");\n        if (transactionStartedByUs) {\n          yield queryRunner.commitTransaction();\n        }\n        // console.timeEnd(\".commit\");\n        return insertResult;\n      } catch (error) {\n        // rollback transaction if we started it\n        if (transactionStartedByUs) {\n          try {\n            yield queryRunner.rollbackTransaction();\n          } catch (rollbackError) {}\n        }\n        throw error;\n      } finally {\n        // console.time(\".releasing connection\");\n        if (queryRunner !== _this.queryRunner) {\n          // means we created our own query runner\n          yield queryRunner.release();\n        }\n        // console.timeEnd(\".releasing connection\");\n        // console.timeEnd(\"QueryBuilder.execute\");\n      }\n    })();\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Specifies INTO which entity's table insertion will be executed.\n   */\n  into(entityTarget, columns) {\n    entityTarget = InstanceChecker.isEntitySchema(entityTarget) ? entityTarget.options.name : entityTarget;\n    const mainAlias = this.createFromAlias(entityTarget);\n    this.expressionMap.setMainAlias(mainAlias);\n    this.expressionMap.insertColumns = columns || [];\n    return this;\n  }\n  /**\n   * Values needs to be inserted into table.\n   */\n  values(values) {\n    this.expressionMap.valuesSet = values;\n    return this;\n  }\n  /**\n   * Optional returning/output clause.\n   */\n  output(output) {\n    return this.returning(output);\n  }\n  /**\n   * Optional returning/output clause.\n   */\n  returning(returning) {\n    // not all databases support returning/output cause\n    if (!this.connection.driver.isReturningSqlSupported(\"insert\")) {\n      throw new ReturningStatementNotSupportedError();\n    }\n    this.expressionMap.returning = returning;\n    return this;\n  }\n  /**\n   * Indicates if entity must be updated after insertion operations.\n   * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).\n   * Enabled by default.\n   */\n  updateEntity(enabled) {\n    this.expressionMap.updateEntity = enabled;\n    return this;\n  }\n  /**\n   * Adds additional ON CONFLICT statement supported in postgres and cockroach.\n   *\n   * @deprecated Use `orIgnore` or `orUpdate`\n   */\n  onConflict(statement) {\n    this.expressionMap.onConflict = statement;\n    return this;\n  }\n  /**\n   * Adds additional ignore statement supported in databases.\n   */\n  orIgnore(statement = true) {\n    this.expressionMap.onIgnore = !!statement;\n    return this;\n  }\n  /**\n   * Adds additional update statement supported in databases.\n   */\n  orUpdate(statementOrOverwrite, conflictTarget, orUpdateOptions) {\n    if (!Array.isArray(statementOrOverwrite)) {\n      this.expressionMap.onUpdate = {\n        conflict: statementOrOverwrite === null || statementOrOverwrite === void 0 ? void 0 : statementOrOverwrite.conflict_target,\n        columns: statementOrOverwrite === null || statementOrOverwrite === void 0 ? void 0 : statementOrOverwrite.columns,\n        overwrite: statementOrOverwrite === null || statementOrOverwrite === void 0 ? void 0 : statementOrOverwrite.overwrite,\n        skipUpdateIfNoValuesChanged: orUpdateOptions === null || orUpdateOptions === void 0 ? void 0 : orUpdateOptions.skipUpdateIfNoValuesChanged,\n        upsertType: orUpdateOptions === null || orUpdateOptions === void 0 ? void 0 : orUpdateOptions.upsertType\n      };\n      return this;\n    }\n    this.expressionMap.onUpdate = {\n      overwrite: statementOrOverwrite,\n      conflict: conflictTarget,\n      skipUpdateIfNoValuesChanged: orUpdateOptions === null || orUpdateOptions === void 0 ? void 0 : orUpdateOptions.skipUpdateIfNoValuesChanged,\n      indexPredicate: orUpdateOptions === null || orUpdateOptions === void 0 ? void 0 : orUpdateOptions.indexPredicate,\n      upsertType: orUpdateOptions === null || orUpdateOptions === void 0 ? void 0 : orUpdateOptions.upsertType\n    };\n    return this;\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Creates INSERT express used to perform insert query.\n   */\n  createInsertExpression() {\n    var _a, _b;\n    const tableName = this.getTableName(this.getMainTableName());\n    const valuesExpression = this.createValuesExpression(); // its important to get values before returning expression because oracle rely on native parameters and ordering of them is important\n    const returningExpression = this.connection.driver.options.type === \"oracle\" && this.getValueSets().length > 1 ? null : this.createReturningExpression(\"insert\"); // oracle doesnt support returning with multi-row insert\n    const columnsExpression = this.createColumnNamesExpression();\n    let query = \"INSERT \";\n    if (((_a = this.expressionMap.onUpdate) === null || _a === void 0 ? void 0 : _a.upsertType) === \"primary-key\") {\n      query = \"UPSERT \";\n    }\n    if (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === \"aurora-mysql\") {\n      query += `${this.expressionMap.onIgnore ? \" IGNORE \" : \"\"}`;\n    }\n    query += `INTO ${tableName}`;\n    if (this.alias !== this.getMainTableName() && DriverUtils.isPostgresFamily(this.connection.driver)) {\n      query += ` AS \"${this.alias}\"`;\n    }\n    // add columns expression\n    if (columnsExpression) {\n      query += `(${columnsExpression})`;\n    } else {\n      if (!valuesExpression && (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === \"aurora-mysql\"))\n        // special syntax for mysql DEFAULT VALUES insertion\n        query += \"()\";\n    }\n    // add OUTPUT expression\n    if (returningExpression && this.connection.driver.options.type === \"mssql\") {\n      query += ` OUTPUT ${returningExpression}`;\n    }\n    // add VALUES expression\n    if (valuesExpression) {\n      if (this.connection.driver.options.type === \"oracle\" && this.getValueSets().length > 1) {\n        query += ` ${valuesExpression}`;\n      } else {\n        query += ` VALUES ${valuesExpression}`;\n      }\n    } else {\n      if (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === \"aurora-mysql\") {\n        // special syntax for mysql DEFAULT VALUES insertion\n        query += \" VALUES ()\";\n      } else {\n        query += ` DEFAULT VALUES`;\n      }\n    }\n    if (((_b = this.expressionMap.onUpdate) === null || _b === void 0 ? void 0 : _b.upsertType) !== \"primary-key\") {\n      if (this.connection.driver.supportedUpsertTypes.includes(\"on-conflict-do-update\")) {\n        if (this.expressionMap.onIgnore) {\n          query += \" ON CONFLICT DO NOTHING \";\n        } else if (this.expressionMap.onConflict) {\n          query += ` ON CONFLICT ${this.expressionMap.onConflict} `;\n        } else if (this.expressionMap.onUpdate) {\n          const {\n            overwrite,\n            columns,\n            conflict,\n            skipUpdateIfNoValuesChanged,\n            indexPredicate\n          } = this.expressionMap.onUpdate;\n          let conflictTarget = \"ON CONFLICT\";\n          if (Array.isArray(conflict)) {\n            conflictTarget += ` ( ${conflict.map(column => this.escape(column)).join(\", \")} )`;\n            if (indexPredicate && !DriverUtils.isPostgresFamily(this.connection.driver)) {\n              throw new TypeORMError(`indexPredicate option is not supported by the current database driver`);\n            }\n            if (indexPredicate && DriverUtils.isPostgresFamily(this.connection.driver)) {\n              conflictTarget += ` WHERE ( ${this.escape(indexPredicate)} )`;\n            }\n          } else if (conflict) {\n            conflictTarget += ` ON CONSTRAINT ${this.escape(conflict)}`;\n          }\n          if (Array.isArray(overwrite)) {\n            query += ` ${conflictTarget} DO UPDATE SET `;\n            query += overwrite === null || overwrite === void 0 ? void 0 : overwrite.map(column => `${this.escape(column)} = EXCLUDED.${this.escape(column)}`).join(\", \");\n            query += \" \";\n          } else if (columns) {\n            query += ` ${conflictTarget} DO UPDATE SET `;\n            query += columns.map(column => `${this.escape(column)} = :${column}`).join(\", \");\n            query += \" \";\n          }\n          if (Array.isArray(overwrite) && skipUpdateIfNoValuesChanged && DriverUtils.isPostgresFamily(this.connection.driver)) {\n            query += ` WHERE (`;\n            query += overwrite.map(column => `${tableName}.${this.escape(column)} IS DISTINCT FROM EXCLUDED.${this.escape(column)}`).join(\" OR \");\n            query += \") \";\n          }\n        }\n      } else if (this.connection.driver.supportedUpsertTypes.includes(\"on-duplicate-key-update\")) {\n        if (this.expressionMap.onUpdate) {\n          const {\n            overwrite,\n            columns\n          } = this.expressionMap.onUpdate;\n          if (Array.isArray(overwrite)) {\n            query += \" ON DUPLICATE KEY UPDATE \";\n            query += overwrite.map(column => `${this.escape(column)} = VALUES(${this.escape(column)})`).join(\", \");\n            query += \" \";\n          } else if (Array.isArray(columns)) {\n            query += \" ON DUPLICATE KEY UPDATE \";\n            query += columns.map(column => `${this.escape(column)} = :${column}`).join(\", \");\n            query += \" \";\n          }\n        }\n      } else {\n        if (this.expressionMap.onUpdate) {\n          throw new TypeORMError(`onUpdate is not supported by the current database driver`);\n        }\n      }\n    }\n    // add RETURNING expression\n    if (returningExpression && (DriverUtils.isPostgresFamily(this.connection.driver) || this.connection.driver.options.type === \"oracle\" || this.connection.driver.options.type === \"cockroachdb\" || DriverUtils.isMySQLFamily(this.connection.driver))) {\n      query += ` RETURNING ${returningExpression}`;\n    }\n    // Inserting a specific value for an auto-increment primary key in mssql requires enabling IDENTITY_INSERT\n    // IDENTITY_INSERT can only be enabled for tables where there is an IDENTITY column and only if there is a value to be inserted (i.e. supplying DEFAULT is prohibited if IDENTITY_INSERT is enabled)\n    if (this.connection.driver.options.type === \"mssql\" && this.expressionMap.mainAlias.hasMetadata && this.expressionMap.mainAlias.metadata.columns.filter(column => this.expressionMap.insertColumns.length > 0 ? this.expressionMap.insertColumns.indexOf(column.propertyPath) !== -1 : column.isInsert).some(column => this.isOverridingAutoIncrementBehavior(column))) {\n      query = `SET IDENTITY_INSERT ${tableName} ON; ${query}; SET IDENTITY_INSERT ${tableName} OFF`;\n    }\n    return query;\n  }\n  /**\n   * Gets list of columns where values must be inserted to.\n   */\n  getInsertedColumns() {\n    if (!this.expressionMap.mainAlias.hasMetadata) return [];\n    return this.expressionMap.mainAlias.metadata.columns.filter(column => {\n      // if user specified list of columns he wants to insert to, then we filter only them\n      if (this.expressionMap.insertColumns.length) return this.expressionMap.insertColumns.indexOf(column.propertyPath) !== -1;\n      // skip columns the user doesn't want included by default\n      if (!column.isInsert) {\n        return false;\n      }\n      // if user did not specified such list then return all columns except auto-increment one\n      // for Oracle we return auto-increment column as well because Oracle does not support DEFAULT VALUES expression\n      if (column.isGenerated && column.generationStrategy === \"increment\" && !(this.connection.driver.options.type === \"spanner\") && !(this.connection.driver.options.type === \"oracle\") && !DriverUtils.isSQLiteFamily(this.connection.driver) && !DriverUtils.isMySQLFamily(this.connection.driver) && !(this.connection.driver.options.type === \"aurora-mysql\") && !(this.connection.driver.options.type === \"mssql\" && this.isOverridingAutoIncrementBehavior(column))) return false;\n      return true;\n    });\n  }\n  /**\n   * Creates a columns string where values must be inserted to for INSERT INTO expression.\n   */\n  createColumnNamesExpression() {\n    const columns = this.getInsertedColumns();\n    if (columns.length > 0) return columns.map(column => this.escape(column.databaseName)).join(\", \");\n    // in the case if there are no insert columns specified and table without metadata used\n    // we get columns from the inserted value map, in the case if only one inserted map is specified\n    if (!this.expressionMap.mainAlias.hasMetadata && !this.expressionMap.insertColumns.length) {\n      const valueSets = this.getValueSets();\n      if (valueSets.length === 1) return Object.keys(valueSets[0]).map(columnName => this.escape(columnName)).join(\", \");\n    }\n    // get a table name and all column database names\n    return this.expressionMap.insertColumns.map(columnName => this.escape(columnName)).join(\", \");\n  }\n  /**\n   * Creates list of values needs to be inserted in the VALUES expression.\n   */\n  createValuesExpression() {\n    const valueSets = this.getValueSets();\n    const columns = this.getInsertedColumns();\n    // if column metadatas are given then apply all necessary operations with values\n    if (columns.length > 0) {\n      let expression = \"\";\n      valueSets.forEach((valueSet, valueSetIndex) => {\n        columns.forEach((column, columnIndex) => {\n          if (columnIndex === 0) {\n            if (this.connection.driver.options.type === \"oracle\" && valueSets.length > 1) {\n              expression += \" SELECT \";\n            } else if (this.connection.driver.options.type === \"sap\" && valueSets.length > 1) {\n              expression += \" SELECT \";\n            } else {\n              expression += \"(\";\n            }\n          }\n          // extract real value from the entity\n          let value = column.getEntityValue(valueSet);\n          // if column is relational and value is an object then get real referenced column value from this object\n          // for example column value is { question: { id: 1 } }, value will be equal to { id: 1 }\n          // and we extract \"1\" from this object\n          /*if (column.referencedColumn && value instanceof Object && !(typeof value === \"function\")) { // todo: check if we still need it since getEntityValue already has similar code\n              value = column.referencedColumn.getEntityValue(value);\n          }*/\n          if (!(typeof value === \"function\")) {\n            // make sure our value is normalized by a driver\n            value = this.connection.driver.preparePersistentValue(value, column);\n          }\n          // newly inserted entities always have a version equal to 1 (first version)\n          // also, user-specified version must be empty\n          if (column.isVersion && value === undefined) {\n            expression += \"1\";\n            // } else if (column.isNestedSetLeft) {\n            //     const tableName = this.connection.driver.escape(column.entityMetadata.tablePath);\n            //     const rightColumnName = this.connection.driver.escape(column.entityMetadata.nestedSetRightColumn!.databaseName);\n            //     const subQuery = `(SELECT c.max + 1 FROM (SELECT MAX(${rightColumnName}) as max from ${tableName}) c)`;\n            //     expression += subQuery;\n            //\n            // } else if (column.isNestedSetRight) {\n            //     const tableName = this.connection.driver.escape(column.entityMetadata.tablePath);\n            //     const rightColumnName = this.connection.driver.escape(column.entityMetadata.nestedSetRightColumn!.databaseName);\n            //     const subQuery = `(SELECT c.max + 2 FROM (SELECT MAX(${rightColumnName}) as max from ${tableName}) c)`;\n            //     expression += subQuery;\n          } else if (column.isDiscriminator) {\n            expression += this.createParameter(this.expressionMap.mainAlias.metadata.discriminatorValue);\n            // return \"1\";\n            // for create and update dates we insert current date\n            // no, we don't do it because this constant is already in \"default\" value of the column\n            // with extended timestamp functionality, like CURRENT_TIMESTAMP(6) for example\n            // } else if (column.isCreateDate || column.isUpdateDate) {\n            //     return \"CURRENT_TIMESTAMP\";\n            // if column is generated uuid and database does not support its generation and custom generated value was not provided by a user - we generate a new uuid value for insertion\n          } else if (column.isGenerated && column.generationStrategy === \"uuid\" && !this.connection.driver.isUUIDGenerationSupported() && value === undefined) {\n            value = uuidv4();\n            expression += this.createParameter(value);\n            if (!(valueSetIndex in this.expressionMap.locallyGenerated)) {\n              this.expressionMap.locallyGenerated[valueSetIndex] = {};\n            }\n            column.setEntityValue(this.expressionMap.locallyGenerated[valueSetIndex], value);\n            // if value for this column was not provided then insert default value\n          } else if (value === undefined) {\n            if (this.connection.driver.options.type === \"oracle\" && valueSets.length > 1 || DriverUtils.isSQLiteFamily(this.connection.driver) || this.connection.driver.options.type === \"sap\" || this.connection.driver.options.type === \"spanner\") {\n              // unfortunately sqlite does not support DEFAULT expression in INSERT queries\n              if (column.default !== undefined && column.default !== null) {\n                // try to use default defined in the column\n                expression += this.connection.driver.normalizeDefault(column);\n              } else {\n                expression += \"NULL\"; // otherwise simply use NULL and pray if column is nullable\n              }\n            } else {\n              expression += \"DEFAULT\";\n            }\n          } else if (value === null && this.connection.driver.options.type === \"spanner\") {\n            expression += \"NULL\";\n            // support for SQL expressions in queries\n          } else if (typeof value === \"function\") {\n            expression += value();\n            // just any other regular value\n          } else {\n            if (this.connection.driver.options.type === \"mssql\") value = this.connection.driver.parametrizeValue(column, value);\n            // we need to store array values in a special class to make sure parameter replacement will work correctly\n            // if (value instanceof Array)\n            //     value = new ArrayParameter(value);\n            const paramName = this.createParameter(value);\n            if ((DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === \"aurora-mysql\") && this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {\n              const useLegacy = this.connection.driver.options.legacySpatialSupport;\n              const geomFromText = useLegacy ? \"GeomFromText\" : \"ST_GeomFromText\";\n              if (column.srid != null) {\n                expression += `${geomFromText}(${paramName}, ${column.srid})`;\n              } else {\n                expression += `${geomFromText}(${paramName})`;\n              }\n            } else if (DriverUtils.isPostgresFamily(this.connection.driver) && this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {\n              if (column.srid != null) {\n                expression += `ST_SetSRID(ST_GeomFromGeoJSON(${paramName}), ${column.srid})::${column.type}`;\n              } else {\n                expression += `ST_GeomFromGeoJSON(${paramName})::${column.type}`;\n              }\n            } else if (this.connection.driver.options.type === \"mssql\" && this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {\n              expression += column.type + \"::STGeomFromText(\" + paramName + \", \" + (column.srid || \"0\") + \")\";\n            } else {\n              expression += paramName;\n            }\n          }\n          if (columnIndex === columns.length - 1) {\n            if (valueSetIndex === valueSets.length - 1) {\n              if (this.connection.driver.options.type === \"oracle\" && valueSets.length > 1) {\n                expression += \" FROM DUAL \";\n              } else if (this.connection.driver.options.type === \"sap\" && valueSets.length > 1) {\n                expression += \" FROM dummy \";\n              } else {\n                expression += \")\";\n              }\n            } else {\n              if (this.connection.driver.options.type === \"oracle\" && valueSets.length > 1) {\n                expression += \" FROM DUAL UNION ALL \";\n              } else if (this.connection.driver.options.type === \"sap\" && valueSets.length > 1) {\n                expression += \" FROM dummy UNION ALL \";\n              } else {\n                expression += \"), \";\n              }\n            }\n          } else {\n            expression += \", \";\n          }\n        });\n      });\n      if (expression === \"()\") return \"\";\n      return expression;\n    } else {\n      // for tables without metadata\n      // get values needs to be inserted\n      let expression = \"\";\n      valueSets.forEach((valueSet, insertionIndex) => {\n        const columns = Object.keys(valueSet);\n        columns.forEach((columnName, columnIndex) => {\n          if (columnIndex === 0) {\n            expression += \"(\";\n          }\n          const value = valueSet[columnName];\n          // support for SQL expressions in queries\n          if (typeof value === \"function\") {\n            expression += value();\n            // if value for this column was not provided then insert default value\n          } else if (value === undefined) {\n            if (this.connection.driver.options.type === \"oracle\" && valueSets.length > 1 || DriverUtils.isSQLiteFamily(this.connection.driver) || this.connection.driver.options.type === \"sap\" || this.connection.driver.options.type === \"spanner\") {\n              expression += \"NULL\";\n            } else {\n              expression += \"DEFAULT\";\n            }\n          } else if (value === null && this.connection.driver.options.type === \"spanner\") {\n            // just any other regular value\n          } else {\n            expression += this.createParameter(value);\n          }\n          if (columnIndex === Object.keys(valueSet).length - 1) {\n            if (insertionIndex === valueSets.length - 1) {\n              expression += \")\";\n            } else {\n              expression += \"), \";\n            }\n          } else {\n            expression += \", \";\n          }\n        });\n      });\n      if (expression === \"()\") return \"\";\n      return expression;\n    }\n  }\n  /**\n   * Gets array of values need to be inserted into the target table.\n   */\n  getValueSets() {\n    if (Array.isArray(this.expressionMap.valuesSet)) return this.expressionMap.valuesSet;\n    if (ObjectUtils.isObject(this.expressionMap.valuesSet)) return [this.expressionMap.valuesSet];\n    throw new InsertValuesMissingError();\n  }\n  /**\n   * Checks if column is an auto-generated primary key, but the current insertion specifies a value for it.\n   *\n   * @param column\n   */\n  isOverridingAutoIncrementBehavior(column) {\n    return column.isPrimary && column.isGenerated && column.generationStrategy === \"increment\" && this.getValueSets().some(valueSet => column.getEntityValue(valueSet) !== undefined && column.getEntityValue(valueSet) !== null);\n  }\n}","map":{"version":3,"names":["v4","uuidv4","DriverUtils","TypeORMError","InsertValuesMissingError","ReturningStatementNotSupportedError","BroadcasterResult","InstanceChecker","ObjectUtils","QueryBuilder","InsertResult","ReturningResultsEntityUpdator","InsertQueryBuilder","constructor","arguments","Symbol","for","getQuery","sql","createComment","createCteExpression","createInsertExpression","replacePropertyNamesForTheWholeQuery","trim","execute","_this","_asyncToGenerator","valueSets","getValueSets","length","queryRunner","obtainQueryRunner","transactionStartedByUs","expressionMap","useTransaction","isTransactionActive","startTransaction","callListeners","mainAlias","hasMetadata","broadcastResult","forEach","valueSet","broadcaster","broadcastBeforeInsertEvent","metadata","wait","declareSql","selectOutputSql","returningResultsEntityUpdator","returningColumns","Array","isArray","returning","columnPath","push","findColumnsWithPropertyPath","updateEntity","connection","driver","options","type","extraReturningColumns","getInsertionReturningColumns","filter","c","includes","buildTableVariableDeclaration","insertSql","parameters","getQueryAndParameters","statements","s","join","queryResult","query","insertResult","from","insert","broadcastAfterInsertEvent","commitTransaction","error","rollbackTransaction","rollbackError","release","into","entityTarget","columns","isEntitySchema","name","createFromAlias","setMainAlias","insertColumns","values","valuesSet","output","isReturningSqlSupported","enabled","onConflict","statement","orIgnore","onIgnore","orUpdate","statementOrOverwrite","conflictTarget","orUpdateOptions","onUpdate","conflict","conflict_target","overwrite","skipUpdateIfNoValuesChanged","upsertType","indexPredicate","_a","_b","tableName","getTableName","getMainTableName","valuesExpression","createValuesExpression","returningExpression","createReturningExpression","columnsExpression","createColumnNamesExpression","isMySQLFamily","alias","isPostgresFamily","supportedUpsertTypes","map","column","escape","indexOf","propertyPath","isInsert","some","isOverridingAutoIncrementBehavior","getInsertedColumns","isGenerated","generationStrategy","isSQLiteFamily","databaseName","Object","keys","columnName","expression","valueSetIndex","columnIndex","value","getEntityValue","preparePersistentValue","isVersion","undefined","isDiscriminator","createParameter","discriminatorValue","isUUIDGenerationSupported","locallyGenerated","setEntityValue","default","normalizeDefault","parametrizeValue","paramName","spatialTypes","useLegacy","legacySpatialSupport","geomFromText","srid","insertionIndex","isObject","isPrimary"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/query-builder/InsertQueryBuilder.js"],"sourcesContent":["import { v4 as uuidv4 } from \"uuid\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\nimport { TypeORMError } from \"../error\";\nimport { InsertValuesMissingError } from \"../error/InsertValuesMissingError\";\nimport { ReturningStatementNotSupportedError } from \"../error/ReturningStatementNotSupportedError\";\nimport { BroadcasterResult } from \"../subscriber/BroadcasterResult\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\nimport { ObjectUtils } from \"../util/ObjectUtils\";\nimport { QueryBuilder } from \"./QueryBuilder\";\nimport { InsertResult } from \"./result/InsertResult\";\nimport { ReturningResultsEntityUpdator } from \"./ReturningResultsEntityUpdator\";\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\nexport class InsertQueryBuilder extends QueryBuilder {\n    constructor() {\n        super(...arguments);\n        this[\"@instanceof\"] = Symbol.for(\"InsertQueryBuilder\");\n    }\n    // -------------------------------------------------------------------------\n    // Public Implemented Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Gets generated SQL query without parameters being replaced.\n     */\n    getQuery() {\n        let sql = this.createComment();\n        sql += this.createCteExpression();\n        sql += this.createInsertExpression();\n        return this.replacePropertyNamesForTheWholeQuery(sql.trim());\n    }\n    /**\n     * Executes sql generated by query builder and returns raw database results.\n     */\n    async execute() {\n        // console.time(\".value sets\");\n        const valueSets = this.getValueSets();\n        // console.timeEnd(\".value sets\");\n        // If user passed empty array of entities then we don't need to do\n        // anything.\n        //\n        // Fixes GitHub issues #3111 and #5734. If we were to let this through\n        // we would run into problems downstream, like subscribers getting\n        // invoked with the empty array where they expect an entity, and SQL\n        // queries with an empty VALUES clause.\n        if (valueSets.length === 0)\n            return new InsertResult();\n        // console.time(\"QueryBuilder.execute\");\n        // console.time(\".database stuff\");\n        const queryRunner = this.obtainQueryRunner();\n        let transactionStartedByUs = false;\n        try {\n            // start transaction if it was enabled\n            if (this.expressionMap.useTransaction === true &&\n                queryRunner.isTransactionActive === false) {\n                await queryRunner.startTransaction();\n                transactionStartedByUs = true;\n            }\n            // console.timeEnd(\".database stuff\");\n            // call before insertion methods in listeners and subscribers\n            if (this.expressionMap.callListeners === true &&\n                this.expressionMap.mainAlias.hasMetadata) {\n                const broadcastResult = new BroadcasterResult();\n                valueSets.forEach((valueSet) => {\n                    queryRunner.broadcaster.broadcastBeforeInsertEvent(broadcastResult, this.expressionMap.mainAlias.metadata, valueSet);\n                });\n                await broadcastResult.wait();\n            }\n            let declareSql = null;\n            let selectOutputSql = null;\n            // if update entity mode is enabled we may need extra columns for the returning statement\n            // console.time(\".prepare returning statement\");\n            const returningResultsEntityUpdator = new ReturningResultsEntityUpdator(queryRunner, this.expressionMap);\n            const returningColumns = [];\n            if (Array.isArray(this.expressionMap.returning) &&\n                this.expressionMap.mainAlias.hasMetadata) {\n                for (const columnPath of this.expressionMap.returning) {\n                    returningColumns.push(...this.expressionMap.mainAlias.metadata.findColumnsWithPropertyPath(columnPath));\n                }\n            }\n            if (this.expressionMap.updateEntity === true &&\n                this.expressionMap.mainAlias.hasMetadata) {\n                if (!(valueSets.length > 1 &&\n                    this.connection.driver.options.type === \"oracle\")) {\n                    this.expressionMap.extraReturningColumns =\n                        this.expressionMap.mainAlias.metadata.getInsertionReturningColumns();\n                }\n                returningColumns.push(...this.expressionMap.extraReturningColumns.filter((c) => !returningColumns.includes(c)));\n            }\n            if (returningColumns.length > 0 &&\n                this.connection.driver.options.type === \"mssql\") {\n                declareSql = this.connection.driver.buildTableVariableDeclaration(\"@OutputTable\", returningColumns);\n                selectOutputSql = `SELECT * FROM @OutputTable`;\n            }\n            // console.timeEnd(\".prepare returning statement\");\n            // execute query\n            // console.time(\".getting query and parameters\");\n            const [insertSql, parameters] = this.getQueryAndParameters();\n            // console.timeEnd(\".getting query and parameters\");\n            // console.time(\".query execution by database\");\n            const statements = [declareSql, insertSql, selectOutputSql];\n            const sql = statements.filter((s) => s != null).join(\";\\n\\n\");\n            const queryResult = await queryRunner.query(sql, parameters, true);\n            const insertResult = InsertResult.from(queryResult);\n            // console.timeEnd(\".query execution by database\");\n            // load returning results and set them to the entity if entity updation is enabled\n            if (this.expressionMap.updateEntity === true &&\n                this.expressionMap.mainAlias.hasMetadata) {\n                // console.time(\".updating entity\");\n                await returningResultsEntityUpdator.insert(insertResult, valueSets);\n                // console.timeEnd(\".updating entity\");\n            }\n            // call after insertion methods in listeners and subscribers\n            if (this.expressionMap.callListeners === true &&\n                this.expressionMap.mainAlias.hasMetadata) {\n                const broadcastResult = new BroadcasterResult();\n                valueSets.forEach((valueSet) => {\n                    queryRunner.broadcaster.broadcastAfterInsertEvent(broadcastResult, this.expressionMap.mainAlias.metadata, valueSet);\n                });\n                await broadcastResult.wait();\n            }\n            // close transaction if we started it\n            // console.time(\".commit\");\n            if (transactionStartedByUs) {\n                await queryRunner.commitTransaction();\n            }\n            // console.timeEnd(\".commit\");\n            return insertResult;\n        }\n        catch (error) {\n            // rollback transaction if we started it\n            if (transactionStartedByUs) {\n                try {\n                    await queryRunner.rollbackTransaction();\n                }\n                catch (rollbackError) { }\n            }\n            throw error;\n        }\n        finally {\n            // console.time(\".releasing connection\");\n            if (queryRunner !== this.queryRunner) {\n                // means we created our own query runner\n                await queryRunner.release();\n            }\n            // console.timeEnd(\".releasing connection\");\n            // console.timeEnd(\"QueryBuilder.execute\");\n        }\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Specifies INTO which entity's table insertion will be executed.\n     */\n    into(entityTarget, columns) {\n        entityTarget = InstanceChecker.isEntitySchema(entityTarget)\n            ? entityTarget.options.name\n            : entityTarget;\n        const mainAlias = this.createFromAlias(entityTarget);\n        this.expressionMap.setMainAlias(mainAlias);\n        this.expressionMap.insertColumns = columns || [];\n        return this;\n    }\n    /**\n     * Values needs to be inserted into table.\n     */\n    values(values) {\n        this.expressionMap.valuesSet = values;\n        return this;\n    }\n    /**\n     * Optional returning/output clause.\n     */\n    output(output) {\n        return this.returning(output);\n    }\n    /**\n     * Optional returning/output clause.\n     */\n    returning(returning) {\n        // not all databases support returning/output cause\n        if (!this.connection.driver.isReturningSqlSupported(\"insert\")) {\n            throw new ReturningStatementNotSupportedError();\n        }\n        this.expressionMap.returning = returning;\n        return this;\n    }\n    /**\n     * Indicates if entity must be updated after insertion operations.\n     * This may produce extra query or use RETURNING / OUTPUT statement (depend on database).\n     * Enabled by default.\n     */\n    updateEntity(enabled) {\n        this.expressionMap.updateEntity = enabled;\n        return this;\n    }\n    /**\n     * Adds additional ON CONFLICT statement supported in postgres and cockroach.\n     *\n     * @deprecated Use `orIgnore` or `orUpdate`\n     */\n    onConflict(statement) {\n        this.expressionMap.onConflict = statement;\n        return this;\n    }\n    /**\n     * Adds additional ignore statement supported in databases.\n     */\n    orIgnore(statement = true) {\n        this.expressionMap.onIgnore = !!statement;\n        return this;\n    }\n    /**\n     * Adds additional update statement supported in databases.\n     */\n    orUpdate(statementOrOverwrite, conflictTarget, orUpdateOptions) {\n        if (!Array.isArray(statementOrOverwrite)) {\n            this.expressionMap.onUpdate = {\n                conflict: statementOrOverwrite === null || statementOrOverwrite === void 0 ? void 0 : statementOrOverwrite.conflict_target,\n                columns: statementOrOverwrite === null || statementOrOverwrite === void 0 ? void 0 : statementOrOverwrite.columns,\n                overwrite: statementOrOverwrite === null || statementOrOverwrite === void 0 ? void 0 : statementOrOverwrite.overwrite,\n                skipUpdateIfNoValuesChanged: orUpdateOptions === null || orUpdateOptions === void 0 ? void 0 : orUpdateOptions.skipUpdateIfNoValuesChanged,\n                upsertType: orUpdateOptions === null || orUpdateOptions === void 0 ? void 0 : orUpdateOptions.upsertType,\n            };\n            return this;\n        }\n        this.expressionMap.onUpdate = {\n            overwrite: statementOrOverwrite,\n            conflict: conflictTarget,\n            skipUpdateIfNoValuesChanged: orUpdateOptions === null || orUpdateOptions === void 0 ? void 0 : orUpdateOptions.skipUpdateIfNoValuesChanged,\n            indexPredicate: orUpdateOptions === null || orUpdateOptions === void 0 ? void 0 : orUpdateOptions.indexPredicate,\n            upsertType: orUpdateOptions === null || orUpdateOptions === void 0 ? void 0 : orUpdateOptions.upsertType,\n        };\n        return this;\n    }\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Creates INSERT express used to perform insert query.\n     */\n    createInsertExpression() {\n        var _a, _b;\n        const tableName = this.getTableName(this.getMainTableName());\n        const valuesExpression = this.createValuesExpression(); // its important to get values before returning expression because oracle rely on native parameters and ordering of them is important\n        const returningExpression = this.connection.driver.options.type === \"oracle\" &&\n            this.getValueSets().length > 1\n            ? null\n            : this.createReturningExpression(\"insert\"); // oracle doesnt support returning with multi-row insert\n        const columnsExpression = this.createColumnNamesExpression();\n        let query = \"INSERT \";\n        if (((_a = this.expressionMap.onUpdate) === null || _a === void 0 ? void 0 : _a.upsertType) === \"primary-key\") {\n            query = \"UPSERT \";\n        }\n        if (DriverUtils.isMySQLFamily(this.connection.driver) ||\n            this.connection.driver.options.type === \"aurora-mysql\") {\n            query += `${this.expressionMap.onIgnore ? \" IGNORE \" : \"\"}`;\n        }\n        query += `INTO ${tableName}`;\n        if (this.alias !== this.getMainTableName() &&\n            DriverUtils.isPostgresFamily(this.connection.driver)) {\n            query += ` AS \"${this.alias}\"`;\n        }\n        // add columns expression\n        if (columnsExpression) {\n            query += `(${columnsExpression})`;\n        }\n        else {\n            if (!valuesExpression &&\n                (DriverUtils.isMySQLFamily(this.connection.driver) ||\n                    this.connection.driver.options.type === \"aurora-mysql\"))\n                // special syntax for mysql DEFAULT VALUES insertion\n                query += \"()\";\n        }\n        // add OUTPUT expression\n        if (returningExpression &&\n            this.connection.driver.options.type === \"mssql\") {\n            query += ` OUTPUT ${returningExpression}`;\n        }\n        // add VALUES expression\n        if (valuesExpression) {\n            if (this.connection.driver.options.type === \"oracle\" &&\n                this.getValueSets().length > 1) {\n                query += ` ${valuesExpression}`;\n            }\n            else {\n                query += ` VALUES ${valuesExpression}`;\n            }\n        }\n        else {\n            if (DriverUtils.isMySQLFamily(this.connection.driver) ||\n                this.connection.driver.options.type === \"aurora-mysql\") {\n                // special syntax for mysql DEFAULT VALUES insertion\n                query += \" VALUES ()\";\n            }\n            else {\n                query += ` DEFAULT VALUES`;\n            }\n        }\n        if (((_b = this.expressionMap.onUpdate) === null || _b === void 0 ? void 0 : _b.upsertType) !== \"primary-key\") {\n            if (this.connection.driver.supportedUpsertTypes.includes(\"on-conflict-do-update\")) {\n                if (this.expressionMap.onIgnore) {\n                    query += \" ON CONFLICT DO NOTHING \";\n                }\n                else if (this.expressionMap.onConflict) {\n                    query += ` ON CONFLICT ${this.expressionMap.onConflict} `;\n                }\n                else if (this.expressionMap.onUpdate) {\n                    const { overwrite, columns, conflict, skipUpdateIfNoValuesChanged, indexPredicate, } = this.expressionMap.onUpdate;\n                    let conflictTarget = \"ON CONFLICT\";\n                    if (Array.isArray(conflict)) {\n                        conflictTarget += ` ( ${conflict\n                            .map((column) => this.escape(column))\n                            .join(\", \")} )`;\n                        if (indexPredicate &&\n                            !DriverUtils.isPostgresFamily(this.connection.driver)) {\n                            throw new TypeORMError(`indexPredicate option is not supported by the current database driver`);\n                        }\n                        if (indexPredicate &&\n                            DriverUtils.isPostgresFamily(this.connection.driver)) {\n                            conflictTarget += ` WHERE ( ${this.escape(indexPredicate)} )`;\n                        }\n                    }\n                    else if (conflict) {\n                        conflictTarget += ` ON CONSTRAINT ${this.escape(conflict)}`;\n                    }\n                    if (Array.isArray(overwrite)) {\n                        query += ` ${conflictTarget} DO UPDATE SET `;\n                        query += overwrite === null || overwrite === void 0 ? void 0 : overwrite.map((column) => `${this.escape(column)} = EXCLUDED.${this.escape(column)}`).join(\", \");\n                        query += \" \";\n                    }\n                    else if (columns) {\n                        query += ` ${conflictTarget} DO UPDATE SET `;\n                        query += columns\n                            .map((column) => `${this.escape(column)} = :${column}`)\n                            .join(\", \");\n                        query += \" \";\n                    }\n                    if (Array.isArray(overwrite) &&\n                        skipUpdateIfNoValuesChanged &&\n                        DriverUtils.isPostgresFamily(this.connection.driver)) {\n                        query += ` WHERE (`;\n                        query += overwrite\n                            .map((column) => `${tableName}.${this.escape(column)} IS DISTINCT FROM EXCLUDED.${this.escape(column)}`)\n                            .join(\" OR \");\n                        query += \") \";\n                    }\n                }\n            }\n            else if (this.connection.driver.supportedUpsertTypes.includes(\"on-duplicate-key-update\")) {\n                if (this.expressionMap.onUpdate) {\n                    const { overwrite, columns } = this.expressionMap.onUpdate;\n                    if (Array.isArray(overwrite)) {\n                        query += \" ON DUPLICATE KEY UPDATE \";\n                        query += overwrite\n                            .map((column) => `${this.escape(column)} = VALUES(${this.escape(column)})`)\n                            .join(\", \");\n                        query += \" \";\n                    }\n                    else if (Array.isArray(columns)) {\n                        query += \" ON DUPLICATE KEY UPDATE \";\n                        query += columns\n                            .map((column) => `${this.escape(column)} = :${column}`)\n                            .join(\", \");\n                        query += \" \";\n                    }\n                }\n            }\n            else {\n                if (this.expressionMap.onUpdate) {\n                    throw new TypeORMError(`onUpdate is not supported by the current database driver`);\n                }\n            }\n        }\n        // add RETURNING expression\n        if (returningExpression &&\n            (DriverUtils.isPostgresFamily(this.connection.driver) ||\n                this.connection.driver.options.type === \"oracle\" ||\n                this.connection.driver.options.type === \"cockroachdb\" ||\n                DriverUtils.isMySQLFamily(this.connection.driver))) {\n            query += ` RETURNING ${returningExpression}`;\n        }\n        // Inserting a specific value for an auto-increment primary key in mssql requires enabling IDENTITY_INSERT\n        // IDENTITY_INSERT can only be enabled for tables where there is an IDENTITY column and only if there is a value to be inserted (i.e. supplying DEFAULT is prohibited if IDENTITY_INSERT is enabled)\n        if (this.connection.driver.options.type === \"mssql\" &&\n            this.expressionMap.mainAlias.hasMetadata &&\n            this.expressionMap\n                .mainAlias.metadata.columns.filter((column) => this.expressionMap.insertColumns.length > 0\n                ? this.expressionMap.insertColumns.indexOf(column.propertyPath) !== -1\n                : column.isInsert)\n                .some((column) => this.isOverridingAutoIncrementBehavior(column))) {\n            query = `SET IDENTITY_INSERT ${tableName} ON; ${query}; SET IDENTITY_INSERT ${tableName} OFF`;\n        }\n        return query;\n    }\n    /**\n     * Gets list of columns where values must be inserted to.\n     */\n    getInsertedColumns() {\n        if (!this.expressionMap.mainAlias.hasMetadata)\n            return [];\n        return this.expressionMap.mainAlias.metadata.columns.filter((column) => {\n            // if user specified list of columns he wants to insert to, then we filter only them\n            if (this.expressionMap.insertColumns.length)\n                return (this.expressionMap.insertColumns.indexOf(column.propertyPath) !== -1);\n            // skip columns the user doesn't want included by default\n            if (!column.isInsert) {\n                return false;\n            }\n            // if user did not specified such list then return all columns except auto-increment one\n            // for Oracle we return auto-increment column as well because Oracle does not support DEFAULT VALUES expression\n            if (column.isGenerated &&\n                column.generationStrategy === \"increment\" &&\n                !(this.connection.driver.options.type === \"spanner\") &&\n                !(this.connection.driver.options.type === \"oracle\") &&\n                !DriverUtils.isSQLiteFamily(this.connection.driver) &&\n                !DriverUtils.isMySQLFamily(this.connection.driver) &&\n                !(this.connection.driver.options.type === \"aurora-mysql\") &&\n                !(this.connection.driver.options.type === \"mssql\" &&\n                    this.isOverridingAutoIncrementBehavior(column)))\n                return false;\n            return true;\n        });\n    }\n    /**\n     * Creates a columns string where values must be inserted to for INSERT INTO expression.\n     */\n    createColumnNamesExpression() {\n        const columns = this.getInsertedColumns();\n        if (columns.length > 0)\n            return columns\n                .map((column) => this.escape(column.databaseName))\n                .join(\", \");\n        // in the case if there are no insert columns specified and table without metadata used\n        // we get columns from the inserted value map, in the case if only one inserted map is specified\n        if (!this.expressionMap.mainAlias.hasMetadata &&\n            !this.expressionMap.insertColumns.length) {\n            const valueSets = this.getValueSets();\n            if (valueSets.length === 1)\n                return Object.keys(valueSets[0])\n                    .map((columnName) => this.escape(columnName))\n                    .join(\", \");\n        }\n        // get a table name and all column database names\n        return this.expressionMap.insertColumns\n            .map((columnName) => this.escape(columnName))\n            .join(\", \");\n    }\n    /**\n     * Creates list of values needs to be inserted in the VALUES expression.\n     */\n    createValuesExpression() {\n        const valueSets = this.getValueSets();\n        const columns = this.getInsertedColumns();\n        // if column metadatas are given then apply all necessary operations with values\n        if (columns.length > 0) {\n            let expression = \"\";\n            valueSets.forEach((valueSet, valueSetIndex) => {\n                columns.forEach((column, columnIndex) => {\n                    if (columnIndex === 0) {\n                        if (this.connection.driver.options.type === \"oracle\" &&\n                            valueSets.length > 1) {\n                            expression += \" SELECT \";\n                        }\n                        else if (this.connection.driver.options.type === \"sap\" &&\n                            valueSets.length > 1) {\n                            expression += \" SELECT \";\n                        }\n                        else {\n                            expression += \"(\";\n                        }\n                    }\n                    // extract real value from the entity\n                    let value = column.getEntityValue(valueSet);\n                    // if column is relational and value is an object then get real referenced column value from this object\n                    // for example column value is { question: { id: 1 } }, value will be equal to { id: 1 }\n                    // and we extract \"1\" from this object\n                    /*if (column.referencedColumn && value instanceof Object && !(typeof value === \"function\")) { // todo: check if we still need it since getEntityValue already has similar code\n                        value = column.referencedColumn.getEntityValue(value);\n                    }*/\n                    if (!(typeof value === \"function\")) {\n                        // make sure our value is normalized by a driver\n                        value = this.connection.driver.preparePersistentValue(value, column);\n                    }\n                    // newly inserted entities always have a version equal to 1 (first version)\n                    // also, user-specified version must be empty\n                    if (column.isVersion && value === undefined) {\n                        expression += \"1\";\n                        // } else if (column.isNestedSetLeft) {\n                        //     const tableName = this.connection.driver.escape(column.entityMetadata.tablePath);\n                        //     const rightColumnName = this.connection.driver.escape(column.entityMetadata.nestedSetRightColumn!.databaseName);\n                        //     const subQuery = `(SELECT c.max + 1 FROM (SELECT MAX(${rightColumnName}) as max from ${tableName}) c)`;\n                        //     expression += subQuery;\n                        //\n                        // } else if (column.isNestedSetRight) {\n                        //     const tableName = this.connection.driver.escape(column.entityMetadata.tablePath);\n                        //     const rightColumnName = this.connection.driver.escape(column.entityMetadata.nestedSetRightColumn!.databaseName);\n                        //     const subQuery = `(SELECT c.max + 2 FROM (SELECT MAX(${rightColumnName}) as max from ${tableName}) c)`;\n                        //     expression += subQuery;\n                    }\n                    else if (column.isDiscriminator) {\n                        expression += this.createParameter(this.expressionMap.mainAlias.metadata\n                            .discriminatorValue);\n                        // return \"1\";\n                        // for create and update dates we insert current date\n                        // no, we don't do it because this constant is already in \"default\" value of the column\n                        // with extended timestamp functionality, like CURRENT_TIMESTAMP(6) for example\n                        // } else if (column.isCreateDate || column.isUpdateDate) {\n                        //     return \"CURRENT_TIMESTAMP\";\n                        // if column is generated uuid and database does not support its generation and custom generated value was not provided by a user - we generate a new uuid value for insertion\n                    }\n                    else if (column.isGenerated &&\n                        column.generationStrategy === \"uuid\" &&\n                        !this.connection.driver.isUUIDGenerationSupported() &&\n                        value === undefined) {\n                        value = uuidv4();\n                        expression += this.createParameter(value);\n                        if (!(valueSetIndex in\n                            this.expressionMap.locallyGenerated)) {\n                            this.expressionMap.locallyGenerated[valueSetIndex] =\n                                {};\n                        }\n                        column.setEntityValue(this.expressionMap.locallyGenerated[valueSetIndex], value);\n                        // if value for this column was not provided then insert default value\n                    }\n                    else if (value === undefined) {\n                        if ((this.connection.driver.options.type === \"oracle\" &&\n                            valueSets.length > 1) ||\n                            DriverUtils.isSQLiteFamily(this.connection.driver) ||\n                            this.connection.driver.options.type === \"sap\" ||\n                            this.connection.driver.options.type === \"spanner\") {\n                            // unfortunately sqlite does not support DEFAULT expression in INSERT queries\n                            if (column.default !== undefined &&\n                                column.default !== null) {\n                                // try to use default defined in the column\n                                expression +=\n                                    this.connection.driver.normalizeDefault(column);\n                            }\n                            else {\n                                expression += \"NULL\"; // otherwise simply use NULL and pray if column is nullable\n                            }\n                        }\n                        else {\n                            expression += \"DEFAULT\";\n                        }\n                    }\n                    else if (value === null &&\n                        this.connection.driver.options.type === \"spanner\") {\n                        expression += \"NULL\";\n                        // support for SQL expressions in queries\n                    }\n                    else if (typeof value === \"function\") {\n                        expression += value();\n                        // just any other regular value\n                    }\n                    else {\n                        if (this.connection.driver.options.type === \"mssql\")\n                            value = this.connection.driver.parametrizeValue(column, value);\n                        // we need to store array values in a special class to make sure parameter replacement will work correctly\n                        // if (value instanceof Array)\n                        //     value = new ArrayParameter(value);\n                        const paramName = this.createParameter(value);\n                        if ((DriverUtils.isMySQLFamily(this.connection.driver) ||\n                            this.connection.driver.options.type ===\n                                \"aurora-mysql\") &&\n                            this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {\n                            const useLegacy = this.connection.driver.options.legacySpatialSupport;\n                            const geomFromText = useLegacy\n                                ? \"GeomFromText\"\n                                : \"ST_GeomFromText\";\n                            if (column.srid != null) {\n                                expression += `${geomFromText}(${paramName}, ${column.srid})`;\n                            }\n                            else {\n                                expression += `${geomFromText}(${paramName})`;\n                            }\n                        }\n                        else if (DriverUtils.isPostgresFamily(this.connection.driver) &&\n                            this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {\n                            if (column.srid != null) {\n                                expression += `ST_SetSRID(ST_GeomFromGeoJSON(${paramName}), ${column.srid})::${column.type}`;\n                            }\n                            else {\n                                expression += `ST_GeomFromGeoJSON(${paramName})::${column.type}`;\n                            }\n                        }\n                        else if (this.connection.driver.options.type === \"mssql\" &&\n                            this.connection.driver.spatialTypes.indexOf(column.type) !== -1) {\n                            expression +=\n                                column.type +\n                                    \"::STGeomFromText(\" +\n                                    paramName +\n                                    \", \" +\n                                    (column.srid || \"0\") +\n                                    \")\";\n                        }\n                        else {\n                            expression += paramName;\n                        }\n                    }\n                    if (columnIndex === columns.length - 1) {\n                        if (valueSetIndex === valueSets.length - 1) {\n                            if (this.connection.driver.options.type ===\n                                \"oracle\" &&\n                                valueSets.length > 1) {\n                                expression += \" FROM DUAL \";\n                            }\n                            else if (this.connection.driver.options.type === \"sap\" &&\n                                valueSets.length > 1) {\n                                expression += \" FROM dummy \";\n                            }\n                            else {\n                                expression += \")\";\n                            }\n                        }\n                        else {\n                            if (this.connection.driver.options.type ===\n                                \"oracle\" &&\n                                valueSets.length > 1) {\n                                expression += \" FROM DUAL UNION ALL \";\n                            }\n                            else if (this.connection.driver.options.type === \"sap\" &&\n                                valueSets.length > 1) {\n                                expression += \" FROM dummy UNION ALL \";\n                            }\n                            else {\n                                expression += \"), \";\n                            }\n                        }\n                    }\n                    else {\n                        expression += \", \";\n                    }\n                });\n            });\n            if (expression === \"()\")\n                return \"\";\n            return expression;\n        }\n        else {\n            // for tables without metadata\n            // get values needs to be inserted\n            let expression = \"\";\n            valueSets.forEach((valueSet, insertionIndex) => {\n                const columns = Object.keys(valueSet);\n                columns.forEach((columnName, columnIndex) => {\n                    if (columnIndex === 0) {\n                        expression += \"(\";\n                    }\n                    const value = valueSet[columnName];\n                    // support for SQL expressions in queries\n                    if (typeof value === \"function\") {\n                        expression += value();\n                        // if value for this column was not provided then insert default value\n                    }\n                    else if (value === undefined) {\n                        if ((this.connection.driver.options.type === \"oracle\" &&\n                            valueSets.length > 1) ||\n                            DriverUtils.isSQLiteFamily(this.connection.driver) ||\n                            this.connection.driver.options.type === \"sap\" ||\n                            this.connection.driver.options.type === \"spanner\") {\n                            expression += \"NULL\";\n                        }\n                        else {\n                            expression += \"DEFAULT\";\n                        }\n                    }\n                    else if (value === null &&\n                        this.connection.driver.options.type === \"spanner\") {\n                        // just any other regular value\n                    }\n                    else {\n                        expression += this.createParameter(value);\n                    }\n                    if (columnIndex === Object.keys(valueSet).length - 1) {\n                        if (insertionIndex === valueSets.length - 1) {\n                            expression += \")\";\n                        }\n                        else {\n                            expression += \"), \";\n                        }\n                    }\n                    else {\n                        expression += \", \";\n                    }\n                });\n            });\n            if (expression === \"()\")\n                return \"\";\n            return expression;\n        }\n    }\n    /**\n     * Gets array of values need to be inserted into the target table.\n     */\n    getValueSets() {\n        if (Array.isArray(this.expressionMap.valuesSet))\n            return this.expressionMap.valuesSet;\n        if (ObjectUtils.isObject(this.expressionMap.valuesSet))\n            return [this.expressionMap.valuesSet];\n        throw new InsertValuesMissingError();\n    }\n    /**\n     * Checks if column is an auto-generated primary key, but the current insertion specifies a value for it.\n     *\n     * @param column\n     */\n    isOverridingAutoIncrementBehavior(column) {\n        return (column.isPrimary &&\n            column.isGenerated &&\n            column.generationStrategy === \"increment\" &&\n            this.getValueSets().some((valueSet) => column.getEntityValue(valueSet) !== undefined &&\n                column.getEntityValue(valueSet) !== null));\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}