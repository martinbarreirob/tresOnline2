{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/practicas/Downloads/angular/tresOnline/frontend-tres-en-raya/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { QueryExpressionMap } from \"./QueryExpressionMap\";\nimport { Brackets } from \"./Brackets\";\nimport { FindOperator } from \"../find-options/FindOperator\";\nimport { In } from \"../find-options/operator/In\";\nimport { TypeORMError } from \"../error\";\nimport { EntityPropertyNotFoundError } from \"../error/EntityPropertyNotFoundError\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\nimport { escapeRegExp } from \"../util/escapeRegExp\";\n// todo: completely cover query builder with tests\n// todo: entityOrProperty can be target name. implement proper behaviour if it is.\n// todo: check in persistment if id exist on object and throw exception (can be in partial selection?)\n// todo: fix problem with long aliases eg getMaxIdentifierLength\n// todo: fix replacing in .select(\"COUNT(post.id) AS cnt\") statement\n// todo: implement joinAlways in relations and relationId\n// todo: finish partial selection\n// todo: sugar methods like: .addCount and .selectCount, selectCountAndMap, selectSum, selectSumAndMap, ...\n// todo: implement @Select decorator\n// todo: add select and map functions\n// todo: implement relation/entity loading and setting them into properties within a separate query\n// .loadAndMap(\"post.categories\", \"post.categories\", qb => ...)\n// .loadAndMap(\"post.categories\", Category, qb => ...)\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\nexport class QueryBuilder {\n  /**\n   * QueryBuilder can be initialized from given Connection and QueryRunner objects or from given other QueryBuilder.\n   */\n  constructor(connectionOrQueryBuilder, queryRunner) {\n    this[\"@instanceof\"] = Symbol.for(\"QueryBuilder\");\n    /**\n     * Memo to help keep place of current parameter index for `createParameter`\n     */\n    this.parameterIndex = 0;\n    if (InstanceChecker.isDataSource(connectionOrQueryBuilder)) {\n      this.connection = connectionOrQueryBuilder;\n      this.queryRunner = queryRunner;\n      this.expressionMap = new QueryExpressionMap(this.connection);\n    } else {\n      this.connection = connectionOrQueryBuilder.connection;\n      this.queryRunner = connectionOrQueryBuilder.queryRunner;\n      this.expressionMap = connectionOrQueryBuilder.expressionMap.clone();\n    }\n  }\n  // -------------------------------------------------------------------------\n  // Accessors\n  // -------------------------------------------------------------------------\n  /**\n   * Gets the main alias string used in this query builder.\n   */\n  get alias() {\n    if (!this.expressionMap.mainAlias) throw new TypeORMError(`Main alias is not set`); // todo: better exception\n    return this.expressionMap.mainAlias.name;\n  }\n  /**\n   * Creates SELECT query and selects given data.\n   * Replaces all previous selections if they exist.\n   */\n  select(selection, selectionAliasName) {\n    this.expressionMap.queryType = \"select\";\n    if (Array.isArray(selection)) {\n      this.expressionMap.selects = selection.map(selection => ({\n        selection: selection\n      }));\n    } else if (selection) {\n      this.expressionMap.selects = [{\n        selection: selection,\n        aliasName: selectionAliasName\n      }];\n    }\n    // loading it dynamically because of circular issue\n    const SelectQueryBuilderCls = require(\"./SelectQueryBuilder\").SelectQueryBuilder;\n    if (InstanceChecker.isSelectQueryBuilder(this)) return this;\n    return new SelectQueryBuilderCls(this);\n  }\n  /**\n   * Creates INSERT query.\n   */\n  insert() {\n    this.expressionMap.queryType = \"insert\";\n    // loading it dynamically because of circular issue\n    const InsertQueryBuilderCls = require(\"./InsertQueryBuilder\").InsertQueryBuilder;\n    if (InstanceChecker.isInsertQueryBuilder(this)) return this;\n    return new InsertQueryBuilderCls(this);\n  }\n  /**\n   * Creates UPDATE query and applies given update values.\n   */\n  update(entityOrTableNameUpdateSet, maybeUpdateSet) {\n    const updateSet = maybeUpdateSet ? maybeUpdateSet : entityOrTableNameUpdateSet;\n    entityOrTableNameUpdateSet = InstanceChecker.isEntitySchema(entityOrTableNameUpdateSet) ? entityOrTableNameUpdateSet.options.name : entityOrTableNameUpdateSet;\n    if (typeof entityOrTableNameUpdateSet === \"function\" || typeof entityOrTableNameUpdateSet === \"string\") {\n      const mainAlias = this.createFromAlias(entityOrTableNameUpdateSet);\n      this.expressionMap.setMainAlias(mainAlias);\n    }\n    this.expressionMap.queryType = \"update\";\n    this.expressionMap.valuesSet = updateSet;\n    // loading it dynamically because of circular issue\n    const UpdateQueryBuilderCls = require(\"./UpdateQueryBuilder\").UpdateQueryBuilder;\n    if (InstanceChecker.isUpdateQueryBuilder(this)) return this;\n    return new UpdateQueryBuilderCls(this);\n  }\n  /**\n   * Creates DELETE query.\n   */\n  delete() {\n    this.expressionMap.queryType = \"delete\";\n    // loading it dynamically because of circular issue\n    const DeleteQueryBuilderCls = require(\"./DeleteQueryBuilder\").DeleteQueryBuilder;\n    if (InstanceChecker.isDeleteQueryBuilder(this)) return this;\n    return new DeleteQueryBuilderCls(this);\n  }\n  softDelete() {\n    this.expressionMap.queryType = \"soft-delete\";\n    // loading it dynamically because of circular issue\n    const SoftDeleteQueryBuilderCls = require(\"./SoftDeleteQueryBuilder\").SoftDeleteQueryBuilder;\n    if (InstanceChecker.isSoftDeleteQueryBuilder(this)) return this;\n    return new SoftDeleteQueryBuilderCls(this);\n  }\n  restore() {\n    this.expressionMap.queryType = \"restore\";\n    // loading it dynamically because of circular issue\n    const SoftDeleteQueryBuilderCls = require(\"./SoftDeleteQueryBuilder\").SoftDeleteQueryBuilder;\n    if (InstanceChecker.isSoftDeleteQueryBuilder(this)) return this;\n    return new SoftDeleteQueryBuilderCls(this);\n  }\n  /**\n   * Sets entity's relation with which this query builder gonna work.\n   */\n  relation(entityTargetOrPropertyPath, maybePropertyPath) {\n    const entityTarget = arguments.length === 2 ? entityTargetOrPropertyPath : undefined;\n    const propertyPath = arguments.length === 2 ? maybePropertyPath : entityTargetOrPropertyPath;\n    this.expressionMap.queryType = \"relation\";\n    this.expressionMap.relationPropertyPath = propertyPath;\n    if (entityTarget) {\n      const mainAlias = this.createFromAlias(entityTarget);\n      this.expressionMap.setMainAlias(mainAlias);\n    }\n    // loading it dynamically because of circular issue\n    const RelationQueryBuilderCls = require(\"./RelationQueryBuilder\").RelationQueryBuilder;\n    if (InstanceChecker.isRelationQueryBuilder(this)) return this;\n    return new RelationQueryBuilderCls(this);\n  }\n  /**\n   * Checks if given relation or relations exist in the entity.\n   * Returns true if relation exists, false otherwise.\n   *\n   * todo: move this method to manager? or create a shortcut?\n   */\n  hasRelation(target, relation) {\n    const entityMetadata = this.connection.getMetadata(target);\n    const relations = Array.isArray(relation) ? relation : [relation];\n    return relations.every(relation => {\n      return !!entityMetadata.findRelationWithPropertyPath(relation);\n    });\n  }\n  /**\n   * Check the existence of a parameter for this query builder.\n   */\n  hasParameter(key) {\n    var _a;\n    return ((_a = this.parentQueryBuilder) === null || _a === void 0 ? void 0 : _a.hasParameter(key)) || key in this.expressionMap.parameters;\n  }\n  /**\n   * Sets parameter name and its value.\n   *\n   * The key for this parameter may contain numbers, letters, underscores, or periods.\n   */\n  setParameter(key, value) {\n    if (typeof value === \"function\") {\n      throw new TypeORMError(`Function parameter isn't supported in the parameters. Please check \"${key}\" parameter.`);\n    }\n    if (!key.match(/^([A-Za-z0-9_.]+)$/)) {\n      throw new TypeORMError(\"QueryBuilder parameter keys may only contain numbers, letters, underscores, or periods.\");\n    }\n    if (this.parentQueryBuilder) {\n      this.parentQueryBuilder.setParameter(key, value);\n    }\n    this.expressionMap.parameters[key] = value;\n    return this;\n  }\n  /**\n   * Adds all parameters from the given object.\n   */\n  setParameters(parameters) {\n    for (const [key, value] of Object.entries(parameters)) {\n      this.setParameter(key, value);\n    }\n    return this;\n  }\n  createParameter(value) {\n    let parameterName;\n    do {\n      parameterName = `orm_param_${this.parameterIndex++}`;\n    } while (this.hasParameter(parameterName));\n    this.setParameter(parameterName, value);\n    return `:${parameterName}`;\n  }\n  /**\n   * Adds native parameters from the given object.\n   *\n   * @deprecated Use `setParameters` instead\n   */\n  setNativeParameters(parameters) {\n    // set parent query builder parameters as well in sub-query mode\n    if (this.parentQueryBuilder) {\n      this.parentQueryBuilder.setNativeParameters(parameters);\n    }\n    Object.keys(parameters).forEach(key => {\n      this.expressionMap.nativeParameters[key] = parameters[key];\n    });\n    return this;\n  }\n  /**\n   * Gets all parameters.\n   */\n  getParameters() {\n    const parameters = Object.assign({}, this.expressionMap.parameters);\n    // add discriminator column parameter if it exist\n    if (this.expressionMap.mainAlias && this.expressionMap.mainAlias.hasMetadata) {\n      const metadata = this.expressionMap.mainAlias.metadata;\n      if (metadata.discriminatorColumn && metadata.parentEntityMetadata) {\n        const values = metadata.childEntityMetadatas.filter(childMetadata => childMetadata.discriminatorColumn).map(childMetadata => childMetadata.discriminatorValue);\n        values.push(metadata.discriminatorValue);\n        parameters[\"discriminatorColumnValues\"] = values;\n      }\n    }\n    return parameters;\n  }\n  /**\n   * Prints sql to stdout using console.log.\n   */\n  printSql() {\n    // TODO rename to logSql()\n    const [query, parameters] = this.getQueryAndParameters();\n    this.connection.logger.logQuery(query, parameters);\n    return this;\n  }\n  /**\n   * Gets generated sql that will be executed.\n   * Parameters in the query are escaped for the currently used driver.\n   */\n  getSql() {\n    return this.getQueryAndParameters()[0];\n  }\n  /**\n   * Gets query to be executed with all parameters used in it.\n   */\n  getQueryAndParameters() {\n    // this execution order is important because getQuery method generates this.expressionMap.nativeParameters values\n    const query = this.getQuery();\n    const parameters = this.getParameters();\n    return this.connection.driver.escapeQueryWithParameters(query, parameters, this.expressionMap.nativeParameters);\n  }\n  /**\n   * Executes sql generated by query builder and returns raw database results.\n   */\n  execute() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const [sql, parameters] = _this.getQueryAndParameters();\n      const queryRunner = _this.obtainQueryRunner();\n      try {\n        return yield queryRunner.query(sql, parameters); // await is needed here because we are using finally\n      } finally {\n        if (queryRunner !== _this.queryRunner) {\n          // means we created our own query runner\n          yield queryRunner.release();\n        }\n      }\n    })();\n  }\n  /**\n   * Creates a completely new query builder.\n   * Uses same query runner as current QueryBuilder.\n   */\n  createQueryBuilder() {\n    return new this.constructor(this.connection, this.queryRunner);\n  }\n  /**\n   * Clones query builder as it is.\n   * Note: it uses new query runner, if you want query builder that uses exactly same query runner,\n   * you can create query builder using its constructor, for example new SelectQueryBuilder(queryBuilder)\n   * where queryBuilder is cloned QueryBuilder.\n   */\n  clone() {\n    return new this.constructor(this);\n  }\n  /**\n   * Includes a Query comment in the query builder.  This is helpful for debugging purposes,\n   * such as finding a specific query in the database server's logs, or for categorization using\n   * an APM product.\n   */\n  comment(comment) {\n    this.expressionMap.comment = comment;\n    return this;\n  }\n  /**\n   * Disables escaping.\n   */\n  disableEscaping() {\n    this.expressionMap.disableEscaping = false;\n    return this;\n  }\n  /**\n   * Escapes table name, column name or alias name using current database's escaping character.\n   */\n  escape(name) {\n    if (!this.expressionMap.disableEscaping) return name;\n    return this.connection.driver.escape(name);\n  }\n  /**\n   * Sets or overrides query builder's QueryRunner.\n   */\n  setQueryRunner(queryRunner) {\n    this.queryRunner = queryRunner;\n    return this;\n  }\n  /**\n   * Indicates if listeners and subscribers must be called before and after query execution.\n   * Enabled by default.\n   */\n  callListeners(enabled) {\n    this.expressionMap.callListeners = enabled;\n    return this;\n  }\n  /**\n   * If set to true the query will be wrapped into a transaction.\n   */\n  useTransaction(enabled) {\n    this.expressionMap.useTransaction = enabled;\n    return this;\n  }\n  /**\n   * Adds CTE to query\n   */\n  addCommonTableExpression(queryBuilder, alias, options) {\n    this.expressionMap.commonTableExpressions.push({\n      queryBuilder,\n      alias,\n      options: options || {}\n    });\n    return this;\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Gets escaped table name with schema name if SqlServer driver used with custom\n   * schema name, otherwise returns escaped table name.\n   */\n  getTableName(tablePath) {\n    return tablePath.split(\".\").map(i => {\n      // this condition need because in SQL Server driver when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string\n      if (i === \"\") return i;\n      return this.escape(i);\n    }).join(\".\");\n  }\n  /**\n   * Gets name of the table where insert should be performed.\n   */\n  getMainTableName() {\n    if (!this.expressionMap.mainAlias) throw new TypeORMError(`Entity where values should be inserted is not specified. Call \"qb.into(entity)\" method to specify it.`);\n    if (this.expressionMap.mainAlias.hasMetadata) return this.expressionMap.mainAlias.metadata.tablePath;\n    return this.expressionMap.mainAlias.tablePath;\n  }\n  /**\n   * Specifies FROM which entity's table select/update/delete will be executed.\n   * Also sets a main string alias of the selection data.\n   */\n  createFromAlias(entityTarget, aliasName) {\n    // if table has a metadata then find it to properly escape its properties\n    // const metadata = this.connection.entityMetadatas.find(metadata => metadata.tableName === tableName);\n    if (this.connection.hasMetadata(entityTarget)) {\n      const metadata = this.connection.getMetadata(entityTarget);\n      return this.expressionMap.createAlias({\n        type: \"from\",\n        name: aliasName,\n        metadata: this.connection.getMetadata(entityTarget),\n        tablePath: metadata.tablePath\n      });\n    } else {\n      if (typeof entityTarget === \"string\") {\n        const isSubquery = entityTarget.substr(0, 1) === \"(\" && entityTarget.substr(-1) === \")\";\n        return this.expressionMap.createAlias({\n          type: \"from\",\n          name: aliasName,\n          tablePath: !isSubquery ? entityTarget : undefined,\n          subQuery: isSubquery ? entityTarget : undefined\n        });\n      }\n      const subQueryBuilder = entityTarget(this.subQuery());\n      this.setParameters(subQueryBuilder.getParameters());\n      const subquery = subQueryBuilder.getQuery();\n      return this.expressionMap.createAlias({\n        type: \"from\",\n        name: aliasName,\n        subQuery: subquery\n      });\n    }\n  }\n  /**\n   * @deprecated this way of replace property names is too slow.\n   *  Instead, we'll replace property names at the end - once query is build.\n   */\n  replacePropertyNames(statement) {\n    return statement;\n  }\n  /**\n   * Replaces all entity's propertyName to name in the given SQL string.\n   */\n  replacePropertyNamesForTheWholeQuery(statement) {\n    const replacements = {};\n    for (const alias of this.expressionMap.aliases) {\n      if (!alias.hasMetadata) continue;\n      const replaceAliasNamePrefix = this.expressionMap.aliasNamePrefixingEnabled && alias.name ? `${alias.name}.` : \"\";\n      if (!replacements[replaceAliasNamePrefix]) {\n        replacements[replaceAliasNamePrefix] = {};\n      }\n      // Insert & overwrite the replacements from least to most relevant in our replacements object.\n      // To do this we iterate and overwrite in the order of relevance.\n      // Least to Most Relevant:\n      // * Relation Property Path to first join column key\n      // * Relation Property Path + Column Path\n      // * Column Database Name\n      // * Column Property Name\n      // * Column Property Path\n      for (const relation of alias.metadata.relations) {\n        if (relation.joinColumns.length > 0) replacements[replaceAliasNamePrefix][relation.propertyPath] = relation.joinColumns[0].databaseName;\n      }\n      for (const relation of alias.metadata.relations) {\n        const allColumns = [...relation.joinColumns, ...relation.inverseJoinColumns];\n        for (const joinColumn of allColumns) {\n          const propertyKey = `${relation.propertyPath}.${joinColumn.referencedColumn.propertyPath}`;\n          replacements[replaceAliasNamePrefix][propertyKey] = joinColumn.databaseName;\n        }\n      }\n      for (const column of alias.metadata.columns) {\n        replacements[replaceAliasNamePrefix][column.databaseName] = column.databaseName;\n      }\n      for (const column of alias.metadata.columns) {\n        replacements[replaceAliasNamePrefix][column.propertyName] = column.databaseName;\n      }\n      for (const column of alias.metadata.columns) {\n        replacements[replaceAliasNamePrefix][column.propertyPath] = column.databaseName;\n      }\n    }\n    const replacementKeys = Object.keys(replacements);\n    const replaceAliasNamePrefixes = replacementKeys.map(key => escapeRegExp(key)).join(\"|\");\n    if (replacementKeys.length > 0) {\n      statement = statement.replace(new RegExp(\n      // Avoid a lookbehind here since it's not well supported\n      `([ =\\(]|^.{0})` +\n      // any of ' =(' or start of line\n      // followed by our prefix, e.g. 'tablename.' or ''\n      `${replaceAliasNamePrefixes ? \"(\" + replaceAliasNamePrefixes + \")\" : \"\"}([^ =\\(\\)\\,]+)` +\n      // a possible property name: sequence of anything but ' =(),'\n      // terminated by ' =),' or end of line\n      `(?=[ =\\)\\,]|.{0}$)`, \"gm\"), (...matches) => {\n        let match, pre, p;\n        if (replaceAliasNamePrefixes) {\n          match = matches[0];\n          pre = matches[1];\n          p = matches[3];\n          if (replacements[matches[2]][p]) {\n            return `${pre}${this.escape(matches[2].substring(0, matches[2].length - 1))}.${this.escape(replacements[matches[2]][p])}`;\n          }\n        } else {\n          match = matches[0];\n          pre = matches[1];\n          p = matches[2];\n          if (replacements[\"\"][p]) {\n            return `${pre}${this.escape(replacements[\"\"][p])}`;\n          }\n        }\n        return match;\n      });\n    }\n    return statement;\n  }\n  createComment() {\n    if (!this.expressionMap.comment) {\n      return \"\";\n    }\n    // ANSI SQL 2003 support C style comments - comments that start with `/*` and end with `*/`\n    // In some dialects query nesting is available - but not all.  Because of this, we'll need\n    // to scrub \"ending\" characters from the SQL but otherwise we can leave everything else\n    // as-is and it should be valid.\n    return `/* ${this.expressionMap.comment.replace(\"*/\", \"\")} */ `;\n  }\n  /**\n   * Time travel queries for CockroachDB\n   */\n  createTimeTravelQuery() {\n    if (this.expressionMap.queryType === \"select\" && this.expressionMap.timeTravel) {\n      return ` AS OF SYSTEM TIME ${this.expressionMap.timeTravel}`;\n    }\n    return \"\";\n  }\n  /**\n   * Creates \"WHERE\" expression.\n   */\n  createWhereExpression() {\n    const conditionsArray = [];\n    const whereExpression = this.createWhereClausesExpression(this.expressionMap.wheres);\n    if (whereExpression.length > 0 && whereExpression !== \"1=1\") {\n      conditionsArray.push(this.replacePropertyNames(whereExpression));\n    }\n    if (this.expressionMap.mainAlias.hasMetadata) {\n      const metadata = this.expressionMap.mainAlias.metadata;\n      // Adds the global condition of \"non-deleted\" for the entity with delete date columns in select query.\n      if (this.expressionMap.queryType === \"select\" && !this.expressionMap.withDeleted && metadata.deleteDateColumn) {\n        const column = this.expressionMap.aliasNamePrefixingEnabled ? this.expressionMap.mainAlias.name + \".\" + metadata.deleteDateColumn.propertyName : metadata.deleteDateColumn.propertyName;\n        const condition = `${this.replacePropertyNames(column)} IS NULL`;\n        conditionsArray.push(condition);\n      }\n      if (metadata.discriminatorColumn && metadata.parentEntityMetadata) {\n        const column = this.expressionMap.aliasNamePrefixingEnabled ? this.expressionMap.mainAlias.name + \".\" + metadata.discriminatorColumn.databaseName : metadata.discriminatorColumn.databaseName;\n        const condition = `${this.replacePropertyNames(column)} IN (:...discriminatorColumnValues)`;\n        conditionsArray.push(condition);\n      }\n    }\n    if (this.expressionMap.extraAppendedAndWhereCondition) {\n      const condition = this.replacePropertyNames(this.expressionMap.extraAppendedAndWhereCondition);\n      conditionsArray.push(condition);\n    }\n    let condition = \"\";\n    // time travel\n    condition += this.createTimeTravelQuery();\n    if (!conditionsArray.length) {\n      condition += \"\";\n    } else if (conditionsArray.length === 1) {\n      condition += ` WHERE ${conditionsArray[0]}`;\n    } else {\n      condition += ` WHERE ( ${conditionsArray.join(\" ) AND ( \")} )`;\n    }\n    return condition;\n  }\n  /**\n   * Creates \"RETURNING\" / \"OUTPUT\" expression.\n   */\n  createReturningExpression(returningType) {\n    const columns = this.getReturningColumns();\n    const driver = this.connection.driver;\n    // also add columns we must auto-return to perform entity updation\n    // if user gave his own returning\n    if (typeof this.expressionMap.returning !== \"string\" && this.expressionMap.extraReturningColumns.length > 0 && driver.isReturningSqlSupported(returningType)) {\n      columns.push(...this.expressionMap.extraReturningColumns.filter(column => {\n        return columns.indexOf(column) === -1;\n      }));\n    }\n    if (columns.length) {\n      let columnsExpression = columns.map(column => {\n        const name = this.escape(column.databaseName);\n        if (driver.options.type === \"mssql\") {\n          if (this.expressionMap.queryType === \"insert\" || this.expressionMap.queryType === \"update\" || this.expressionMap.queryType === \"soft-delete\" || this.expressionMap.queryType === \"restore\") {\n            return \"INSERTED.\" + name;\n          } else {\n            return this.escape(this.getMainTableName()) + \".\" + name;\n          }\n        } else {\n          return name;\n        }\n      }).join(\", \");\n      if (driver.options.type === \"oracle\") {\n        columnsExpression += \" INTO \" + columns.map(column => {\n          return this.createParameter({\n            type: driver.columnTypeToNativeParameter(column.type),\n            dir: driver.oracle.BIND_OUT\n          });\n        }).join(\", \");\n      }\n      if (driver.options.type === \"mssql\") {\n        if (this.expressionMap.queryType === \"insert\" || this.expressionMap.queryType === \"update\") {\n          columnsExpression += \" INTO @OutputTable\";\n        }\n      }\n      return columnsExpression;\n    } else if (typeof this.expressionMap.returning === \"string\") {\n      return this.expressionMap.returning;\n    }\n    return \"\";\n  }\n  /**\n   * If returning / output cause is set to array of column names,\n   * then this method will return all column metadatas of those column names.\n   */\n  getReturningColumns() {\n    const columns = [];\n    if (Array.isArray(this.expressionMap.returning)) {\n      ;\n      this.expressionMap.returning.forEach(columnName => {\n        if (this.expressionMap.mainAlias.hasMetadata) {\n          columns.push(...this.expressionMap.mainAlias.metadata.findColumnsWithPropertyPath(columnName));\n        }\n      });\n    }\n    return columns;\n  }\n  createWhereClausesExpression(clauses) {\n    return clauses.map((clause, index) => {\n      const expression = this.createWhereConditionExpression(clause.condition);\n      switch (clause.type) {\n        case \"and\":\n          return (index > 0 ? \"AND \" : \"\") + expression;\n        case \"or\":\n          return (index > 0 ? \"OR \" : \"\") + expression;\n      }\n      return expression;\n    }).join(\" \").trim();\n  }\n  /**\n   * Computes given where argument - transforms to a where string all forms it can take.\n   */\n  createWhereConditionExpression(condition, alwaysWrap = false) {\n    if (typeof condition === \"string\") return condition;\n    if (Array.isArray(condition)) {\n      if (condition.length === 0) {\n        return \"1=1\";\n      }\n      // In the future we should probably remove this entire condition\n      // but for now to prevent any breaking changes it exists.\n      if (condition.length === 1 && !alwaysWrap) {\n        return this.createWhereClausesExpression(condition);\n      }\n      return \"(\" + this.createWhereClausesExpression(condition) + \")\";\n    }\n    const {\n      driver\n    } = this.connection;\n    switch (condition.operator) {\n      case \"lessThan\":\n        return `${condition.parameters[0]} < ${condition.parameters[1]}`;\n      case \"lessThanOrEqual\":\n        return `${condition.parameters[0]} <= ${condition.parameters[1]}`;\n      case \"arrayContains\":\n        return `${condition.parameters[0]} @> ${condition.parameters[1]}`;\n      case \"jsonContains\":\n        return `${condition.parameters[0]} ::jsonb @> ${condition.parameters[1]}`;\n      case \"arrayContainedBy\":\n        return `${condition.parameters[0]} <@ ${condition.parameters[1]}`;\n      case \"arrayOverlap\":\n        return `${condition.parameters[0]} && ${condition.parameters[1]}`;\n      case \"moreThan\":\n        return `${condition.parameters[0]} > ${condition.parameters[1]}`;\n      case \"moreThanOrEqual\":\n        return `${condition.parameters[0]} >= ${condition.parameters[1]}`;\n      case \"notEqual\":\n        return `${condition.parameters[0]} != ${condition.parameters[1]}`;\n      case \"equal\":\n        return `${condition.parameters[0]} = ${condition.parameters[1]}`;\n      case \"ilike\":\n        if (driver.options.type === \"postgres\" || driver.options.type === \"cockroachdb\") {\n          return `${condition.parameters[0]} ILIKE ${condition.parameters[1]}`;\n        }\n        return `UPPER(${condition.parameters[0]}) LIKE UPPER(${condition.parameters[1]})`;\n      case \"like\":\n        return `${condition.parameters[0]} LIKE ${condition.parameters[1]}`;\n      case \"between\":\n        return `${condition.parameters[0]} BETWEEN ${condition.parameters[1]} AND ${condition.parameters[2]}`;\n      case \"in\":\n        if (condition.parameters.length <= 1) {\n          return \"0=1\";\n        }\n        return `${condition.parameters[0]} IN (${condition.parameters.slice(1).join(\", \")})`;\n      case \"any\":\n        if (driver.options.type === \"cockroachdb\") {\n          return `${condition.parameters[0]}::STRING = ANY(${condition.parameters[1]}::STRING[])`;\n        }\n        return `${condition.parameters[0]} = ANY(${condition.parameters[1]})`;\n      case \"isNull\":\n        return `${condition.parameters[0]} IS NULL`;\n      case \"not\":\n        return `NOT(${this.createWhereConditionExpression(condition.condition)})`;\n      case \"brackets\":\n        return `${this.createWhereConditionExpression(condition.condition, true)}`;\n      case \"and\":\n        return condition.parameters.join(\" AND \");\n    }\n    throw new TypeError(`Unsupported FindOperator ${FindOperator.constructor.name}`);\n  }\n  createCteExpression() {\n    if (!this.hasCommonTableExpressions()) {\n      return \"\";\n    }\n    const databaseRequireRecusiveHint = this.connection.driver.cteCapabilities.requiresRecursiveHint;\n    const cteStrings = this.expressionMap.commonTableExpressions.map(cte => {\n      const cteBodyExpression = typeof cte.queryBuilder === \"string\" ? cte.queryBuilder : cte.queryBuilder.getQuery();\n      if (typeof cte.queryBuilder !== \"string\") {\n        if (cte.queryBuilder.hasCommonTableExpressions()) {\n          throw new TypeORMError(`Nested CTEs aren't supported (CTE: ${cte.alias})`);\n        }\n        if (!this.connection.driver.cteCapabilities.writable && !InstanceChecker.isSelectQueryBuilder(cte.queryBuilder)) {\n          throw new TypeORMError(`Only select queries are supported in CTEs in ${this.connection.options.type} (CTE: ${cte.alias})`);\n        }\n        this.setParameters(cte.queryBuilder.getParameters());\n      }\n      let cteHeader = this.escape(cte.alias);\n      if (cte.options.columnNames) {\n        const escapedColumnNames = cte.options.columnNames.map(column => this.escape(column));\n        if (InstanceChecker.isSelectQueryBuilder(cte.queryBuilder)) {\n          if (cte.queryBuilder.expressionMap.selects.length && cte.options.columnNames.length !== cte.queryBuilder.expressionMap.selects.length) {\n            throw new TypeORMError(`cte.options.columnNames length (${cte.options.columnNames.length}) doesn't match subquery select list length ${cte.queryBuilder.expressionMap.selects.length} (CTE: ${cte.alias})`);\n          }\n        }\n        cteHeader += `(${escapedColumnNames.join(\", \")})`;\n      }\n      const recursiveClause = cte.options.recursive && databaseRequireRecusiveHint ? \"RECURSIVE\" : \"\";\n      let materializeClause = \"\";\n      if (this.connection.driver.cteCapabilities.materializedHint && cte.options.materialized !== undefined) {\n        materializeClause = cte.options.materialized ? \"MATERIALIZED\" : \"NOT MATERIALIZED\";\n      }\n      return [recursiveClause, cteHeader, \"AS\", materializeClause, `(${cteBodyExpression})`].filter(Boolean).join(\" \");\n    });\n    return \"WITH \" + cteStrings.join(\", \") + \" \";\n  }\n  /**\n   * Creates \"WHERE\" condition for an in-ids condition.\n   */\n  getWhereInIdsCondition(ids) {\n    const metadata = this.expressionMap.mainAlias.metadata;\n    const normalized = (Array.isArray(ids) ? ids : [ids]).map(id => metadata.ensureEntityIdMap(id));\n    // using in(...ids) for single primary key entities\n    if (!metadata.hasMultiplePrimaryKeys) {\n      const primaryColumn = metadata.primaryColumns[0];\n      // getEntityValue will try to transform `In`, it is a bug\n      // todo: remove this transformer check after #2390 is fixed\n      // This also fails for embedded & relation, so until that is fixed skip it.\n      if (!primaryColumn.transformer && !primaryColumn.relationMetadata && !primaryColumn.embeddedMetadata) {\n        return {\n          [primaryColumn.propertyName]: In(normalized.map(id => primaryColumn.getEntityValue(id, false)))\n        };\n      }\n    }\n    return new Brackets(qb => {\n      for (const data of normalized) {\n        qb.orWhere(new Brackets(qb => qb.where(data)));\n      }\n    });\n  }\n  getExistsCondition(subQuery) {\n    const query = subQuery.clone().orderBy().groupBy().offset(undefined).limit(undefined).skip(undefined).take(undefined).select(\"1\").setOption(\"disable-global-order\");\n    return [`EXISTS (${query.getQuery()})`, query.getParameters()];\n  }\n  findColumnsForPropertyPath(propertyPath) {\n    // Make a helper to iterate the entity & relations?\n    // Use that to set the correct alias?  Or the other way around?\n    // Start with the main alias with our property paths\n    let alias = this.expressionMap.mainAlias;\n    const root = [];\n    const propertyPathParts = propertyPath.split(\".\");\n    while (propertyPathParts.length > 1) {\n      const part = propertyPathParts[0];\n      if (!(alias === null || alias === void 0 ? void 0 : alias.hasMetadata)) {\n        // If there's no metadata, we're wasting our time\n        // and can't actually look any of this up.\n        break;\n      }\n      if (alias.metadata.hasEmbeddedWithPropertyPath(part)) {\n        // If this is an embedded then we should combine the two as part of our lookup.\n        // Instead of just breaking, we keep going with this in case there's an embedded/relation\n        // inside an embedded.\n        propertyPathParts.unshift(`${propertyPathParts.shift()}.${propertyPathParts.shift()}`);\n        continue;\n      }\n      if (alias.metadata.hasRelationWithPropertyPath(part)) {\n        // If this is a relation then we should find the aliases\n        // that match the relation & then continue further down\n        // the property path\n        const joinAttr = this.expressionMap.joinAttributes.find(joinAttr => joinAttr.relationPropertyPath === part);\n        if (!(joinAttr === null || joinAttr === void 0 ? void 0 : joinAttr.alias)) {\n          const fullRelationPath = root.length > 0 ? `${root.join(\".\")}.${part}` : part;\n          throw new Error(`Cannot find alias for relation at ${fullRelationPath}`);\n        }\n        alias = joinAttr.alias;\n        root.push(...part.split(\".\"));\n        propertyPathParts.shift();\n        continue;\n      }\n      break;\n    }\n    if (!alias) {\n      throw new Error(`Cannot find alias for property ${propertyPath}`);\n    }\n    // Remaining parts are combined back and used to find the actual property path\n    const aliasPropertyPath = propertyPathParts.join(\".\");\n    const columns = alias.metadata.findColumnsWithPropertyPath(aliasPropertyPath);\n    if (!columns.length) {\n      throw new EntityPropertyNotFoundError(propertyPath, alias.metadata);\n    }\n    return [alias, root, columns];\n  }\n  /**\n   * Creates a property paths for a given ObjectLiteral.\n   */\n  createPropertyPath(metadata, entity, prefix = \"\") {\n    const paths = [];\n    for (const key of Object.keys(entity)) {\n      const path = prefix ? `${prefix}.${key}` : key;\n      // There's times where we don't actually want to traverse deeper.\n      // If the value is a `FindOperator`, or null, or not an object, then we don't, for example.\n      if (entity[key] === null || typeof entity[key] !== \"object\" || InstanceChecker.isFindOperator(entity[key])) {\n        paths.push(path);\n        continue;\n      }\n      if (metadata.hasEmbeddedWithPropertyPath(path)) {\n        const subPaths = this.createPropertyPath(metadata, entity[key], path);\n        paths.push(...subPaths);\n        continue;\n      }\n      if (metadata.hasRelationWithPropertyPath(path)) {\n        const relation = metadata.findRelationWithPropertyPath(path);\n        // There's also cases where we don't want to return back all of the properties.\n        // These handles the situation where someone passes the model & we don't need to make\n        // a HUGE `where` to uniquely look up the entity.\n        // In the case of a *-to-one, there's only ever one possible entity on the other side\n        // so if the join columns are all defined we can return just the relation itself\n        // because it will fetch only the join columns and do the lookup.\n        if (relation.relationType === \"one-to-one\" || relation.relationType === \"many-to-one\") {\n          const joinColumns = relation.joinColumns.map(j => j.referencedColumn).filter(j => !!j);\n          const hasAllJoinColumns = joinColumns.length > 0 && joinColumns.every(column => column.getEntityValue(entity[key], false));\n          if (hasAllJoinColumns) {\n            paths.push(path);\n            continue;\n          }\n        }\n        if (relation.relationType === \"one-to-many\" || relation.relationType === \"many-to-many\") {\n          throw new Error(`Cannot query across ${relation.relationType} for property ${path}`);\n        }\n        // For any other case, if the `entity[key]` contains all of the primary keys we can do a\n        // lookup via these.  We don't need to look up via any other values 'cause these are\n        // the unique primary keys.\n        // This handles the situation where someone passes the model & we don't need to make\n        // a HUGE where.\n        const primaryColumns = relation.inverseEntityMetadata.primaryColumns;\n        const hasAllPrimaryKeys = primaryColumns.length > 0 && primaryColumns.every(column => column.getEntityValue(entity[key], false));\n        if (hasAllPrimaryKeys) {\n          const subPaths = primaryColumns.map(column => `${path}.${column.propertyPath}`);\n          paths.push(...subPaths);\n          continue;\n        }\n        // If nothing else, just return every property that's being passed to us.\n        const subPaths = this.createPropertyPath(relation.inverseEntityMetadata, entity[key]).map(p => `${path}.${p}`);\n        paths.push(...subPaths);\n        continue;\n      }\n      paths.push(path);\n    }\n    return paths;\n  }\n  *getPredicates(where) {\n    if (this.expressionMap.mainAlias.hasMetadata) {\n      const propertyPaths = this.createPropertyPath(this.expressionMap.mainAlias.metadata, where);\n      for (const propertyPath of propertyPaths) {\n        const [alias, aliasPropertyPath, columns] = this.findColumnsForPropertyPath(propertyPath);\n        for (const column of columns) {\n          let containedWhere = where;\n          for (const part of aliasPropertyPath) {\n            if (!containedWhere || !(part in containedWhere)) {\n              containedWhere = {};\n              break;\n            }\n            containedWhere = containedWhere[part];\n          }\n          // Use the correct alias & the property path from the column\n          const aliasPath = this.expressionMap.aliasNamePrefixingEnabled ? `${alias.name}.${column.propertyPath}` : column.propertyPath;\n          const parameterValue = column.getEntityValue(containedWhere, true);\n          yield [aliasPath, parameterValue];\n        }\n      }\n    } else {\n      for (const key of Object.keys(where)) {\n        const parameterValue = where[key];\n        const aliasPath = this.expressionMap.aliasNamePrefixingEnabled ? `${this.alias}.${key}` : key;\n        yield [aliasPath, parameterValue];\n      }\n    }\n  }\n  getWherePredicateCondition(aliasPath, parameterValue) {\n    if (InstanceChecker.isFindOperator(parameterValue)) {\n      let parameters = [];\n      if (parameterValue.useParameter) {\n        if (parameterValue.objectLiteralParameters) {\n          this.setParameters(parameterValue.objectLiteralParameters);\n        } else if (parameterValue.multipleParameters) {\n          for (const v of parameterValue.value) {\n            parameters.push(this.createParameter(v));\n          }\n        } else {\n          parameters.push(this.createParameter(parameterValue.value));\n        }\n      }\n      if (parameterValue.type === \"raw\") {\n        if (parameterValue.getSql) {\n          return parameterValue.getSql(aliasPath);\n        } else {\n          return {\n            operator: \"equal\",\n            parameters: [aliasPath, parameterValue.value]\n          };\n        }\n      } else if (parameterValue.type === \"not\") {\n        if (parameterValue.child) {\n          return {\n            operator: parameterValue.type,\n            condition: this.getWherePredicateCondition(aliasPath, parameterValue.child)\n          };\n        } else {\n          return {\n            operator: \"notEqual\",\n            parameters: [aliasPath, ...parameters]\n          };\n        }\n      } else if (parameterValue.type === \"and\") {\n        const values = parameterValue.value;\n        return {\n          operator: parameterValue.type,\n          parameters: values.map(operator => this.createWhereConditionExpression(this.getWherePredicateCondition(aliasPath, operator)))\n        };\n      } else {\n        return {\n          operator: parameterValue.type,\n          parameters: [aliasPath, ...parameters]\n        };\n      }\n      // } else if (parameterValue === null) {\n      //     return {\n      //         operator: \"isNull\",\n      //         parameters: [\n      //             aliasPath,\n      //         ]\n      //     };\n    } else {\n      return {\n        operator: \"equal\",\n        parameters: [aliasPath, this.createParameter(parameterValue)]\n      };\n    }\n  }\n  getWhereCondition(where) {\n    if (typeof where === \"string\") {\n      return where;\n    }\n    if (InstanceChecker.isBrackets(where)) {\n      const whereQueryBuilder = this.createQueryBuilder();\n      whereQueryBuilder.parentQueryBuilder = this;\n      whereQueryBuilder.expressionMap.mainAlias = this.expressionMap.mainAlias;\n      whereQueryBuilder.expressionMap.aliasNamePrefixingEnabled = this.expressionMap.aliasNamePrefixingEnabled;\n      whereQueryBuilder.expressionMap.parameters = this.expressionMap.parameters;\n      whereQueryBuilder.expressionMap.nativeParameters = this.expressionMap.nativeParameters;\n      whereQueryBuilder.expressionMap.wheres = [];\n      where.whereFactory(whereQueryBuilder);\n      return {\n        operator: InstanceChecker.isNotBrackets(where) ? \"not\" : \"brackets\",\n        condition: whereQueryBuilder.expressionMap.wheres\n      };\n    }\n    if (typeof where === \"function\") {\n      return where(this);\n    }\n    const wheres = Array.isArray(where) ? where : [where];\n    const clauses = [];\n    for (const where of wheres) {\n      const conditions = [];\n      // Filter the conditions and set up the parameter values\n      for (const [aliasPath, parameterValue] of this.getPredicates(where)) {\n        conditions.push({\n          type: \"and\",\n          condition: this.getWherePredicateCondition(aliasPath, parameterValue)\n        });\n      }\n      clauses.push({\n        type: \"or\",\n        condition: conditions\n      });\n    }\n    if (clauses.length === 1) {\n      return clauses[0].condition;\n    }\n    return clauses;\n  }\n  /**\n   * Creates a query builder used to execute sql queries inside this query builder.\n   */\n  obtainQueryRunner() {\n    return this.queryRunner || this.connection.createQueryRunner();\n  }\n  hasCommonTableExpressions() {\n    return this.expressionMap.commonTableExpressions.length > 0;\n  }\n}","map":{"version":3,"names":["QueryExpressionMap","Brackets","FindOperator","In","TypeORMError","EntityPropertyNotFoundError","InstanceChecker","escapeRegExp","QueryBuilder","constructor","connectionOrQueryBuilder","queryRunner","Symbol","for","parameterIndex","isDataSource","connection","expressionMap","clone","alias","mainAlias","name","select","selection","selectionAliasName","queryType","Array","isArray","selects","map","aliasName","SelectQueryBuilderCls","require","SelectQueryBuilder","isSelectQueryBuilder","insert","InsertQueryBuilderCls","InsertQueryBuilder","isInsertQueryBuilder","update","entityOrTableNameUpdateSet","maybeUpdateSet","updateSet","isEntitySchema","options","createFromAlias","setMainAlias","valuesSet","UpdateQueryBuilderCls","UpdateQueryBuilder","isUpdateQueryBuilder","delete","DeleteQueryBuilderCls","DeleteQueryBuilder","isDeleteQueryBuilder","softDelete","SoftDeleteQueryBuilderCls","SoftDeleteQueryBuilder","isSoftDeleteQueryBuilder","restore","relation","entityTargetOrPropertyPath","maybePropertyPath","entityTarget","arguments","length","undefined","propertyPath","relationPropertyPath","RelationQueryBuilderCls","RelationQueryBuilder","isRelationQueryBuilder","hasRelation","target","entityMetadata","getMetadata","relations","every","findRelationWithPropertyPath","hasParameter","key","_a","parentQueryBuilder","parameters","setParameter","value","match","setParameters","Object","entries","createParameter","parameterName","setNativeParameters","keys","forEach","nativeParameters","getParameters","assign","hasMetadata","metadata","discriminatorColumn","parentEntityMetadata","values","childEntityMetadatas","filter","childMetadata","discriminatorValue","push","printSql","query","getQueryAndParameters","logger","logQuery","getSql","getQuery","driver","escapeQueryWithParameters","execute","_this","_asyncToGenerator","sql","obtainQueryRunner","release","createQueryBuilder","comment","disableEscaping","escape","setQueryRunner","callListeners","enabled","useTransaction","addCommonTableExpression","queryBuilder","commonTableExpressions","getTableName","tablePath","split","i","join","getMainTableName","createAlias","type","isSubquery","substr","subQuery","subQueryBuilder","subquery","replacePropertyNames","statement","replacePropertyNamesForTheWholeQuery","replacements","aliases","replaceAliasNamePrefix","aliasNamePrefixingEnabled","joinColumns","databaseName","allColumns","inverseJoinColumns","joinColumn","propertyKey","referencedColumn","column","columns","propertyName","replacementKeys","replaceAliasNamePrefixes","replace","RegExp","matches","pre","p","substring","createComment","createTimeTravelQuery","timeTravel","createWhereExpression","conditionsArray","whereExpression","createWhereClausesExpression","wheres","withDeleted","deleteDateColumn","condition","extraAppendedAndWhereCondition","createReturningExpression","returningType","getReturningColumns","returning","extraReturningColumns","isReturningSqlSupported","indexOf","columnsExpression","columnTypeToNativeParameter","dir","oracle","BIND_OUT","columnName","findColumnsWithPropertyPath","clauses","clause","index","expression","createWhereConditionExpression","trim","alwaysWrap","operator","slice","TypeError","createCteExpression","hasCommonTableExpressions","databaseRequireRecusiveHint","cteCapabilities","requiresRecursiveHint","cteStrings","cte","cteBodyExpression","writable","cteHeader","columnNames","escapedColumnNames","recursiveClause","recursive","materializeClause","materializedHint","materialized","Boolean","getWhereInIdsCondition","ids","normalized","id","ensureEntityIdMap","hasMultiplePrimaryKeys","primaryColumn","primaryColumns","transformer","relationMetadata","embeddedMetadata","getEntityValue","qb","data","orWhere","where","getExistsCondition","orderBy","groupBy","offset","limit","skip","take","setOption","findColumnsForPropertyPath","root","propertyPathParts","part","hasEmbeddedWithPropertyPath","unshift","shift","hasRelationWithPropertyPath","joinAttr","joinAttributes","find","fullRelationPath","Error","aliasPropertyPath","createPropertyPath","entity","prefix","paths","path","isFindOperator","subPaths","relationType","j","hasAllJoinColumns","inverseEntityMetadata","hasAllPrimaryKeys","getPredicates","propertyPaths","containedWhere","aliasPath","parameterValue","getWherePredicateCondition","useParameter","objectLiteralParameters","multipleParameters","v","child","getWhereCondition","isBrackets","whereQueryBuilder","whereFactory","isNotBrackets","conditions","createQueryRunner"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/query-builder/QueryBuilder.js"],"sourcesContent":["import { QueryExpressionMap } from \"./QueryExpressionMap\";\nimport { Brackets } from \"./Brackets\";\nimport { FindOperator } from \"../find-options/FindOperator\";\nimport { In } from \"../find-options/operator/In\";\nimport { TypeORMError } from \"../error\";\nimport { EntityPropertyNotFoundError } from \"../error/EntityPropertyNotFoundError\";\nimport { InstanceChecker } from \"../util/InstanceChecker\";\nimport { escapeRegExp } from \"../util/escapeRegExp\";\n// todo: completely cover query builder with tests\n// todo: entityOrProperty can be target name. implement proper behaviour if it is.\n// todo: check in persistment if id exist on object and throw exception (can be in partial selection?)\n// todo: fix problem with long aliases eg getMaxIdentifierLength\n// todo: fix replacing in .select(\"COUNT(post.id) AS cnt\") statement\n// todo: implement joinAlways in relations and relationId\n// todo: finish partial selection\n// todo: sugar methods like: .addCount and .selectCount, selectCountAndMap, selectSum, selectSumAndMap, ...\n// todo: implement @Select decorator\n// todo: add select and map functions\n// todo: implement relation/entity loading and setting them into properties within a separate query\n// .loadAndMap(\"post.categories\", \"post.categories\", qb => ...)\n// .loadAndMap(\"post.categories\", Category, qb => ...)\n/**\n * Allows to build complex sql queries in a fashion way and execute those queries.\n */\nexport class QueryBuilder {\n    /**\n     * QueryBuilder can be initialized from given Connection and QueryRunner objects or from given other QueryBuilder.\n     */\n    constructor(connectionOrQueryBuilder, queryRunner) {\n        this[\"@instanceof\"] = Symbol.for(\"QueryBuilder\");\n        /**\n         * Memo to help keep place of current parameter index for `createParameter`\n         */\n        this.parameterIndex = 0;\n        if (InstanceChecker.isDataSource(connectionOrQueryBuilder)) {\n            this.connection = connectionOrQueryBuilder;\n            this.queryRunner = queryRunner;\n            this.expressionMap = new QueryExpressionMap(this.connection);\n        }\n        else {\n            this.connection = connectionOrQueryBuilder.connection;\n            this.queryRunner = connectionOrQueryBuilder.queryRunner;\n            this.expressionMap = connectionOrQueryBuilder.expressionMap.clone();\n        }\n    }\n    // -------------------------------------------------------------------------\n    // Accessors\n    // -------------------------------------------------------------------------\n    /**\n     * Gets the main alias string used in this query builder.\n     */\n    get alias() {\n        if (!this.expressionMap.mainAlias)\n            throw new TypeORMError(`Main alias is not set`); // todo: better exception\n        return this.expressionMap.mainAlias.name;\n    }\n    /**\n     * Creates SELECT query and selects given data.\n     * Replaces all previous selections if they exist.\n     */\n    select(selection, selectionAliasName) {\n        this.expressionMap.queryType = \"select\";\n        if (Array.isArray(selection)) {\n            this.expressionMap.selects = selection.map((selection) => ({\n                selection: selection,\n            }));\n        }\n        else if (selection) {\n            this.expressionMap.selects = [\n                { selection: selection, aliasName: selectionAliasName },\n            ];\n        }\n        // loading it dynamically because of circular issue\n        const SelectQueryBuilderCls = require(\"./SelectQueryBuilder\").SelectQueryBuilder;\n        if (InstanceChecker.isSelectQueryBuilder(this))\n            return this;\n        return new SelectQueryBuilderCls(this);\n    }\n    /**\n     * Creates INSERT query.\n     */\n    insert() {\n        this.expressionMap.queryType = \"insert\";\n        // loading it dynamically because of circular issue\n        const InsertQueryBuilderCls = require(\"./InsertQueryBuilder\").InsertQueryBuilder;\n        if (InstanceChecker.isInsertQueryBuilder(this))\n            return this;\n        return new InsertQueryBuilderCls(this);\n    }\n    /**\n     * Creates UPDATE query and applies given update values.\n     */\n    update(entityOrTableNameUpdateSet, maybeUpdateSet) {\n        const updateSet = maybeUpdateSet\n            ? maybeUpdateSet\n            : entityOrTableNameUpdateSet;\n        entityOrTableNameUpdateSet = InstanceChecker.isEntitySchema(entityOrTableNameUpdateSet)\n            ? entityOrTableNameUpdateSet.options.name\n            : entityOrTableNameUpdateSet;\n        if (typeof entityOrTableNameUpdateSet === \"function\" ||\n            typeof entityOrTableNameUpdateSet === \"string\") {\n            const mainAlias = this.createFromAlias(entityOrTableNameUpdateSet);\n            this.expressionMap.setMainAlias(mainAlias);\n        }\n        this.expressionMap.queryType = \"update\";\n        this.expressionMap.valuesSet = updateSet;\n        // loading it dynamically because of circular issue\n        const UpdateQueryBuilderCls = require(\"./UpdateQueryBuilder\").UpdateQueryBuilder;\n        if (InstanceChecker.isUpdateQueryBuilder(this))\n            return this;\n        return new UpdateQueryBuilderCls(this);\n    }\n    /**\n     * Creates DELETE query.\n     */\n    delete() {\n        this.expressionMap.queryType = \"delete\";\n        // loading it dynamically because of circular issue\n        const DeleteQueryBuilderCls = require(\"./DeleteQueryBuilder\").DeleteQueryBuilder;\n        if (InstanceChecker.isDeleteQueryBuilder(this))\n            return this;\n        return new DeleteQueryBuilderCls(this);\n    }\n    softDelete() {\n        this.expressionMap.queryType = \"soft-delete\";\n        // loading it dynamically because of circular issue\n        const SoftDeleteQueryBuilderCls = require(\"./SoftDeleteQueryBuilder\").SoftDeleteQueryBuilder;\n        if (InstanceChecker.isSoftDeleteQueryBuilder(this))\n            return this;\n        return new SoftDeleteQueryBuilderCls(this);\n    }\n    restore() {\n        this.expressionMap.queryType = \"restore\";\n        // loading it dynamically because of circular issue\n        const SoftDeleteQueryBuilderCls = require(\"./SoftDeleteQueryBuilder\").SoftDeleteQueryBuilder;\n        if (InstanceChecker.isSoftDeleteQueryBuilder(this))\n            return this;\n        return new SoftDeleteQueryBuilderCls(this);\n    }\n    /**\n     * Sets entity's relation with which this query builder gonna work.\n     */\n    relation(entityTargetOrPropertyPath, maybePropertyPath) {\n        const entityTarget = arguments.length === 2 ? entityTargetOrPropertyPath : undefined;\n        const propertyPath = arguments.length === 2\n            ? maybePropertyPath\n            : entityTargetOrPropertyPath;\n        this.expressionMap.queryType = \"relation\";\n        this.expressionMap.relationPropertyPath = propertyPath;\n        if (entityTarget) {\n            const mainAlias = this.createFromAlias(entityTarget);\n            this.expressionMap.setMainAlias(mainAlias);\n        }\n        // loading it dynamically because of circular issue\n        const RelationQueryBuilderCls = require(\"./RelationQueryBuilder\").RelationQueryBuilder;\n        if (InstanceChecker.isRelationQueryBuilder(this))\n            return this;\n        return new RelationQueryBuilderCls(this);\n    }\n    /**\n     * Checks if given relation or relations exist in the entity.\n     * Returns true if relation exists, false otherwise.\n     *\n     * todo: move this method to manager? or create a shortcut?\n     */\n    hasRelation(target, relation) {\n        const entityMetadata = this.connection.getMetadata(target);\n        const relations = Array.isArray(relation) ? relation : [relation];\n        return relations.every((relation) => {\n            return !!entityMetadata.findRelationWithPropertyPath(relation);\n        });\n    }\n    /**\n     * Check the existence of a parameter for this query builder.\n     */\n    hasParameter(key) {\n        var _a;\n        return (((_a = this.parentQueryBuilder) === null || _a === void 0 ? void 0 : _a.hasParameter(key)) ||\n            key in this.expressionMap.parameters);\n    }\n    /**\n     * Sets parameter name and its value.\n     *\n     * The key for this parameter may contain numbers, letters, underscores, or periods.\n     */\n    setParameter(key, value) {\n        if (typeof value === \"function\") {\n            throw new TypeORMError(`Function parameter isn't supported in the parameters. Please check \"${key}\" parameter.`);\n        }\n        if (!key.match(/^([A-Za-z0-9_.]+)$/)) {\n            throw new TypeORMError(\"QueryBuilder parameter keys may only contain numbers, letters, underscores, or periods.\");\n        }\n        if (this.parentQueryBuilder) {\n            this.parentQueryBuilder.setParameter(key, value);\n        }\n        this.expressionMap.parameters[key] = value;\n        return this;\n    }\n    /**\n     * Adds all parameters from the given object.\n     */\n    setParameters(parameters) {\n        for (const [key, value] of Object.entries(parameters)) {\n            this.setParameter(key, value);\n        }\n        return this;\n    }\n    createParameter(value) {\n        let parameterName;\n        do {\n            parameterName = `orm_param_${this.parameterIndex++}`;\n        } while (this.hasParameter(parameterName));\n        this.setParameter(parameterName, value);\n        return `:${parameterName}`;\n    }\n    /**\n     * Adds native parameters from the given object.\n     *\n     * @deprecated Use `setParameters` instead\n     */\n    setNativeParameters(parameters) {\n        // set parent query builder parameters as well in sub-query mode\n        if (this.parentQueryBuilder) {\n            this.parentQueryBuilder.setNativeParameters(parameters);\n        }\n        Object.keys(parameters).forEach((key) => {\n            this.expressionMap.nativeParameters[key] = parameters[key];\n        });\n        return this;\n    }\n    /**\n     * Gets all parameters.\n     */\n    getParameters() {\n        const parameters = Object.assign({}, this.expressionMap.parameters);\n        // add discriminator column parameter if it exist\n        if (this.expressionMap.mainAlias &&\n            this.expressionMap.mainAlias.hasMetadata) {\n            const metadata = this.expressionMap.mainAlias.metadata;\n            if (metadata.discriminatorColumn && metadata.parentEntityMetadata) {\n                const values = metadata.childEntityMetadatas\n                    .filter((childMetadata) => childMetadata.discriminatorColumn)\n                    .map((childMetadata) => childMetadata.discriminatorValue);\n                values.push(metadata.discriminatorValue);\n                parameters[\"discriminatorColumnValues\"] = values;\n            }\n        }\n        return parameters;\n    }\n    /**\n     * Prints sql to stdout using console.log.\n     */\n    printSql() {\n        // TODO rename to logSql()\n        const [query, parameters] = this.getQueryAndParameters();\n        this.connection.logger.logQuery(query, parameters);\n        return this;\n    }\n    /**\n     * Gets generated sql that will be executed.\n     * Parameters in the query are escaped for the currently used driver.\n     */\n    getSql() {\n        return this.getQueryAndParameters()[0];\n    }\n    /**\n     * Gets query to be executed with all parameters used in it.\n     */\n    getQueryAndParameters() {\n        // this execution order is important because getQuery method generates this.expressionMap.nativeParameters values\n        const query = this.getQuery();\n        const parameters = this.getParameters();\n        return this.connection.driver.escapeQueryWithParameters(query, parameters, this.expressionMap.nativeParameters);\n    }\n    /**\n     * Executes sql generated by query builder and returns raw database results.\n     */\n    async execute() {\n        const [sql, parameters] = this.getQueryAndParameters();\n        const queryRunner = this.obtainQueryRunner();\n        try {\n            return await queryRunner.query(sql, parameters); // await is needed here because we are using finally\n        }\n        finally {\n            if (queryRunner !== this.queryRunner) {\n                // means we created our own query runner\n                await queryRunner.release();\n            }\n        }\n    }\n    /**\n     * Creates a completely new query builder.\n     * Uses same query runner as current QueryBuilder.\n     */\n    createQueryBuilder() {\n        return new this.constructor(this.connection, this.queryRunner);\n    }\n    /**\n     * Clones query builder as it is.\n     * Note: it uses new query runner, if you want query builder that uses exactly same query runner,\n     * you can create query builder using its constructor, for example new SelectQueryBuilder(queryBuilder)\n     * where queryBuilder is cloned QueryBuilder.\n     */\n    clone() {\n        return new this.constructor(this);\n    }\n    /**\n     * Includes a Query comment in the query builder.  This is helpful for debugging purposes,\n     * such as finding a specific query in the database server's logs, or for categorization using\n     * an APM product.\n     */\n    comment(comment) {\n        this.expressionMap.comment = comment;\n        return this;\n    }\n    /**\n     * Disables escaping.\n     */\n    disableEscaping() {\n        this.expressionMap.disableEscaping = false;\n        return this;\n    }\n    /**\n     * Escapes table name, column name or alias name using current database's escaping character.\n     */\n    escape(name) {\n        if (!this.expressionMap.disableEscaping)\n            return name;\n        return this.connection.driver.escape(name);\n    }\n    /**\n     * Sets or overrides query builder's QueryRunner.\n     */\n    setQueryRunner(queryRunner) {\n        this.queryRunner = queryRunner;\n        return this;\n    }\n    /**\n     * Indicates if listeners and subscribers must be called before and after query execution.\n     * Enabled by default.\n     */\n    callListeners(enabled) {\n        this.expressionMap.callListeners = enabled;\n        return this;\n    }\n    /**\n     * If set to true the query will be wrapped into a transaction.\n     */\n    useTransaction(enabled) {\n        this.expressionMap.useTransaction = enabled;\n        return this;\n    }\n    /**\n     * Adds CTE to query\n     */\n    addCommonTableExpression(queryBuilder, alias, options) {\n        this.expressionMap.commonTableExpressions.push({\n            queryBuilder,\n            alias,\n            options: options || {},\n        });\n        return this;\n    }\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Gets escaped table name with schema name if SqlServer driver used with custom\n     * schema name, otherwise returns escaped table name.\n     */\n    getTableName(tablePath) {\n        return tablePath\n            .split(\".\")\n            .map((i) => {\n            // this condition need because in SQL Server driver when custom database name was specified and schema name was not, we got `dbName..tableName` string, and doesn't need to escape middle empty string\n            if (i === \"\")\n                return i;\n            return this.escape(i);\n        })\n            .join(\".\");\n    }\n    /**\n     * Gets name of the table where insert should be performed.\n     */\n    getMainTableName() {\n        if (!this.expressionMap.mainAlias)\n            throw new TypeORMError(`Entity where values should be inserted is not specified. Call \"qb.into(entity)\" method to specify it.`);\n        if (this.expressionMap.mainAlias.hasMetadata)\n            return this.expressionMap.mainAlias.metadata.tablePath;\n        return this.expressionMap.mainAlias.tablePath;\n    }\n    /**\n     * Specifies FROM which entity's table select/update/delete will be executed.\n     * Also sets a main string alias of the selection data.\n     */\n    createFromAlias(entityTarget, aliasName) {\n        // if table has a metadata then find it to properly escape its properties\n        // const metadata = this.connection.entityMetadatas.find(metadata => metadata.tableName === tableName);\n        if (this.connection.hasMetadata(entityTarget)) {\n            const metadata = this.connection.getMetadata(entityTarget);\n            return this.expressionMap.createAlias({\n                type: \"from\",\n                name: aliasName,\n                metadata: this.connection.getMetadata(entityTarget),\n                tablePath: metadata.tablePath,\n            });\n        }\n        else {\n            if (typeof entityTarget === \"string\") {\n                const isSubquery = entityTarget.substr(0, 1) === \"(\" &&\n                    entityTarget.substr(-1) === \")\";\n                return this.expressionMap.createAlias({\n                    type: \"from\",\n                    name: aliasName,\n                    tablePath: !isSubquery\n                        ? entityTarget\n                        : undefined,\n                    subQuery: isSubquery ? entityTarget : undefined,\n                });\n            }\n            const subQueryBuilder = entityTarget(this.subQuery());\n            this.setParameters(subQueryBuilder.getParameters());\n            const subquery = subQueryBuilder.getQuery();\n            return this.expressionMap.createAlias({\n                type: \"from\",\n                name: aliasName,\n                subQuery: subquery,\n            });\n        }\n    }\n    /**\n     * @deprecated this way of replace property names is too slow.\n     *  Instead, we'll replace property names at the end - once query is build.\n     */\n    replacePropertyNames(statement) {\n        return statement;\n    }\n    /**\n     * Replaces all entity's propertyName to name in the given SQL string.\n     */\n    replacePropertyNamesForTheWholeQuery(statement) {\n        const replacements = {};\n        for (const alias of this.expressionMap.aliases) {\n            if (!alias.hasMetadata)\n                continue;\n            const replaceAliasNamePrefix = this.expressionMap.aliasNamePrefixingEnabled && alias.name\n                ? `${alias.name}.`\n                : \"\";\n            if (!replacements[replaceAliasNamePrefix]) {\n                replacements[replaceAliasNamePrefix] = {};\n            }\n            // Insert & overwrite the replacements from least to most relevant in our replacements object.\n            // To do this we iterate and overwrite in the order of relevance.\n            // Least to Most Relevant:\n            // * Relation Property Path to first join column key\n            // * Relation Property Path + Column Path\n            // * Column Database Name\n            // * Column Property Name\n            // * Column Property Path\n            for (const relation of alias.metadata.relations) {\n                if (relation.joinColumns.length > 0)\n                    replacements[replaceAliasNamePrefix][relation.propertyPath] = relation.joinColumns[0].databaseName;\n            }\n            for (const relation of alias.metadata.relations) {\n                const allColumns = [\n                    ...relation.joinColumns,\n                    ...relation.inverseJoinColumns,\n                ];\n                for (const joinColumn of allColumns) {\n                    const propertyKey = `${relation.propertyPath}.${joinColumn.referencedColumn.propertyPath}`;\n                    replacements[replaceAliasNamePrefix][propertyKey] =\n                        joinColumn.databaseName;\n                }\n            }\n            for (const column of alias.metadata.columns) {\n                replacements[replaceAliasNamePrefix][column.databaseName] =\n                    column.databaseName;\n            }\n            for (const column of alias.metadata.columns) {\n                replacements[replaceAliasNamePrefix][column.propertyName] =\n                    column.databaseName;\n            }\n            for (const column of alias.metadata.columns) {\n                replacements[replaceAliasNamePrefix][column.propertyPath] =\n                    column.databaseName;\n            }\n        }\n        const replacementKeys = Object.keys(replacements);\n        const replaceAliasNamePrefixes = replacementKeys\n            .map((key) => escapeRegExp(key))\n            .join(\"|\");\n        if (replacementKeys.length > 0) {\n            statement = statement.replace(new RegExp(\n            // Avoid a lookbehind here since it's not well supported\n            `([ =\\(]|^.{0})` + // any of ' =(' or start of line\n                // followed by our prefix, e.g. 'tablename.' or ''\n                `${replaceAliasNamePrefixes\n                    ? \"(\" + replaceAliasNamePrefixes + \")\"\n                    : \"\"}([^ =\\(\\)\\,]+)` + // a possible property name: sequence of anything but ' =(),'\n                // terminated by ' =),' or end of line\n                `(?=[ =\\)\\,]|.{0}$)`, \"gm\"), (...matches) => {\n                let match, pre, p;\n                if (replaceAliasNamePrefixes) {\n                    match = matches[0];\n                    pre = matches[1];\n                    p = matches[3];\n                    if (replacements[matches[2]][p]) {\n                        return `${pre}${this.escape(matches[2].substring(0, matches[2].length - 1))}.${this.escape(replacements[matches[2]][p])}`;\n                    }\n                }\n                else {\n                    match = matches[0];\n                    pre = matches[1];\n                    p = matches[2];\n                    if (replacements[\"\"][p]) {\n                        return `${pre}${this.escape(replacements[\"\"][p])}`;\n                    }\n                }\n                return match;\n            });\n        }\n        return statement;\n    }\n    createComment() {\n        if (!this.expressionMap.comment) {\n            return \"\";\n        }\n        // ANSI SQL 2003 support C style comments - comments that start with `/*` and end with `*/`\n        // In some dialects query nesting is available - but not all.  Because of this, we'll need\n        // to scrub \"ending\" characters from the SQL but otherwise we can leave everything else\n        // as-is and it should be valid.\n        return `/* ${this.expressionMap.comment.replace(\"*/\", \"\")} */ `;\n    }\n    /**\n     * Time travel queries for CockroachDB\n     */\n    createTimeTravelQuery() {\n        if (this.expressionMap.queryType === \"select\" &&\n            this.expressionMap.timeTravel) {\n            return ` AS OF SYSTEM TIME ${this.expressionMap.timeTravel}`;\n        }\n        return \"\";\n    }\n    /**\n     * Creates \"WHERE\" expression.\n     */\n    createWhereExpression() {\n        const conditionsArray = [];\n        const whereExpression = this.createWhereClausesExpression(this.expressionMap.wheres);\n        if (whereExpression.length > 0 && whereExpression !== \"1=1\") {\n            conditionsArray.push(this.replacePropertyNames(whereExpression));\n        }\n        if (this.expressionMap.mainAlias.hasMetadata) {\n            const metadata = this.expressionMap.mainAlias.metadata;\n            // Adds the global condition of \"non-deleted\" for the entity with delete date columns in select query.\n            if (this.expressionMap.queryType === \"select\" &&\n                !this.expressionMap.withDeleted &&\n                metadata.deleteDateColumn) {\n                const column = this.expressionMap.aliasNamePrefixingEnabled\n                    ? this.expressionMap.mainAlias.name +\n                        \".\" +\n                        metadata.deleteDateColumn.propertyName\n                    : metadata.deleteDateColumn.propertyName;\n                const condition = `${this.replacePropertyNames(column)} IS NULL`;\n                conditionsArray.push(condition);\n            }\n            if (metadata.discriminatorColumn && metadata.parentEntityMetadata) {\n                const column = this.expressionMap.aliasNamePrefixingEnabled\n                    ? this.expressionMap.mainAlias.name +\n                        \".\" +\n                        metadata.discriminatorColumn.databaseName\n                    : metadata.discriminatorColumn.databaseName;\n                const condition = `${this.replacePropertyNames(column)} IN (:...discriminatorColumnValues)`;\n                conditionsArray.push(condition);\n            }\n        }\n        if (this.expressionMap.extraAppendedAndWhereCondition) {\n            const condition = this.replacePropertyNames(this.expressionMap.extraAppendedAndWhereCondition);\n            conditionsArray.push(condition);\n        }\n        let condition = \"\";\n        // time travel\n        condition += this.createTimeTravelQuery();\n        if (!conditionsArray.length) {\n            condition += \"\";\n        }\n        else if (conditionsArray.length === 1) {\n            condition += ` WHERE ${conditionsArray[0]}`;\n        }\n        else {\n            condition += ` WHERE ( ${conditionsArray.join(\" ) AND ( \")} )`;\n        }\n        return condition;\n    }\n    /**\n     * Creates \"RETURNING\" / \"OUTPUT\" expression.\n     */\n    createReturningExpression(returningType) {\n        const columns = this.getReturningColumns();\n        const driver = this.connection.driver;\n        // also add columns we must auto-return to perform entity updation\n        // if user gave his own returning\n        if (typeof this.expressionMap.returning !== \"string\" &&\n            this.expressionMap.extraReturningColumns.length > 0 &&\n            driver.isReturningSqlSupported(returningType)) {\n            columns.push(...this.expressionMap.extraReturningColumns.filter((column) => {\n                return columns.indexOf(column) === -1;\n            }));\n        }\n        if (columns.length) {\n            let columnsExpression = columns\n                .map((column) => {\n                const name = this.escape(column.databaseName);\n                if (driver.options.type === \"mssql\") {\n                    if (this.expressionMap.queryType === \"insert\" ||\n                        this.expressionMap.queryType === \"update\" ||\n                        this.expressionMap.queryType === \"soft-delete\" ||\n                        this.expressionMap.queryType === \"restore\") {\n                        return \"INSERTED.\" + name;\n                    }\n                    else {\n                        return (this.escape(this.getMainTableName()) +\n                            \".\" +\n                            name);\n                    }\n                }\n                else {\n                    return name;\n                }\n            })\n                .join(\", \");\n            if (driver.options.type === \"oracle\") {\n                columnsExpression +=\n                    \" INTO \" +\n                        columns\n                            .map((column) => {\n                            return this.createParameter({\n                                type: driver.columnTypeToNativeParameter(column.type),\n                                dir: driver.oracle.BIND_OUT,\n                            });\n                        })\n                            .join(\", \");\n            }\n            if (driver.options.type === \"mssql\") {\n                if (this.expressionMap.queryType === \"insert\" ||\n                    this.expressionMap.queryType === \"update\") {\n                    columnsExpression += \" INTO @OutputTable\";\n                }\n            }\n            return columnsExpression;\n        }\n        else if (typeof this.expressionMap.returning === \"string\") {\n            return this.expressionMap.returning;\n        }\n        return \"\";\n    }\n    /**\n     * If returning / output cause is set to array of column names,\n     * then this method will return all column metadatas of those column names.\n     */\n    getReturningColumns() {\n        const columns = [];\n        if (Array.isArray(this.expressionMap.returning)) {\n            ;\n            this.expressionMap.returning.forEach((columnName) => {\n                if (this.expressionMap.mainAlias.hasMetadata) {\n                    columns.push(...this.expressionMap.mainAlias.metadata.findColumnsWithPropertyPath(columnName));\n                }\n            });\n        }\n        return columns;\n    }\n    createWhereClausesExpression(clauses) {\n        return clauses\n            .map((clause, index) => {\n            const expression = this.createWhereConditionExpression(clause.condition);\n            switch (clause.type) {\n                case \"and\":\n                    return (index > 0 ? \"AND \" : \"\") + expression;\n                case \"or\":\n                    return (index > 0 ? \"OR \" : \"\") + expression;\n            }\n            return expression;\n        })\n            .join(\" \")\n            .trim();\n    }\n    /**\n     * Computes given where argument - transforms to a where string all forms it can take.\n     */\n    createWhereConditionExpression(condition, alwaysWrap = false) {\n        if (typeof condition === \"string\")\n            return condition;\n        if (Array.isArray(condition)) {\n            if (condition.length === 0) {\n                return \"1=1\";\n            }\n            // In the future we should probably remove this entire condition\n            // but for now to prevent any breaking changes it exists.\n            if (condition.length === 1 && !alwaysWrap) {\n                return this.createWhereClausesExpression(condition);\n            }\n            return \"(\" + this.createWhereClausesExpression(condition) + \")\";\n        }\n        const { driver } = this.connection;\n        switch (condition.operator) {\n            case \"lessThan\":\n                return `${condition.parameters[0]} < ${condition.parameters[1]}`;\n            case \"lessThanOrEqual\":\n                return `${condition.parameters[0]} <= ${condition.parameters[1]}`;\n            case \"arrayContains\":\n                return `${condition.parameters[0]} @> ${condition.parameters[1]}`;\n            case \"jsonContains\":\n                return `${condition.parameters[0]} ::jsonb @> ${condition.parameters[1]}`;\n            case \"arrayContainedBy\":\n                return `${condition.parameters[0]} <@ ${condition.parameters[1]}`;\n            case \"arrayOverlap\":\n                return `${condition.parameters[0]} && ${condition.parameters[1]}`;\n            case \"moreThan\":\n                return `${condition.parameters[0]} > ${condition.parameters[1]}`;\n            case \"moreThanOrEqual\":\n                return `${condition.parameters[0]} >= ${condition.parameters[1]}`;\n            case \"notEqual\":\n                return `${condition.parameters[0]} != ${condition.parameters[1]}`;\n            case \"equal\":\n                return `${condition.parameters[0]} = ${condition.parameters[1]}`;\n            case \"ilike\":\n                if (driver.options.type === \"postgres\" ||\n                    driver.options.type === \"cockroachdb\") {\n                    return `${condition.parameters[0]} ILIKE ${condition.parameters[1]}`;\n                }\n                return `UPPER(${condition.parameters[0]}) LIKE UPPER(${condition.parameters[1]})`;\n            case \"like\":\n                return `${condition.parameters[0]} LIKE ${condition.parameters[1]}`;\n            case \"between\":\n                return `${condition.parameters[0]} BETWEEN ${condition.parameters[1]} AND ${condition.parameters[2]}`;\n            case \"in\":\n                if (condition.parameters.length <= 1) {\n                    return \"0=1\";\n                }\n                return `${condition.parameters[0]} IN (${condition.parameters\n                    .slice(1)\n                    .join(\", \")})`;\n            case \"any\":\n                if (driver.options.type === \"cockroachdb\") {\n                    return `${condition.parameters[0]}::STRING = ANY(${condition.parameters[1]}::STRING[])`;\n                }\n                return `${condition.parameters[0]} = ANY(${condition.parameters[1]})`;\n            case \"isNull\":\n                return `${condition.parameters[0]} IS NULL`;\n            case \"not\":\n                return `NOT(${this.createWhereConditionExpression(condition.condition)})`;\n            case \"brackets\":\n                return `${this.createWhereConditionExpression(condition.condition, true)}`;\n            case \"and\":\n                return condition.parameters.join(\" AND \");\n        }\n        throw new TypeError(`Unsupported FindOperator ${FindOperator.constructor.name}`);\n    }\n    createCteExpression() {\n        if (!this.hasCommonTableExpressions()) {\n            return \"\";\n        }\n        const databaseRequireRecusiveHint = this.connection.driver.cteCapabilities.requiresRecursiveHint;\n        const cteStrings = this.expressionMap.commonTableExpressions.map((cte) => {\n            const cteBodyExpression = typeof cte.queryBuilder === \"string\"\n                ? cte.queryBuilder\n                : cte.queryBuilder.getQuery();\n            if (typeof cte.queryBuilder !== \"string\") {\n                if (cte.queryBuilder.hasCommonTableExpressions()) {\n                    throw new TypeORMError(`Nested CTEs aren't supported (CTE: ${cte.alias})`);\n                }\n                if (!this.connection.driver.cteCapabilities.writable &&\n                    !InstanceChecker.isSelectQueryBuilder(cte.queryBuilder)) {\n                    throw new TypeORMError(`Only select queries are supported in CTEs in ${this.connection.options.type} (CTE: ${cte.alias})`);\n                }\n                this.setParameters(cte.queryBuilder.getParameters());\n            }\n            let cteHeader = this.escape(cte.alias);\n            if (cte.options.columnNames) {\n                const escapedColumnNames = cte.options.columnNames.map((column) => this.escape(column));\n                if (InstanceChecker.isSelectQueryBuilder(cte.queryBuilder)) {\n                    if (cte.queryBuilder.expressionMap.selects.length &&\n                        cte.options.columnNames.length !==\n                            cte.queryBuilder.expressionMap.selects.length) {\n                        throw new TypeORMError(`cte.options.columnNames length (${cte.options.columnNames.length}) doesn't match subquery select list length ${cte.queryBuilder.expressionMap.selects.length} (CTE: ${cte.alias})`);\n                    }\n                }\n                cteHeader += `(${escapedColumnNames.join(\", \")})`;\n            }\n            const recursiveClause = cte.options.recursive && databaseRequireRecusiveHint\n                ? \"RECURSIVE\"\n                : \"\";\n            let materializeClause = \"\";\n            if (this.connection.driver.cteCapabilities.materializedHint &&\n                cte.options.materialized !== undefined) {\n                materializeClause = cte.options.materialized\n                    ? \"MATERIALIZED\"\n                    : \"NOT MATERIALIZED\";\n            }\n            return [\n                recursiveClause,\n                cteHeader,\n                \"AS\",\n                materializeClause,\n                `(${cteBodyExpression})`,\n            ]\n                .filter(Boolean)\n                .join(\" \");\n        });\n        return \"WITH \" + cteStrings.join(\", \") + \" \";\n    }\n    /**\n     * Creates \"WHERE\" condition for an in-ids condition.\n     */\n    getWhereInIdsCondition(ids) {\n        const metadata = this.expressionMap.mainAlias.metadata;\n        const normalized = (Array.isArray(ids) ? ids : [ids]).map((id) => metadata.ensureEntityIdMap(id));\n        // using in(...ids) for single primary key entities\n        if (!metadata.hasMultiplePrimaryKeys) {\n            const primaryColumn = metadata.primaryColumns[0];\n            // getEntityValue will try to transform `In`, it is a bug\n            // todo: remove this transformer check after #2390 is fixed\n            // This also fails for embedded & relation, so until that is fixed skip it.\n            if (!primaryColumn.transformer &&\n                !primaryColumn.relationMetadata &&\n                !primaryColumn.embeddedMetadata) {\n                return {\n                    [primaryColumn.propertyName]: In(normalized.map((id) => primaryColumn.getEntityValue(id, false))),\n                };\n            }\n        }\n        return new Brackets((qb) => {\n            for (const data of normalized) {\n                qb.orWhere(new Brackets((qb) => qb.where(data)));\n            }\n        });\n    }\n    getExistsCondition(subQuery) {\n        const query = subQuery\n            .clone()\n            .orderBy()\n            .groupBy()\n            .offset(undefined)\n            .limit(undefined)\n            .skip(undefined)\n            .take(undefined)\n            .select(\"1\")\n            .setOption(\"disable-global-order\");\n        return [`EXISTS (${query.getQuery()})`, query.getParameters()];\n    }\n    findColumnsForPropertyPath(propertyPath) {\n        // Make a helper to iterate the entity & relations?\n        // Use that to set the correct alias?  Or the other way around?\n        // Start with the main alias with our property paths\n        let alias = this.expressionMap.mainAlias;\n        const root = [];\n        const propertyPathParts = propertyPath.split(\".\");\n        while (propertyPathParts.length > 1) {\n            const part = propertyPathParts[0];\n            if (!(alias === null || alias === void 0 ? void 0 : alias.hasMetadata)) {\n                // If there's no metadata, we're wasting our time\n                // and can't actually look any of this up.\n                break;\n            }\n            if (alias.metadata.hasEmbeddedWithPropertyPath(part)) {\n                // If this is an embedded then we should combine the two as part of our lookup.\n                // Instead of just breaking, we keep going with this in case there's an embedded/relation\n                // inside an embedded.\n                propertyPathParts.unshift(`${propertyPathParts.shift()}.${propertyPathParts.shift()}`);\n                continue;\n            }\n            if (alias.metadata.hasRelationWithPropertyPath(part)) {\n                // If this is a relation then we should find the aliases\n                // that match the relation & then continue further down\n                // the property path\n                const joinAttr = this.expressionMap.joinAttributes.find((joinAttr) => joinAttr.relationPropertyPath === part);\n                if (!(joinAttr === null || joinAttr === void 0 ? void 0 : joinAttr.alias)) {\n                    const fullRelationPath = root.length > 0 ? `${root.join(\".\")}.${part}` : part;\n                    throw new Error(`Cannot find alias for relation at ${fullRelationPath}`);\n                }\n                alias = joinAttr.alias;\n                root.push(...part.split(\".\"));\n                propertyPathParts.shift();\n                continue;\n            }\n            break;\n        }\n        if (!alias) {\n            throw new Error(`Cannot find alias for property ${propertyPath}`);\n        }\n        // Remaining parts are combined back and used to find the actual property path\n        const aliasPropertyPath = propertyPathParts.join(\".\");\n        const columns = alias.metadata.findColumnsWithPropertyPath(aliasPropertyPath);\n        if (!columns.length) {\n            throw new EntityPropertyNotFoundError(propertyPath, alias.metadata);\n        }\n        return [alias, root, columns];\n    }\n    /**\n     * Creates a property paths for a given ObjectLiteral.\n     */\n    createPropertyPath(metadata, entity, prefix = \"\") {\n        const paths = [];\n        for (const key of Object.keys(entity)) {\n            const path = prefix ? `${prefix}.${key}` : key;\n            // There's times where we don't actually want to traverse deeper.\n            // If the value is a `FindOperator`, or null, or not an object, then we don't, for example.\n            if (entity[key] === null ||\n                typeof entity[key] !== \"object\" ||\n                InstanceChecker.isFindOperator(entity[key])) {\n                paths.push(path);\n                continue;\n            }\n            if (metadata.hasEmbeddedWithPropertyPath(path)) {\n                const subPaths = this.createPropertyPath(metadata, entity[key], path);\n                paths.push(...subPaths);\n                continue;\n            }\n            if (metadata.hasRelationWithPropertyPath(path)) {\n                const relation = metadata.findRelationWithPropertyPath(path);\n                // There's also cases where we don't want to return back all of the properties.\n                // These handles the situation where someone passes the model & we don't need to make\n                // a HUGE `where` to uniquely look up the entity.\n                // In the case of a *-to-one, there's only ever one possible entity on the other side\n                // so if the join columns are all defined we can return just the relation itself\n                // because it will fetch only the join columns and do the lookup.\n                if (relation.relationType === \"one-to-one\" ||\n                    relation.relationType === \"many-to-one\") {\n                    const joinColumns = relation.joinColumns\n                        .map((j) => j.referencedColumn)\n                        .filter((j) => !!j);\n                    const hasAllJoinColumns = joinColumns.length > 0 &&\n                        joinColumns.every((column) => column.getEntityValue(entity[key], false));\n                    if (hasAllJoinColumns) {\n                        paths.push(path);\n                        continue;\n                    }\n                }\n                if (relation.relationType === \"one-to-many\" ||\n                    relation.relationType === \"many-to-many\") {\n                    throw new Error(`Cannot query across ${relation.relationType} for property ${path}`);\n                }\n                // For any other case, if the `entity[key]` contains all of the primary keys we can do a\n                // lookup via these.  We don't need to look up via any other values 'cause these are\n                // the unique primary keys.\n                // This handles the situation where someone passes the model & we don't need to make\n                // a HUGE where.\n                const primaryColumns = relation.inverseEntityMetadata.primaryColumns;\n                const hasAllPrimaryKeys = primaryColumns.length > 0 &&\n                    primaryColumns.every((column) => column.getEntityValue(entity[key], false));\n                if (hasAllPrimaryKeys) {\n                    const subPaths = primaryColumns.map((column) => `${path}.${column.propertyPath}`);\n                    paths.push(...subPaths);\n                    continue;\n                }\n                // If nothing else, just return every property that's being passed to us.\n                const subPaths = this.createPropertyPath(relation.inverseEntityMetadata, entity[key]).map((p) => `${path}.${p}`);\n                paths.push(...subPaths);\n                continue;\n            }\n            paths.push(path);\n        }\n        return paths;\n    }\n    *getPredicates(where) {\n        if (this.expressionMap.mainAlias.hasMetadata) {\n            const propertyPaths = this.createPropertyPath(this.expressionMap.mainAlias.metadata, where);\n            for (const propertyPath of propertyPaths) {\n                const [alias, aliasPropertyPath, columns] = this.findColumnsForPropertyPath(propertyPath);\n                for (const column of columns) {\n                    let containedWhere = where;\n                    for (const part of aliasPropertyPath) {\n                        if (!containedWhere || !(part in containedWhere)) {\n                            containedWhere = {};\n                            break;\n                        }\n                        containedWhere = containedWhere[part];\n                    }\n                    // Use the correct alias & the property path from the column\n                    const aliasPath = this.expressionMap\n                        .aliasNamePrefixingEnabled\n                        ? `${alias.name}.${column.propertyPath}`\n                        : column.propertyPath;\n                    const parameterValue = column.getEntityValue(containedWhere, true);\n                    yield [aliasPath, parameterValue];\n                }\n            }\n        }\n        else {\n            for (const key of Object.keys(where)) {\n                const parameterValue = where[key];\n                const aliasPath = this.expressionMap.aliasNamePrefixingEnabled\n                    ? `${this.alias}.${key}`\n                    : key;\n                yield [aliasPath, parameterValue];\n            }\n        }\n    }\n    getWherePredicateCondition(aliasPath, parameterValue) {\n        if (InstanceChecker.isFindOperator(parameterValue)) {\n            let parameters = [];\n            if (parameterValue.useParameter) {\n                if (parameterValue.objectLiteralParameters) {\n                    this.setParameters(parameterValue.objectLiteralParameters);\n                }\n                else if (parameterValue.multipleParameters) {\n                    for (const v of parameterValue.value) {\n                        parameters.push(this.createParameter(v));\n                    }\n                }\n                else {\n                    parameters.push(this.createParameter(parameterValue.value));\n                }\n            }\n            if (parameterValue.type === \"raw\") {\n                if (parameterValue.getSql) {\n                    return parameterValue.getSql(aliasPath);\n                }\n                else {\n                    return {\n                        operator: \"equal\",\n                        parameters: [aliasPath, parameterValue.value],\n                    };\n                }\n            }\n            else if (parameterValue.type === \"not\") {\n                if (parameterValue.child) {\n                    return {\n                        operator: parameterValue.type,\n                        condition: this.getWherePredicateCondition(aliasPath, parameterValue.child),\n                    };\n                }\n                else {\n                    return {\n                        operator: \"notEqual\",\n                        parameters: [aliasPath, ...parameters],\n                    };\n                }\n            }\n            else if (parameterValue.type === \"and\") {\n                const values = parameterValue.value;\n                return {\n                    operator: parameterValue.type,\n                    parameters: values.map((operator) => this.createWhereConditionExpression(this.getWherePredicateCondition(aliasPath, operator))),\n                };\n            }\n            else {\n                return {\n                    operator: parameterValue.type,\n                    parameters: [aliasPath, ...parameters],\n                };\n            }\n            // } else if (parameterValue === null) {\n            //     return {\n            //         operator: \"isNull\",\n            //         parameters: [\n            //             aliasPath,\n            //         ]\n            //     };\n        }\n        else {\n            return {\n                operator: \"equal\",\n                parameters: [aliasPath, this.createParameter(parameterValue)],\n            };\n        }\n    }\n    getWhereCondition(where) {\n        if (typeof where === \"string\") {\n            return where;\n        }\n        if (InstanceChecker.isBrackets(where)) {\n            const whereQueryBuilder = this.createQueryBuilder();\n            whereQueryBuilder.parentQueryBuilder = this;\n            whereQueryBuilder.expressionMap.mainAlias =\n                this.expressionMap.mainAlias;\n            whereQueryBuilder.expressionMap.aliasNamePrefixingEnabled =\n                this.expressionMap.aliasNamePrefixingEnabled;\n            whereQueryBuilder.expressionMap.parameters =\n                this.expressionMap.parameters;\n            whereQueryBuilder.expressionMap.nativeParameters =\n                this.expressionMap.nativeParameters;\n            whereQueryBuilder.expressionMap.wheres = [];\n            where.whereFactory(whereQueryBuilder);\n            return {\n                operator: InstanceChecker.isNotBrackets(where)\n                    ? \"not\"\n                    : \"brackets\",\n                condition: whereQueryBuilder.expressionMap.wheres,\n            };\n        }\n        if (typeof where === \"function\") {\n            return where(this);\n        }\n        const wheres = Array.isArray(where) ? where : [where];\n        const clauses = [];\n        for (const where of wheres) {\n            const conditions = [];\n            // Filter the conditions and set up the parameter values\n            for (const [aliasPath, parameterValue] of this.getPredicates(where)) {\n                conditions.push({\n                    type: \"and\",\n                    condition: this.getWherePredicateCondition(aliasPath, parameterValue),\n                });\n            }\n            clauses.push({ type: \"or\", condition: conditions });\n        }\n        if (clauses.length === 1) {\n            return clauses[0].condition;\n        }\n        return clauses;\n    }\n    /**\n     * Creates a query builder used to execute sql queries inside this query builder.\n     */\n    obtainQueryRunner() {\n        return this.queryRunner || this.connection.createQueryRunner();\n    }\n    hasCommonTableExpressions() {\n        return this.expressionMap.commonTableExpressions.length > 0;\n    }\n}\n\n"],"mappings":";AAAA,SAASA,kBAAkB,QAAQ,sBAAsB;AACzD,SAASC,QAAQ,QAAQ,YAAY;AACrC,SAASC,YAAY,QAAQ,8BAA8B;AAC3D,SAASC,EAAE,QAAQ,6BAA6B;AAChD,SAASC,YAAY,QAAQ,UAAU;AACvC,SAASC,2BAA2B,QAAQ,sCAAsC;AAClF,SAASC,eAAe,QAAQ,yBAAyB;AACzD,SAASC,YAAY,QAAQ,sBAAsB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO,MAAMC,YAAY,CAAC;EACtB;AACJ;AACA;EACIC,WAAWA,CAACC,wBAAwB,EAAEC,WAAW,EAAE;IAC/C,IAAI,CAAC,aAAa,CAAC,GAAGC,MAAM,CAACC,GAAG,CAAC,cAAc,CAAC;IAChD;AACR;AACA;IACQ,IAAI,CAACC,cAAc,GAAG,CAAC;IACvB,IAAIR,eAAe,CAACS,YAAY,CAACL,wBAAwB,CAAC,EAAE;MACxD,IAAI,CAACM,UAAU,GAAGN,wBAAwB;MAC1C,IAAI,CAACC,WAAW,GAAGA,WAAW;MAC9B,IAAI,CAACM,aAAa,GAAG,IAAIjB,kBAAkB,CAAC,IAAI,CAACgB,UAAU,CAAC;IAChE,CAAC,MACI;MACD,IAAI,CAACA,UAAU,GAAGN,wBAAwB,CAACM,UAAU;MACrD,IAAI,CAACL,WAAW,GAAGD,wBAAwB,CAACC,WAAW;MACvD,IAAI,CAACM,aAAa,GAAGP,wBAAwB,CAACO,aAAa,CAACC,KAAK,CAAC,CAAC;IACvE;EACJ;EACA;EACA;EACA;EACA;AACJ;AACA;EACI,IAAIC,KAAKA,CAAA,EAAG;IACR,IAAI,CAAC,IAAI,CAACF,aAAa,CAACG,SAAS,EAC7B,MAAM,IAAIhB,YAAY,CAAE,uBAAsB,CAAC,CAAC,CAAC;IACrD,OAAO,IAAI,CAACa,aAAa,CAACG,SAAS,CAACC,IAAI;EAC5C;EACA;AACJ;AACA;AACA;EACIC,MAAMA,CAACC,SAAS,EAAEC,kBAAkB,EAAE;IAClC,IAAI,CAACP,aAAa,CAACQ,SAAS,GAAG,QAAQ;IACvC,IAAIC,KAAK,CAACC,OAAO,CAACJ,SAAS,CAAC,EAAE;MAC1B,IAAI,CAACN,aAAa,CAACW,OAAO,GAAGL,SAAS,CAACM,GAAG,CAAEN,SAAS,KAAM;QACvDA,SAAS,EAAEA;MACf,CAAC,CAAC,CAAC;IACP,CAAC,MACI,IAAIA,SAAS,EAAE;MAChB,IAAI,CAACN,aAAa,CAACW,OAAO,GAAG,CACzB;QAAEL,SAAS,EAAEA,SAAS;QAAEO,SAAS,EAAEN;MAAmB,CAAC,CAC1D;IACL;IACA;IACA,MAAMO,qBAAqB,GAAGC,OAAO,CAAC,sBAAsB,CAAC,CAACC,kBAAkB;IAChF,IAAI3B,eAAe,CAAC4B,oBAAoB,CAAC,IAAI,CAAC,EAC1C,OAAO,IAAI;IACf,OAAO,IAAIH,qBAAqB,CAAC,IAAI,CAAC;EAC1C;EACA;AACJ;AACA;EACII,MAAMA,CAAA,EAAG;IACL,IAAI,CAAClB,aAAa,CAACQ,SAAS,GAAG,QAAQ;IACvC;IACA,MAAMW,qBAAqB,GAAGJ,OAAO,CAAC,sBAAsB,CAAC,CAACK,kBAAkB;IAChF,IAAI/B,eAAe,CAACgC,oBAAoB,CAAC,IAAI,CAAC,EAC1C,OAAO,IAAI;IACf,OAAO,IAAIF,qBAAqB,CAAC,IAAI,CAAC;EAC1C;EACA;AACJ;AACA;EACIG,MAAMA,CAACC,0BAA0B,EAAEC,cAAc,EAAE;IAC/C,MAAMC,SAAS,GAAGD,cAAc,GAC1BA,cAAc,GACdD,0BAA0B;IAChCA,0BAA0B,GAAGlC,eAAe,CAACqC,cAAc,CAACH,0BAA0B,CAAC,GACjFA,0BAA0B,CAACI,OAAO,CAACvB,IAAI,GACvCmB,0BAA0B;IAChC,IAAI,OAAOA,0BAA0B,KAAK,UAAU,IAChD,OAAOA,0BAA0B,KAAK,QAAQ,EAAE;MAChD,MAAMpB,SAAS,GAAG,IAAI,CAACyB,eAAe,CAACL,0BAA0B,CAAC;MAClE,IAAI,CAACvB,aAAa,CAAC6B,YAAY,CAAC1B,SAAS,CAAC;IAC9C;IACA,IAAI,CAACH,aAAa,CAACQ,SAAS,GAAG,QAAQ;IACvC,IAAI,CAACR,aAAa,CAAC8B,SAAS,GAAGL,SAAS;IACxC;IACA,MAAMM,qBAAqB,GAAGhB,OAAO,CAAC,sBAAsB,CAAC,CAACiB,kBAAkB;IAChF,IAAI3C,eAAe,CAAC4C,oBAAoB,CAAC,IAAI,CAAC,EAC1C,OAAO,IAAI;IACf,OAAO,IAAIF,qBAAqB,CAAC,IAAI,CAAC;EAC1C;EACA;AACJ;AACA;EACIG,MAAMA,CAAA,EAAG;IACL,IAAI,CAAClC,aAAa,CAACQ,SAAS,GAAG,QAAQ;IACvC;IACA,MAAM2B,qBAAqB,GAAGpB,OAAO,CAAC,sBAAsB,CAAC,CAACqB,kBAAkB;IAChF,IAAI/C,eAAe,CAACgD,oBAAoB,CAAC,IAAI,CAAC,EAC1C,OAAO,IAAI;IACf,OAAO,IAAIF,qBAAqB,CAAC,IAAI,CAAC;EAC1C;EACAG,UAAUA,CAAA,EAAG;IACT,IAAI,CAACtC,aAAa,CAACQ,SAAS,GAAG,aAAa;IAC5C;IACA,MAAM+B,yBAAyB,GAAGxB,OAAO,CAAC,0BAA0B,CAAC,CAACyB,sBAAsB;IAC5F,IAAInD,eAAe,CAACoD,wBAAwB,CAAC,IAAI,CAAC,EAC9C,OAAO,IAAI;IACf,OAAO,IAAIF,yBAAyB,CAAC,IAAI,CAAC;EAC9C;EACAG,OAAOA,CAAA,EAAG;IACN,IAAI,CAAC1C,aAAa,CAACQ,SAAS,GAAG,SAAS;IACxC;IACA,MAAM+B,yBAAyB,GAAGxB,OAAO,CAAC,0BAA0B,CAAC,CAACyB,sBAAsB;IAC5F,IAAInD,eAAe,CAACoD,wBAAwB,CAAC,IAAI,CAAC,EAC9C,OAAO,IAAI;IACf,OAAO,IAAIF,yBAAyB,CAAC,IAAI,CAAC;EAC9C;EACA;AACJ;AACA;EACII,QAAQA,CAACC,0BAA0B,EAAEC,iBAAiB,EAAE;IACpD,MAAMC,YAAY,GAAGC,SAAS,CAACC,MAAM,KAAK,CAAC,GAAGJ,0BAA0B,GAAGK,SAAS;IACpF,MAAMC,YAAY,GAAGH,SAAS,CAACC,MAAM,KAAK,CAAC,GACrCH,iBAAiB,GACjBD,0BAA0B;IAChC,IAAI,CAAC5C,aAAa,CAACQ,SAAS,GAAG,UAAU;IACzC,IAAI,CAACR,aAAa,CAACmD,oBAAoB,GAAGD,YAAY;IACtD,IAAIJ,YAAY,EAAE;MACd,MAAM3C,SAAS,GAAG,IAAI,CAACyB,eAAe,CAACkB,YAAY,CAAC;MACpD,IAAI,CAAC9C,aAAa,CAAC6B,YAAY,CAAC1B,SAAS,CAAC;IAC9C;IACA;IACA,MAAMiD,uBAAuB,GAAGrC,OAAO,CAAC,wBAAwB,CAAC,CAACsC,oBAAoB;IACtF,IAAIhE,eAAe,CAACiE,sBAAsB,CAAC,IAAI,CAAC,EAC5C,OAAO,IAAI;IACf,OAAO,IAAIF,uBAAuB,CAAC,IAAI,CAAC;EAC5C;EACA;AACJ;AACA;AACA;AACA;AACA;EACIG,WAAWA,CAACC,MAAM,EAAEb,QAAQ,EAAE;IAC1B,MAAMc,cAAc,GAAG,IAAI,CAAC1D,UAAU,CAAC2D,WAAW,CAACF,MAAM,CAAC;IAC1D,MAAMG,SAAS,GAAGlD,KAAK,CAACC,OAAO,CAACiC,QAAQ,CAAC,GAAGA,QAAQ,GAAG,CAACA,QAAQ,CAAC;IACjE,OAAOgB,SAAS,CAACC,KAAK,CAAEjB,QAAQ,IAAK;MACjC,OAAO,CAAC,CAACc,cAAc,CAACI,4BAA4B,CAAClB,QAAQ,CAAC;IAClE,CAAC,CAAC;EACN;EACA;AACJ;AACA;EACImB,YAAYA,CAACC,GAAG,EAAE;IACd,IAAIC,EAAE;IACN,OAAQ,CAAC,CAACA,EAAE,GAAG,IAAI,CAACC,kBAAkB,MAAM,IAAI,IAAID,EAAE,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,EAAE,CAACF,YAAY,CAACC,GAAG,CAAC,KAC7FA,GAAG,IAAI,IAAI,CAAC/D,aAAa,CAACkE,UAAU;EAC5C;EACA;AACJ;AACA;AACA;AACA;EACIC,YAAYA,CAACJ,GAAG,EAAEK,KAAK,EAAE;IACrB,IAAI,OAAOA,KAAK,KAAK,UAAU,EAAE;MAC7B,MAAM,IAAIjF,YAAY,CAAE,uEAAsE4E,GAAI,cAAa,CAAC;IACpH;IACA,IAAI,CAACA,GAAG,CAACM,KAAK,CAAC,oBAAoB,CAAC,EAAE;MAClC,MAAM,IAAIlF,YAAY,CAAC,yFAAyF,CAAC;IACrH;IACA,IAAI,IAAI,CAAC8E,kBAAkB,EAAE;MACzB,IAAI,CAACA,kBAAkB,CAACE,YAAY,CAACJ,GAAG,EAAEK,KAAK,CAAC;IACpD;IACA,IAAI,CAACpE,aAAa,CAACkE,UAAU,CAACH,GAAG,CAAC,GAAGK,KAAK;IAC1C,OAAO,IAAI;EACf;EACA;AACJ;AACA;EACIE,aAAaA,CAACJ,UAAU,EAAE;IACtB,KAAK,MAAM,CAACH,GAAG,EAAEK,KAAK,CAAC,IAAIG,MAAM,CAACC,OAAO,CAACN,UAAU,CAAC,EAAE;MACnD,IAAI,CAACC,YAAY,CAACJ,GAAG,EAAEK,KAAK,CAAC;IACjC;IACA,OAAO,IAAI;EACf;EACAK,eAAeA,CAACL,KAAK,EAAE;IACnB,IAAIM,aAAa;IACjB,GAAG;MACCA,aAAa,GAAI,aAAY,IAAI,CAAC7E,cAAc,EAAG,EAAC;IACxD,CAAC,QAAQ,IAAI,CAACiE,YAAY,CAACY,aAAa,CAAC;IACzC,IAAI,CAACP,YAAY,CAACO,aAAa,EAAEN,KAAK,CAAC;IACvC,OAAQ,IAAGM,aAAc,EAAC;EAC9B;EACA;AACJ;AACA;AACA;AACA;EACIC,mBAAmBA,CAACT,UAAU,EAAE;IAC5B;IACA,IAAI,IAAI,CAACD,kBAAkB,EAAE;MACzB,IAAI,CAACA,kBAAkB,CAACU,mBAAmB,CAACT,UAAU,CAAC;IAC3D;IACAK,MAAM,CAACK,IAAI,CAACV,UAAU,CAAC,CAACW,OAAO,CAAEd,GAAG,IAAK;MACrC,IAAI,CAAC/D,aAAa,CAAC8E,gBAAgB,CAACf,GAAG,CAAC,GAAGG,UAAU,CAACH,GAAG,CAAC;IAC9D,CAAC,CAAC;IACF,OAAO,IAAI;EACf;EACA;AACJ;AACA;EACIgB,aAAaA,CAAA,EAAG;IACZ,MAAMb,UAAU,GAAGK,MAAM,CAACS,MAAM,CAAC,CAAC,CAAC,EAAE,IAAI,CAAChF,aAAa,CAACkE,UAAU,CAAC;IACnE;IACA,IAAI,IAAI,CAAClE,aAAa,CAACG,SAAS,IAC5B,IAAI,CAACH,aAAa,CAACG,SAAS,CAAC8E,WAAW,EAAE;MAC1C,MAAMC,QAAQ,GAAG,IAAI,CAAClF,aAAa,CAACG,SAAS,CAAC+E,QAAQ;MACtD,IAAIA,QAAQ,CAACC,mBAAmB,IAAID,QAAQ,CAACE,oBAAoB,EAAE;QAC/D,MAAMC,MAAM,GAAGH,QAAQ,CAACI,oBAAoB,CACvCC,MAAM,CAAEC,aAAa,IAAKA,aAAa,CAACL,mBAAmB,CAAC,CAC5DvE,GAAG,CAAE4E,aAAa,IAAKA,aAAa,CAACC,kBAAkB,CAAC;QAC7DJ,MAAM,CAACK,IAAI,CAACR,QAAQ,CAACO,kBAAkB,CAAC;QACxCvB,UAAU,CAAC,2BAA2B,CAAC,GAAGmB,MAAM;MACpD;IACJ;IACA,OAAOnB,UAAU;EACrB;EACA;AACJ;AACA;EACIyB,QAAQA,CAAA,EAAG;IACP;IACA,MAAM,CAACC,KAAK,EAAE1B,UAAU,CAAC,GAAG,IAAI,CAAC2B,qBAAqB,CAAC,CAAC;IACxD,IAAI,CAAC9F,UAAU,CAAC+F,MAAM,CAACC,QAAQ,CAACH,KAAK,EAAE1B,UAAU,CAAC;IAClD,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;EACI8B,MAAMA,CAAA,EAAG;IACL,OAAO,IAAI,CAACH,qBAAqB,CAAC,CAAC,CAAC,CAAC,CAAC;EAC1C;EACA;AACJ;AACA;EACIA,qBAAqBA,CAAA,EAAG;IACpB;IACA,MAAMD,KAAK,GAAG,IAAI,CAACK,QAAQ,CAAC,CAAC;IAC7B,MAAM/B,UAAU,GAAG,IAAI,CAACa,aAAa,CAAC,CAAC;IACvC,OAAO,IAAI,CAAChF,UAAU,CAACmG,MAAM,CAACC,yBAAyB,CAACP,KAAK,EAAE1B,UAAU,EAAE,IAAI,CAAClE,aAAa,CAAC8E,gBAAgB,CAAC;EACnH;EACA;AACJ;AACA;EACUsB,OAAOA,CAAA,EAAG;IAAA,IAAAC,KAAA;IAAA,OAAAC,iBAAA;MACZ,MAAM,CAACC,GAAG,EAAErC,UAAU,CAAC,GAAGmC,KAAI,CAACR,qBAAqB,CAAC,CAAC;MACtD,MAAMnG,WAAW,GAAG2G,KAAI,CAACG,iBAAiB,CAAC,CAAC;MAC5C,IAAI;QACA,aAAa9G,WAAW,CAACkG,KAAK,CAACW,GAAG,EAAErC,UAAU,CAAC,CAAC,CAAC;MACrD,CAAC,SACO;QACJ,IAAIxE,WAAW,KAAK2G,KAAI,CAAC3G,WAAW,EAAE;UAClC;UACA,MAAMA,WAAW,CAAC+G,OAAO,CAAC,CAAC;QAC/B;MACJ;IAAC;EACL;EACA;AACJ;AACA;AACA;EACIC,kBAAkBA,CAAA,EAAG;IACjB,OAAO,IAAI,IAAI,CAAClH,WAAW,CAAC,IAAI,CAACO,UAAU,EAAE,IAAI,CAACL,WAAW,CAAC;EAClE;EACA;AACJ;AACA;AACA;AACA;AACA;EACIO,KAAKA,CAAA,EAAG;IACJ,OAAO,IAAI,IAAI,CAACT,WAAW,CAAC,IAAI,CAAC;EACrC;EACA;AACJ;AACA;AACA;AACA;EACImH,OAAOA,CAACA,OAAO,EAAE;IACb,IAAI,CAAC3G,aAAa,CAAC2G,OAAO,GAAGA,OAAO;IACpC,OAAO,IAAI;EACf;EACA;AACJ;AACA;EACIC,eAAeA,CAAA,EAAG;IACd,IAAI,CAAC5G,aAAa,CAAC4G,eAAe,GAAG,KAAK;IAC1C,OAAO,IAAI;EACf;EACA;AACJ;AACA;EACIC,MAAMA,CAACzG,IAAI,EAAE;IACT,IAAI,CAAC,IAAI,CAACJ,aAAa,CAAC4G,eAAe,EACnC,OAAOxG,IAAI;IACf,OAAO,IAAI,CAACL,UAAU,CAACmG,MAAM,CAACW,MAAM,CAACzG,IAAI,CAAC;EAC9C;EACA;AACJ;AACA;EACI0G,cAAcA,CAACpH,WAAW,EAAE;IACxB,IAAI,CAACA,WAAW,GAAGA,WAAW;IAC9B,OAAO,IAAI;EACf;EACA;AACJ;AACA;AACA;EACIqH,aAAaA,CAACC,OAAO,EAAE;IACnB,IAAI,CAAChH,aAAa,CAAC+G,aAAa,GAAGC,OAAO;IAC1C,OAAO,IAAI;EACf;EACA;AACJ;AACA;EACIC,cAAcA,CAACD,OAAO,EAAE;IACpB,IAAI,CAAChH,aAAa,CAACiH,cAAc,GAAGD,OAAO;IAC3C,OAAO,IAAI;EACf;EACA;AACJ;AACA;EACIE,wBAAwBA,CAACC,YAAY,EAAEjH,KAAK,EAAEyB,OAAO,EAAE;IACnD,IAAI,CAAC3B,aAAa,CAACoH,sBAAsB,CAAC1B,IAAI,CAAC;MAC3CyB,YAAY;MACZjH,KAAK;MACLyB,OAAO,EAAEA,OAAO,IAAI,CAAC;IACzB,CAAC,CAAC;IACF,OAAO,IAAI;EACf;EACA;EACA;EACA;EACA;AACJ;AACA;AACA;EACI0F,YAAYA,CAACC,SAAS,EAAE;IACpB,OAAOA,SAAS,CACXC,KAAK,CAAC,GAAG,CAAC,CACV3G,GAAG,CAAE4G,CAAC,IAAK;MACZ;MACA,IAAIA,CAAC,KAAK,EAAE,EACR,OAAOA,CAAC;MACZ,OAAO,IAAI,CAACX,MAAM,CAACW,CAAC,CAAC;IACzB,CAAC,CAAC,CACGC,IAAI,CAAC,GAAG,CAAC;EAClB;EACA;AACJ;AACA;EACIC,gBAAgBA,CAAA,EAAG;IACf,IAAI,CAAC,IAAI,CAAC1H,aAAa,CAACG,SAAS,EAC7B,MAAM,IAAIhB,YAAY,CAAE,uGAAsG,CAAC;IACnI,IAAI,IAAI,CAACa,aAAa,CAACG,SAAS,CAAC8E,WAAW,EACxC,OAAO,IAAI,CAACjF,aAAa,CAACG,SAAS,CAAC+E,QAAQ,CAACoC,SAAS;IAC1D,OAAO,IAAI,CAACtH,aAAa,CAACG,SAAS,CAACmH,SAAS;EACjD;EACA;AACJ;AACA;AACA;EACI1F,eAAeA,CAACkB,YAAY,EAAEjC,SAAS,EAAE;IACrC;IACA;IACA,IAAI,IAAI,CAACd,UAAU,CAACkF,WAAW,CAACnC,YAAY,CAAC,EAAE;MAC3C,MAAMoC,QAAQ,GAAG,IAAI,CAACnF,UAAU,CAAC2D,WAAW,CAACZ,YAAY,CAAC;MAC1D,OAAO,IAAI,CAAC9C,aAAa,CAAC2H,WAAW,CAAC;QAClCC,IAAI,EAAE,MAAM;QACZxH,IAAI,EAAES,SAAS;QACfqE,QAAQ,EAAE,IAAI,CAACnF,UAAU,CAAC2D,WAAW,CAACZ,YAAY,CAAC;QACnDwE,SAAS,EAAEpC,QAAQ,CAACoC;MACxB,CAAC,CAAC;IACN,CAAC,MACI;MACD,IAAI,OAAOxE,YAAY,KAAK,QAAQ,EAAE;QAClC,MAAM+E,UAAU,GAAG/E,YAAY,CAACgF,MAAM,CAAC,CAAC,EAAE,CAAC,CAAC,KAAK,GAAG,IAChDhF,YAAY,CAACgF,MAAM,CAAC,CAAC,CAAC,CAAC,KAAK,GAAG;QACnC,OAAO,IAAI,CAAC9H,aAAa,CAAC2H,WAAW,CAAC;UAClCC,IAAI,EAAE,MAAM;UACZxH,IAAI,EAAES,SAAS;UACfyG,SAAS,EAAE,CAACO,UAAU,GAChB/E,YAAY,GACZG,SAAS;UACf8E,QAAQ,EAAEF,UAAU,GAAG/E,YAAY,GAAGG;QAC1C,CAAC,CAAC;MACN;MACA,MAAM+E,eAAe,GAAGlF,YAAY,CAAC,IAAI,CAACiF,QAAQ,CAAC,CAAC,CAAC;MACrD,IAAI,CAACzD,aAAa,CAAC0D,eAAe,CAACjD,aAAa,CAAC,CAAC,CAAC;MACnD,MAAMkD,QAAQ,GAAGD,eAAe,CAAC/B,QAAQ,CAAC,CAAC;MAC3C,OAAO,IAAI,CAACjG,aAAa,CAAC2H,WAAW,CAAC;QAClCC,IAAI,EAAE,MAAM;QACZxH,IAAI,EAAES,SAAS;QACfkH,QAAQ,EAAEE;MACd,CAAC,CAAC;IACN;EACJ;EACA;AACJ;AACA;AACA;EACIC,oBAAoBA,CAACC,SAAS,EAAE;IAC5B,OAAOA,SAAS;EACpB;EACA;AACJ;AACA;EACIC,oCAAoCA,CAACD,SAAS,EAAE;IAC5C,MAAME,YAAY,GAAG,CAAC,CAAC;IACvB,KAAK,MAAMnI,KAAK,IAAI,IAAI,CAACF,aAAa,CAACsI,OAAO,EAAE;MAC5C,IAAI,CAACpI,KAAK,CAAC+E,WAAW,EAClB;MACJ,MAAMsD,sBAAsB,GAAG,IAAI,CAACvI,aAAa,CAACwI,yBAAyB,IAAItI,KAAK,CAACE,IAAI,GAClF,GAAEF,KAAK,CAACE,IAAK,GAAE,GAChB,EAAE;MACR,IAAI,CAACiI,YAAY,CAACE,sBAAsB,CAAC,EAAE;QACvCF,YAAY,CAACE,sBAAsB,CAAC,GAAG,CAAC,CAAC;MAC7C;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA;MACA,KAAK,MAAM5F,QAAQ,IAAIzC,KAAK,CAACgF,QAAQ,CAACvB,SAAS,EAAE;QAC7C,IAAIhB,QAAQ,CAAC8F,WAAW,CAACzF,MAAM,GAAG,CAAC,EAC/BqF,YAAY,CAACE,sBAAsB,CAAC,CAAC5F,QAAQ,CAACO,YAAY,CAAC,GAAGP,QAAQ,CAAC8F,WAAW,CAAC,CAAC,CAAC,CAACC,YAAY;MAC1G;MACA,KAAK,MAAM/F,QAAQ,IAAIzC,KAAK,CAACgF,QAAQ,CAACvB,SAAS,EAAE;QAC7C,MAAMgF,UAAU,GAAG,CACf,GAAGhG,QAAQ,CAAC8F,WAAW,EACvB,GAAG9F,QAAQ,CAACiG,kBAAkB,CACjC;QACD,KAAK,MAAMC,UAAU,IAAIF,UAAU,EAAE;UACjC,MAAMG,WAAW,GAAI,GAAEnG,QAAQ,CAACO,YAAa,IAAG2F,UAAU,CAACE,gBAAgB,CAAC7F,YAAa,EAAC;UAC1FmF,YAAY,CAACE,sBAAsB,CAAC,CAACO,WAAW,CAAC,GAC7CD,UAAU,CAACH,YAAY;QAC/B;MACJ;MACA,KAAK,MAAMM,MAAM,IAAI9I,KAAK,CAACgF,QAAQ,CAAC+D,OAAO,EAAE;QACzCZ,YAAY,CAACE,sBAAsB,CAAC,CAACS,MAAM,CAACN,YAAY,CAAC,GACrDM,MAAM,CAACN,YAAY;MAC3B;MACA,KAAK,MAAMM,MAAM,IAAI9I,KAAK,CAACgF,QAAQ,CAAC+D,OAAO,EAAE;QACzCZ,YAAY,CAACE,sBAAsB,CAAC,CAACS,MAAM,CAACE,YAAY,CAAC,GACrDF,MAAM,CAACN,YAAY;MAC3B;MACA,KAAK,MAAMM,MAAM,IAAI9I,KAAK,CAACgF,QAAQ,CAAC+D,OAAO,EAAE;QACzCZ,YAAY,CAACE,sBAAsB,CAAC,CAACS,MAAM,CAAC9F,YAAY,CAAC,GACrD8F,MAAM,CAACN,YAAY;MAC3B;IACJ;IACA,MAAMS,eAAe,GAAG5E,MAAM,CAACK,IAAI,CAACyD,YAAY,CAAC;IACjD,MAAMe,wBAAwB,GAAGD,eAAe,CAC3CvI,GAAG,CAAEmD,GAAG,IAAKzE,YAAY,CAACyE,GAAG,CAAC,CAAC,CAC/B0D,IAAI,CAAC,GAAG,CAAC;IACd,IAAI0B,eAAe,CAACnG,MAAM,GAAG,CAAC,EAAE;MAC5BmF,SAAS,GAAGA,SAAS,CAACkB,OAAO,CAAC,IAAIC,MAAM;MACxC;MACC,gBAAe;MAAG;MACf;MACC,GAAEF,wBAAwB,GACrB,GAAG,GAAGA,wBAAwB,GAAG,GAAG,GACpC,EAAG,gBAAe;MAAG;MAC3B;MACC,oBAAmB,EAAE,IAAI,CAAC,EAAE,CAAC,GAAGG,OAAO,KAAK;QAC7C,IAAIlF,KAAK,EAAEmF,GAAG,EAAEC,CAAC;QACjB,IAAIL,wBAAwB,EAAE;UAC1B/E,KAAK,GAAGkF,OAAO,CAAC,CAAC,CAAC;UAClBC,GAAG,GAAGD,OAAO,CAAC,CAAC,CAAC;UAChBE,CAAC,GAAGF,OAAO,CAAC,CAAC,CAAC;UACd,IAAIlB,YAAY,CAACkB,OAAO,CAAC,CAAC,CAAC,CAAC,CAACE,CAAC,CAAC,EAAE;YAC7B,OAAQ,GAAED,GAAI,GAAE,IAAI,CAAC3C,MAAM,CAAC0C,OAAO,CAAC,CAAC,CAAC,CAACG,SAAS,CAAC,CAAC,EAAEH,OAAO,CAAC,CAAC,CAAC,CAACvG,MAAM,GAAG,CAAC,CAAC,CAAE,IAAG,IAAI,CAAC6D,MAAM,CAACwB,YAAY,CAACkB,OAAO,CAAC,CAAC,CAAC,CAAC,CAACE,CAAC,CAAC,CAAE,EAAC;UAC7H;QACJ,CAAC,MACI;UACDpF,KAAK,GAAGkF,OAAO,CAAC,CAAC,CAAC;UAClBC,GAAG,GAAGD,OAAO,CAAC,CAAC,CAAC;UAChBE,CAAC,GAAGF,OAAO,CAAC,CAAC,CAAC;UACd,IAAIlB,YAAY,CAAC,EAAE,CAAC,CAACoB,CAAC,CAAC,EAAE;YACrB,OAAQ,GAAED,GAAI,GAAE,IAAI,CAAC3C,MAAM,CAACwB,YAAY,CAAC,EAAE,CAAC,CAACoB,CAAC,CAAC,CAAE,EAAC;UACtD;QACJ;QACA,OAAOpF,KAAK;MAChB,CAAC,CAAC;IACN;IACA,OAAO8D,SAAS;EACpB;EACAwB,aAAaA,CAAA,EAAG;IACZ,IAAI,CAAC,IAAI,CAAC3J,aAAa,CAAC2G,OAAO,EAAE;MAC7B,OAAO,EAAE;IACb;IACA;IACA;IACA;IACA;IACA,OAAQ,MAAK,IAAI,CAAC3G,aAAa,CAAC2G,OAAO,CAAC0C,OAAO,CAAC,IAAI,EAAE,EAAE,CAAE,MAAK;EACnE;EACA;AACJ;AACA;EACIO,qBAAqBA,CAAA,EAAG;IACpB,IAAI,IAAI,CAAC5J,aAAa,CAACQ,SAAS,KAAK,QAAQ,IACzC,IAAI,CAACR,aAAa,CAAC6J,UAAU,EAAE;MAC/B,OAAQ,sBAAqB,IAAI,CAAC7J,aAAa,CAAC6J,UAAW,EAAC;IAChE;IACA,OAAO,EAAE;EACb;EACA;AACJ;AACA;EACIC,qBAAqBA,CAAA,EAAG;IACpB,MAAMC,eAAe,GAAG,EAAE;IAC1B,MAAMC,eAAe,GAAG,IAAI,CAACC,4BAA4B,CAAC,IAAI,CAACjK,aAAa,CAACkK,MAAM,CAAC;IACpF,IAAIF,eAAe,CAAChH,MAAM,GAAG,CAAC,IAAIgH,eAAe,KAAK,KAAK,EAAE;MACzDD,eAAe,CAACrE,IAAI,CAAC,IAAI,CAACwC,oBAAoB,CAAC8B,eAAe,CAAC,CAAC;IACpE;IACA,IAAI,IAAI,CAAChK,aAAa,CAACG,SAAS,CAAC8E,WAAW,EAAE;MAC1C,MAAMC,QAAQ,GAAG,IAAI,CAAClF,aAAa,CAACG,SAAS,CAAC+E,QAAQ;MACtD;MACA,IAAI,IAAI,CAAClF,aAAa,CAACQ,SAAS,KAAK,QAAQ,IACzC,CAAC,IAAI,CAACR,aAAa,CAACmK,WAAW,IAC/BjF,QAAQ,CAACkF,gBAAgB,EAAE;QAC3B,MAAMpB,MAAM,GAAG,IAAI,CAAChJ,aAAa,CAACwI,yBAAyB,GACrD,IAAI,CAACxI,aAAa,CAACG,SAAS,CAACC,IAAI,GAC/B,GAAG,GACH8E,QAAQ,CAACkF,gBAAgB,CAAClB,YAAY,GACxChE,QAAQ,CAACkF,gBAAgB,CAAClB,YAAY;QAC5C,MAAMmB,SAAS,GAAI,GAAE,IAAI,CAACnC,oBAAoB,CAACc,MAAM,CAAE,UAAS;QAChEe,eAAe,CAACrE,IAAI,CAAC2E,SAAS,CAAC;MACnC;MACA,IAAInF,QAAQ,CAACC,mBAAmB,IAAID,QAAQ,CAACE,oBAAoB,EAAE;QAC/D,MAAM4D,MAAM,GAAG,IAAI,CAAChJ,aAAa,CAACwI,yBAAyB,GACrD,IAAI,CAACxI,aAAa,CAACG,SAAS,CAACC,IAAI,GAC/B,GAAG,GACH8E,QAAQ,CAACC,mBAAmB,CAACuD,YAAY,GAC3CxD,QAAQ,CAACC,mBAAmB,CAACuD,YAAY;QAC/C,MAAM2B,SAAS,GAAI,GAAE,IAAI,CAACnC,oBAAoB,CAACc,MAAM,CAAE,qCAAoC;QAC3Fe,eAAe,CAACrE,IAAI,CAAC2E,SAAS,CAAC;MACnC;IACJ;IACA,IAAI,IAAI,CAACrK,aAAa,CAACsK,8BAA8B,EAAE;MACnD,MAAMD,SAAS,GAAG,IAAI,CAACnC,oBAAoB,CAAC,IAAI,CAAClI,aAAa,CAACsK,8BAA8B,CAAC;MAC9FP,eAAe,CAACrE,IAAI,CAAC2E,SAAS,CAAC;IACnC;IACA,IAAIA,SAAS,GAAG,EAAE;IAClB;IACAA,SAAS,IAAI,IAAI,CAACT,qBAAqB,CAAC,CAAC;IACzC,IAAI,CAACG,eAAe,CAAC/G,MAAM,EAAE;MACzBqH,SAAS,IAAI,EAAE;IACnB,CAAC,MACI,IAAIN,eAAe,CAAC/G,MAAM,KAAK,CAAC,EAAE;MACnCqH,SAAS,IAAK,UAASN,eAAe,CAAC,CAAC,CAAE,EAAC;IAC/C,CAAC,MACI;MACDM,SAAS,IAAK,YAAWN,eAAe,CAACtC,IAAI,CAAC,WAAW,CAAE,IAAG;IAClE;IACA,OAAO4C,SAAS;EACpB;EACA;AACJ;AACA;EACIE,yBAAyBA,CAACC,aAAa,EAAE;IACrC,MAAMvB,OAAO,GAAG,IAAI,CAACwB,mBAAmB,CAAC,CAAC;IAC1C,MAAMvE,MAAM,GAAG,IAAI,CAACnG,UAAU,CAACmG,MAAM;IACrC;IACA;IACA,IAAI,OAAO,IAAI,CAAClG,aAAa,CAAC0K,SAAS,KAAK,QAAQ,IAChD,IAAI,CAAC1K,aAAa,CAAC2K,qBAAqB,CAAC3H,MAAM,GAAG,CAAC,IACnDkD,MAAM,CAAC0E,uBAAuB,CAACJ,aAAa,CAAC,EAAE;MAC/CvB,OAAO,CAACvD,IAAI,CAAC,GAAG,IAAI,CAAC1F,aAAa,CAAC2K,qBAAqB,CAACpF,MAAM,CAAEyD,MAAM,IAAK;QACxE,OAAOC,OAAO,CAAC4B,OAAO,CAAC7B,MAAM,CAAC,KAAK,CAAC,CAAC;MACzC,CAAC,CAAC,CAAC;IACP;IACA,IAAIC,OAAO,CAACjG,MAAM,EAAE;MAChB,IAAI8H,iBAAiB,GAAG7B,OAAO,CAC1BrI,GAAG,CAAEoI,MAAM,IAAK;QACjB,MAAM5I,IAAI,GAAG,IAAI,CAACyG,MAAM,CAACmC,MAAM,CAACN,YAAY,CAAC;QAC7C,IAAIxC,MAAM,CAACvE,OAAO,CAACiG,IAAI,KAAK,OAAO,EAAE;UACjC,IAAI,IAAI,CAAC5H,aAAa,CAACQ,SAAS,KAAK,QAAQ,IACzC,IAAI,CAACR,aAAa,CAACQ,SAAS,KAAK,QAAQ,IACzC,IAAI,CAACR,aAAa,CAACQ,SAAS,KAAK,aAAa,IAC9C,IAAI,CAACR,aAAa,CAACQ,SAAS,KAAK,SAAS,EAAE;YAC5C,OAAO,WAAW,GAAGJ,IAAI;UAC7B,CAAC,MACI;YACD,OAAQ,IAAI,CAACyG,MAAM,CAAC,IAAI,CAACa,gBAAgB,CAAC,CAAC,CAAC,GACxC,GAAG,GACHtH,IAAI;UACZ;QACJ,CAAC,MACI;UACD,OAAOA,IAAI;QACf;MACJ,CAAC,CAAC,CACGqH,IAAI,CAAC,IAAI,CAAC;MACf,IAAIvB,MAAM,CAACvE,OAAO,CAACiG,IAAI,KAAK,QAAQ,EAAE;QAClCkD,iBAAiB,IACb,QAAQ,GACJ7B,OAAO,CACFrI,GAAG,CAAEoI,MAAM,IAAK;UACjB,OAAO,IAAI,CAACvE,eAAe,CAAC;YACxBmD,IAAI,EAAE1B,MAAM,CAAC6E,2BAA2B,CAAC/B,MAAM,CAACpB,IAAI,CAAC;YACrDoD,GAAG,EAAE9E,MAAM,CAAC+E,MAAM,CAACC;UACvB,CAAC,CAAC;QACN,CAAC,CAAC,CACGzD,IAAI,CAAC,IAAI,CAAC;MAC3B;MACA,IAAIvB,MAAM,CAACvE,OAAO,CAACiG,IAAI,KAAK,OAAO,EAAE;QACjC,IAAI,IAAI,CAAC5H,aAAa,CAACQ,SAAS,KAAK,QAAQ,IACzC,IAAI,CAACR,aAAa,CAACQ,SAAS,KAAK,QAAQ,EAAE;UAC3CsK,iBAAiB,IAAI,oBAAoB;QAC7C;MACJ;MACA,OAAOA,iBAAiB;IAC5B,CAAC,MACI,IAAI,OAAO,IAAI,CAAC9K,aAAa,CAAC0K,SAAS,KAAK,QAAQ,EAAE;MACvD,OAAO,IAAI,CAAC1K,aAAa,CAAC0K,SAAS;IACvC;IACA,OAAO,EAAE;EACb;EACA;AACJ;AACA;AACA;EACID,mBAAmBA,CAAA,EAAG;IAClB,MAAMxB,OAAO,GAAG,EAAE;IAClB,IAAIxI,KAAK,CAACC,OAAO,CAAC,IAAI,CAACV,aAAa,CAAC0K,SAAS,CAAC,EAAE;MAC7C;MACA,IAAI,CAAC1K,aAAa,CAAC0K,SAAS,CAAC7F,OAAO,CAAEsG,UAAU,IAAK;QACjD,IAAI,IAAI,CAACnL,aAAa,CAACG,SAAS,CAAC8E,WAAW,EAAE;UAC1CgE,OAAO,CAACvD,IAAI,CAAC,GAAG,IAAI,CAAC1F,aAAa,CAACG,SAAS,CAAC+E,QAAQ,CAACkG,2BAA2B,CAACD,UAAU,CAAC,CAAC;QAClG;MACJ,CAAC,CAAC;IACN;IACA,OAAOlC,OAAO;EAClB;EACAgB,4BAA4BA,CAACoB,OAAO,EAAE;IAClC,OAAOA,OAAO,CACTzK,GAAG,CAAC,CAAC0K,MAAM,EAAEC,KAAK,KAAK;MACxB,MAAMC,UAAU,GAAG,IAAI,CAACC,8BAA8B,CAACH,MAAM,CAACjB,SAAS,CAAC;MACxE,QAAQiB,MAAM,CAAC1D,IAAI;QACf,KAAK,KAAK;UACN,OAAO,CAAC2D,KAAK,GAAG,CAAC,GAAG,MAAM,GAAG,EAAE,IAAIC,UAAU;QACjD,KAAK,IAAI;UACL,OAAO,CAACD,KAAK,GAAG,CAAC,GAAG,KAAK,GAAG,EAAE,IAAIC,UAAU;MACpD;MACA,OAAOA,UAAU;IACrB,CAAC,CAAC,CACG/D,IAAI,CAAC,GAAG,CAAC,CACTiE,IAAI,CAAC,CAAC;EACf;EACA;AACJ;AACA;EACID,8BAA8BA,CAACpB,SAAS,EAAEsB,UAAU,GAAG,KAAK,EAAE;IAC1D,IAAI,OAAOtB,SAAS,KAAK,QAAQ,EAC7B,OAAOA,SAAS;IACpB,IAAI5J,KAAK,CAACC,OAAO,CAAC2J,SAAS,CAAC,EAAE;MAC1B,IAAIA,SAAS,CAACrH,MAAM,KAAK,CAAC,EAAE;QACxB,OAAO,KAAK;MAChB;MACA;MACA;MACA,IAAIqH,SAAS,CAACrH,MAAM,KAAK,CAAC,IAAI,CAAC2I,UAAU,EAAE;QACvC,OAAO,IAAI,CAAC1B,4BAA4B,CAACI,SAAS,CAAC;MACvD;MACA,OAAO,GAAG,GAAG,IAAI,CAACJ,4BAA4B,CAACI,SAAS,CAAC,GAAG,GAAG;IACnE;IACA,MAAM;MAAEnE;IAAO,CAAC,GAAG,IAAI,CAACnG,UAAU;IAClC,QAAQsK,SAAS,CAACuB,QAAQ;MACtB,KAAK,UAAU;QACX,OAAQ,GAAEvB,SAAS,CAACnG,UAAU,CAAC,CAAC,CAAE,MAAKmG,SAAS,CAACnG,UAAU,CAAC,CAAC,CAAE,EAAC;MACpE,KAAK,iBAAiB;QAClB,OAAQ,GAAEmG,SAAS,CAACnG,UAAU,CAAC,CAAC,CAAE,OAAMmG,SAAS,CAACnG,UAAU,CAAC,CAAC,CAAE,EAAC;MACrE,KAAK,eAAe;QAChB,OAAQ,GAAEmG,SAAS,CAACnG,UAAU,CAAC,CAAC,CAAE,OAAMmG,SAAS,CAACnG,UAAU,CAAC,CAAC,CAAE,EAAC;MACrE,KAAK,cAAc;QACf,OAAQ,GAAEmG,SAAS,CAACnG,UAAU,CAAC,CAAC,CAAE,eAAcmG,SAAS,CAACnG,UAAU,CAAC,CAAC,CAAE,EAAC;MAC7E,KAAK,kBAAkB;QACnB,OAAQ,GAAEmG,SAAS,CAACnG,UAAU,CAAC,CAAC,CAAE,OAAMmG,SAAS,CAACnG,UAAU,CAAC,CAAC,CAAE,EAAC;MACrE,KAAK,cAAc;QACf,OAAQ,GAAEmG,SAAS,CAACnG,UAAU,CAAC,CAAC,CAAE,OAAMmG,SAAS,CAACnG,UAAU,CAAC,CAAC,CAAE,EAAC;MACrE,KAAK,UAAU;QACX,OAAQ,GAAEmG,SAAS,CAACnG,UAAU,CAAC,CAAC,CAAE,MAAKmG,SAAS,CAACnG,UAAU,CAAC,CAAC,CAAE,EAAC;MACpE,KAAK,iBAAiB;QAClB,OAAQ,GAAEmG,SAAS,CAACnG,UAAU,CAAC,CAAC,CAAE,OAAMmG,SAAS,CAACnG,UAAU,CAAC,CAAC,CAAE,EAAC;MACrE,KAAK,UAAU;QACX,OAAQ,GAAEmG,SAAS,CAACnG,UAAU,CAAC,CAAC,CAAE,OAAMmG,SAAS,CAACnG,UAAU,CAAC,CAAC,CAAE,EAAC;MACrE,KAAK,OAAO;QACR,OAAQ,GAAEmG,SAAS,CAACnG,UAAU,CAAC,CAAC,CAAE,MAAKmG,SAAS,CAACnG,UAAU,CAAC,CAAC,CAAE,EAAC;MACpE,KAAK,OAAO;QACR,IAAIgC,MAAM,CAACvE,OAAO,CAACiG,IAAI,KAAK,UAAU,IAClC1B,MAAM,CAACvE,OAAO,CAACiG,IAAI,KAAK,aAAa,EAAE;UACvC,OAAQ,GAAEyC,SAAS,CAACnG,UAAU,CAAC,CAAC,CAAE,UAASmG,SAAS,CAACnG,UAAU,CAAC,CAAC,CAAE,EAAC;QACxE;QACA,OAAQ,SAAQmG,SAAS,CAACnG,UAAU,CAAC,CAAC,CAAE,gBAAemG,SAAS,CAACnG,UAAU,CAAC,CAAC,CAAE,GAAE;MACrF,KAAK,MAAM;QACP,OAAQ,GAAEmG,SAAS,CAACnG,UAAU,CAAC,CAAC,CAAE,SAAQmG,SAAS,CAACnG,UAAU,CAAC,CAAC,CAAE,EAAC;MACvE,KAAK,SAAS;QACV,OAAQ,GAAEmG,SAAS,CAACnG,UAAU,CAAC,CAAC,CAAE,YAAWmG,SAAS,CAACnG,UAAU,CAAC,CAAC,CAAE,QAAOmG,SAAS,CAACnG,UAAU,CAAC,CAAC,CAAE,EAAC;MACzG,KAAK,IAAI;QACL,IAAImG,SAAS,CAACnG,UAAU,CAAClB,MAAM,IAAI,CAAC,EAAE;UAClC,OAAO,KAAK;QAChB;QACA,OAAQ,GAAEqH,SAAS,CAACnG,UAAU,CAAC,CAAC,CAAE,QAAOmG,SAAS,CAACnG,UAAU,CACxD2H,KAAK,CAAC,CAAC,CAAC,CACRpE,IAAI,CAAC,IAAI,CAAE,GAAE;MACtB,KAAK,KAAK;QACN,IAAIvB,MAAM,CAACvE,OAAO,CAACiG,IAAI,KAAK,aAAa,EAAE;UACvC,OAAQ,GAAEyC,SAAS,CAACnG,UAAU,CAAC,CAAC,CAAE,kBAAiBmG,SAAS,CAACnG,UAAU,CAAC,CAAC,CAAE,aAAY;QAC3F;QACA,OAAQ,GAAEmG,SAAS,CAACnG,UAAU,CAAC,CAAC,CAAE,UAASmG,SAAS,CAACnG,UAAU,CAAC,CAAC,CAAE,GAAE;MACzE,KAAK,QAAQ;QACT,OAAQ,GAAEmG,SAAS,CAACnG,UAAU,CAAC,CAAC,CAAE,UAAS;MAC/C,KAAK,KAAK;QACN,OAAQ,OAAM,IAAI,CAACuH,8BAA8B,CAACpB,SAAS,CAACA,SAAS,CAAE,GAAE;MAC7E,KAAK,UAAU;QACX,OAAQ,GAAE,IAAI,CAACoB,8BAA8B,CAACpB,SAAS,CAACA,SAAS,EAAE,IAAI,CAAE,EAAC;MAC9E,KAAK,KAAK;QACN,OAAOA,SAAS,CAACnG,UAAU,CAACuD,IAAI,CAAC,OAAO,CAAC;IACjD;IACA,MAAM,IAAIqE,SAAS,CAAE,4BAA2B7M,YAAY,CAACO,WAAW,CAACY,IAAK,EAAC,CAAC;EACpF;EACA2L,mBAAmBA,CAAA,EAAG;IAClB,IAAI,CAAC,IAAI,CAACC,yBAAyB,CAAC,CAAC,EAAE;MACnC,OAAO,EAAE;IACb;IACA,MAAMC,2BAA2B,GAAG,IAAI,CAAClM,UAAU,CAACmG,MAAM,CAACgG,eAAe,CAACC,qBAAqB;IAChG,MAAMC,UAAU,GAAG,IAAI,CAACpM,aAAa,CAACoH,sBAAsB,CAACxG,GAAG,CAAEyL,GAAG,IAAK;MACtE,MAAMC,iBAAiB,GAAG,OAAOD,GAAG,CAAClF,YAAY,KAAK,QAAQ,GACxDkF,GAAG,CAAClF,YAAY,GAChBkF,GAAG,CAAClF,YAAY,CAAClB,QAAQ,CAAC,CAAC;MACjC,IAAI,OAAOoG,GAAG,CAAClF,YAAY,KAAK,QAAQ,EAAE;QACtC,IAAIkF,GAAG,CAAClF,YAAY,CAAC6E,yBAAyB,CAAC,CAAC,EAAE;UAC9C,MAAM,IAAI7M,YAAY,CAAE,sCAAqCkN,GAAG,CAACnM,KAAM,GAAE,CAAC;QAC9E;QACA,IAAI,CAAC,IAAI,CAACH,UAAU,CAACmG,MAAM,CAACgG,eAAe,CAACK,QAAQ,IAChD,CAAClN,eAAe,CAAC4B,oBAAoB,CAACoL,GAAG,CAAClF,YAAY,CAAC,EAAE;UACzD,MAAM,IAAIhI,YAAY,CAAE,gDAA+C,IAAI,CAACY,UAAU,CAAC4B,OAAO,CAACiG,IAAK,UAASyE,GAAG,CAACnM,KAAM,GAAE,CAAC;QAC9H;QACA,IAAI,CAACoE,aAAa,CAAC+H,GAAG,CAAClF,YAAY,CAACpC,aAAa,CAAC,CAAC,CAAC;MACxD;MACA,IAAIyH,SAAS,GAAG,IAAI,CAAC3F,MAAM,CAACwF,GAAG,CAACnM,KAAK,CAAC;MACtC,IAAImM,GAAG,CAAC1K,OAAO,CAAC8K,WAAW,EAAE;QACzB,MAAMC,kBAAkB,GAAGL,GAAG,CAAC1K,OAAO,CAAC8K,WAAW,CAAC7L,GAAG,CAAEoI,MAAM,IAAK,IAAI,CAACnC,MAAM,CAACmC,MAAM,CAAC,CAAC;QACvF,IAAI3J,eAAe,CAAC4B,oBAAoB,CAACoL,GAAG,CAAClF,YAAY,CAAC,EAAE;UACxD,IAAIkF,GAAG,CAAClF,YAAY,CAACnH,aAAa,CAACW,OAAO,CAACqC,MAAM,IAC7CqJ,GAAG,CAAC1K,OAAO,CAAC8K,WAAW,CAACzJ,MAAM,KAC1BqJ,GAAG,CAAClF,YAAY,CAACnH,aAAa,CAACW,OAAO,CAACqC,MAAM,EAAE;YACnD,MAAM,IAAI7D,YAAY,CAAE,mCAAkCkN,GAAG,CAAC1K,OAAO,CAAC8K,WAAW,CAACzJ,MAAO,+CAA8CqJ,GAAG,CAAClF,YAAY,CAACnH,aAAa,CAACW,OAAO,CAACqC,MAAO,UAASqJ,GAAG,CAACnM,KAAM,GAAE,CAAC;UAC/M;QACJ;QACAsM,SAAS,IAAK,IAAGE,kBAAkB,CAACjF,IAAI,CAAC,IAAI,CAAE,GAAE;MACrD;MACA,MAAMkF,eAAe,GAAGN,GAAG,CAAC1K,OAAO,CAACiL,SAAS,IAAIX,2BAA2B,GACtE,WAAW,GACX,EAAE;MACR,IAAIY,iBAAiB,GAAG,EAAE;MAC1B,IAAI,IAAI,CAAC9M,UAAU,CAACmG,MAAM,CAACgG,eAAe,CAACY,gBAAgB,IACvDT,GAAG,CAAC1K,OAAO,CAACoL,YAAY,KAAK9J,SAAS,EAAE;QACxC4J,iBAAiB,GAAGR,GAAG,CAAC1K,OAAO,CAACoL,YAAY,GACtC,cAAc,GACd,kBAAkB;MAC5B;MACA,OAAO,CACHJ,eAAe,EACfH,SAAS,EACT,IAAI,EACJK,iBAAiB,EAChB,IAAGP,iBAAkB,GAAE,CAC3B,CACI/G,MAAM,CAACyH,OAAO,CAAC,CACfvF,IAAI,CAAC,GAAG,CAAC;IAClB,CAAC,CAAC;IACF,OAAO,OAAO,GAAG2E,UAAU,CAAC3E,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG;EAChD;EACA;AACJ;AACA;EACIwF,sBAAsBA,CAACC,GAAG,EAAE;IACxB,MAAMhI,QAAQ,GAAG,IAAI,CAAClF,aAAa,CAACG,SAAS,CAAC+E,QAAQ;IACtD,MAAMiI,UAAU,GAAG,CAAC1M,KAAK,CAACC,OAAO,CAACwM,GAAG,CAAC,GAAGA,GAAG,GAAG,CAACA,GAAG,CAAC,EAAEtM,GAAG,CAAEwM,EAAE,IAAKlI,QAAQ,CAACmI,iBAAiB,CAACD,EAAE,CAAC,CAAC;IACjG;IACA,IAAI,CAAClI,QAAQ,CAACoI,sBAAsB,EAAE;MAClC,MAAMC,aAAa,GAAGrI,QAAQ,CAACsI,cAAc,CAAC,CAAC,CAAC;MAChD;MACA;MACA;MACA,IAAI,CAACD,aAAa,CAACE,WAAW,IAC1B,CAACF,aAAa,CAACG,gBAAgB,IAC/B,CAACH,aAAa,CAACI,gBAAgB,EAAE;QACjC,OAAO;UACH,CAACJ,aAAa,CAACrE,YAAY,GAAGhK,EAAE,CAACiO,UAAU,CAACvM,GAAG,CAAEwM,EAAE,IAAKG,aAAa,CAACK,cAAc,CAACR,EAAE,EAAE,KAAK,CAAC,CAAC;QACpG,CAAC;MACL;IACJ;IACA,OAAO,IAAIpO,QAAQ,CAAE6O,EAAE,IAAK;MACxB,KAAK,MAAMC,IAAI,IAAIX,UAAU,EAAE;QAC3BU,EAAE,CAACE,OAAO,CAAC,IAAI/O,QAAQ,CAAE6O,EAAE,IAAKA,EAAE,CAACG,KAAK,CAACF,IAAI,CAAC,CAAC,CAAC;MACpD;IACJ,CAAC,CAAC;EACN;EACAG,kBAAkBA,CAAClG,QAAQ,EAAE;IACzB,MAAMnC,KAAK,GAAGmC,QAAQ,CACjB9H,KAAK,CAAC,CAAC,CACPiO,OAAO,CAAC,CAAC,CACTC,OAAO,CAAC,CAAC,CACTC,MAAM,CAACnL,SAAS,CAAC,CACjBoL,KAAK,CAACpL,SAAS,CAAC,CAChBqL,IAAI,CAACrL,SAAS,CAAC,CACfsL,IAAI,CAACtL,SAAS,CAAC,CACf5C,MAAM,CAAC,GAAG,CAAC,CACXmO,SAAS,CAAC,sBAAsB,CAAC;IACtC,OAAO,CAAE,WAAU5I,KAAK,CAACK,QAAQ,CAAC,CAAE,GAAE,EAAEL,KAAK,CAACb,aAAa,CAAC,CAAC,CAAC;EAClE;EACA0J,0BAA0BA,CAACvL,YAAY,EAAE;IACrC;IACA;IACA;IACA,IAAIhD,KAAK,GAAG,IAAI,CAACF,aAAa,CAACG,SAAS;IACxC,MAAMuO,IAAI,GAAG,EAAE;IACf,MAAMC,iBAAiB,GAAGzL,YAAY,CAACqE,KAAK,CAAC,GAAG,CAAC;IACjD,OAAOoH,iBAAiB,CAAC3L,MAAM,GAAG,CAAC,EAAE;MACjC,MAAM4L,IAAI,GAAGD,iBAAiB,CAAC,CAAC,CAAC;MACjC,IAAI,EAAEzO,KAAK,KAAK,IAAI,IAAIA,KAAK,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,KAAK,CAAC+E,WAAW,CAAC,EAAE;QACpE;QACA;QACA;MACJ;MACA,IAAI/E,KAAK,CAACgF,QAAQ,CAAC2J,2BAA2B,CAACD,IAAI,CAAC,EAAE;QAClD;QACA;QACA;QACAD,iBAAiB,CAACG,OAAO,CAAE,GAAEH,iBAAiB,CAACI,KAAK,CAAC,CAAE,IAAGJ,iBAAiB,CAACI,KAAK,CAAC,CAAE,EAAC,CAAC;QACtF;MACJ;MACA,IAAI7O,KAAK,CAACgF,QAAQ,CAAC8J,2BAA2B,CAACJ,IAAI,CAAC,EAAE;QAClD;QACA;QACA;QACA,MAAMK,QAAQ,GAAG,IAAI,CAACjP,aAAa,CAACkP,cAAc,CAACC,IAAI,CAAEF,QAAQ,IAAKA,QAAQ,CAAC9L,oBAAoB,KAAKyL,IAAI,CAAC;QAC7G,IAAI,EAAEK,QAAQ,KAAK,IAAI,IAAIA,QAAQ,KAAK,KAAK,CAAC,GAAG,KAAK,CAAC,GAAGA,QAAQ,CAAC/O,KAAK,CAAC,EAAE;UACvE,MAAMkP,gBAAgB,GAAGV,IAAI,CAAC1L,MAAM,GAAG,CAAC,GAAI,GAAE0L,IAAI,CAACjH,IAAI,CAAC,GAAG,CAAE,IAAGmH,IAAK,EAAC,GAAGA,IAAI;UAC7E,MAAM,IAAIS,KAAK,CAAE,qCAAoCD,gBAAiB,EAAC,CAAC;QAC5E;QACAlP,KAAK,GAAG+O,QAAQ,CAAC/O,KAAK;QACtBwO,IAAI,CAAChJ,IAAI,CAAC,GAAGkJ,IAAI,CAACrH,KAAK,CAAC,GAAG,CAAC,CAAC;QAC7BoH,iBAAiB,CAACI,KAAK,CAAC,CAAC;QACzB;MACJ;MACA;IACJ;IACA,IAAI,CAAC7O,KAAK,EAAE;MACR,MAAM,IAAImP,KAAK,CAAE,kCAAiCnM,YAAa,EAAC,CAAC;IACrE;IACA;IACA,MAAMoM,iBAAiB,GAAGX,iBAAiB,CAAClH,IAAI,CAAC,GAAG,CAAC;IACrD,MAAMwB,OAAO,GAAG/I,KAAK,CAACgF,QAAQ,CAACkG,2BAA2B,CAACkE,iBAAiB,CAAC;IAC7E,IAAI,CAACrG,OAAO,CAACjG,MAAM,EAAE;MACjB,MAAM,IAAI5D,2BAA2B,CAAC8D,YAAY,EAAEhD,KAAK,CAACgF,QAAQ,CAAC;IACvE;IACA,OAAO,CAAChF,KAAK,EAAEwO,IAAI,EAAEzF,OAAO,CAAC;EACjC;EACA;AACJ;AACA;EACIsG,kBAAkBA,CAACrK,QAAQ,EAAEsK,MAAM,EAAEC,MAAM,GAAG,EAAE,EAAE;IAC9C,MAAMC,KAAK,GAAG,EAAE;IAChB,KAAK,MAAM3L,GAAG,IAAIQ,MAAM,CAACK,IAAI,CAAC4K,MAAM,CAAC,EAAE;MACnC,MAAMG,IAAI,GAAGF,MAAM,GAAI,GAAEA,MAAO,IAAG1L,GAAI,EAAC,GAAGA,GAAG;MAC9C;MACA;MACA,IAAIyL,MAAM,CAACzL,GAAG,CAAC,KAAK,IAAI,IACpB,OAAOyL,MAAM,CAACzL,GAAG,CAAC,KAAK,QAAQ,IAC/B1E,eAAe,CAACuQ,cAAc,CAACJ,MAAM,CAACzL,GAAG,CAAC,CAAC,EAAE;QAC7C2L,KAAK,CAAChK,IAAI,CAACiK,IAAI,CAAC;QAChB;MACJ;MACA,IAAIzK,QAAQ,CAAC2J,2BAA2B,CAACc,IAAI,CAAC,EAAE;QAC5C,MAAME,QAAQ,GAAG,IAAI,CAACN,kBAAkB,CAACrK,QAAQ,EAAEsK,MAAM,CAACzL,GAAG,CAAC,EAAE4L,IAAI,CAAC;QACrED,KAAK,CAAChK,IAAI,CAAC,GAAGmK,QAAQ,CAAC;QACvB;MACJ;MACA,IAAI3K,QAAQ,CAAC8J,2BAA2B,CAACW,IAAI,CAAC,EAAE;QAC5C,MAAMhN,QAAQ,GAAGuC,QAAQ,CAACrB,4BAA4B,CAAC8L,IAAI,CAAC;QAC5D;QACA;QACA;QACA;QACA;QACA;QACA,IAAIhN,QAAQ,CAACmN,YAAY,KAAK,YAAY,IACtCnN,QAAQ,CAACmN,YAAY,KAAK,aAAa,EAAE;UACzC,MAAMrH,WAAW,GAAG9F,QAAQ,CAAC8F,WAAW,CACnC7H,GAAG,CAAEmP,CAAC,IAAKA,CAAC,CAAChH,gBAAgB,CAAC,CAC9BxD,MAAM,CAAEwK,CAAC,IAAK,CAAC,CAACA,CAAC,CAAC;UACvB,MAAMC,iBAAiB,GAAGvH,WAAW,CAACzF,MAAM,GAAG,CAAC,IAC5CyF,WAAW,CAAC7E,KAAK,CAAEoF,MAAM,IAAKA,MAAM,CAAC4E,cAAc,CAAC4B,MAAM,CAACzL,GAAG,CAAC,EAAE,KAAK,CAAC,CAAC;UAC5E,IAAIiM,iBAAiB,EAAE;YACnBN,KAAK,CAAChK,IAAI,CAACiK,IAAI,CAAC;YAChB;UACJ;QACJ;QACA,IAAIhN,QAAQ,CAACmN,YAAY,KAAK,aAAa,IACvCnN,QAAQ,CAACmN,YAAY,KAAK,cAAc,EAAE;UAC1C,MAAM,IAAIT,KAAK,CAAE,uBAAsB1M,QAAQ,CAACmN,YAAa,iBAAgBH,IAAK,EAAC,CAAC;QACxF;QACA;QACA;QACA;QACA;QACA;QACA,MAAMnC,cAAc,GAAG7K,QAAQ,CAACsN,qBAAqB,CAACzC,cAAc;QACpE,MAAM0C,iBAAiB,GAAG1C,cAAc,CAACxK,MAAM,GAAG,CAAC,IAC/CwK,cAAc,CAAC5J,KAAK,CAAEoF,MAAM,IAAKA,MAAM,CAAC4E,cAAc,CAAC4B,MAAM,CAACzL,GAAG,CAAC,EAAE,KAAK,CAAC,CAAC;QAC/E,IAAImM,iBAAiB,EAAE;UACnB,MAAML,QAAQ,GAAGrC,cAAc,CAAC5M,GAAG,CAAEoI,MAAM,IAAM,GAAE2G,IAAK,IAAG3G,MAAM,CAAC9F,YAAa,EAAC,CAAC;UACjFwM,KAAK,CAAChK,IAAI,CAAC,GAAGmK,QAAQ,CAAC;UACvB;QACJ;QACA;QACA,MAAMA,QAAQ,GAAG,IAAI,CAACN,kBAAkB,CAAC5M,QAAQ,CAACsN,qBAAqB,EAAET,MAAM,CAACzL,GAAG,CAAC,CAAC,CAACnD,GAAG,CAAE6I,CAAC,IAAM,GAAEkG,IAAK,IAAGlG,CAAE,EAAC,CAAC;QAChHiG,KAAK,CAAChK,IAAI,CAAC,GAAGmK,QAAQ,CAAC;QACvB;MACJ;MACAH,KAAK,CAAChK,IAAI,CAACiK,IAAI,CAAC;IACpB;IACA,OAAOD,KAAK;EAChB;EACA,CAACS,aAAaA,CAACnC,KAAK,EAAE;IAClB,IAAI,IAAI,CAAChO,aAAa,CAACG,SAAS,CAAC8E,WAAW,EAAE;MAC1C,MAAMmL,aAAa,GAAG,IAAI,CAACb,kBAAkB,CAAC,IAAI,CAACvP,aAAa,CAACG,SAAS,CAAC+E,QAAQ,EAAE8I,KAAK,CAAC;MAC3F,KAAK,MAAM9K,YAAY,IAAIkN,aAAa,EAAE;QACtC,MAAM,CAAClQ,KAAK,EAAEoP,iBAAiB,EAAErG,OAAO,CAAC,GAAG,IAAI,CAACwF,0BAA0B,CAACvL,YAAY,CAAC;QACzF,KAAK,MAAM8F,MAAM,IAAIC,OAAO,EAAE;UAC1B,IAAIoH,cAAc,GAAGrC,KAAK;UAC1B,KAAK,MAAMY,IAAI,IAAIU,iBAAiB,EAAE;YAClC,IAAI,CAACe,cAAc,IAAI,EAAEzB,IAAI,IAAIyB,cAAc,CAAC,EAAE;cAC9CA,cAAc,GAAG,CAAC,CAAC;cACnB;YACJ;YACAA,cAAc,GAAGA,cAAc,CAACzB,IAAI,CAAC;UACzC;UACA;UACA,MAAM0B,SAAS,GAAG,IAAI,CAACtQ,aAAa,CAC/BwI,yBAAyB,GACvB,GAAEtI,KAAK,CAACE,IAAK,IAAG4I,MAAM,CAAC9F,YAAa,EAAC,GACtC8F,MAAM,CAAC9F,YAAY;UACzB,MAAMqN,cAAc,GAAGvH,MAAM,CAAC4E,cAAc,CAACyC,cAAc,EAAE,IAAI,CAAC;UAClE,MAAM,CAACC,SAAS,EAAEC,cAAc,CAAC;QACrC;MACJ;IACJ,CAAC,MACI;MACD,KAAK,MAAMxM,GAAG,IAAIQ,MAAM,CAACK,IAAI,CAACoJ,KAAK,CAAC,EAAE;QAClC,MAAMuC,cAAc,GAAGvC,KAAK,CAACjK,GAAG,CAAC;QACjC,MAAMuM,SAAS,GAAG,IAAI,CAACtQ,aAAa,CAACwI,yBAAyB,GACvD,GAAE,IAAI,CAACtI,KAAM,IAAG6D,GAAI,EAAC,GACtBA,GAAG;QACT,MAAM,CAACuM,SAAS,EAAEC,cAAc,CAAC;MACrC;IACJ;EACJ;EACAC,0BAA0BA,CAACF,SAAS,EAAEC,cAAc,EAAE;IAClD,IAAIlR,eAAe,CAACuQ,cAAc,CAACW,cAAc,CAAC,EAAE;MAChD,IAAIrM,UAAU,GAAG,EAAE;MACnB,IAAIqM,cAAc,CAACE,YAAY,EAAE;QAC7B,IAAIF,cAAc,CAACG,uBAAuB,EAAE;UACxC,IAAI,CAACpM,aAAa,CAACiM,cAAc,CAACG,uBAAuB,CAAC;QAC9D,CAAC,MACI,IAAIH,cAAc,CAACI,kBAAkB,EAAE;UACxC,KAAK,MAAMC,CAAC,IAAIL,cAAc,CAACnM,KAAK,EAAE;YAClCF,UAAU,CAACwB,IAAI,CAAC,IAAI,CAACjB,eAAe,CAACmM,CAAC,CAAC,CAAC;UAC5C;QACJ,CAAC,MACI;UACD1M,UAAU,CAACwB,IAAI,CAAC,IAAI,CAACjB,eAAe,CAAC8L,cAAc,CAACnM,KAAK,CAAC,CAAC;QAC/D;MACJ;MACA,IAAImM,cAAc,CAAC3I,IAAI,KAAK,KAAK,EAAE;QAC/B,IAAI2I,cAAc,CAACvK,MAAM,EAAE;UACvB,OAAOuK,cAAc,CAACvK,MAAM,CAACsK,SAAS,CAAC;QAC3C,CAAC,MACI;UACD,OAAO;YACH1E,QAAQ,EAAE,OAAO;YACjB1H,UAAU,EAAE,CAACoM,SAAS,EAAEC,cAAc,CAACnM,KAAK;UAChD,CAAC;QACL;MACJ,CAAC,MACI,IAAImM,cAAc,CAAC3I,IAAI,KAAK,KAAK,EAAE;QACpC,IAAI2I,cAAc,CAACM,KAAK,EAAE;UACtB,OAAO;YACHjF,QAAQ,EAAE2E,cAAc,CAAC3I,IAAI;YAC7ByC,SAAS,EAAE,IAAI,CAACmG,0BAA0B,CAACF,SAAS,EAAEC,cAAc,CAACM,KAAK;UAC9E,CAAC;QACL,CAAC,MACI;UACD,OAAO;YACHjF,QAAQ,EAAE,UAAU;YACpB1H,UAAU,EAAE,CAACoM,SAAS,EAAE,GAAGpM,UAAU;UACzC,CAAC;QACL;MACJ,CAAC,MACI,IAAIqM,cAAc,CAAC3I,IAAI,KAAK,KAAK,EAAE;QACpC,MAAMvC,MAAM,GAAGkL,cAAc,CAACnM,KAAK;QACnC,OAAO;UACHwH,QAAQ,EAAE2E,cAAc,CAAC3I,IAAI;UAC7B1D,UAAU,EAAEmB,MAAM,CAACzE,GAAG,CAAEgL,QAAQ,IAAK,IAAI,CAACH,8BAA8B,CAAC,IAAI,CAAC+E,0BAA0B,CAACF,SAAS,EAAE1E,QAAQ,CAAC,CAAC;QAClI,CAAC;MACL,CAAC,MACI;QACD,OAAO;UACHA,QAAQ,EAAE2E,cAAc,CAAC3I,IAAI;UAC7B1D,UAAU,EAAE,CAACoM,SAAS,EAAE,GAAGpM,UAAU;QACzC,CAAC;MACL;MACA;MACA;MACA;MACA;MACA;MACA;MACA;IACJ,CAAC,MACI;MACD,OAAO;QACH0H,QAAQ,EAAE,OAAO;QACjB1H,UAAU,EAAE,CAACoM,SAAS,EAAE,IAAI,CAAC7L,eAAe,CAAC8L,cAAc,CAAC;MAChE,CAAC;IACL;EACJ;EACAO,iBAAiBA,CAAC9C,KAAK,EAAE;IACrB,IAAI,OAAOA,KAAK,KAAK,QAAQ,EAAE;MAC3B,OAAOA,KAAK;IAChB;IACA,IAAI3O,eAAe,CAAC0R,UAAU,CAAC/C,KAAK,CAAC,EAAE;MACnC,MAAMgD,iBAAiB,GAAG,IAAI,CAACtK,kBAAkB,CAAC,CAAC;MACnDsK,iBAAiB,CAAC/M,kBAAkB,GAAG,IAAI;MAC3C+M,iBAAiB,CAAChR,aAAa,CAACG,SAAS,GACrC,IAAI,CAACH,aAAa,CAACG,SAAS;MAChC6Q,iBAAiB,CAAChR,aAAa,CAACwI,yBAAyB,GACrD,IAAI,CAACxI,aAAa,CAACwI,yBAAyB;MAChDwI,iBAAiB,CAAChR,aAAa,CAACkE,UAAU,GACtC,IAAI,CAAClE,aAAa,CAACkE,UAAU;MACjC8M,iBAAiB,CAAChR,aAAa,CAAC8E,gBAAgB,GAC5C,IAAI,CAAC9E,aAAa,CAAC8E,gBAAgB;MACvCkM,iBAAiB,CAAChR,aAAa,CAACkK,MAAM,GAAG,EAAE;MAC3C8D,KAAK,CAACiD,YAAY,CAACD,iBAAiB,CAAC;MACrC,OAAO;QACHpF,QAAQ,EAAEvM,eAAe,CAAC6R,aAAa,CAAClD,KAAK,CAAC,GACxC,KAAK,GACL,UAAU;QAChB3D,SAAS,EAAE2G,iBAAiB,CAAChR,aAAa,CAACkK;MAC/C,CAAC;IACL;IACA,IAAI,OAAO8D,KAAK,KAAK,UAAU,EAAE;MAC7B,OAAOA,KAAK,CAAC,IAAI,CAAC;IACtB;IACA,MAAM9D,MAAM,GAAGzJ,KAAK,CAACC,OAAO,CAACsN,KAAK,CAAC,GAAGA,KAAK,GAAG,CAACA,KAAK,CAAC;IACrD,MAAM3C,OAAO,GAAG,EAAE;IAClB,KAAK,MAAM2C,KAAK,IAAI9D,MAAM,EAAE;MACxB,MAAMiH,UAAU,GAAG,EAAE;MACrB;MACA,KAAK,MAAM,CAACb,SAAS,EAAEC,cAAc,CAAC,IAAI,IAAI,CAACJ,aAAa,CAACnC,KAAK,CAAC,EAAE;QACjEmD,UAAU,CAACzL,IAAI,CAAC;UACZkC,IAAI,EAAE,KAAK;UACXyC,SAAS,EAAE,IAAI,CAACmG,0BAA0B,CAACF,SAAS,EAAEC,cAAc;QACxE,CAAC,CAAC;MACN;MACAlF,OAAO,CAAC3F,IAAI,CAAC;QAAEkC,IAAI,EAAE,IAAI;QAAEyC,SAAS,EAAE8G;MAAW,CAAC,CAAC;IACvD;IACA,IAAI9F,OAAO,CAACrI,MAAM,KAAK,CAAC,EAAE;MACtB,OAAOqI,OAAO,CAAC,CAAC,CAAC,CAAChB,SAAS;IAC/B;IACA,OAAOgB,OAAO;EAClB;EACA;AACJ;AACA;EACI7E,iBAAiBA,CAAA,EAAG;IAChB,OAAO,IAAI,CAAC9G,WAAW,IAAI,IAAI,CAACK,UAAU,CAACqR,iBAAiB,CAAC,CAAC;EAClE;EACApF,yBAAyBA,CAAA,EAAG;IACxB,OAAO,IAAI,CAAChM,aAAa,CAACoH,sBAAsB,CAACpE,MAAM,GAAG,CAAC;EAC/D;AACJ"},"metadata":{},"sourceType":"module","externalDependencies":[]}