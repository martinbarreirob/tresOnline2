{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/practicas/Downloads/angular/tresOnline/frontend-tres-en-raya/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { Table } from \"./table/Table\";\nimport { TableColumn } from \"./table/TableColumn\";\nimport { TableForeignKey } from \"./table/TableForeignKey\";\nimport { TableIndex } from \"./table/TableIndex\";\nimport { TableUtils } from \"./util/TableUtils\";\nimport { TableUnique } from \"./table/TableUnique\";\nimport { TableCheck } from \"./table/TableCheck\";\nimport { TableExclusion } from \"./table/TableExclusion\";\nimport { View } from \"./view/View\";\nimport { ViewUtils } from \"./util/ViewUtils\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\n/**\n * Creates complete tables schemas in the database based on the entity metadatas.\n *\n * Steps how schema is being built:\n * 1. load list of all tables with complete column and keys information from the db\n * 2. drop all (old) foreign keys that exist in the table, but does not exist in the metadata\n * 3. create new tables that does not exist in the db, but exist in the metadata\n * 4. drop all columns exist (left old) in the db table, but does not exist in the metadata\n * 5. add columns from metadata which does not exist in the table\n * 6. update all exist columns which metadata has changed\n * 7. update primary keys - update old and create new primary key from changed columns\n * 8. create foreign keys which does not exist in the table yet\n * 9. create indices which are missing in db yet, and drops indices which exist in the db, but does not exist in the metadata anymore\n */\nexport class RdbmsSchemaBuilder {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection) {\n    this.connection = connection;\n    this[\"@instanceof\"] = Symbol.for(\"RdbmsSchemaBuilder\");\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Creates complete schemas for the given entity metadatas.\n   */\n  build() {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      _this.queryRunner = _this.connection.createQueryRunner();\n      // this.connection.driver.database || this.currentDatabase;\n      _this.currentDatabase = _this.connection.driver.database;\n      _this.currentSchema = _this.connection.driver.schema;\n      // CockroachDB implements asynchronous schema sync operations which can not been executed in transaction.\n      // E.g. if you try to DROP column and ADD it again in the same transaction, crdb throws error.\n      // In Spanner queries against the INFORMATION_SCHEMA can be used in a read-only transaction,\n      // but not in a read-write transaction.\n      const isUsingTransactions = !(_this.connection.driver.options.type === \"cockroachdb\") && !(_this.connection.driver.options.type === \"spanner\") && _this.connection.options.migrationsTransactionMode !== \"none\";\n      yield _this.queryRunner.beforeMigration();\n      if (isUsingTransactions) {\n        yield _this.queryRunner.startTransaction();\n      }\n      try {\n        yield _this.createMetadataTableIfNecessary(_this.queryRunner);\n        // Flush the queryrunner table & view cache\n        const tablePaths = _this.entityToSyncMetadatas.map(metadata => _this.getTablePath(metadata));\n        const viewPaths = _this.viewEntityToSyncMetadatas.map(metadata => _this.getTablePath(metadata));\n        yield _this.queryRunner.getTables(tablePaths);\n        yield _this.queryRunner.getViews(viewPaths);\n        yield _this.executeSchemaSyncOperationsInProperOrder();\n        // if cache is enabled then perform cache-synchronization as well\n        if (_this.connection.queryResultCache) yield _this.connection.queryResultCache.synchronize(_this.queryRunner);\n        if (isUsingTransactions) {\n          yield _this.queryRunner.commitTransaction();\n        }\n      } catch (error) {\n        try {\n          // we throw original error even if rollback thrown an error\n          if (isUsingTransactions) {\n            yield _this.queryRunner.rollbackTransaction();\n          }\n        } catch (rollbackError) {}\n        throw error;\n      } finally {\n        yield _this.queryRunner.afterMigration();\n        yield _this.queryRunner.release();\n      }\n    })();\n  }\n  /**\n   * Create the typeorm_metadata table if necessary.\n   */\n  createMetadataTableIfNecessary(queryRunner) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      if (_this2.viewEntityToSyncMetadatas.length > 0 || _this2.hasGeneratedColumns()) {\n        yield _this2.createTypeormMetadataTable(queryRunner);\n      }\n    })();\n  }\n  /**\n   * Returns sql queries to be executed by schema builder.\n   */\n  log() {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      _this3.queryRunner = _this3.connection.createQueryRunner();\n      try {\n        // Flush the queryrunner table & view cache\n        const tablePaths = _this3.entityToSyncMetadatas.map(metadata => _this3.getTablePath(metadata));\n        const viewPaths = _this3.viewEntityToSyncMetadatas.map(metadata => _this3.getTablePath(metadata));\n        yield _this3.queryRunner.getTables(tablePaths);\n        yield _this3.queryRunner.getViews(viewPaths);\n        _this3.queryRunner.enableSqlMemory();\n        yield _this3.executeSchemaSyncOperationsInProperOrder();\n        // if cache is enabled then perform cache-synchronization as well\n        if (_this3.connection.queryResultCache)\n          // todo: check this functionality\n          yield _this3.connection.queryResultCache.synchronize(_this3.queryRunner);\n        return _this3.queryRunner.getMemorySql();\n      } finally {\n        // its important to disable this mode despite the fact we are release query builder\n        // because there exist drivers which reuse same query runner. Also its important to disable\n        // sql memory after call of getMemorySql() method because last one flushes sql memory.\n        _this3.queryRunner.disableSqlMemory();\n        yield _this3.queryRunner.release();\n      }\n    })();\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Returns only entities that should be synced in the database.\n   */\n  get entityToSyncMetadatas() {\n    return this.connection.entityMetadatas.filter(metadata => metadata.synchronize && metadata.tableType !== \"entity-child\" && metadata.tableType !== \"view\");\n  }\n  /**\n   * Returns only entities that should be synced in the database.\n   */\n  get viewEntityToSyncMetadatas() {\n    return this.connection.entityMetadatas.filter(metadata => metadata.tableType === \"view\" && metadata.synchronize)\n    // sort views in creation order by dependencies\n    .sort(ViewUtils.viewMetadataCmp);\n  }\n  /**\n   * Checks if there are at least one generated column.\n   */\n  hasGeneratedColumns() {\n    return this.connection.entityMetadatas.some(entityMetadata => {\n      return entityMetadata.columns.some(column => column.generatedType);\n    });\n  }\n  /**\n   * Executes schema sync operations in a proper order.\n   * Order of operations matter here.\n   */\n  executeSchemaSyncOperationsInProperOrder() {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      yield _this4.dropOldViews();\n      yield _this4.dropOldForeignKeys();\n      yield _this4.dropOldIndices();\n      yield _this4.dropOldChecks();\n      yield _this4.dropOldExclusions();\n      yield _this4.dropCompositeUniqueConstraints();\n      // await this.renameTables();\n      yield _this4.renameColumns();\n      yield _this4.createNewTables();\n      yield _this4.dropRemovedColumns();\n      yield _this4.addNewColumns();\n      yield _this4.updatePrimaryKeys();\n      yield _this4.updateExistColumns();\n      yield _this4.createNewIndices();\n      yield _this4.createNewChecks();\n      yield _this4.createNewExclusions();\n      yield _this4.createCompositeUniqueConstraints();\n      yield _this4.createForeignKeys();\n      yield _this4.createViews();\n      yield _this4.createNewViewIndices();\n    })();\n  }\n  getTablePath(target) {\n    const parsed = this.connection.driver.parseTableName(target);\n    return this.connection.driver.buildTableName(parsed.tableName, parsed.schema || this.currentSchema, parsed.database || this.currentDatabase);\n  }\n  /**\n   * Drops all (old) foreign keys that exist in the tables, but do not exist in the entity metadata.\n   */\n  dropOldForeignKeys() {\n    var _this5 = this;\n    return _asyncToGenerator(function* () {\n      for (const metadata of _this5.entityToSyncMetadatas) {\n        const table = _this5.queryRunner.loadedTables.find(table => _this5.getTablePath(table) === _this5.getTablePath(metadata));\n        if (!table) continue;\n        // find foreign keys that exist in the schemas but does not exist in the entity metadata\n        const tableForeignKeysToDrop = table.foreignKeys.filter(tableForeignKey => {\n          const metadataFK = metadata.foreignKeys.find(metadataForeignKey => tableForeignKey.name === metadataForeignKey.name && _this5.getTablePath(tableForeignKey) === _this5.getTablePath(metadataForeignKey.referencedEntityMetadata));\n          return !metadataFK || metadataFK.onDelete && metadataFK.onDelete !== tableForeignKey.onDelete || metadataFK.onUpdate && metadataFK.onUpdate !== tableForeignKey.onUpdate;\n        });\n        if (tableForeignKeysToDrop.length === 0) continue;\n        _this5.connection.logger.logSchemaBuild(`dropping old foreign keys of ${table.name}: ${tableForeignKeysToDrop.map(dbForeignKey => dbForeignKey.name).join(\", \")}`);\n        // drop foreign keys from the database\n        yield _this5.queryRunner.dropForeignKeys(table, tableForeignKeysToDrop);\n      }\n    })();\n  }\n  /**\n   * Rename tables\n   */\n  renameTables() {\n    return _asyncToGenerator(function* () {})();\n  } // for (const metadata of this.entityToSyncMetadatas) {\n  //     const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));\n  // }\n  /**\n   * Renames columns.\n   * Works if only one column per table was changed.\n   * Changes only column name. If something besides name was changed, these changes will be ignored.\n   */\n  renameColumns() {\n    var _this6 = this;\n    return _asyncToGenerator(function* () {\n      for (const metadata of _this6.entityToSyncMetadatas) {\n        const table = _this6.queryRunner.loadedTables.find(table => _this6.getTablePath(table) === _this6.getTablePath(metadata));\n        if (!table) continue;\n        if (metadata.columns.length !== table.columns.length) continue;\n        const renamedMetadataColumns = metadata.columns.filter(c => !c.isVirtualProperty).filter(column => {\n          return !table.columns.find(tableColumn => {\n            return tableColumn.name === column.databaseName && tableColumn.type === _this6.connection.driver.normalizeType(column) && tableColumn.isNullable === column.isNullable && tableColumn.isUnique === _this6.connection.driver.normalizeIsUnique(column);\n          });\n        });\n        if (renamedMetadataColumns.length === 0 || renamedMetadataColumns.length > 1) continue;\n        const renamedTableColumns = table.columns.filter(tableColumn => {\n          return !metadata.columns.find(column => {\n            return !column.isVirtualProperty && column.databaseName === tableColumn.name && _this6.connection.driver.normalizeType(column) === tableColumn.type && column.isNullable === tableColumn.isNullable && _this6.connection.driver.normalizeIsUnique(column) === tableColumn.isUnique;\n          });\n        });\n        if (renamedTableColumns.length === 0 || renamedTableColumns.length > 1) continue;\n        const renamedColumn = renamedTableColumns[0].clone();\n        renamedColumn.name = renamedMetadataColumns[0].databaseName;\n        _this6.connection.logger.logSchemaBuild(`renaming column \"${renamedTableColumns[0].name}\" in \"${table.name}\" to \"${renamedColumn.name}\"`);\n        yield _this6.queryRunner.renameColumn(table, renamedTableColumns[0], renamedColumn);\n      }\n    })();\n  }\n  dropOldIndices() {\n    var _this7 = this;\n    return _asyncToGenerator(function* () {\n      for (const metadata of _this7.entityToSyncMetadatas) {\n        const table = _this7.queryRunner.loadedTables.find(table => _this7.getTablePath(table) === _this7.getTablePath(metadata));\n        if (!table) continue;\n        const dropQueries = table.indices.filter(tableIndex => {\n          const indexMetadata = metadata.indices.find(index => index.name === tableIndex.name);\n          if (indexMetadata) {\n            if (indexMetadata.synchronize === false) return false;\n            if (indexMetadata.isUnique !== tableIndex.isUnique) return true;\n            if (indexMetadata.isSpatial !== tableIndex.isSpatial) return true;\n            if (_this7.connection.driver.isFullTextColumnTypeSupported() && indexMetadata.isFulltext !== tableIndex.isFulltext) return true;\n            if (indexMetadata.columns.length !== tableIndex.columnNames.length) return true;\n            return !indexMetadata.columns.every(column => tableIndex.columnNames.indexOf(column.databaseName) !== -1);\n          }\n          return true;\n        }).map( /*#__PURE__*/function () {\n          var _ref = _asyncToGenerator(function* (tableIndex) {\n            _this7.connection.logger.logSchemaBuild(`dropping an index: \"${tableIndex.name}\" from table ${table.name}`);\n            yield _this7.queryRunner.dropIndex(table, tableIndex);\n          });\n          return function (_x) {\n            return _ref.apply(this, arguments);\n          };\n        }());\n        yield Promise.all(dropQueries);\n      }\n      if (_this7.connection.options.type === \"postgres\") {\n        const postgresQueryRunner = _this7.queryRunner;\n        for (const metadata of _this7.viewEntityToSyncMetadatas) {\n          const view = _this7.queryRunner.loadedViews.find(view => _this7.getTablePath(view) === _this7.getTablePath(metadata));\n          if (!view) continue;\n          const dropQueries = view.indices.filter(tableIndex => {\n            const indexMetadata = metadata.indices.find(index => index.name === tableIndex.name);\n            if (indexMetadata) {\n              if (indexMetadata.synchronize === false) return false;\n              if (indexMetadata.isUnique !== tableIndex.isUnique) return true;\n              if (indexMetadata.isSpatial !== tableIndex.isSpatial) return true;\n              if (_this7.connection.driver.isFullTextColumnTypeSupported() && indexMetadata.isFulltext !== tableIndex.isFulltext) return true;\n              if (indexMetadata.columns.length !== tableIndex.columnNames.length) return true;\n              return !indexMetadata.columns.every(column => tableIndex.columnNames.indexOf(column.databaseName) !== -1);\n            }\n            return true;\n          }).map( /*#__PURE__*/function () {\n            var _ref2 = _asyncToGenerator(function* (tableIndex) {\n              _this7.connection.logger.logSchemaBuild(`dropping an index: \"${tableIndex.name}\" from view ${view.name}`);\n              yield postgresQueryRunner.dropViewIndex(view, tableIndex);\n            });\n            return function (_x2) {\n              return _ref2.apply(this, arguments);\n            };\n          }());\n          yield Promise.all(dropQueries);\n        }\n      }\n    })();\n  }\n  dropOldChecks() {\n    var _this8 = this;\n    return _asyncToGenerator(function* () {\n      // Mysql does not support check constraints\n      if (DriverUtils.isMySQLFamily(_this8.connection.driver) || _this8.connection.driver.options.type === \"aurora-mysql\") return;\n      for (const metadata of _this8.entityToSyncMetadatas) {\n        const table = _this8.queryRunner.loadedTables.find(table => _this8.getTablePath(table) === _this8.getTablePath(metadata));\n        if (!table) continue;\n        const oldChecks = table.checks.filter(tableCheck => {\n          return !metadata.checks.find(checkMetadata => checkMetadata.name === tableCheck.name);\n        });\n        if (oldChecks.length === 0) continue;\n        _this8.connection.logger.logSchemaBuild(`dropping old check constraint: ${oldChecks.map(check => `\"${check.name}\"`).join(\", \")} from table \"${table.name}\"`);\n        yield _this8.queryRunner.dropCheckConstraints(table, oldChecks);\n      }\n    })();\n  }\n  dropCompositeUniqueConstraints() {\n    var _this9 = this;\n    return _asyncToGenerator(function* () {\n      for (const metadata of _this9.entityToSyncMetadatas) {\n        const table = _this9.queryRunner.loadedTables.find(table => _this9.getTablePath(table) === _this9.getTablePath(metadata));\n        if (!table) continue;\n        const compositeUniques = table.uniques.filter(tableUnique => {\n          return tableUnique.columnNames.length > 1 && !metadata.uniques.find(uniqueMetadata => uniqueMetadata.name === tableUnique.name);\n        });\n        if (compositeUniques.length === 0) continue;\n        _this9.connection.logger.logSchemaBuild(`dropping old unique constraint: ${compositeUniques.map(unique => `\"${unique.name}\"`).join(\", \")} from table \"${table.name}\"`);\n        yield _this9.queryRunner.dropUniqueConstraints(table, compositeUniques);\n      }\n    })();\n  }\n  dropOldExclusions() {\n    var _this10 = this;\n    return _asyncToGenerator(function* () {\n      // Only PostgreSQL supports exclusion constraints\n      if (!(_this10.connection.driver.options.type === \"postgres\")) return;\n      for (const metadata of _this10.entityToSyncMetadatas) {\n        const table = _this10.queryRunner.loadedTables.find(table => _this10.getTablePath(table) === _this10.getTablePath(metadata));\n        if (!table) continue;\n        const oldExclusions = table.exclusions.filter(tableExclusion => {\n          return !metadata.exclusions.find(exclusionMetadata => exclusionMetadata.name === tableExclusion.name);\n        });\n        if (oldExclusions.length === 0) continue;\n        _this10.connection.logger.logSchemaBuild(`dropping old exclusion constraint: ${oldExclusions.map(exclusion => `\"${exclusion.name}\"`).join(\", \")} from table \"${table.name}\"`);\n        yield _this10.queryRunner.dropExclusionConstraints(table, oldExclusions);\n      }\n    })();\n  }\n  /**\n   * Creates tables that do not exist in the database yet.\n   * New tables are created without foreign and primary keys.\n   * Primary key only can be created in conclusion with auto generated column.\n   */\n  createNewTables() {\n    var _this11 = this;\n    return _asyncToGenerator(function* () {\n      for (const metadata of _this11.entityToSyncMetadatas) {\n        // check if table does not exist yet\n        const existTable = _this11.queryRunner.loadedTables.find(table => _this11.getTablePath(table) === _this11.getTablePath(metadata));\n        if (existTable) continue;\n        _this11.connection.logger.logSchemaBuild(`creating a new table: ${_this11.getTablePath(metadata)}`);\n        // create a new table and sync it in the database\n        const table = Table.create(metadata, _this11.connection.driver);\n        yield _this11.queryRunner.createTable(table, false, false);\n        _this11.queryRunner.loadedTables.push(table);\n      }\n    })();\n  }\n  createViews() {\n    var _this12 = this;\n    return _asyncToGenerator(function* () {\n      for (const metadata of _this12.viewEntityToSyncMetadatas) {\n        // check if view does not exist yet\n        const existView = _this12.queryRunner.loadedViews.find(view => {\n          const viewExpression = typeof view.expression === \"string\" ? view.expression.trim() : view.expression(_this12.connection).getQuery();\n          const metadataExpression = typeof metadata.expression === \"string\" ? metadata.expression.trim() : metadata.expression(_this12.connection).getQuery();\n          return _this12.getTablePath(view) === _this12.getTablePath(metadata) && viewExpression === metadataExpression;\n        });\n        if (existView) continue;\n        _this12.connection.logger.logSchemaBuild(`creating a new view: ${_this12.getTablePath(metadata)}`);\n        // create a new view and sync it in the database\n        const view = View.create(metadata, _this12.connection.driver);\n        yield _this12.queryRunner.createView(view, true);\n        _this12.queryRunner.loadedViews.push(view);\n      }\n    })();\n  }\n  dropOldViews() {\n    var _this13 = this;\n    return _asyncToGenerator(function* () {\n      const droppedViews = [];\n      const viewEntityToSyncMetadatas = _this13.viewEntityToSyncMetadatas;\n      // BuIld lookup cache for finding views metadata\n      const viewToMetadata = new Map();\n      for (const view of _this13.queryRunner.loadedViews) {\n        const viewMetadata = viewEntityToSyncMetadatas.find(metadata => {\n          return _this13.getTablePath(view) === _this13.getTablePath(metadata);\n        });\n        if (viewMetadata) {\n          viewToMetadata.set(view, viewMetadata);\n        }\n      }\n      // Gather all changed view, that need a drop\n      for (const view of _this13.queryRunner.loadedViews) {\n        const viewMetadata = viewToMetadata.get(view);\n        if (!viewMetadata) {\n          continue;\n        }\n        const viewExpression = typeof view.expression === \"string\" ? view.expression.trim() : view.expression(_this13.connection).getQuery();\n        const metadataExpression = typeof viewMetadata.expression === \"string\" ? viewMetadata.expression.trim() : viewMetadata.expression(_this13.connection).getQuery();\n        if (viewExpression === metadataExpression) continue;\n        _this13.connection.logger.logSchemaBuild(`dropping an old view: ${view.name}`);\n        // Collect view to be dropped\n        droppedViews.push(view);\n      }\n      // Helper function that for a given view, will recursively return list of the view and all views that depend on it\n      const viewDependencyChain = view => {\n        // Get the view metadata\n        const viewMetadata = viewToMetadata.get(view);\n        let viewWithDependencies = [view];\n        // If no metadata is known for the view, simply return the view itself\n        if (!viewMetadata) {\n          return viewWithDependencies;\n        }\n        // Iterate over all known views\n        for (const [currentView, currentMetadata] of viewToMetadata.entries()) {\n          // Ignore self reference\n          if (currentView === view) {\n            continue;\n          }\n          // If the currently iterated view depends on the passed in view\n          if (currentMetadata.dependsOn && (currentMetadata.dependsOn.has(viewMetadata.target) || currentMetadata.dependsOn.has(viewMetadata.name))) {\n            // Recursively add currently iterate view and its dependents\n            viewWithDependencies = viewWithDependencies.concat(viewDependencyChain(currentView));\n          }\n        }\n        // Return all collected views\n        return viewWithDependencies;\n      };\n      // Collect final list of views to be dropped in a Set so there are no duplicates\n      const droppedViewsWithDependencies = new Set(\n      // Collect all dropped views, and their dependencies\n      droppedViews.map(view => viewDependencyChain(view))\n      // Flattened to single Array ( can be replaced with flatMap, once supported)\n      .reduce((all, segment) => {\n        return all.concat(segment);\n      }, [])\n      // Sort the views to be dropped in creation order\n      .sort((a, b) => {\n        return ViewUtils.viewMetadataCmp(viewToMetadata.get(a), viewToMetadata.get(b));\n      })\n      // reverse order to get drop order\n      .reverse());\n      // Finally emit all drop views\n      for (const view of droppedViewsWithDependencies) {\n        yield _this13.queryRunner.dropView(view);\n      }\n      _this13.queryRunner.loadedViews = _this13.queryRunner.loadedViews.filter(view => !droppedViewsWithDependencies.has(view));\n    })();\n  }\n  /**\n   * Drops all columns that exist in the table, but does not exist in the metadata (left old).\n   * We drop their keys too, since it should be safe.\n   */\n  dropRemovedColumns() {\n    var _this14 = this;\n    return _asyncToGenerator(function* () {\n      for (const metadata of _this14.entityToSyncMetadatas) {\n        const table = _this14.queryRunner.loadedTables.find(table => _this14.getTablePath(table) === _this14.getTablePath(metadata));\n        if (!table) continue;\n        // find columns that exist in the database but does not exist in the metadata\n        const droppedTableColumns = table.columns.filter(tableColumn => {\n          return !metadata.columns.find(columnMetadata => columnMetadata.isVirtualProperty || columnMetadata.databaseName === tableColumn.name);\n        });\n        if (droppedTableColumns.length === 0) continue;\n        _this14.connection.logger.logSchemaBuild(`columns dropped in ${table.name}: ` + droppedTableColumns.map(column => column.name).join(\", \"));\n        // drop columns from the database\n        yield _this14.queryRunner.dropColumns(table, droppedTableColumns);\n      }\n    })();\n  }\n  /**\n   * Adds columns from metadata which does not exist in the table.\n   * Columns are created without keys.\n   */\n  addNewColumns() {\n    var _this15 = this;\n    return _asyncToGenerator(function* () {\n      for (const metadata of _this15.entityToSyncMetadatas) {\n        const table = _this15.queryRunner.loadedTables.find(table => _this15.getTablePath(table) === _this15.getTablePath(metadata));\n        if (!table) continue;\n        // find which columns are new\n        const newColumnMetadatas = metadata.columns.filter(columnMetadata => {\n          return !columnMetadata.isVirtualProperty && !table.columns.find(tableColumn => tableColumn.name === columnMetadata.databaseName);\n        });\n        if (newColumnMetadatas.length === 0) continue;\n        // create columns in the database\n        const newTableColumnOptions = _this15.metadataColumnsToTableColumnOptions(newColumnMetadatas);\n        const newTableColumns = newTableColumnOptions.map(option => new TableColumn(option));\n        if (newTableColumns.length === 0) continue;\n        _this15.connection.logger.logSchemaBuild(`new columns added: ` + newColumnMetadatas.map(column => column.databaseName).join(\", \"));\n        yield _this15.queryRunner.addColumns(table, newTableColumns);\n      }\n    })();\n  }\n  /**\n   * Updates composite primary keys.\n   */\n  updatePrimaryKeys() {\n    var _this16 = this;\n    return _asyncToGenerator(function* () {\n      for (const metadata of _this16.entityToSyncMetadatas) {\n        const table = _this16.queryRunner.loadedTables.find(table => _this16.getTablePath(table) === _this16.getTablePath(metadata));\n        if (!table) continue;\n        const primaryMetadataColumns = metadata.columns.filter(column => column.isPrimary);\n        const primaryTableColumns = table.columns.filter(column => column.isPrimary);\n        if (primaryTableColumns.length !== primaryMetadataColumns.length && primaryMetadataColumns.length > 1) {\n          const changedPrimaryColumns = primaryMetadataColumns.map(primaryMetadataColumn => {\n            return new TableColumn(TableUtils.createTableColumnOptions(primaryMetadataColumn, _this16.connection.driver));\n          });\n          yield _this16.queryRunner.updatePrimaryKeys(table, changedPrimaryColumns);\n        }\n      }\n    })();\n  }\n  /**\n   * Update all exist columns which metadata has changed.\n   * Still don't create keys. Also we don't touch foreign keys of the changed columns.\n   */\n  updateExistColumns() {\n    var _this17 = this;\n    return _asyncToGenerator(function* () {\n      for (const metadata of _this17.entityToSyncMetadatas) {\n        const table = _this17.queryRunner.loadedTables.find(table => _this17.getTablePath(table) === _this17.getTablePath(metadata));\n        if (!table) continue;\n        const changedColumns = _this17.connection.driver.findChangedColumns(table.columns, metadata.columns);\n        if (changedColumns.length === 0) continue;\n        // drop all foreign keys that point to this column\n        for (const changedColumn of changedColumns) {\n          yield _this17.dropColumnReferencedForeignKeys(_this17.getTablePath(metadata), changedColumn.databaseName);\n        }\n        // drop all composite indices related to this column\n        for (const changedColumn of changedColumns) {\n          yield _this17.dropColumnCompositeIndices(_this17.getTablePath(metadata), changedColumn.databaseName);\n        }\n        // drop all composite uniques related to this column\n        // Mysql does not support unique constraints.\n        if (!(DriverUtils.isMySQLFamily(_this17.connection.driver) || _this17.connection.driver.options.type === \"aurora-mysql\" || _this17.connection.driver.options.type === \"spanner\")) {\n          for (const changedColumn of changedColumns) {\n            yield _this17.dropColumnCompositeUniques(_this17.getTablePath(metadata), changedColumn.databaseName);\n          }\n        }\n        // generate a map of new/old columns\n        const newAndOldTableColumns = changedColumns.map(changedColumn => {\n          const oldTableColumn = table.columns.find(column => column.name === changedColumn.databaseName);\n          const newTableColumnOptions = TableUtils.createTableColumnOptions(changedColumn, _this17.connection.driver);\n          const newTableColumn = new TableColumn(newTableColumnOptions);\n          return {\n            oldColumn: oldTableColumn,\n            newColumn: newTableColumn\n          };\n        });\n        if (newAndOldTableColumns.length === 0) continue;\n        _this17.connection.logger.logSchemaBuild(`columns changed in \"${table.name}\". updating: ` + changedColumns.map(column => column.databaseName).join(\", \"));\n        yield _this17.queryRunner.changeColumns(table, newAndOldTableColumns);\n      }\n    })();\n  }\n  /**\n   * Creates composite indices which are missing in db yet.\n   */\n  createNewIndices() {\n    var _this18 = this;\n    return _asyncToGenerator(function* () {\n      for (const metadata of _this18.entityToSyncMetadatas) {\n        const table = _this18.queryRunner.loadedTables.find(table => _this18.getTablePath(table) === _this18.getTablePath(metadata));\n        if (!table) continue;\n        const newIndices = metadata.indices.filter(indexMetadata => !table.indices.find(tableIndex => tableIndex.name === indexMetadata.name) && indexMetadata.synchronize === true).map(indexMetadata => TableIndex.create(indexMetadata));\n        if (newIndices.length === 0) continue;\n        _this18.connection.logger.logSchemaBuild(`adding new indices ${newIndices.map(index => `\"${index.name}\"`).join(\", \")} in table \"${table.name}\"`);\n        yield _this18.queryRunner.createIndices(table, newIndices);\n      }\n    })();\n  }\n  /**\n   * Creates indices for materialized views.\n   */\n  createNewViewIndices() {\n    var _this19 = this;\n    return _asyncToGenerator(function* () {\n      // Only PostgreSQL supports indices for materialized views.\n      if (_this19.connection.options.type !== \"postgres\" || !DriverUtils.isPostgresFamily(_this19.connection.driver)) {\n        return;\n      }\n      const postgresQueryRunner = _this19.queryRunner;\n      for (const metadata of _this19.viewEntityToSyncMetadatas) {\n        // check if view does not exist yet\n        const view = _this19.queryRunner.loadedViews.find(view => {\n          const viewExpression = typeof view.expression === \"string\" ? view.expression.trim() : view.expression(_this19.connection).getQuery();\n          const metadataExpression = typeof metadata.expression === \"string\" ? metadata.expression.trim() : metadata.expression(_this19.connection).getQuery();\n          return _this19.getTablePath(view) === _this19.getTablePath(metadata) && viewExpression === metadataExpression;\n        });\n        if (!view || !view.materialized) continue;\n        const newIndices = metadata.indices.filter(indexMetadata => !view.indices.find(tableIndex => tableIndex.name === indexMetadata.name) && indexMetadata.synchronize === true).map(indexMetadata => TableIndex.create(indexMetadata));\n        if (newIndices.length === 0) continue;\n        _this19.connection.logger.logSchemaBuild(`adding new indices ${newIndices.map(index => `\"${index.name}\"`).join(\", \")} in view \"${view.name}\"`);\n        yield postgresQueryRunner.createViewIndices(view, newIndices);\n      }\n    })();\n  }\n  createNewChecks() {\n    var _this20 = this;\n    return _asyncToGenerator(function* () {\n      // Mysql does not support check constraints\n      if (DriverUtils.isMySQLFamily(_this20.connection.driver) || _this20.connection.driver.options.type === \"aurora-mysql\") return;\n      for (const metadata of _this20.entityToSyncMetadatas) {\n        const table = _this20.queryRunner.loadedTables.find(table => _this20.getTablePath(table) === _this20.getTablePath(metadata));\n        if (!table) continue;\n        const newChecks = metadata.checks.filter(checkMetadata => !table.checks.find(tableCheck => tableCheck.name === checkMetadata.name)).map(checkMetadata => TableCheck.create(checkMetadata));\n        if (newChecks.length === 0) continue;\n        _this20.connection.logger.logSchemaBuild(`adding new check constraints: ${newChecks.map(index => `\"${index.name}\"`).join(\", \")} in table \"${table.name}\"`);\n        yield _this20.queryRunner.createCheckConstraints(table, newChecks);\n      }\n    })();\n  }\n  /**\n   * Creates composite uniques which are missing in db yet.\n   */\n  createCompositeUniqueConstraints() {\n    var _this21 = this;\n    return _asyncToGenerator(function* () {\n      for (const metadata of _this21.entityToSyncMetadatas) {\n        const table = _this21.queryRunner.loadedTables.find(table => _this21.getTablePath(table) === _this21.getTablePath(metadata));\n        if (!table) continue;\n        const compositeUniques = metadata.uniques.filter(uniqueMetadata => uniqueMetadata.columns.length > 1 && !table.uniques.find(tableUnique => tableUnique.name === uniqueMetadata.name)).map(uniqueMetadata => TableUnique.create(uniqueMetadata));\n        if (compositeUniques.length === 0) continue;\n        _this21.connection.logger.logSchemaBuild(`adding new unique constraints: ${compositeUniques.map(unique => `\"${unique.name}\"`).join(\", \")} in table \"${table.name}\"`);\n        yield _this21.queryRunner.createUniqueConstraints(table, compositeUniques);\n      }\n    })();\n  }\n  /**\n   * Creates exclusions which are missing in db yet.\n   */\n  createNewExclusions() {\n    var _this22 = this;\n    return _asyncToGenerator(function* () {\n      // Only PostgreSQL supports exclusion constraints\n      if (!(_this22.connection.driver.options.type === \"postgres\")) return;\n      for (const metadata of _this22.entityToSyncMetadatas) {\n        const table = _this22.queryRunner.loadedTables.find(table => _this22.getTablePath(table) === _this22.getTablePath(metadata));\n        if (!table) continue;\n        const newExclusions = metadata.exclusions.filter(exclusionMetadata => !table.exclusions.find(tableExclusion => tableExclusion.name === exclusionMetadata.name)).map(exclusionMetadata => TableExclusion.create(exclusionMetadata));\n        if (newExclusions.length === 0) continue;\n        _this22.connection.logger.logSchemaBuild(`adding new exclusion constraints: ${newExclusions.map(exclusion => `\"${exclusion.name}\"`).join(\", \")} in table \"${table.name}\"`);\n        yield _this22.queryRunner.createExclusionConstraints(table, newExclusions);\n      }\n    })();\n  }\n  /**\n   * Creates foreign keys which does not exist in the table yet.\n   */\n  createForeignKeys() {\n    var _this23 = this;\n    return _asyncToGenerator(function* () {\n      for (const metadata of _this23.entityToSyncMetadatas) {\n        const table = _this23.queryRunner.loadedTables.find(table => _this23.getTablePath(table) === _this23.getTablePath(metadata));\n        if (!table) continue;\n        const newKeys = metadata.foreignKeys.filter(foreignKey => {\n          return !table.foreignKeys.find(dbForeignKey => dbForeignKey.name === foreignKey.name && _this23.getTablePath(dbForeignKey) === _this23.getTablePath(foreignKey.referencedEntityMetadata));\n        });\n        if (newKeys.length === 0) continue;\n        const dbForeignKeys = newKeys.map(foreignKeyMetadata => TableForeignKey.create(foreignKeyMetadata, _this23.connection.driver));\n        _this23.connection.logger.logSchemaBuild(`creating a foreign keys: ${newKeys.map(key => key.name).join(\", \")} on table \"${table.name}\"`);\n        yield _this23.queryRunner.createForeignKeys(table, dbForeignKeys);\n      }\n    })();\n  }\n  /**\n   * Drops all foreign keys where given column of the given table is being used.\n   */\n  dropColumnReferencedForeignKeys(tablePath, columnName) {\n    var _this24 = this;\n    return _asyncToGenerator(function* () {\n      const table = _this24.queryRunner.loadedTables.find(table => _this24.getTablePath(table) === tablePath);\n      if (!table) return;\n      const tablesWithFK = [];\n      const columnForeignKey = table.foreignKeys.find(foreignKey => foreignKey.columnNames.indexOf(columnName) !== -1);\n      if (columnForeignKey) {\n        const clonedTable = table.clone();\n        clonedTable.foreignKeys = [columnForeignKey];\n        tablesWithFK.push(clonedTable);\n        table.removeForeignKey(columnForeignKey);\n      }\n      for (const loadedTable of _this24.queryRunner.loadedTables) {\n        const dependForeignKeys = loadedTable.foreignKeys.filter(foreignKey => {\n          return _this24.getTablePath(foreignKey) === tablePath && foreignKey.referencedColumnNames.indexOf(columnName) !== -1;\n        });\n        if (dependForeignKeys.length > 0) {\n          const clonedTable = loadedTable.clone();\n          clonedTable.foreignKeys = dependForeignKeys;\n          tablesWithFK.push(clonedTable);\n          dependForeignKeys.forEach(dependForeignKey => loadedTable.removeForeignKey(dependForeignKey));\n        }\n      }\n      if (tablesWithFK.length > 0) {\n        for (const tableWithFK of tablesWithFK) {\n          _this24.connection.logger.logSchemaBuild(`dropping related foreign keys of ${tableWithFK.name}: ${tableWithFK.foreignKeys.map(foreignKey => foreignKey.name).join(\", \")}`);\n          yield _this24.queryRunner.dropForeignKeys(tableWithFK, tableWithFK.foreignKeys);\n        }\n      }\n    })();\n  }\n  /**\n   * Drops all composite indices, related to given column.\n   */\n  dropColumnCompositeIndices(tablePath, columnName) {\n    var _this25 = this;\n    return _asyncToGenerator(function* () {\n      const table = _this25.queryRunner.loadedTables.find(table => _this25.getTablePath(table) === tablePath);\n      if (!table) return;\n      const relatedIndices = table.indices.filter(index => index.columnNames.length > 1 && index.columnNames.indexOf(columnName) !== -1);\n      if (relatedIndices.length === 0) return;\n      _this25.connection.logger.logSchemaBuild(`dropping related indices of \"${tablePath}\".\"${columnName}\": ${relatedIndices.map(index => index.name).join(\", \")}`);\n      yield _this25.queryRunner.dropIndices(table, relatedIndices);\n    })();\n  }\n  /**\n   * Drops all composite uniques, related to given column.\n   */\n  dropColumnCompositeUniques(tablePath, columnName) {\n    var _this26 = this;\n    return _asyncToGenerator(function* () {\n      const table = _this26.queryRunner.loadedTables.find(table => _this26.getTablePath(table) === tablePath);\n      if (!table) return;\n      const relatedUniques = table.uniques.filter(unique => unique.columnNames.length > 1 && unique.columnNames.indexOf(columnName) !== -1);\n      if (relatedUniques.length === 0) return;\n      _this26.connection.logger.logSchemaBuild(`dropping related unique constraints of \"${tablePath}\".\"${columnName}\": ${relatedUniques.map(unique => unique.name).join(\", \")}`);\n      yield _this26.queryRunner.dropUniqueConstraints(table, relatedUniques);\n    })();\n  }\n  /**\n   * Creates new columns from the given column metadatas.\n   */\n  metadataColumnsToTableColumnOptions(columns) {\n    return columns.map(columnMetadata => TableUtils.createTableColumnOptions(columnMetadata, this.connection.driver));\n  }\n  /**\n   * Creates typeorm service table for storing user defined Views and generate columns.\n   */\n  createTypeormMetadataTable(queryRunner) {\n    var _this27 = this;\n    return _asyncToGenerator(function* () {\n      const schema = _this27.currentSchema;\n      const database = _this27.currentDatabase;\n      const typeormMetadataTable = _this27.connection.driver.buildTableName(_this27.connection.metadataTableName, schema, database);\n      // Spanner requires at least one primary key in a table.\n      // Since we don't have unique column in \"typeorm_metadata\" table\n      // and we should avoid breaking changes, we mark all columns as primary for Spanner driver.\n      const isPrimary = _this27.connection.driver.options.type === \"spanner\";\n      yield queryRunner.createTable(new Table({\n        database: database,\n        schema: schema,\n        name: typeormMetadataTable,\n        columns: [{\n          name: \"type\",\n          type: _this27.connection.driver.normalizeType({\n            type: _this27.connection.driver.mappedDataTypes.metadataType\n          }),\n          isNullable: false,\n          isPrimary\n        }, {\n          name: \"database\",\n          type: _this27.connection.driver.normalizeType({\n            type: _this27.connection.driver.mappedDataTypes.metadataDatabase\n          }),\n          isNullable: true,\n          isPrimary\n        }, {\n          name: \"schema\",\n          type: _this27.connection.driver.normalizeType({\n            type: _this27.connection.driver.mappedDataTypes.metadataSchema\n          }),\n          isNullable: true,\n          isPrimary\n        }, {\n          name: \"table\",\n          type: _this27.connection.driver.normalizeType({\n            type: _this27.connection.driver.mappedDataTypes.metadataTable\n          }),\n          isNullable: true,\n          isPrimary\n        }, {\n          name: \"name\",\n          type: _this27.connection.driver.normalizeType({\n            type: _this27.connection.driver.mappedDataTypes.metadataName\n          }),\n          isNullable: true,\n          isPrimary\n        }, {\n          name: \"value\",\n          type: _this27.connection.driver.normalizeType({\n            type: _this27.connection.driver.mappedDataTypes.metadataValue\n          }),\n          isNullable: true,\n          isPrimary\n        }]\n      }), true);\n    })();\n  }\n}","map":{"version":3,"names":["Table","TableColumn","TableForeignKey","TableIndex","TableUtils","TableUnique","TableCheck","TableExclusion","View","ViewUtils","DriverUtils","RdbmsSchemaBuilder","constructor","connection","Symbol","for","build","_this","_asyncToGenerator","queryRunner","createQueryRunner","currentDatabase","driver","database","currentSchema","schema","isUsingTransactions","options","type","migrationsTransactionMode","beforeMigration","startTransaction","createMetadataTableIfNecessary","tablePaths","entityToSyncMetadatas","map","metadata","getTablePath","viewPaths","viewEntityToSyncMetadatas","getTables","getViews","executeSchemaSyncOperationsInProperOrder","queryResultCache","synchronize","commitTransaction","error","rollbackTransaction","rollbackError","afterMigration","release","_this2","length","hasGeneratedColumns","createTypeormMetadataTable","log","_this3","enableSqlMemory","getMemorySql","disableSqlMemory","entityMetadatas","filter","tableType","sort","viewMetadataCmp","some","entityMetadata","columns","column","generatedType","_this4","dropOldViews","dropOldForeignKeys","dropOldIndices","dropOldChecks","dropOldExclusions","dropCompositeUniqueConstraints","renameColumns","createNewTables","dropRemovedColumns","addNewColumns","updatePrimaryKeys","updateExistColumns","createNewIndices","createNewChecks","createNewExclusions","createCompositeUniqueConstraints","createForeignKeys","createViews","createNewViewIndices","target","parsed","parseTableName","buildTableName","tableName","_this5","table","loadedTables","find","tableForeignKeysToDrop","foreignKeys","tableForeignKey","metadataFK","metadataForeignKey","name","referencedEntityMetadata","onDelete","onUpdate","logger","logSchemaBuild","dbForeignKey","join","dropForeignKeys","renameTables","_this6","renamedMetadataColumns","c","isVirtualProperty","tableColumn","databaseName","normalizeType","isNullable","isUnique","normalizeIsUnique","renamedTableColumns","renamedColumn","clone","renameColumn","_this7","dropQueries","indices","tableIndex","indexMetadata","index","isSpatial","isFullTextColumnTypeSupported","isFulltext","columnNames","every","indexOf","_ref","dropIndex","_x","apply","arguments","Promise","all","postgresQueryRunner","view","loadedViews","_ref2","dropViewIndex","_x2","_this8","isMySQLFamily","oldChecks","checks","tableCheck","checkMetadata","check","dropCheckConstraints","_this9","compositeUniques","uniques","tableUnique","uniqueMetadata","unique","dropUniqueConstraints","_this10","oldExclusions","exclusions","tableExclusion","exclusionMetadata","exclusion","dropExclusionConstraints","_this11","existTable","create","createTable","push","_this12","existView","viewExpression","expression","trim","getQuery","metadataExpression","createView","_this13","droppedViews","viewToMetadata","Map","viewMetadata","set","get","viewDependencyChain","viewWithDependencies","currentView","currentMetadata","entries","dependsOn","has","concat","droppedViewsWithDependencies","Set","reduce","segment","a","b","reverse","dropView","_this14","droppedTableColumns","columnMetadata","dropColumns","_this15","newColumnMetadatas","newTableColumnOptions","metadataColumnsToTableColumnOptions","newTableColumns","option","addColumns","_this16","primaryMetadataColumns","isPrimary","primaryTableColumns","changedPrimaryColumns","primaryMetadataColumn","createTableColumnOptions","_this17","changedColumns","findChangedColumns","changedColumn","dropColumnReferencedForeignKeys","dropColumnCompositeIndices","dropColumnCompositeUniques","newAndOldTableColumns","oldTableColumn","newTableColumn","oldColumn","newColumn","changeColumns","_this18","newIndices","createIndices","_this19","isPostgresFamily","materialized","createViewIndices","_this20","newChecks","createCheckConstraints","_this21","createUniqueConstraints","_this22","newExclusions","createExclusionConstraints","_this23","newKeys","foreignKey","dbForeignKeys","foreignKeyMetadata","key","tablePath","columnName","_this24","tablesWithFK","columnForeignKey","clonedTable","removeForeignKey","loadedTable","dependForeignKeys","referencedColumnNames","forEach","dependForeignKey","tableWithFK","_this25","relatedIndices","dropIndices","_this26","relatedUniques","_this27","typeormMetadataTable","metadataTableName","mappedDataTypes","metadataType","metadataDatabase","metadataSchema","metadataTable","metadataName","metadataValue"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/schema-builder/RdbmsSchemaBuilder.js"],"sourcesContent":["import { Table } from \"./table/Table\";\nimport { TableColumn } from \"./table/TableColumn\";\nimport { TableForeignKey } from \"./table/TableForeignKey\";\nimport { TableIndex } from \"./table/TableIndex\";\nimport { TableUtils } from \"./util/TableUtils\";\nimport { TableUnique } from \"./table/TableUnique\";\nimport { TableCheck } from \"./table/TableCheck\";\nimport { TableExclusion } from \"./table/TableExclusion\";\nimport { View } from \"./view/View\";\nimport { ViewUtils } from \"./util/ViewUtils\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\n/**\n * Creates complete tables schemas in the database based on the entity metadatas.\n *\n * Steps how schema is being built:\n * 1. load list of all tables with complete column and keys information from the db\n * 2. drop all (old) foreign keys that exist in the table, but does not exist in the metadata\n * 3. create new tables that does not exist in the db, but exist in the metadata\n * 4. drop all columns exist (left old) in the db table, but does not exist in the metadata\n * 5. add columns from metadata which does not exist in the table\n * 6. update all exist columns which metadata has changed\n * 7. update primary keys - update old and create new primary key from changed columns\n * 8. create foreign keys which does not exist in the table yet\n * 9. create indices which are missing in db yet, and drops indices which exist in the db, but does not exist in the metadata anymore\n */\nexport class RdbmsSchemaBuilder {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n    constructor(connection) {\n        this.connection = connection;\n        this[\"@instanceof\"] = Symbol.for(\"RdbmsSchemaBuilder\");\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Creates complete schemas for the given entity metadatas.\n     */\n    async build() {\n        this.queryRunner = this.connection.createQueryRunner();\n        // this.connection.driver.database || this.currentDatabase;\n        this.currentDatabase = this.connection.driver.database;\n        this.currentSchema = this.connection.driver.schema;\n        // CockroachDB implements asynchronous schema sync operations which can not been executed in transaction.\n        // E.g. if you try to DROP column and ADD it again in the same transaction, crdb throws error.\n        // In Spanner queries against the INFORMATION_SCHEMA can be used in a read-only transaction,\n        // but not in a read-write transaction.\n        const isUsingTransactions = !(this.connection.driver.options.type === \"cockroachdb\") &&\n            !(this.connection.driver.options.type === \"spanner\") &&\n            this.connection.options.migrationsTransactionMode !== \"none\";\n        await this.queryRunner.beforeMigration();\n        if (isUsingTransactions) {\n            await this.queryRunner.startTransaction();\n        }\n        try {\n            await this.createMetadataTableIfNecessary(this.queryRunner);\n            // Flush the queryrunner table & view cache\n            const tablePaths = this.entityToSyncMetadatas.map((metadata) => this.getTablePath(metadata));\n            const viewPaths = this.viewEntityToSyncMetadatas.map((metadata) => this.getTablePath(metadata));\n            await this.queryRunner.getTables(tablePaths);\n            await this.queryRunner.getViews(viewPaths);\n            await this.executeSchemaSyncOperationsInProperOrder();\n            // if cache is enabled then perform cache-synchronization as well\n            if (this.connection.queryResultCache)\n                await this.connection.queryResultCache.synchronize(this.queryRunner);\n            if (isUsingTransactions) {\n                await this.queryRunner.commitTransaction();\n            }\n        }\n        catch (error) {\n            try {\n                // we throw original error even if rollback thrown an error\n                if (isUsingTransactions) {\n                    await this.queryRunner.rollbackTransaction();\n                }\n            }\n            catch (rollbackError) { }\n            throw error;\n        }\n        finally {\n            await this.queryRunner.afterMigration();\n            await this.queryRunner.release();\n        }\n    }\n    /**\n     * Create the typeorm_metadata table if necessary.\n     */\n    async createMetadataTableIfNecessary(queryRunner) {\n        if (this.viewEntityToSyncMetadatas.length > 0 ||\n            this.hasGeneratedColumns()) {\n            await this.createTypeormMetadataTable(queryRunner);\n        }\n    }\n    /**\n     * Returns sql queries to be executed by schema builder.\n     */\n    async log() {\n        this.queryRunner = this.connection.createQueryRunner();\n        try {\n            // Flush the queryrunner table & view cache\n            const tablePaths = this.entityToSyncMetadatas.map((metadata) => this.getTablePath(metadata));\n            const viewPaths = this.viewEntityToSyncMetadatas.map((metadata) => this.getTablePath(metadata));\n            await this.queryRunner.getTables(tablePaths);\n            await this.queryRunner.getViews(viewPaths);\n            this.queryRunner.enableSqlMemory();\n            await this.executeSchemaSyncOperationsInProperOrder();\n            // if cache is enabled then perform cache-synchronization as well\n            if (this.connection.queryResultCache)\n                // todo: check this functionality\n                await this.connection.queryResultCache.synchronize(this.queryRunner);\n            return this.queryRunner.getMemorySql();\n        }\n        finally {\n            // its important to disable this mode despite the fact we are release query builder\n            // because there exist drivers which reuse same query runner. Also its important to disable\n            // sql memory after call of getMemorySql() method because last one flushes sql memory.\n            this.queryRunner.disableSqlMemory();\n            await this.queryRunner.release();\n        }\n    }\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Returns only entities that should be synced in the database.\n     */\n    get entityToSyncMetadatas() {\n        return this.connection.entityMetadatas.filter((metadata) => metadata.synchronize &&\n            metadata.tableType !== \"entity-child\" &&\n            metadata.tableType !== \"view\");\n    }\n    /**\n     * Returns only entities that should be synced in the database.\n     */\n    get viewEntityToSyncMetadatas() {\n        return (this.connection.entityMetadatas\n            .filter((metadata) => metadata.tableType === \"view\" && metadata.synchronize)\n            // sort views in creation order by dependencies\n            .sort(ViewUtils.viewMetadataCmp));\n    }\n    /**\n     * Checks if there are at least one generated column.\n     */\n    hasGeneratedColumns() {\n        return this.connection.entityMetadatas.some((entityMetadata) => {\n            return entityMetadata.columns.some((column) => column.generatedType);\n        });\n    }\n    /**\n     * Executes schema sync operations in a proper order.\n     * Order of operations matter here.\n     */\n    async executeSchemaSyncOperationsInProperOrder() {\n        await this.dropOldViews();\n        await this.dropOldForeignKeys();\n        await this.dropOldIndices();\n        await this.dropOldChecks();\n        await this.dropOldExclusions();\n        await this.dropCompositeUniqueConstraints();\n        // await this.renameTables();\n        await this.renameColumns();\n        await this.createNewTables();\n        await this.dropRemovedColumns();\n        await this.addNewColumns();\n        await this.updatePrimaryKeys();\n        await this.updateExistColumns();\n        await this.createNewIndices();\n        await this.createNewChecks();\n        await this.createNewExclusions();\n        await this.createCompositeUniqueConstraints();\n        await this.createForeignKeys();\n        await this.createViews();\n        await this.createNewViewIndices();\n    }\n    getTablePath(target) {\n        const parsed = this.connection.driver.parseTableName(target);\n        return this.connection.driver.buildTableName(parsed.tableName, parsed.schema || this.currentSchema, parsed.database || this.currentDatabase);\n    }\n    /**\n     * Drops all (old) foreign keys that exist in the tables, but do not exist in the entity metadata.\n     */\n    async dropOldForeignKeys() {\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find((table) => this.getTablePath(table) === this.getTablePath(metadata));\n            if (!table)\n                continue;\n            // find foreign keys that exist in the schemas but does not exist in the entity metadata\n            const tableForeignKeysToDrop = table.foreignKeys.filter((tableForeignKey) => {\n                const metadataFK = metadata.foreignKeys.find((metadataForeignKey) => tableForeignKey.name === metadataForeignKey.name &&\n                    this.getTablePath(tableForeignKey) ===\n                        this.getTablePath(metadataForeignKey.referencedEntityMetadata));\n                return (!metadataFK ||\n                    (metadataFK.onDelete &&\n                        metadataFK.onDelete !== tableForeignKey.onDelete) ||\n                    (metadataFK.onUpdate &&\n                        metadataFK.onUpdate !== tableForeignKey.onUpdate));\n            });\n            if (tableForeignKeysToDrop.length === 0)\n                continue;\n            this.connection.logger.logSchemaBuild(`dropping old foreign keys of ${table.name}: ${tableForeignKeysToDrop\n                .map((dbForeignKey) => dbForeignKey.name)\n                .join(\", \")}`);\n            // drop foreign keys from the database\n            await this.queryRunner.dropForeignKeys(table, tableForeignKeysToDrop);\n        }\n    }\n    /**\n     * Rename tables\n     */\n    async renameTables() {\n        // for (const metadata of this.entityToSyncMetadatas) {\n        //     const table = this.queryRunner.loadedTables.find(table => this.getTablePath(table) === this.getTablePath(metadata));\n        // }\n    }\n    /**\n     * Renames columns.\n     * Works if only one column per table was changed.\n     * Changes only column name. If something besides name was changed, these changes will be ignored.\n     */\n    async renameColumns() {\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find((table) => this.getTablePath(table) === this.getTablePath(metadata));\n            if (!table)\n                continue;\n            if (metadata.columns.length !== table.columns.length)\n                continue;\n            const renamedMetadataColumns = metadata.columns\n                .filter((c) => !c.isVirtualProperty)\n                .filter((column) => {\n                return !table.columns.find((tableColumn) => {\n                    return (tableColumn.name === column.databaseName &&\n                        tableColumn.type ===\n                            this.connection.driver.normalizeType(column) &&\n                        tableColumn.isNullable === column.isNullable &&\n                        tableColumn.isUnique ===\n                            this.connection.driver.normalizeIsUnique(column));\n                });\n            });\n            if (renamedMetadataColumns.length === 0 ||\n                renamedMetadataColumns.length > 1)\n                continue;\n            const renamedTableColumns = table.columns.filter((tableColumn) => {\n                return !metadata.columns.find((column) => {\n                    return (!column.isVirtualProperty &&\n                        column.databaseName === tableColumn.name &&\n                        this.connection.driver.normalizeType(column) ===\n                            tableColumn.type &&\n                        column.isNullable === tableColumn.isNullable &&\n                        this.connection.driver.normalizeIsUnique(column) ===\n                            tableColumn.isUnique);\n                });\n            });\n            if (renamedTableColumns.length === 0 ||\n                renamedTableColumns.length > 1)\n                continue;\n            const renamedColumn = renamedTableColumns[0].clone();\n            renamedColumn.name = renamedMetadataColumns[0].databaseName;\n            this.connection.logger.logSchemaBuild(`renaming column \"${renamedTableColumns[0].name}\" in \"${table.name}\" to \"${renamedColumn.name}\"`);\n            await this.queryRunner.renameColumn(table, renamedTableColumns[0], renamedColumn);\n        }\n    }\n    async dropOldIndices() {\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find((table) => this.getTablePath(table) === this.getTablePath(metadata));\n            if (!table)\n                continue;\n            const dropQueries = table.indices\n                .filter((tableIndex) => {\n                const indexMetadata = metadata.indices.find((index) => index.name === tableIndex.name);\n                if (indexMetadata) {\n                    if (indexMetadata.synchronize === false)\n                        return false;\n                    if (indexMetadata.isUnique !== tableIndex.isUnique)\n                        return true;\n                    if (indexMetadata.isSpatial !== tableIndex.isSpatial)\n                        return true;\n                    if (this.connection.driver.isFullTextColumnTypeSupported() &&\n                        indexMetadata.isFulltext !== tableIndex.isFulltext)\n                        return true;\n                    if (indexMetadata.columns.length !==\n                        tableIndex.columnNames.length)\n                        return true;\n                    return !indexMetadata.columns.every((column) => tableIndex.columnNames.indexOf(column.databaseName) !== -1);\n                }\n                return true;\n            })\n                .map(async (tableIndex) => {\n                this.connection.logger.logSchemaBuild(`dropping an index: \"${tableIndex.name}\" from table ${table.name}`);\n                await this.queryRunner.dropIndex(table, tableIndex);\n            });\n            await Promise.all(dropQueries);\n        }\n        if (this.connection.options.type === \"postgres\") {\n            const postgresQueryRunner = this.queryRunner;\n            for (const metadata of this.viewEntityToSyncMetadatas) {\n                const view = this.queryRunner.loadedViews.find((view) => this.getTablePath(view) === this.getTablePath(metadata));\n                if (!view)\n                    continue;\n                const dropQueries = view.indices\n                    .filter((tableIndex) => {\n                    const indexMetadata = metadata.indices.find((index) => index.name === tableIndex.name);\n                    if (indexMetadata) {\n                        if (indexMetadata.synchronize === false)\n                            return false;\n                        if (indexMetadata.isUnique !== tableIndex.isUnique)\n                            return true;\n                        if (indexMetadata.isSpatial !== tableIndex.isSpatial)\n                            return true;\n                        if (this.connection.driver.isFullTextColumnTypeSupported() &&\n                            indexMetadata.isFulltext !==\n                                tableIndex.isFulltext)\n                            return true;\n                        if (indexMetadata.columns.length !==\n                            tableIndex.columnNames.length)\n                            return true;\n                        return !indexMetadata.columns.every((column) => tableIndex.columnNames.indexOf(column.databaseName) !== -1);\n                    }\n                    return true;\n                })\n                    .map(async (tableIndex) => {\n                    this.connection.logger.logSchemaBuild(`dropping an index: \"${tableIndex.name}\" from view ${view.name}`);\n                    await postgresQueryRunner.dropViewIndex(view, tableIndex);\n                });\n                await Promise.all(dropQueries);\n            }\n        }\n    }\n    async dropOldChecks() {\n        // Mysql does not support check constraints\n        if (DriverUtils.isMySQLFamily(this.connection.driver) ||\n            this.connection.driver.options.type === \"aurora-mysql\")\n            return;\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find((table) => this.getTablePath(table) === this.getTablePath(metadata));\n            if (!table)\n                continue;\n            const oldChecks = table.checks.filter((tableCheck) => {\n                return !metadata.checks.find((checkMetadata) => checkMetadata.name === tableCheck.name);\n            });\n            if (oldChecks.length === 0)\n                continue;\n            this.connection.logger.logSchemaBuild(`dropping old check constraint: ${oldChecks\n                .map((check) => `\"${check.name}\"`)\n                .join(\", \")} from table \"${table.name}\"`);\n            await this.queryRunner.dropCheckConstraints(table, oldChecks);\n        }\n    }\n    async dropCompositeUniqueConstraints() {\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find((table) => this.getTablePath(table) === this.getTablePath(metadata));\n            if (!table)\n                continue;\n            const compositeUniques = table.uniques.filter((tableUnique) => {\n                return (tableUnique.columnNames.length > 1 &&\n                    !metadata.uniques.find((uniqueMetadata) => uniqueMetadata.name === tableUnique.name));\n            });\n            if (compositeUniques.length === 0)\n                continue;\n            this.connection.logger.logSchemaBuild(`dropping old unique constraint: ${compositeUniques\n                .map((unique) => `\"${unique.name}\"`)\n                .join(\", \")} from table \"${table.name}\"`);\n            await this.queryRunner.dropUniqueConstraints(table, compositeUniques);\n        }\n    }\n    async dropOldExclusions() {\n        // Only PostgreSQL supports exclusion constraints\n        if (!(this.connection.driver.options.type === \"postgres\"))\n            return;\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find((table) => this.getTablePath(table) === this.getTablePath(metadata));\n            if (!table)\n                continue;\n            const oldExclusions = table.exclusions.filter((tableExclusion) => {\n                return !metadata.exclusions.find((exclusionMetadata) => exclusionMetadata.name === tableExclusion.name);\n            });\n            if (oldExclusions.length === 0)\n                continue;\n            this.connection.logger.logSchemaBuild(`dropping old exclusion constraint: ${oldExclusions\n                .map((exclusion) => `\"${exclusion.name}\"`)\n                .join(\", \")} from table \"${table.name}\"`);\n            await this.queryRunner.dropExclusionConstraints(table, oldExclusions);\n        }\n    }\n    /**\n     * Creates tables that do not exist in the database yet.\n     * New tables are created without foreign and primary keys.\n     * Primary key only can be created in conclusion with auto generated column.\n     */\n    async createNewTables() {\n        for (const metadata of this.entityToSyncMetadatas) {\n            // check if table does not exist yet\n            const existTable = this.queryRunner.loadedTables.find((table) => this.getTablePath(table) === this.getTablePath(metadata));\n            if (existTable)\n                continue;\n            this.connection.logger.logSchemaBuild(`creating a new table: ${this.getTablePath(metadata)}`);\n            // create a new table and sync it in the database\n            const table = Table.create(metadata, this.connection.driver);\n            await this.queryRunner.createTable(table, false, false);\n            this.queryRunner.loadedTables.push(table);\n        }\n    }\n    async createViews() {\n        for (const metadata of this.viewEntityToSyncMetadatas) {\n            // check if view does not exist yet\n            const existView = this.queryRunner.loadedViews.find((view) => {\n                const viewExpression = typeof view.expression === \"string\"\n                    ? view.expression.trim()\n                    : view.expression(this.connection).getQuery();\n                const metadataExpression = typeof metadata.expression === \"string\"\n                    ? metadata.expression.trim()\n                    : metadata.expression(this.connection).getQuery();\n                return (this.getTablePath(view) === this.getTablePath(metadata) &&\n                    viewExpression === metadataExpression);\n            });\n            if (existView)\n                continue;\n            this.connection.logger.logSchemaBuild(`creating a new view: ${this.getTablePath(metadata)}`);\n            // create a new view and sync it in the database\n            const view = View.create(metadata, this.connection.driver);\n            await this.queryRunner.createView(view, true);\n            this.queryRunner.loadedViews.push(view);\n        }\n    }\n    async dropOldViews() {\n        const droppedViews = [];\n        const viewEntityToSyncMetadatas = this.viewEntityToSyncMetadatas;\n        // BuIld lookup cache for finding views metadata\n        const viewToMetadata = new Map();\n        for (const view of this.queryRunner.loadedViews) {\n            const viewMetadata = viewEntityToSyncMetadatas.find((metadata) => {\n                return this.getTablePath(view) === this.getTablePath(metadata);\n            });\n            if (viewMetadata) {\n                viewToMetadata.set(view, viewMetadata);\n            }\n        }\n        // Gather all changed view, that need a drop\n        for (const view of this.queryRunner.loadedViews) {\n            const viewMetadata = viewToMetadata.get(view);\n            if (!viewMetadata) {\n                continue;\n            }\n            const viewExpression = typeof view.expression === \"string\"\n                ? view.expression.trim()\n                : view.expression(this.connection).getQuery();\n            const metadataExpression = typeof viewMetadata.expression === \"string\"\n                ? viewMetadata.expression.trim()\n                : viewMetadata.expression(this.connection).getQuery();\n            if (viewExpression === metadataExpression)\n                continue;\n            this.connection.logger.logSchemaBuild(`dropping an old view: ${view.name}`);\n            // Collect view to be dropped\n            droppedViews.push(view);\n        }\n        // Helper function that for a given view, will recursively return list of the view and all views that depend on it\n        const viewDependencyChain = (view) => {\n            // Get the view metadata\n            const viewMetadata = viewToMetadata.get(view);\n            let viewWithDependencies = [view];\n            // If no metadata is known for the view, simply return the view itself\n            if (!viewMetadata) {\n                return viewWithDependencies;\n            }\n            // Iterate over all known views\n            for (const [currentView, currentMetadata,] of viewToMetadata.entries()) {\n                // Ignore self reference\n                if (currentView === view) {\n                    continue;\n                }\n                // If the currently iterated view depends on the passed in view\n                if (currentMetadata.dependsOn &&\n                    (currentMetadata.dependsOn.has(viewMetadata.target) ||\n                        currentMetadata.dependsOn.has(viewMetadata.name))) {\n                    // Recursively add currently iterate view and its dependents\n                    viewWithDependencies = viewWithDependencies.concat(viewDependencyChain(currentView));\n                }\n            }\n            // Return all collected views\n            return viewWithDependencies;\n        };\n        // Collect final list of views to be dropped in a Set so there are no duplicates\n        const droppedViewsWithDependencies = new Set(\n        // Collect all dropped views, and their dependencies\n        droppedViews\n            .map((view) => viewDependencyChain(view))\n            // Flattened to single Array ( can be replaced with flatMap, once supported)\n            .reduce((all, segment) => {\n            return all.concat(segment);\n        }, [])\n            // Sort the views to be dropped in creation order\n            .sort((a, b) => {\n            return ViewUtils.viewMetadataCmp(viewToMetadata.get(a), viewToMetadata.get(b));\n        })\n            // reverse order to get drop order\n            .reverse());\n        // Finally emit all drop views\n        for (const view of droppedViewsWithDependencies) {\n            await this.queryRunner.dropView(view);\n        }\n        this.queryRunner.loadedViews = this.queryRunner.loadedViews.filter((view) => !droppedViewsWithDependencies.has(view));\n    }\n    /**\n     * Drops all columns that exist in the table, but does not exist in the metadata (left old).\n     * We drop their keys too, since it should be safe.\n     */\n    async dropRemovedColumns() {\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find((table) => this.getTablePath(table) === this.getTablePath(metadata));\n            if (!table)\n                continue;\n            // find columns that exist in the database but does not exist in the metadata\n            const droppedTableColumns = table.columns.filter((tableColumn) => {\n                return !metadata.columns.find((columnMetadata) => columnMetadata.isVirtualProperty ||\n                    columnMetadata.databaseName === tableColumn.name);\n            });\n            if (droppedTableColumns.length === 0)\n                continue;\n            this.connection.logger.logSchemaBuild(`columns dropped in ${table.name}: ` +\n                droppedTableColumns.map((column) => column.name).join(\", \"));\n            // drop columns from the database\n            await this.queryRunner.dropColumns(table, droppedTableColumns);\n        }\n    }\n    /**\n     * Adds columns from metadata which does not exist in the table.\n     * Columns are created without keys.\n     */\n    async addNewColumns() {\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find((table) => this.getTablePath(table) === this.getTablePath(metadata));\n            if (!table)\n                continue;\n            // find which columns are new\n            const newColumnMetadatas = metadata.columns.filter((columnMetadata) => {\n                return (!columnMetadata.isVirtualProperty &&\n                    !table.columns.find((tableColumn) => tableColumn.name ===\n                        columnMetadata.databaseName));\n            });\n            if (newColumnMetadatas.length === 0)\n                continue;\n            // create columns in the database\n            const newTableColumnOptions = this.metadataColumnsToTableColumnOptions(newColumnMetadatas);\n            const newTableColumns = newTableColumnOptions.map((option) => new TableColumn(option));\n            if (newTableColumns.length === 0)\n                continue;\n            this.connection.logger.logSchemaBuild(`new columns added: ` +\n                newColumnMetadatas\n                    .map((column) => column.databaseName)\n                    .join(\", \"));\n            await this.queryRunner.addColumns(table, newTableColumns);\n        }\n    }\n    /**\n     * Updates composite primary keys.\n     */\n    async updatePrimaryKeys() {\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find((table) => this.getTablePath(table) === this.getTablePath(metadata));\n            if (!table)\n                continue;\n            const primaryMetadataColumns = metadata.columns.filter((column) => column.isPrimary);\n            const primaryTableColumns = table.columns.filter((column) => column.isPrimary);\n            if (primaryTableColumns.length !== primaryMetadataColumns.length &&\n                primaryMetadataColumns.length > 1) {\n                const changedPrimaryColumns = primaryMetadataColumns.map((primaryMetadataColumn) => {\n                    return new TableColumn(TableUtils.createTableColumnOptions(primaryMetadataColumn, this.connection.driver));\n                });\n                await this.queryRunner.updatePrimaryKeys(table, changedPrimaryColumns);\n            }\n        }\n    }\n    /**\n     * Update all exist columns which metadata has changed.\n     * Still don't create keys. Also we don't touch foreign keys of the changed columns.\n     */\n    async updateExistColumns() {\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find((table) => this.getTablePath(table) === this.getTablePath(metadata));\n            if (!table)\n                continue;\n            const changedColumns = this.connection.driver.findChangedColumns(table.columns, metadata.columns);\n            if (changedColumns.length === 0)\n                continue;\n            // drop all foreign keys that point to this column\n            for (const changedColumn of changedColumns) {\n                await this.dropColumnReferencedForeignKeys(this.getTablePath(metadata), changedColumn.databaseName);\n            }\n            // drop all composite indices related to this column\n            for (const changedColumn of changedColumns) {\n                await this.dropColumnCompositeIndices(this.getTablePath(metadata), changedColumn.databaseName);\n            }\n            // drop all composite uniques related to this column\n            // Mysql does not support unique constraints.\n            if (!(DriverUtils.isMySQLFamily(this.connection.driver) ||\n                this.connection.driver.options.type === \"aurora-mysql\" ||\n                this.connection.driver.options.type === \"spanner\")) {\n                for (const changedColumn of changedColumns) {\n                    await this.dropColumnCompositeUniques(this.getTablePath(metadata), changedColumn.databaseName);\n                }\n            }\n            // generate a map of new/old columns\n            const newAndOldTableColumns = changedColumns.map((changedColumn) => {\n                const oldTableColumn = table.columns.find((column) => column.name === changedColumn.databaseName);\n                const newTableColumnOptions = TableUtils.createTableColumnOptions(changedColumn, this.connection.driver);\n                const newTableColumn = new TableColumn(newTableColumnOptions);\n                return {\n                    oldColumn: oldTableColumn,\n                    newColumn: newTableColumn,\n                };\n            });\n            if (newAndOldTableColumns.length === 0)\n                continue;\n            this.connection.logger.logSchemaBuild(`columns changed in \"${table.name}\". updating: ` +\n                changedColumns\n                    .map((column) => column.databaseName)\n                    .join(\", \"));\n            await this.queryRunner.changeColumns(table, newAndOldTableColumns);\n        }\n    }\n    /**\n     * Creates composite indices which are missing in db yet.\n     */\n    async createNewIndices() {\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find((table) => this.getTablePath(table) === this.getTablePath(metadata));\n            if (!table)\n                continue;\n            const newIndices = metadata.indices\n                .filter((indexMetadata) => !table.indices.find((tableIndex) => tableIndex.name === indexMetadata.name) && indexMetadata.synchronize === true)\n                .map((indexMetadata) => TableIndex.create(indexMetadata));\n            if (newIndices.length === 0)\n                continue;\n            this.connection.logger.logSchemaBuild(`adding new indices ${newIndices\n                .map((index) => `\"${index.name}\"`)\n                .join(\", \")} in table \"${table.name}\"`);\n            await this.queryRunner.createIndices(table, newIndices);\n        }\n    }\n    /**\n     * Creates indices for materialized views.\n     */\n    async createNewViewIndices() {\n        // Only PostgreSQL supports indices for materialized views.\n        if (this.connection.options.type !== \"postgres\" ||\n            !DriverUtils.isPostgresFamily(this.connection.driver)) {\n            return;\n        }\n        const postgresQueryRunner = (this.queryRunner);\n        for (const metadata of this.viewEntityToSyncMetadatas) {\n            // check if view does not exist yet\n            const view = this.queryRunner.loadedViews.find((view) => {\n                const viewExpression = typeof view.expression === \"string\"\n                    ? view.expression.trim()\n                    : view.expression(this.connection).getQuery();\n                const metadataExpression = typeof metadata.expression === \"string\"\n                    ? metadata.expression.trim()\n                    : metadata.expression(this.connection).getQuery();\n                return (this.getTablePath(view) === this.getTablePath(metadata) &&\n                    viewExpression === metadataExpression);\n            });\n            if (!view || !view.materialized)\n                continue;\n            const newIndices = metadata.indices\n                .filter((indexMetadata) => !view.indices.find((tableIndex) => tableIndex.name === indexMetadata.name) && indexMetadata.synchronize === true)\n                .map((indexMetadata) => TableIndex.create(indexMetadata));\n            if (newIndices.length === 0)\n                continue;\n            this.connection.logger.logSchemaBuild(`adding new indices ${newIndices\n                .map((index) => `\"${index.name}\"`)\n                .join(\", \")} in view \"${view.name}\"`);\n            await postgresQueryRunner.createViewIndices(view, newIndices);\n        }\n    }\n    async createNewChecks() {\n        // Mysql does not support check constraints\n        if (DriverUtils.isMySQLFamily(this.connection.driver) ||\n            this.connection.driver.options.type === \"aurora-mysql\")\n            return;\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find((table) => this.getTablePath(table) === this.getTablePath(metadata));\n            if (!table)\n                continue;\n            const newChecks = metadata.checks\n                .filter((checkMetadata) => !table.checks.find((tableCheck) => tableCheck.name === checkMetadata.name))\n                .map((checkMetadata) => TableCheck.create(checkMetadata));\n            if (newChecks.length === 0)\n                continue;\n            this.connection.logger.logSchemaBuild(`adding new check constraints: ${newChecks\n                .map((index) => `\"${index.name}\"`)\n                .join(\", \")} in table \"${table.name}\"`);\n            await this.queryRunner.createCheckConstraints(table, newChecks);\n        }\n    }\n    /**\n     * Creates composite uniques which are missing in db yet.\n     */\n    async createCompositeUniqueConstraints() {\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find((table) => this.getTablePath(table) === this.getTablePath(metadata));\n            if (!table)\n                continue;\n            const compositeUniques = metadata.uniques\n                .filter((uniqueMetadata) => uniqueMetadata.columns.length > 1 &&\n                !table.uniques.find((tableUnique) => tableUnique.name === uniqueMetadata.name))\n                .map((uniqueMetadata) => TableUnique.create(uniqueMetadata));\n            if (compositeUniques.length === 0)\n                continue;\n            this.connection.logger.logSchemaBuild(`adding new unique constraints: ${compositeUniques\n                .map((unique) => `\"${unique.name}\"`)\n                .join(\", \")} in table \"${table.name}\"`);\n            await this.queryRunner.createUniqueConstraints(table, compositeUniques);\n        }\n    }\n    /**\n     * Creates exclusions which are missing in db yet.\n     */\n    async createNewExclusions() {\n        // Only PostgreSQL supports exclusion constraints\n        if (!(this.connection.driver.options.type === \"postgres\"))\n            return;\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find((table) => this.getTablePath(table) === this.getTablePath(metadata));\n            if (!table)\n                continue;\n            const newExclusions = metadata.exclusions\n                .filter((exclusionMetadata) => !table.exclusions.find((tableExclusion) => tableExclusion.name === exclusionMetadata.name))\n                .map((exclusionMetadata) => TableExclusion.create(exclusionMetadata));\n            if (newExclusions.length === 0)\n                continue;\n            this.connection.logger.logSchemaBuild(`adding new exclusion constraints: ${newExclusions\n                .map((exclusion) => `\"${exclusion.name}\"`)\n                .join(\", \")} in table \"${table.name}\"`);\n            await this.queryRunner.createExclusionConstraints(table, newExclusions);\n        }\n    }\n    /**\n     * Creates foreign keys which does not exist in the table yet.\n     */\n    async createForeignKeys() {\n        for (const metadata of this.entityToSyncMetadatas) {\n            const table = this.queryRunner.loadedTables.find((table) => this.getTablePath(table) === this.getTablePath(metadata));\n            if (!table)\n                continue;\n            const newKeys = metadata.foreignKeys.filter((foreignKey) => {\n                return !table.foreignKeys.find((dbForeignKey) => dbForeignKey.name === foreignKey.name &&\n                    this.getTablePath(dbForeignKey) ===\n                        this.getTablePath(foreignKey.referencedEntityMetadata));\n            });\n            if (newKeys.length === 0)\n                continue;\n            const dbForeignKeys = newKeys.map((foreignKeyMetadata) => TableForeignKey.create(foreignKeyMetadata, this.connection.driver));\n            this.connection.logger.logSchemaBuild(`creating a foreign keys: ${newKeys\n                .map((key) => key.name)\n                .join(\", \")} on table \"${table.name}\"`);\n            await this.queryRunner.createForeignKeys(table, dbForeignKeys);\n        }\n    }\n    /**\n     * Drops all foreign keys where given column of the given table is being used.\n     */\n    async dropColumnReferencedForeignKeys(tablePath, columnName) {\n        const table = this.queryRunner.loadedTables.find((table) => this.getTablePath(table) === tablePath);\n        if (!table)\n            return;\n        const tablesWithFK = [];\n        const columnForeignKey = table.foreignKeys.find((foreignKey) => foreignKey.columnNames.indexOf(columnName) !== -1);\n        if (columnForeignKey) {\n            const clonedTable = table.clone();\n            clonedTable.foreignKeys = [columnForeignKey];\n            tablesWithFK.push(clonedTable);\n            table.removeForeignKey(columnForeignKey);\n        }\n        for (const loadedTable of this.queryRunner.loadedTables) {\n            const dependForeignKeys = loadedTable.foreignKeys.filter((foreignKey) => {\n                return (this.getTablePath(foreignKey) === tablePath &&\n                    foreignKey.referencedColumnNames.indexOf(columnName) !==\n                        -1);\n            });\n            if (dependForeignKeys.length > 0) {\n                const clonedTable = loadedTable.clone();\n                clonedTable.foreignKeys = dependForeignKeys;\n                tablesWithFK.push(clonedTable);\n                dependForeignKeys.forEach((dependForeignKey) => loadedTable.removeForeignKey(dependForeignKey));\n            }\n        }\n        if (tablesWithFK.length > 0) {\n            for (const tableWithFK of tablesWithFK) {\n                this.connection.logger.logSchemaBuild(`dropping related foreign keys of ${tableWithFK.name}: ${tableWithFK.foreignKeys\n                    .map((foreignKey) => foreignKey.name)\n                    .join(\", \")}`);\n                await this.queryRunner.dropForeignKeys(tableWithFK, tableWithFK.foreignKeys);\n            }\n        }\n    }\n    /**\n     * Drops all composite indices, related to given column.\n     */\n    async dropColumnCompositeIndices(tablePath, columnName) {\n        const table = this.queryRunner.loadedTables.find((table) => this.getTablePath(table) === tablePath);\n        if (!table)\n            return;\n        const relatedIndices = table.indices.filter((index) => index.columnNames.length > 1 &&\n            index.columnNames.indexOf(columnName) !== -1);\n        if (relatedIndices.length === 0)\n            return;\n        this.connection.logger.logSchemaBuild(`dropping related indices of \"${tablePath}\".\"${columnName}\": ${relatedIndices\n            .map((index) => index.name)\n            .join(\", \")}`);\n        await this.queryRunner.dropIndices(table, relatedIndices);\n    }\n    /**\n     * Drops all composite uniques, related to given column.\n     */\n    async dropColumnCompositeUniques(tablePath, columnName) {\n        const table = this.queryRunner.loadedTables.find((table) => this.getTablePath(table) === tablePath);\n        if (!table)\n            return;\n        const relatedUniques = table.uniques.filter((unique) => unique.columnNames.length > 1 &&\n            unique.columnNames.indexOf(columnName) !== -1);\n        if (relatedUniques.length === 0)\n            return;\n        this.connection.logger.logSchemaBuild(`dropping related unique constraints of \"${tablePath}\".\"${columnName}\": ${relatedUniques\n            .map((unique) => unique.name)\n            .join(\", \")}`);\n        await this.queryRunner.dropUniqueConstraints(table, relatedUniques);\n    }\n    /**\n     * Creates new columns from the given column metadatas.\n     */\n    metadataColumnsToTableColumnOptions(columns) {\n        return columns.map((columnMetadata) => TableUtils.createTableColumnOptions(columnMetadata, this.connection.driver));\n    }\n    /**\n     * Creates typeorm service table for storing user defined Views and generate columns.\n     */\n    async createTypeormMetadataTable(queryRunner) {\n        const schema = this.currentSchema;\n        const database = this.currentDatabase;\n        const typeormMetadataTable = this.connection.driver.buildTableName(this.connection.metadataTableName, schema, database);\n        // Spanner requires at least one primary key in a table.\n        // Since we don't have unique column in \"typeorm_metadata\" table\n        // and we should avoid breaking changes, we mark all columns as primary for Spanner driver.\n        const isPrimary = this.connection.driver.options.type === \"spanner\";\n        await queryRunner.createTable(new Table({\n            database: database,\n            schema: schema,\n            name: typeormMetadataTable,\n            columns: [\n                {\n                    name: \"type\",\n                    type: this.connection.driver.normalizeType({\n                        type: this.connection.driver.mappedDataTypes\n                            .metadataType,\n                    }),\n                    isNullable: false,\n                    isPrimary,\n                },\n                {\n                    name: \"database\",\n                    type: this.connection.driver.normalizeType({\n                        type: this.connection.driver.mappedDataTypes\n                            .metadataDatabase,\n                    }),\n                    isNullable: true,\n                    isPrimary,\n                },\n                {\n                    name: \"schema\",\n                    type: this.connection.driver.normalizeType({\n                        type: this.connection.driver.mappedDataTypes\n                            .metadataSchema,\n                    }),\n                    isNullable: true,\n                    isPrimary,\n                },\n                {\n                    name: \"table\",\n                    type: this.connection.driver.normalizeType({\n                        type: this.connection.driver.mappedDataTypes\n                            .metadataTable,\n                    }),\n                    isNullable: true,\n                    isPrimary,\n                },\n                {\n                    name: \"name\",\n                    type: this.connection.driver.normalizeType({\n                        type: this.connection.driver.mappedDataTypes\n                            .metadataName,\n                    }),\n                    isNullable: true,\n                    isPrimary,\n                },\n                {\n                    name: \"value\",\n                    type: this.connection.driver.normalizeType({\n                        type: this.connection.driver.mappedDataTypes\n                            .metadataValue,\n                    }),\n                    isNullable: true,\n                    isPrimary,\n                },\n            ],\n        }), true);\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}