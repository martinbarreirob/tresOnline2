{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/practicas/Downloads/angular/tresOnline/frontend-tres-en-raya/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\nimport { TypeORMError } from \"../error/TypeORMError\";\nimport { FindOptionsUtils } from \"../find-options/FindOptionsUtils\";\nimport { TreeRepositoryUtils } from \"../util/TreeRepositoryUtils\";\nimport { Repository } from \"./Repository\";\n/**\n * Repository with additional functions to work with trees.\n *\n * @see Repository\n */\nexport class TreeRepository extends Repository {\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Gets complete trees for all roots in the table.\n   */\n  findTrees(options) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      const roots = yield _this.findRoots(options);\n      yield Promise.all(roots.map(root => _this.findDescendantsTree(root, options)));\n      return roots;\n    })();\n  }\n  /**\n   * Roots are entities that have no ancestors. Finds them all.\n   */\n  findRoots(options) {\n    const escapeAlias = alias => this.manager.connection.driver.escape(alias);\n    const escapeColumn = column => this.manager.connection.driver.escape(column);\n    const joinColumn = this.metadata.treeParentRelation.joinColumns[0];\n    const parentPropertyName = joinColumn.givenDatabaseName || joinColumn.databaseName;\n    const qb = this.createQueryBuilder(\"treeEntity\");\n    FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options);\n    return qb.where(`${escapeAlias(\"treeEntity\")}.${escapeColumn(parentPropertyName)} IS NULL`).getMany();\n  }\n  /**\n   * Gets all children (descendants) of the given entity. Returns them all in a flat array.\n   */\n  findDescendants(entity, options) {\n    const qb = this.createDescendantsQueryBuilder(\"treeEntity\", \"treeClosure\", entity);\n    FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options);\n    return qb.getMany();\n  }\n  /**\n   * Gets all children (descendants) of the given entity. Returns them in a tree - nested into each other.\n   */\n  findDescendantsTree(entity, options) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      // todo: throw exception if there is no column of this relation?\n      const qb = _this2.createDescendantsQueryBuilder(\"treeEntity\", \"treeClosure\", entity);\n      FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options);\n      const entities = yield qb.getRawAndEntities();\n      const relationMaps = TreeRepositoryUtils.createRelationMaps(_this2.manager, _this2.metadata, \"treeEntity\", entities.raw);\n      TreeRepositoryUtils.buildChildrenEntityTree(_this2.metadata, entity, entities.entities, relationMaps, {\n        depth: -1,\n        ...options\n      });\n      return entity;\n    })();\n  }\n  /**\n   * Gets number of descendants of the entity.\n   */\n  countDescendants(entity) {\n    return this.createDescendantsQueryBuilder(\"treeEntity\", \"treeClosure\", entity).getCount();\n  }\n  /**\n   * Creates a query builder used to get descendants of the entities in a tree.\n   */\n  createDescendantsQueryBuilder(alias, closureTableAlias, entity) {\n    // create shortcuts for better readability\n    const escape = alias => this.manager.connection.driver.escape(alias);\n    if (this.metadata.treeType === \"closure-table\") {\n      const joinCondition = this.metadata.closureJunctionTable.descendantColumns.map(column => {\n        return escape(closureTableAlias) + \".\" + escape(column.propertyPath) + \" = \" + escape(alias) + \".\" + escape(column.referencedColumn.propertyPath);\n      }).join(\" AND \");\n      const parameters = {};\n      const whereCondition = this.metadata.closureJunctionTable.ancestorColumns.map(column => {\n        parameters[column.referencedColumn.propertyName] = column.referencedColumn.getEntityValue(entity);\n        return escape(closureTableAlias) + \".\" + escape(column.propertyPath) + \" = :\" + column.referencedColumn.propertyName;\n      }).join(\" AND \");\n      return this.createQueryBuilder(alias).innerJoin(this.metadata.closureJunctionTable.tableName, closureTableAlias, joinCondition).where(whereCondition).setParameters(parameters);\n    } else if (this.metadata.treeType === \"nested-set\") {\n      const whereCondition = alias + \".\" + this.metadata.nestedSetLeftColumn.propertyPath + \" BETWEEN \" + \"joined.\" + this.metadata.nestedSetLeftColumn.propertyPath + \" AND joined.\" + this.metadata.nestedSetRightColumn.propertyPath;\n      const parameters = {};\n      const joinCondition = this.metadata.treeParentRelation.joinColumns.map(joinColumn => {\n        const parameterName = joinColumn.referencedColumn.propertyPath.replace(\".\", \"_\");\n        parameters[parameterName] = joinColumn.referencedColumn.getEntityValue(entity);\n        return \"joined.\" + joinColumn.referencedColumn.propertyPath + \" = :\" + parameterName;\n      }).join(\" AND \");\n      return this.createQueryBuilder(alias).innerJoin(this.metadata.targetName, \"joined\", whereCondition).where(joinCondition, parameters);\n    } else if (this.metadata.treeType === \"materialized-path\") {\n      return this.createQueryBuilder(alias).where(qb => {\n        const subQuery = qb.subQuery().select(`${this.metadata.targetName}.${this.metadata.materializedPathColumn.propertyPath}`, \"path\").from(this.metadata.target, this.metadata.targetName).whereInIds(this.metadata.getEntityIdMap(entity));\n        if (DriverUtils.isSQLiteFamily(this.manager.connection.driver)) {\n          return `${alias}.${this.metadata.materializedPathColumn.propertyPath} LIKE ${subQuery.getQuery()} || '%'`;\n        } else {\n          return `${alias}.${this.metadata.materializedPathColumn.propertyPath} LIKE NULLIF(CONCAT(${subQuery.getQuery()}, '%'), '%')`;\n        }\n      });\n    }\n    throw new TypeORMError(`Supported only in tree entities`);\n  }\n  /**\n   * Gets all parents (ancestors) of the given entity. Returns them all in a flat array.\n   */\n  findAncestors(entity, options) {\n    const qb = this.createAncestorsQueryBuilder(\"treeEntity\", \"treeClosure\", entity);\n    FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options);\n    return qb.getMany();\n  }\n  /**\n   * Gets all parents (ancestors) of the given entity. Returns them in a tree - nested into each other.\n   */\n  findAncestorsTree(entity, options) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      // todo: throw exception if there is no column of this relation?\n      const qb = _this3.createAncestorsQueryBuilder(\"treeEntity\", \"treeClosure\", entity);\n      FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options);\n      const entities = yield qb.getRawAndEntities();\n      const relationMaps = TreeRepositoryUtils.createRelationMaps(_this3.manager, _this3.metadata, \"treeEntity\", entities.raw);\n      TreeRepositoryUtils.buildParentEntityTree(_this3.metadata, entity, entities.entities, relationMaps);\n      return entity;\n    })();\n  }\n  /**\n   * Gets number of ancestors of the entity.\n   */\n  countAncestors(entity) {\n    return this.createAncestorsQueryBuilder(\"treeEntity\", \"treeClosure\", entity).getCount();\n  }\n  /**\n   * Creates a query builder used to get ancestors of the entities in the tree.\n   */\n  createAncestorsQueryBuilder(alias, closureTableAlias, entity) {\n    // create shortcuts for better readability\n    // const escape = (alias: string) => this.manager.connection.driver.escape(alias);\n    if (this.metadata.treeType === \"closure-table\") {\n      const joinCondition = this.metadata.closureJunctionTable.ancestorColumns.map(column => {\n        return closureTableAlias + \".\" + column.propertyPath + \" = \" + alias + \".\" + column.referencedColumn.propertyPath;\n      }).join(\" AND \");\n      const parameters = {};\n      const whereCondition = this.metadata.closureJunctionTable.descendantColumns.map(column => {\n        parameters[column.referencedColumn.propertyName] = column.referencedColumn.getEntityValue(entity);\n        return closureTableAlias + \".\" + column.propertyPath + \" = :\" + column.referencedColumn.propertyName;\n      }).join(\" AND \");\n      return this.createQueryBuilder(alias).innerJoin(this.metadata.closureJunctionTable.tableName, closureTableAlias, joinCondition).where(whereCondition).setParameters(parameters);\n    } else if (this.metadata.treeType === \"nested-set\") {\n      const joinCondition = \"joined.\" + this.metadata.nestedSetLeftColumn.propertyPath + \" BETWEEN \" + alias + \".\" + this.metadata.nestedSetLeftColumn.propertyPath + \" AND \" + alias + \".\" + this.metadata.nestedSetRightColumn.propertyPath;\n      const parameters = {};\n      const whereCondition = this.metadata.treeParentRelation.joinColumns.map(joinColumn => {\n        const parameterName = joinColumn.referencedColumn.propertyPath.replace(\".\", \"_\");\n        parameters[parameterName] = joinColumn.referencedColumn.getEntityValue(entity);\n        return \"joined.\" + joinColumn.referencedColumn.propertyPath + \" = :\" + parameterName;\n      }).join(\" AND \");\n      return this.createQueryBuilder(alias).innerJoin(this.metadata.targetName, \"joined\", joinCondition).where(whereCondition, parameters);\n    } else if (this.metadata.treeType === \"materialized-path\") {\n      // example: SELECT * FROM category category WHERE (SELECT mpath FROM `category` WHERE id = 2) LIKE CONCAT(category.mpath, '%');\n      return this.createQueryBuilder(alias).where(qb => {\n        const subQuery = qb.subQuery().select(`${this.metadata.targetName}.${this.metadata.materializedPathColumn.propertyPath}`, \"path\").from(this.metadata.target, this.metadata.targetName).whereInIds(this.metadata.getEntityIdMap(entity));\n        if (DriverUtils.isSQLiteFamily(this.manager.connection.driver)) {\n          return `${subQuery.getQuery()} LIKE ${alias}.${this.metadata.materializedPathColumn.propertyPath} || '%'`;\n        } else {\n          return `${subQuery.getQuery()} LIKE CONCAT(${alias}.${this.metadata.materializedPathColumn.propertyPath}, '%')`;\n        }\n      });\n    }\n    throw new TypeORMError(`Supported only in tree entities`);\n  }\n}","map":{"version":3,"names":["DriverUtils","TypeORMError","FindOptionsUtils","TreeRepositoryUtils","Repository","TreeRepository","findTrees","options","_this","_asyncToGenerator","roots","findRoots","Promise","all","map","root","findDescendantsTree","escapeAlias","alias","manager","connection","driver","escape","escapeColumn","column","joinColumn","metadata","treeParentRelation","joinColumns","parentPropertyName","givenDatabaseName","databaseName","qb","createQueryBuilder","applyOptionsToTreeQueryBuilder","where","getMany","findDescendants","entity","createDescendantsQueryBuilder","_this2","entities","getRawAndEntities","relationMaps","createRelationMaps","raw","buildChildrenEntityTree","depth","countDescendants","getCount","closureTableAlias","treeType","joinCondition","closureJunctionTable","descendantColumns","propertyPath","referencedColumn","join","parameters","whereCondition","ancestorColumns","propertyName","getEntityValue","innerJoin","tableName","setParameters","nestedSetLeftColumn","nestedSetRightColumn","parameterName","replace","targetName","subQuery","select","materializedPathColumn","from","target","whereInIds","getEntityIdMap","isSQLiteFamily","getQuery","findAncestors","createAncestorsQueryBuilder","findAncestorsTree","_this3","buildParentEntityTree","countAncestors"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/repository/TreeRepository.js"],"sourcesContent":["import { DriverUtils } from \"../driver/DriverUtils\";\nimport { TypeORMError } from \"../error/TypeORMError\";\nimport { FindOptionsUtils } from \"../find-options/FindOptionsUtils\";\nimport { TreeRepositoryUtils } from \"../util/TreeRepositoryUtils\";\nimport { Repository } from \"./Repository\";\n/**\n * Repository with additional functions to work with trees.\n *\n * @see Repository\n */\nexport class TreeRepository extends Repository {\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Gets complete trees for all roots in the table.\n     */\n    async findTrees(options) {\n        const roots = await this.findRoots(options);\n        await Promise.all(roots.map((root) => this.findDescendantsTree(root, options)));\n        return roots;\n    }\n    /**\n     * Roots are entities that have no ancestors. Finds them all.\n     */\n    findRoots(options) {\n        const escapeAlias = (alias) => this.manager.connection.driver.escape(alias);\n        const escapeColumn = (column) => this.manager.connection.driver.escape(column);\n        const joinColumn = this.metadata.treeParentRelation.joinColumns[0];\n        const parentPropertyName = joinColumn.givenDatabaseName || joinColumn.databaseName;\n        const qb = this.createQueryBuilder(\"treeEntity\");\n        FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options);\n        return qb\n            .where(`${escapeAlias(\"treeEntity\")}.${escapeColumn(parentPropertyName)} IS NULL`)\n            .getMany();\n    }\n    /**\n     * Gets all children (descendants) of the given entity. Returns them all in a flat array.\n     */\n    findDescendants(entity, options) {\n        const qb = this.createDescendantsQueryBuilder(\"treeEntity\", \"treeClosure\", entity);\n        FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options);\n        return qb.getMany();\n    }\n    /**\n     * Gets all children (descendants) of the given entity. Returns them in a tree - nested into each other.\n     */\n    async findDescendantsTree(entity, options) {\n        // todo: throw exception if there is no column of this relation?\n        const qb = this.createDescendantsQueryBuilder(\"treeEntity\", \"treeClosure\", entity);\n        FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options);\n        const entities = await qb.getRawAndEntities();\n        const relationMaps = TreeRepositoryUtils.createRelationMaps(this.manager, this.metadata, \"treeEntity\", entities.raw);\n        TreeRepositoryUtils.buildChildrenEntityTree(this.metadata, entity, entities.entities, relationMaps, {\n            depth: -1,\n            ...options,\n        });\n        return entity;\n    }\n    /**\n     * Gets number of descendants of the entity.\n     */\n    countDescendants(entity) {\n        return this.createDescendantsQueryBuilder(\"treeEntity\", \"treeClosure\", entity).getCount();\n    }\n    /**\n     * Creates a query builder used to get descendants of the entities in a tree.\n     */\n    createDescendantsQueryBuilder(alias, closureTableAlias, entity) {\n        // create shortcuts for better readability\n        const escape = (alias) => this.manager.connection.driver.escape(alias);\n        if (this.metadata.treeType === \"closure-table\") {\n            const joinCondition = this.metadata.closureJunctionTable.descendantColumns\n                .map((column) => {\n                return (escape(closureTableAlias) +\n                    \".\" +\n                    escape(column.propertyPath) +\n                    \" = \" +\n                    escape(alias) +\n                    \".\" +\n                    escape(column.referencedColumn.propertyPath));\n            })\n                .join(\" AND \");\n            const parameters = {};\n            const whereCondition = this.metadata.closureJunctionTable.ancestorColumns\n                .map((column) => {\n                parameters[column.referencedColumn.propertyName] =\n                    column.referencedColumn.getEntityValue(entity);\n                return (escape(closureTableAlias) +\n                    \".\" +\n                    escape(column.propertyPath) +\n                    \" = :\" +\n                    column.referencedColumn.propertyName);\n            })\n                .join(\" AND \");\n            return this.createQueryBuilder(alias)\n                .innerJoin(this.metadata.closureJunctionTable.tableName, closureTableAlias, joinCondition)\n                .where(whereCondition)\n                .setParameters(parameters);\n        }\n        else if (this.metadata.treeType === \"nested-set\") {\n            const whereCondition = alias +\n                \".\" +\n                this.metadata.nestedSetLeftColumn.propertyPath +\n                \" BETWEEN \" +\n                \"joined.\" +\n                this.metadata.nestedSetLeftColumn.propertyPath +\n                \" AND joined.\" +\n                this.metadata.nestedSetRightColumn.propertyPath;\n            const parameters = {};\n            const joinCondition = this.metadata\n                .treeParentRelation.joinColumns.map((joinColumn) => {\n                const parameterName = joinColumn.referencedColumn.propertyPath.replace(\".\", \"_\");\n                parameters[parameterName] =\n                    joinColumn.referencedColumn.getEntityValue(entity);\n                return (\"joined.\" +\n                    joinColumn.referencedColumn.propertyPath +\n                    \" = :\" +\n                    parameterName);\n            })\n                .join(\" AND \");\n            return this.createQueryBuilder(alias)\n                .innerJoin(this.metadata.targetName, \"joined\", whereCondition)\n                .where(joinCondition, parameters);\n        }\n        else if (this.metadata.treeType === \"materialized-path\") {\n            return this.createQueryBuilder(alias).where((qb) => {\n                const subQuery = qb\n                    .subQuery()\n                    .select(`${this.metadata.targetName}.${this.metadata.materializedPathColumn.propertyPath}`, \"path\")\n                    .from(this.metadata.target, this.metadata.targetName)\n                    .whereInIds(this.metadata.getEntityIdMap(entity));\n                if (DriverUtils.isSQLiteFamily(this.manager.connection.driver)) {\n                    return `${alias}.${this.metadata.materializedPathColumn.propertyPath} LIKE ${subQuery.getQuery()} || '%'`;\n                }\n                else {\n                    return `${alias}.${this.metadata.materializedPathColumn.propertyPath} LIKE NULLIF(CONCAT(${subQuery.getQuery()}, '%'), '%')`;\n                }\n            });\n        }\n        throw new TypeORMError(`Supported only in tree entities`);\n    }\n    /**\n     * Gets all parents (ancestors) of the given entity. Returns them all in a flat array.\n     */\n    findAncestors(entity, options) {\n        const qb = this.createAncestorsQueryBuilder(\"treeEntity\", \"treeClosure\", entity);\n        FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options);\n        return qb.getMany();\n    }\n    /**\n     * Gets all parents (ancestors) of the given entity. Returns them in a tree - nested into each other.\n     */\n    async findAncestorsTree(entity, options) {\n        // todo: throw exception if there is no column of this relation?\n        const qb = this.createAncestorsQueryBuilder(\"treeEntity\", \"treeClosure\", entity);\n        FindOptionsUtils.applyOptionsToTreeQueryBuilder(qb, options);\n        const entities = await qb.getRawAndEntities();\n        const relationMaps = TreeRepositoryUtils.createRelationMaps(this.manager, this.metadata, \"treeEntity\", entities.raw);\n        TreeRepositoryUtils.buildParentEntityTree(this.metadata, entity, entities.entities, relationMaps);\n        return entity;\n    }\n    /**\n     * Gets number of ancestors of the entity.\n     */\n    countAncestors(entity) {\n        return this.createAncestorsQueryBuilder(\"treeEntity\", \"treeClosure\", entity).getCount();\n    }\n    /**\n     * Creates a query builder used to get ancestors of the entities in the tree.\n     */\n    createAncestorsQueryBuilder(alias, closureTableAlias, entity) {\n        // create shortcuts for better readability\n        // const escape = (alias: string) => this.manager.connection.driver.escape(alias);\n        if (this.metadata.treeType === \"closure-table\") {\n            const joinCondition = this.metadata.closureJunctionTable.ancestorColumns\n                .map((column) => {\n                return (closureTableAlias +\n                    \".\" +\n                    column.propertyPath +\n                    \" = \" +\n                    alias +\n                    \".\" +\n                    column.referencedColumn.propertyPath);\n            })\n                .join(\" AND \");\n            const parameters = {};\n            const whereCondition = this.metadata.closureJunctionTable.descendantColumns\n                .map((column) => {\n                parameters[column.referencedColumn.propertyName] =\n                    column.referencedColumn.getEntityValue(entity);\n                return (closureTableAlias +\n                    \".\" +\n                    column.propertyPath +\n                    \" = :\" +\n                    column.referencedColumn.propertyName);\n            })\n                .join(\" AND \");\n            return this.createQueryBuilder(alias)\n                .innerJoin(this.metadata.closureJunctionTable.tableName, closureTableAlias, joinCondition)\n                .where(whereCondition)\n                .setParameters(parameters);\n        }\n        else if (this.metadata.treeType === \"nested-set\") {\n            const joinCondition = \"joined.\" +\n                this.metadata.nestedSetLeftColumn.propertyPath +\n                \" BETWEEN \" +\n                alias +\n                \".\" +\n                this.metadata.nestedSetLeftColumn.propertyPath +\n                \" AND \" +\n                alias +\n                \".\" +\n                this.metadata.nestedSetRightColumn.propertyPath;\n            const parameters = {};\n            const whereCondition = this.metadata\n                .treeParentRelation.joinColumns.map((joinColumn) => {\n                const parameterName = joinColumn.referencedColumn.propertyPath.replace(\".\", \"_\");\n                parameters[parameterName] =\n                    joinColumn.referencedColumn.getEntityValue(entity);\n                return (\"joined.\" +\n                    joinColumn.referencedColumn.propertyPath +\n                    \" = :\" +\n                    parameterName);\n            })\n                .join(\" AND \");\n            return this.createQueryBuilder(alias)\n                .innerJoin(this.metadata.targetName, \"joined\", joinCondition)\n                .where(whereCondition, parameters);\n        }\n        else if (this.metadata.treeType === \"materialized-path\") {\n            // example: SELECT * FROM category category WHERE (SELECT mpath FROM `category` WHERE id = 2) LIKE CONCAT(category.mpath, '%');\n            return this.createQueryBuilder(alias).where((qb) => {\n                const subQuery = qb\n                    .subQuery()\n                    .select(`${this.metadata.targetName}.${this.metadata.materializedPathColumn.propertyPath}`, \"path\")\n                    .from(this.metadata.target, this.metadata.targetName)\n                    .whereInIds(this.metadata.getEntityIdMap(entity));\n                if (DriverUtils.isSQLiteFamily(this.manager.connection.driver)) {\n                    return `${subQuery.getQuery()} LIKE ${alias}.${this.metadata.materializedPathColumn.propertyPath} || '%'`;\n                }\n                else {\n                    return `${subQuery.getQuery()} LIKE CONCAT(${alias}.${this.metadata.materializedPathColumn.propertyPath}, '%')`;\n                }\n            });\n        }\n        throw new TypeORMError(`Supported only in tree entities`);\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}