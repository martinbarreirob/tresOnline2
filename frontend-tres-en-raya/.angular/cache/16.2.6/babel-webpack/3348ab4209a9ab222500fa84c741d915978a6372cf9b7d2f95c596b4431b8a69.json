{"ast":null,"code":"import { EntityMetadata } from \"../metadata/EntityMetadata\";\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\";\nimport { IndexMetadata } from \"../metadata/IndexMetadata\";\nimport { RelationMetadata } from \"../metadata/RelationMetadata\";\nimport { EmbeddedMetadata } from \"../metadata/EmbeddedMetadata\";\nimport { RelationIdMetadata } from \"../metadata/RelationIdMetadata\";\nimport { RelationCountMetadata } from \"../metadata/RelationCountMetadata\";\nimport { EventListenerTypes } from \"../metadata/types/EventListenerTypes\";\nimport { MetadataUtils } from \"./MetadataUtils\";\nimport { JunctionEntityMetadataBuilder } from \"./JunctionEntityMetadataBuilder\";\nimport { ClosureJunctionEntityMetadataBuilder } from \"./ClosureJunctionEntityMetadataBuilder\";\nimport { RelationJoinColumnBuilder } from \"./RelationJoinColumnBuilder\";\nimport { EntityListenerMetadata } from \"../metadata/EntityListenerMetadata\";\nimport { UniqueMetadata } from \"../metadata/UniqueMetadata\";\nimport { CheckMetadata } from \"../metadata/CheckMetadata\";\nimport { ExclusionMetadata } from \"../metadata/ExclusionMetadata\";\nimport { TypeORMError } from \"../error\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\n/**\n * Builds EntityMetadata objects and all its sub-metadatas.\n */\nexport class EntityMetadataBuilder {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection, metadataArgsStorage) {\n    this.connection = connection;\n    this.metadataArgsStorage = metadataArgsStorage;\n    this.junctionEntityMetadataBuilder = new JunctionEntityMetadataBuilder(connection);\n    this.closureJunctionEntityMetadataBuilder = new ClosureJunctionEntityMetadataBuilder(connection);\n    this.relationJoinColumnBuilder = new RelationJoinColumnBuilder(connection);\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Builds a complete entity metadatas for the given entity classes.\n   */\n  build(entityClasses) {\n    // if entity classes to filter entities by are given then do filtering, otherwise use all\n    const allTables = entityClasses ? this.metadataArgsStorage.filterTables(entityClasses) : this.metadataArgsStorage.tables;\n    // filter out table metadata args for those we really create entity metadatas and tables in the db\n    const realTables = allTables.filter(table => table.type === \"regular\" || table.type === \"closure\" || table.type === \"entity-child\" || table.type === \"view\");\n    // create entity metadatas for a user defined entities (marked with @Entity decorator or loaded from entity schemas)\n    const entityMetadatas = realTables.map(tableArgs => this.createEntityMetadata(tableArgs));\n    // compute parent entity metadatas for table inheritance\n    entityMetadatas.forEach(entityMetadata => this.computeParentEntityMetadata(entityMetadatas, entityMetadata));\n    // after all metadatas created we set child entity metadatas for table inheritance\n    entityMetadatas.forEach(metadata => {\n      metadata.childEntityMetadatas = entityMetadatas.filter(childMetadata => {\n        return typeof metadata.target === \"function\" && typeof childMetadata.target === \"function\" && MetadataUtils.isInherited(childMetadata.target, metadata.target);\n      });\n    });\n    // build entity metadata (step0), first for non-single-table-inherited entity metadatas (dependant)\n    entityMetadatas.filter(entityMetadata => entityMetadata.tableType !== \"entity-child\").forEach(entityMetadata => entityMetadata.build());\n    // build entity metadata (step0), now for single-table-inherited entity metadatas (dependant)\n    entityMetadatas.filter(entityMetadata => entityMetadata.tableType === \"entity-child\").forEach(entityMetadata => entityMetadata.build());\n    // compute entity metadata columns, relations, etc. first for the regular, non-single-table-inherited entity metadatas\n    entityMetadatas.filter(entityMetadata => entityMetadata.tableType !== \"entity-child\").forEach(entityMetadata => this.computeEntityMetadataStep1(entityMetadatas, entityMetadata));\n    // then do it for single table inheritance children (since they are depend on their parents to be built)\n    entityMetadatas.filter(entityMetadata => entityMetadata.tableType === \"entity-child\").forEach(entityMetadata => this.computeEntityMetadataStep1(entityMetadatas, entityMetadata));\n    // calculate entity metadata computed properties and all its sub-metadatas\n    entityMetadatas.forEach(entityMetadata => this.computeEntityMetadataStep2(entityMetadata));\n    // calculate entity metadata's inverse properties\n    entityMetadatas.forEach(entityMetadata => this.computeInverseProperties(entityMetadata, entityMetadatas));\n    // go through all entity metadatas and create foreign keys / junction entity metadatas for their relations\n    entityMetadatas.filter(entityMetadata => entityMetadata.tableType !== \"entity-child\").forEach(entityMetadata => {\n      // create entity's relations join columns (for many-to-one and one-to-one owner)\n      entityMetadata.relations.filter(relation => relation.isOneToOne || relation.isManyToOne).forEach(relation => {\n        const joinColumns = this.metadataArgsStorage.filterJoinColumns(relation.target, relation.propertyName);\n        const {\n          foreignKey,\n          columns,\n          uniqueConstraint\n        } = this.relationJoinColumnBuilder.build(joinColumns, relation); // create a foreign key based on its metadata args\n        if (foreignKey) {\n          relation.registerForeignKeys(foreignKey); // push it to the relation and thus register there a join column\n          entityMetadata.foreignKeys.push(foreignKey);\n        }\n        if (columns) {\n          relation.registerJoinColumns(columns);\n        }\n        if (uniqueConstraint) {\n          if (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === \"aurora-mysql\" || this.connection.driver.options.type === \"mssql\" || this.connection.driver.options.type === \"sap\" || this.connection.driver.options.type === \"spanner\") {\n            const index = new IndexMetadata({\n              entityMetadata: uniqueConstraint.entityMetadata,\n              columns: uniqueConstraint.columns,\n              args: {\n                target: uniqueConstraint.target,\n                name: uniqueConstraint.name,\n                unique: true,\n                synchronize: true\n              }\n            });\n            if (this.connection.driver.options.type === \"mssql\") {\n              index.where = index.columns.map(column => {\n                return `${this.connection.driver.escape(column.databaseName)} IS NOT NULL`;\n              }).join(\" AND \");\n            }\n            if (this.connection.driver.options.type === \"spanner\") {\n              index.isNullFiltered = true;\n            }\n            if (relation.embeddedMetadata) {\n              relation.embeddedMetadata.indices.push(index);\n            } else {\n              relation.entityMetadata.ownIndices.push(index);\n            }\n            this.computeEntityMetadataStep2(entityMetadata);\n          } else {\n            if (relation.embeddedMetadata) {\n              relation.embeddedMetadata.uniques.push(uniqueConstraint);\n            } else {\n              relation.entityMetadata.ownUniques.push(uniqueConstraint);\n            }\n            this.computeEntityMetadataStep2(entityMetadata);\n          }\n        }\n        if (foreignKey && this.connection.driver.options.type === \"cockroachdb\") {\n          const index = new IndexMetadata({\n            entityMetadata: relation.entityMetadata,\n            columns: foreignKey.columns,\n            args: {\n              target: relation.entityMetadata.target,\n              synchronize: true\n            }\n          });\n          if (relation.embeddedMetadata) {\n            relation.embeddedMetadata.indices.push(index);\n          } else {\n            relation.entityMetadata.ownIndices.push(index);\n          }\n          this.computeEntityMetadataStep2(entityMetadata);\n        }\n      });\n      // create junction entity metadatas for entity many-to-many relations\n      entityMetadata.relations.filter(relation => relation.isManyToMany).forEach(relation => {\n        const joinTable = this.metadataArgsStorage.findJoinTable(relation.target, relation.propertyName);\n        if (!joinTable) return; // no join table set - no need to do anything (it means this is many-to-many inverse side)\n        // here we create a junction entity metadata for a new junction table of many-to-many relation\n        const junctionEntityMetadata = this.junctionEntityMetadataBuilder.build(relation, joinTable);\n        relation.registerForeignKeys(...junctionEntityMetadata.foreignKeys);\n        relation.registerJoinColumns(junctionEntityMetadata.ownIndices[0].columns, junctionEntityMetadata.ownIndices[1].columns);\n        relation.registerJunctionEntityMetadata(junctionEntityMetadata);\n        // compute new entity metadata properties and push it to entity metadatas pool\n        this.computeEntityMetadataStep2(junctionEntityMetadata);\n        this.computeInverseProperties(junctionEntityMetadata, entityMetadatas);\n        entityMetadatas.push(junctionEntityMetadata);\n      });\n    });\n    // update entity metadata depend properties\n    entityMetadatas.forEach(entityMetadata => {\n      entityMetadata.relationsWithJoinColumns = entityMetadata.relations.filter(relation => relation.isWithJoinColumn);\n      entityMetadata.hasNonNullableRelations = entityMetadata.relationsWithJoinColumns.some(relation => !relation.isNullable || relation.isPrimary);\n    });\n    // generate closure junction tables for all closure tables\n    entityMetadatas.filter(metadata => metadata.treeType === \"closure-table\").forEach(entityMetadata => {\n      const closureJunctionEntityMetadata = this.closureJunctionEntityMetadataBuilder.build(entityMetadata);\n      entityMetadata.closureJunctionTable = closureJunctionEntityMetadata;\n      this.computeEntityMetadataStep2(closureJunctionEntityMetadata);\n      this.computeInverseProperties(closureJunctionEntityMetadata, entityMetadatas);\n      entityMetadatas.push(closureJunctionEntityMetadata);\n    });\n    // generate keys for tables with single-table inheritance\n    entityMetadatas.filter(metadata => metadata.inheritancePattern === \"STI\" && metadata.discriminatorColumn).forEach(entityMetadata => this.createKeysForTableInheritance(entityMetadata));\n    // build all indices (need to do it after relations and their join columns are built)\n    entityMetadatas.forEach(entityMetadata => {\n      entityMetadata.indices.forEach(index => index.build(this.connection.namingStrategy));\n    });\n    // build all unique constraints (need to do it after relations and their join columns are built)\n    entityMetadatas.forEach(entityMetadata => {\n      entityMetadata.uniques.forEach(unique => unique.build(this.connection.namingStrategy));\n    });\n    // build all check constraints\n    entityMetadatas.forEach(entityMetadata => {\n      entityMetadata.checks.forEach(check => check.build(this.connection.namingStrategy));\n    });\n    // build all exclusion constraints\n    entityMetadatas.forEach(entityMetadata => {\n      entityMetadata.exclusions.forEach(exclusion => exclusion.build(this.connection.namingStrategy));\n    });\n    // add lazy initializer for entity relations\n    entityMetadatas.filter(metadata => typeof metadata.target === \"function\").forEach(entityMetadata => {\n      entityMetadata.relations.filter(relation => relation.isLazy).forEach(relation => {\n        this.connection.relationLoader.enableLazyLoad(relation, entityMetadata.target.prototype);\n      });\n    });\n    entityMetadatas.forEach(entityMetadata => {\n      entityMetadata.columns.forEach(column => {\n        // const target = column.embeddedMetadata ? column.embeddedMetadata.type : column.target;\n        const generated = this.metadataArgsStorage.findGenerated(column.target, column.propertyName);\n        if (generated) {\n          column.isGenerated = true;\n          column.generationStrategy = generated.strategy;\n          if (generated.strategy === \"uuid\") {\n            column.type = \"uuid\";\n          } else if (generated.strategy === \"rowid\") {\n            column.type = \"int\";\n          } else {\n            column.type = column.type || Number;\n          }\n          column.build(this.connection);\n          this.computeEntityMetadataStep2(entityMetadata);\n        }\n      });\n    });\n    return entityMetadatas;\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Creates entity metadata from the given table args.\n   * Creates column, relation, etc. metadatas for everything this entity metadata owns.\n   */\n  createEntityMetadata(tableArgs) {\n    // we take all \"inheritance tree\" from a target entity to collect all stored metadata args\n    // (by decorators or inside entity schemas). For example for target Post < ContentModel < Unit\n    // it will be an array of [Post, ContentModel, Unit] and we can then get all metadata args of those classes\n    const inheritanceTree = typeof tableArgs.target === \"function\" ? MetadataUtils.getInheritanceTree(tableArgs.target) : [tableArgs.target]; // todo: implement later here inheritance for string-targets\n    const tableInheritance = this.metadataArgsStorage.findInheritanceType(tableArgs.target);\n    const tableTree = this.metadataArgsStorage.findTree(tableArgs.target);\n    // if single table inheritance used, we need to copy all children columns in to parent table\n    let singleTableChildrenTargets;\n    if (tableInheritance && tableInheritance.pattern === \"STI\" || tableArgs.type === \"entity-child\") {\n      singleTableChildrenTargets = this.metadataArgsStorage.filterSingleTableChildren(tableArgs.target).map(args => args.target).filter(target => typeof target === \"function\");\n      inheritanceTree.push(...singleTableChildrenTargets);\n    }\n    return new EntityMetadata({\n      connection: this.connection,\n      args: tableArgs,\n      inheritanceTree: inheritanceTree,\n      tableTree: tableTree,\n      inheritancePattern: tableInheritance ? tableInheritance.pattern : undefined\n    });\n  }\n  computeParentEntityMetadata(allEntityMetadatas, entityMetadata) {\n    // after all metadatas created we set parent entity metadata for table inheritance\n    if (entityMetadata.tableType === \"entity-child\") {\n      entityMetadata.parentEntityMetadata = allEntityMetadatas.find(allEntityMetadata => {\n        return allEntityMetadata.inheritanceTree.indexOf(entityMetadata.target) !== -1 && allEntityMetadata.inheritancePattern === \"STI\";\n      });\n    }\n  }\n  computeEntityMetadataStep1(allEntityMetadatas, entityMetadata) {\n    const entityInheritance = this.metadataArgsStorage.findInheritanceType(entityMetadata.target);\n    const discriminatorValue = this.metadataArgsStorage.findDiscriminatorValue(entityMetadata.target);\n    if (typeof discriminatorValue !== \"undefined\") {\n      entityMetadata.discriminatorValue = discriminatorValue.value;\n    } else {\n      entityMetadata.discriminatorValue = entityMetadata.target.name;\n    }\n    // if single table inheritance is used, we need to mark all embedded columns as nullable\n    entityMetadata.embeddeds = this.createEmbeddedsRecursively(entityMetadata, this.metadataArgsStorage.filterEmbeddeds(entityMetadata.inheritanceTree)).map(embedded => {\n      if (entityMetadata.inheritancePattern === \"STI\") {\n        embedded.columns = embedded.columns.map(column => {\n          column.isNullable = true;\n          return column;\n        });\n      }\n      return embedded;\n    });\n    entityMetadata.ownColumns = this.metadataArgsStorage.filterColumns(entityMetadata.inheritanceTree).map(args => {\n      // for single table children we reuse columns created for their parents\n      if (entityMetadata.tableType === \"entity-child\") return entityMetadata.parentEntityMetadata.ownColumns.find(column => column.propertyName === args.propertyName);\n      const column = new ColumnMetadata({\n        connection: this.connection,\n        entityMetadata,\n        args\n      });\n      // if single table inheritance used, we need to mark all inherit table columns as nullable\n      const columnInSingleTableInheritedChild = allEntityMetadatas.find(otherEntityMetadata => otherEntityMetadata.tableType === \"entity-child\" && otherEntityMetadata.target === args.target);\n      if (columnInSingleTableInheritedChild) column.isNullable = true;\n      return column;\n    });\n    // for table inheritance we need to add a discriminator column\n    //\n    if (entityInheritance && entityInheritance.column) {\n      const discriminatorColumnName = entityInheritance.column && entityInheritance.column.name ? entityInheritance.column.name : \"type\";\n      let discriminatorColumn = entityMetadata.ownColumns.find(column => column.propertyName === discriminatorColumnName);\n      if (!discriminatorColumn) {\n        discriminatorColumn = new ColumnMetadata({\n          connection: this.connection,\n          entityMetadata: entityMetadata,\n          args: {\n            target: entityMetadata.target,\n            mode: \"virtual\",\n            propertyName: discriminatorColumnName,\n            options: entityInheritance.column || {\n              name: discriminatorColumnName,\n              type: \"varchar\",\n              nullable: false\n            }\n          }\n        });\n        discriminatorColumn.isVirtual = true;\n        discriminatorColumn.isDiscriminator = true;\n        entityMetadata.ownColumns.push(discriminatorColumn);\n      } else {\n        discriminatorColumn.isDiscriminator = true;\n      }\n    }\n    // add discriminator column to the child entity metadatas\n    // discriminator column will not be there automatically since we are creating it in the code above\n    if (entityMetadata.tableType === \"entity-child\") {\n      const discriminatorColumn = entityMetadata.parentEntityMetadata.ownColumns.find(column => column.isDiscriminator);\n      if (discriminatorColumn && !entityMetadata.ownColumns.find(column => column === discriminatorColumn)) {\n        entityMetadata.ownColumns.push(discriminatorColumn);\n      }\n      // also copy the inheritance pattern & tree metadata\n      // this comes in handy when inheritance and trees are used together\n      entityMetadata.inheritancePattern = entityMetadata.parentEntityMetadata.inheritancePattern;\n      if (!entityMetadata.treeType && !!entityMetadata.parentEntityMetadata.treeType) {\n        entityMetadata.treeType = entityMetadata.parentEntityMetadata.treeType;\n        entityMetadata.treeOptions = entityMetadata.parentEntityMetadata.treeOptions;\n        entityMetadata.treeParentRelation = entityMetadata.parentEntityMetadata.treeParentRelation;\n        entityMetadata.treeLevelColumn = entityMetadata.parentEntityMetadata.treeLevelColumn;\n      }\n    }\n    const {\n      namingStrategy\n    } = this.connection;\n    // check if tree is used then we need to add extra columns for specific tree types\n    if (entityMetadata.treeType === \"materialized-path\") {\n      entityMetadata.ownColumns.push(new ColumnMetadata({\n        connection: this.connection,\n        entityMetadata: entityMetadata,\n        materializedPath: true,\n        args: {\n          target: entityMetadata.target,\n          mode: \"virtual\",\n          propertyName: \"mpath\",\n          options: /*tree.column || */{\n            name: namingStrategy.materializedPathColumnName,\n            type: String,\n            nullable: true,\n            default: \"\"\n          }\n        }\n      }));\n    } else if (entityMetadata.treeType === \"nested-set\") {\n      const {\n        left,\n        right\n      } = namingStrategy.nestedSetColumnNames;\n      entityMetadata.ownColumns.push(new ColumnMetadata({\n        connection: this.connection,\n        entityMetadata: entityMetadata,\n        nestedSetLeft: true,\n        args: {\n          target: entityMetadata.target,\n          mode: \"virtual\",\n          propertyName: left,\n          options: /*tree.column || */{\n            name: left,\n            type: Number,\n            nullable: false,\n            default: 1\n          }\n        }\n      }));\n      entityMetadata.ownColumns.push(new ColumnMetadata({\n        connection: this.connection,\n        entityMetadata: entityMetadata,\n        nestedSetRight: true,\n        args: {\n          target: entityMetadata.target,\n          mode: \"virtual\",\n          propertyName: right,\n          options: /*tree.column || */{\n            name: right,\n            type: Number,\n            nullable: false,\n            default: 2\n          }\n        }\n      }));\n    }\n    entityMetadata.ownRelations = this.metadataArgsStorage.filterRelations(entityMetadata.inheritanceTree).map(args => {\n      // for single table children we reuse relations created for their parents\n      if (entityMetadata.tableType === \"entity-child\") {\n        const parentRelation = entityMetadata.parentEntityMetadata.ownRelations.find(relation => relation.propertyName === args.propertyName);\n        const type = typeof args.type === \"function\" ? args.type() : args.type;\n        if (parentRelation.type !== type) {\n          const clone = Object.create(parentRelation);\n          clone.type = type;\n          return clone;\n        }\n        return parentRelation;\n      }\n      return new RelationMetadata({\n        entityMetadata,\n        args\n      });\n    });\n    entityMetadata.relationIds = this.metadataArgsStorage.filterRelationIds(entityMetadata.inheritanceTree).map(args => {\n      // for single table children we reuse relation ids created for their parents\n      if (entityMetadata.tableType === \"entity-child\") return entityMetadata.parentEntityMetadata.relationIds.find(relationId => relationId.propertyName === args.propertyName);\n      return new RelationIdMetadata({\n        entityMetadata,\n        args\n      });\n    });\n    entityMetadata.relationCounts = this.metadataArgsStorage.filterRelationCounts(entityMetadata.inheritanceTree).map(args => {\n      // for single table children we reuse relation counts created for their parents\n      if (entityMetadata.tableType === \"entity-child\") return entityMetadata.parentEntityMetadata.relationCounts.find(relationCount => relationCount.propertyName === args.propertyName);\n      return new RelationCountMetadata({\n        entityMetadata,\n        args\n      });\n    });\n    entityMetadata.ownListeners = this.metadataArgsStorage.filterListeners(entityMetadata.inheritanceTree).map(args => {\n      return new EntityListenerMetadata({\n        entityMetadata: entityMetadata,\n        args: args\n      });\n    });\n    entityMetadata.checks = this.metadataArgsStorage.filterChecks(entityMetadata.inheritanceTree).map(args => {\n      return new CheckMetadata({\n        entityMetadata,\n        args\n      });\n    });\n    // Only PostgreSQL supports exclusion constraints.\n    if (this.connection.driver.options.type === \"postgres\") {\n      entityMetadata.exclusions = this.metadataArgsStorage.filterExclusions(entityMetadata.inheritanceTree).map(args => {\n        return new ExclusionMetadata({\n          entityMetadata,\n          args\n        });\n      });\n    }\n    if (this.connection.driver.options.type === \"cockroachdb\") {\n      entityMetadata.ownIndices = this.metadataArgsStorage.filterIndices(entityMetadata.inheritanceTree).filter(args => !args.unique).map(args => {\n        return new IndexMetadata({\n          entityMetadata,\n          args\n        });\n      });\n      const uniques = this.metadataArgsStorage.filterIndices(entityMetadata.inheritanceTree).filter(args => args.unique).map(args => {\n        return new UniqueMetadata({\n          entityMetadata: entityMetadata,\n          args: {\n            target: args.target,\n            name: args.name,\n            columns: args.columns\n          }\n        });\n      });\n      entityMetadata.ownUniques.push(...uniques);\n    } else {\n      entityMetadata.ownIndices = this.metadataArgsStorage.filterIndices(entityMetadata.inheritanceTree).map(args => {\n        return new IndexMetadata({\n          entityMetadata,\n          args\n        });\n      });\n    }\n    // This drivers stores unique constraints as unique indices.\n    if (DriverUtils.isMySQLFamily(this.connection.driver) || this.connection.driver.options.type === \"aurora-mysql\" || this.connection.driver.options.type === \"sap\" || this.connection.driver.options.type === \"spanner\") {\n      const indices = this.metadataArgsStorage.filterUniques(entityMetadata.inheritanceTree).map(args => {\n        return new IndexMetadata({\n          entityMetadata: entityMetadata,\n          args: {\n            target: args.target,\n            name: args.name,\n            columns: args.columns,\n            unique: true,\n            synchronize: true\n          }\n        });\n      });\n      entityMetadata.ownIndices.push(...indices);\n    } else {\n      const uniques = this.metadataArgsStorage.filterUniques(entityMetadata.inheritanceTree).map(args => {\n        return new UniqueMetadata({\n          entityMetadata,\n          args\n        });\n      });\n      entityMetadata.ownUniques.push(...uniques);\n    }\n  }\n  /**\n   * Creates from the given embedded metadata args real embedded metadatas with its columns and relations,\n   * and does the same for all its sub-embeddeds (goes recursively).\n   */\n  createEmbeddedsRecursively(entityMetadata, embeddedArgs) {\n    return embeddedArgs.map(embeddedArgs => {\n      const embeddedMetadata = new EmbeddedMetadata({\n        entityMetadata: entityMetadata,\n        args: embeddedArgs\n      });\n      const targets = typeof embeddedMetadata.type === \"function\" ? MetadataUtils.getInheritanceTree(embeddedMetadata.type) : [embeddedMetadata.type]; // todo: implement later here inheritance for string-targets\n      embeddedMetadata.columns = this.metadataArgsStorage.filterColumns(targets).map(args => {\n        return new ColumnMetadata({\n          connection: this.connection,\n          entityMetadata,\n          embeddedMetadata,\n          args\n        });\n      });\n      embeddedMetadata.relations = this.metadataArgsStorage.filterRelations(targets).map(args => {\n        return new RelationMetadata({\n          entityMetadata,\n          embeddedMetadata,\n          args\n        });\n      });\n      embeddedMetadata.listeners = this.metadataArgsStorage.filterListeners(targets).map(args => {\n        return new EntityListenerMetadata({\n          entityMetadata,\n          embeddedMetadata,\n          args\n        });\n      });\n      embeddedMetadata.indices = this.metadataArgsStorage.filterIndices(targets).map(args => {\n        return new IndexMetadata({\n          entityMetadata,\n          embeddedMetadata,\n          args\n        });\n      });\n      embeddedMetadata.uniques = this.metadataArgsStorage.filterUniques(targets).map(args => {\n        return new UniqueMetadata({\n          entityMetadata,\n          embeddedMetadata,\n          args\n        });\n      });\n      embeddedMetadata.relationIds = this.metadataArgsStorage.filterRelationIds(targets).map(args => {\n        return new RelationIdMetadata({\n          entityMetadata,\n          args\n        });\n      });\n      embeddedMetadata.relationCounts = this.metadataArgsStorage.filterRelationCounts(targets).map(args => {\n        return new RelationCountMetadata({\n          entityMetadata,\n          args\n        });\n      });\n      embeddedMetadata.embeddeds = this.createEmbeddedsRecursively(entityMetadata, this.metadataArgsStorage.filterEmbeddeds(targets));\n      embeddedMetadata.embeddeds.forEach(subEmbedded => subEmbedded.parentEmbeddedMetadata = embeddedMetadata);\n      entityMetadata.allEmbeddeds.push(embeddedMetadata);\n      return embeddedMetadata;\n    });\n  }\n  /**\n   * Computes all entity metadata's computed properties, and all its sub-metadatas (relations, columns, embeds, etc).\n   */\n  computeEntityMetadataStep2(entityMetadata) {\n    entityMetadata.embeddeds.forEach(embedded => embedded.build(this.connection));\n    entityMetadata.embeddeds.forEach(embedded => {\n      embedded.columnsFromTree.forEach(column => column.build(this.connection));\n      embedded.relationsFromTree.forEach(relation => relation.build());\n    });\n    entityMetadata.ownColumns.forEach(column => column.build(this.connection));\n    entityMetadata.ownRelations.forEach(relation => relation.build());\n    entityMetadata.relations = entityMetadata.embeddeds.reduce((relations, embedded) => relations.concat(embedded.relationsFromTree), entityMetadata.ownRelations);\n    entityMetadata.eagerRelations = entityMetadata.relations.filter(relation => relation.isEager);\n    entityMetadata.lazyRelations = entityMetadata.relations.filter(relation => relation.isLazy);\n    entityMetadata.oneToOneRelations = entityMetadata.relations.filter(relation => relation.isOneToOne);\n    entityMetadata.oneToManyRelations = entityMetadata.relations.filter(relation => relation.isOneToMany);\n    entityMetadata.manyToOneRelations = entityMetadata.relations.filter(relation => relation.isManyToOne);\n    entityMetadata.manyToManyRelations = entityMetadata.relations.filter(relation => relation.isManyToMany);\n    entityMetadata.ownerOneToOneRelations = entityMetadata.relations.filter(relation => relation.isOneToOneOwner);\n    entityMetadata.ownerManyToManyRelations = entityMetadata.relations.filter(relation => relation.isManyToManyOwner);\n    entityMetadata.treeParentRelation = entityMetadata.relations.find(relation => relation.isTreeParent);\n    entityMetadata.treeChildrenRelation = entityMetadata.relations.find(relation => relation.isTreeChildren);\n    entityMetadata.columns = entityMetadata.embeddeds.reduce((columns, embedded) => columns.concat(embedded.columnsFromTree), entityMetadata.ownColumns);\n    entityMetadata.listeners = entityMetadata.embeddeds.reduce((listeners, embedded) => listeners.concat(embedded.listenersFromTree), entityMetadata.ownListeners);\n    entityMetadata.afterLoadListeners = entityMetadata.listeners.filter(listener => listener.type === EventListenerTypes.AFTER_LOAD);\n    entityMetadata.afterInsertListeners = entityMetadata.listeners.filter(listener => listener.type === EventListenerTypes.AFTER_INSERT);\n    entityMetadata.afterUpdateListeners = entityMetadata.listeners.filter(listener => listener.type === EventListenerTypes.AFTER_UPDATE);\n    entityMetadata.afterRemoveListeners = entityMetadata.listeners.filter(listener => listener.type === EventListenerTypes.AFTER_REMOVE);\n    entityMetadata.afterSoftRemoveListeners = entityMetadata.listeners.filter(listener => listener.type === EventListenerTypes.AFTER_SOFT_REMOVE);\n    entityMetadata.afterRecoverListeners = entityMetadata.listeners.filter(listener => listener.type === EventListenerTypes.AFTER_RECOVER);\n    entityMetadata.beforeInsertListeners = entityMetadata.listeners.filter(listener => listener.type === EventListenerTypes.BEFORE_INSERT);\n    entityMetadata.beforeUpdateListeners = entityMetadata.listeners.filter(listener => listener.type === EventListenerTypes.BEFORE_UPDATE);\n    entityMetadata.beforeRemoveListeners = entityMetadata.listeners.filter(listener => listener.type === EventListenerTypes.BEFORE_REMOVE);\n    entityMetadata.beforeSoftRemoveListeners = entityMetadata.listeners.filter(listener => listener.type === EventListenerTypes.BEFORE_SOFT_REMOVE);\n    entityMetadata.beforeRecoverListeners = entityMetadata.listeners.filter(listener => listener.type === EventListenerTypes.BEFORE_RECOVER);\n    entityMetadata.indices = entityMetadata.embeddeds.reduce((indices, embedded) => indices.concat(embedded.indicesFromTree), entityMetadata.ownIndices);\n    entityMetadata.uniques = entityMetadata.embeddeds.reduce((uniques, embedded) => uniques.concat(embedded.uniquesFromTree), entityMetadata.ownUniques);\n    entityMetadata.primaryColumns = entityMetadata.columns.filter(column => column.isPrimary);\n    entityMetadata.nonVirtualColumns = entityMetadata.columns.filter(column => !column.isVirtual);\n    entityMetadata.ancestorColumns = entityMetadata.columns.filter(column => column.closureType === \"ancestor\");\n    entityMetadata.descendantColumns = entityMetadata.columns.filter(column => column.closureType === \"descendant\");\n    entityMetadata.hasMultiplePrimaryKeys = entityMetadata.primaryColumns.length > 1;\n    entityMetadata.generatedColumns = entityMetadata.columns.filter(column => column.isGenerated || column.isObjectId);\n    entityMetadata.hasUUIDGeneratedColumns = entityMetadata.columns.filter(column => column.isGenerated || column.generationStrategy === \"uuid\").length > 0;\n    entityMetadata.createDateColumn = entityMetadata.columns.find(column => column.isCreateDate);\n    entityMetadata.updateDateColumn = entityMetadata.columns.find(column => column.isUpdateDate);\n    entityMetadata.deleteDateColumn = entityMetadata.columns.find(column => column.isDeleteDate);\n    entityMetadata.versionColumn = entityMetadata.columns.find(column => column.isVersion);\n    entityMetadata.discriminatorColumn = entityMetadata.columns.find(column => column.isDiscriminator);\n    entityMetadata.treeLevelColumn = entityMetadata.columns.find(column => column.isTreeLevel);\n    entityMetadata.nestedSetLeftColumn = entityMetadata.columns.find(column => column.isNestedSetLeft);\n    entityMetadata.nestedSetRightColumn = entityMetadata.columns.find(column => column.isNestedSetRight);\n    entityMetadata.materializedPathColumn = entityMetadata.columns.find(column => column.isMaterializedPath);\n    entityMetadata.objectIdColumn = entityMetadata.columns.find(column => column.isObjectId);\n    entityMetadata.foreignKeys.forEach(foreignKey => foreignKey.build(this.connection.namingStrategy));\n    entityMetadata.propertiesMap = entityMetadata.createPropertiesMap();\n    entityMetadata.relationIds.forEach(relationId => relationId.build());\n    entityMetadata.relationCounts.forEach(relationCount => relationCount.build());\n    entityMetadata.embeddeds.forEach(embedded => {\n      embedded.relationIdsFromTree.forEach(relationId => relationId.build());\n      embedded.relationCountsFromTree.forEach(relationCount => relationCount.build());\n    });\n  }\n  /**\n   * Computes entity metadata's relations inverse side properties.\n   */\n  computeInverseProperties(entityMetadata, entityMetadatas) {\n    entityMetadata.relations.forEach(relation => {\n      // compute inverse side (related) entity metadatas for all relation metadatas\n      const inverseEntityMetadata = entityMetadatas.find(m => m.target === relation.type || typeof relation.type === \"string\" && (m.targetName === relation.type || m.givenTableName === relation.type));\n      if (!inverseEntityMetadata) throw new TypeORMError(\"Entity metadata for \" + entityMetadata.name + \"#\" + relation.propertyPath + \" was not found. Check if you specified a correct entity object and if it's connected in the connection options.\");\n      relation.inverseEntityMetadata = inverseEntityMetadata;\n      relation.inverseSidePropertyPath = relation.buildInverseSidePropertyPath();\n      // and compute inverse relation and mark if it has such\n      relation.inverseRelation = inverseEntityMetadata.relations.find(foundRelation => foundRelation.propertyPath === relation.inverseSidePropertyPath);\n    });\n  }\n  /**\n   * Creates indices for the table of single table inheritance.\n   */\n  createKeysForTableInheritance(entityMetadata) {\n    entityMetadata.indices.push(new IndexMetadata({\n      entityMetadata: entityMetadata,\n      columns: [entityMetadata.discriminatorColumn],\n      args: {\n        target: entityMetadata.target,\n        unique: false\n      }\n    }));\n  }\n}","map":{"version":3,"names":["EntityMetadata","ColumnMetadata","IndexMetadata","RelationMetadata","EmbeddedMetadata","RelationIdMetadata","RelationCountMetadata","EventListenerTypes","MetadataUtils","JunctionEntityMetadataBuilder","ClosureJunctionEntityMetadataBuilder","RelationJoinColumnBuilder","EntityListenerMetadata","UniqueMetadata","CheckMetadata","ExclusionMetadata","TypeORMError","DriverUtils","EntityMetadataBuilder","constructor","connection","metadataArgsStorage","junctionEntityMetadataBuilder","closureJunctionEntityMetadataBuilder","relationJoinColumnBuilder","build","entityClasses","allTables","filterTables","tables","realTables","filter","table","type","entityMetadatas","map","tableArgs","createEntityMetadata","forEach","entityMetadata","computeParentEntityMetadata","metadata","childEntityMetadatas","childMetadata","target","isInherited","tableType","computeEntityMetadataStep1","computeEntityMetadataStep2","computeInverseProperties","relations","relation","isOneToOne","isManyToOne","joinColumns","filterJoinColumns","propertyName","foreignKey","columns","uniqueConstraint","registerForeignKeys","foreignKeys","push","registerJoinColumns","isMySQLFamily","driver","options","index","args","name","unique","synchronize","where","column","escape","databaseName","join","isNullFiltered","embeddedMetadata","indices","ownIndices","uniques","ownUniques","isManyToMany","joinTable","findJoinTable","junctionEntityMetadata","registerJunctionEntityMetadata","relationsWithJoinColumns","isWithJoinColumn","hasNonNullableRelations","some","isNullable","isPrimary","treeType","closureJunctionEntityMetadata","closureJunctionTable","inheritancePattern","discriminatorColumn","createKeysForTableInheritance","namingStrategy","checks","check","exclusions","exclusion","isLazy","relationLoader","enableLazyLoad","prototype","generated","findGenerated","isGenerated","generationStrategy","strategy","Number","inheritanceTree","getInheritanceTree","tableInheritance","findInheritanceType","tableTree","findTree","singleTableChildrenTargets","pattern","filterSingleTableChildren","undefined","allEntityMetadatas","parentEntityMetadata","find","allEntityMetadata","indexOf","entityInheritance","discriminatorValue","findDiscriminatorValue","value","embeddeds","createEmbeddedsRecursively","filterEmbeddeds","embedded","ownColumns","filterColumns","columnInSingleTableInheritedChild","otherEntityMetadata","discriminatorColumnName","mode","nullable","isVirtual","isDiscriminator","treeOptions","treeParentRelation","treeLevelColumn","materializedPath","materializedPathColumnName","String","default","left","right","nestedSetColumnNames","nestedSetLeft","nestedSetRight","ownRelations","filterRelations","parentRelation","clone","Object","create","relationIds","filterRelationIds","relationId","relationCounts","filterRelationCounts","relationCount","ownListeners","filterListeners","filterChecks","filterExclusions","filterIndices","filterUniques","embeddedArgs","targets","listeners","subEmbedded","parentEmbeddedMetadata","allEmbeddeds","columnsFromTree","relationsFromTree","reduce","concat","eagerRelations","isEager","lazyRelations","oneToOneRelations","oneToManyRelations","isOneToMany","manyToOneRelations","manyToManyRelations","ownerOneToOneRelations","isOneToOneOwner","ownerManyToManyRelations","isManyToManyOwner","isTreeParent","treeChildrenRelation","isTreeChildren","listenersFromTree","afterLoadListeners","listener","AFTER_LOAD","afterInsertListeners","AFTER_INSERT","afterUpdateListeners","AFTER_UPDATE","afterRemoveListeners","AFTER_REMOVE","afterSoftRemoveListeners","AFTER_SOFT_REMOVE","afterRecoverListeners","AFTER_RECOVER","beforeInsertListeners","BEFORE_INSERT","beforeUpdateListeners","BEFORE_UPDATE","beforeRemoveListeners","BEFORE_REMOVE","beforeSoftRemoveListeners","BEFORE_SOFT_REMOVE","beforeRecoverListeners","BEFORE_RECOVER","indicesFromTree","uniquesFromTree","primaryColumns","nonVirtualColumns","ancestorColumns","closureType","descendantColumns","hasMultiplePrimaryKeys","length","generatedColumns","isObjectId","hasUUIDGeneratedColumns","createDateColumn","isCreateDate","updateDateColumn","isUpdateDate","deleteDateColumn","isDeleteDate","versionColumn","isVersion","isTreeLevel","nestedSetLeftColumn","isNestedSetLeft","nestedSetRightColumn","isNestedSetRight","materializedPathColumn","isMaterializedPath","objectIdColumn","propertiesMap","createPropertiesMap","relationIdsFromTree","relationCountsFromTree","inverseEntityMetadata","m","targetName","givenTableName","propertyPath","inverseSidePropertyPath","buildInverseSidePropertyPath","inverseRelation","foundRelation"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/metadata-builder/EntityMetadataBuilder.js"],"sourcesContent":["import { EntityMetadata } from \"../metadata/EntityMetadata\";\nimport { ColumnMetadata } from \"../metadata/ColumnMetadata\";\nimport { IndexMetadata } from \"../metadata/IndexMetadata\";\nimport { RelationMetadata } from \"../metadata/RelationMetadata\";\nimport { EmbeddedMetadata } from \"../metadata/EmbeddedMetadata\";\nimport { RelationIdMetadata } from \"../metadata/RelationIdMetadata\";\nimport { RelationCountMetadata } from \"../metadata/RelationCountMetadata\";\nimport { EventListenerTypes } from \"../metadata/types/EventListenerTypes\";\nimport { MetadataUtils } from \"./MetadataUtils\";\nimport { JunctionEntityMetadataBuilder } from \"./JunctionEntityMetadataBuilder\";\nimport { ClosureJunctionEntityMetadataBuilder } from \"./ClosureJunctionEntityMetadataBuilder\";\nimport { RelationJoinColumnBuilder } from \"./RelationJoinColumnBuilder\";\nimport { EntityListenerMetadata } from \"../metadata/EntityListenerMetadata\";\nimport { UniqueMetadata } from \"../metadata/UniqueMetadata\";\nimport { CheckMetadata } from \"../metadata/CheckMetadata\";\nimport { ExclusionMetadata } from \"../metadata/ExclusionMetadata\";\nimport { TypeORMError } from \"../error\";\nimport { DriverUtils } from \"../driver/DriverUtils\";\n/**\n * Builds EntityMetadata objects and all its sub-metadatas.\n */\nexport class EntityMetadataBuilder {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n    constructor(connection, metadataArgsStorage) {\n        this.connection = connection;\n        this.metadataArgsStorage = metadataArgsStorage;\n        this.junctionEntityMetadataBuilder = new JunctionEntityMetadataBuilder(connection);\n        this.closureJunctionEntityMetadataBuilder =\n            new ClosureJunctionEntityMetadataBuilder(connection);\n        this.relationJoinColumnBuilder = new RelationJoinColumnBuilder(connection);\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Builds a complete entity metadatas for the given entity classes.\n     */\n    build(entityClasses) {\n        // if entity classes to filter entities by are given then do filtering, otherwise use all\n        const allTables = entityClasses\n            ? this.metadataArgsStorage.filterTables(entityClasses)\n            : this.metadataArgsStorage.tables;\n        // filter out table metadata args for those we really create entity metadatas and tables in the db\n        const realTables = allTables.filter((table) => table.type === \"regular\" ||\n            table.type === \"closure\" ||\n            table.type === \"entity-child\" ||\n            table.type === \"view\");\n        // create entity metadatas for a user defined entities (marked with @Entity decorator or loaded from entity schemas)\n        const entityMetadatas = realTables.map((tableArgs) => this.createEntityMetadata(tableArgs));\n        // compute parent entity metadatas for table inheritance\n        entityMetadatas.forEach((entityMetadata) => this.computeParentEntityMetadata(entityMetadatas, entityMetadata));\n        // after all metadatas created we set child entity metadatas for table inheritance\n        entityMetadatas.forEach((metadata) => {\n            metadata.childEntityMetadatas = entityMetadatas.filter((childMetadata) => {\n                return (typeof metadata.target === \"function\" &&\n                    typeof childMetadata.target === \"function\" &&\n                    MetadataUtils.isInherited(childMetadata.target, metadata.target));\n            });\n        });\n        // build entity metadata (step0), first for non-single-table-inherited entity metadatas (dependant)\n        entityMetadatas\n            .filter((entityMetadata) => entityMetadata.tableType !== \"entity-child\")\n            .forEach((entityMetadata) => entityMetadata.build());\n        // build entity metadata (step0), now for single-table-inherited entity metadatas (dependant)\n        entityMetadatas\n            .filter((entityMetadata) => entityMetadata.tableType === \"entity-child\")\n            .forEach((entityMetadata) => entityMetadata.build());\n        // compute entity metadata columns, relations, etc. first for the regular, non-single-table-inherited entity metadatas\n        entityMetadatas\n            .filter((entityMetadata) => entityMetadata.tableType !== \"entity-child\")\n            .forEach((entityMetadata) => this.computeEntityMetadataStep1(entityMetadatas, entityMetadata));\n        // then do it for single table inheritance children (since they are depend on their parents to be built)\n        entityMetadatas\n            .filter((entityMetadata) => entityMetadata.tableType === \"entity-child\")\n            .forEach((entityMetadata) => this.computeEntityMetadataStep1(entityMetadatas, entityMetadata));\n        // calculate entity metadata computed properties and all its sub-metadatas\n        entityMetadatas.forEach((entityMetadata) => this.computeEntityMetadataStep2(entityMetadata));\n        // calculate entity metadata's inverse properties\n        entityMetadatas.forEach((entityMetadata) => this.computeInverseProperties(entityMetadata, entityMetadatas));\n        // go through all entity metadatas and create foreign keys / junction entity metadatas for their relations\n        entityMetadatas\n            .filter((entityMetadata) => entityMetadata.tableType !== \"entity-child\")\n            .forEach((entityMetadata) => {\n            // create entity's relations join columns (for many-to-one and one-to-one owner)\n            entityMetadata.relations\n                .filter((relation) => relation.isOneToOne || relation.isManyToOne)\n                .forEach((relation) => {\n                const joinColumns = this.metadataArgsStorage.filterJoinColumns(relation.target, relation.propertyName);\n                const { foreignKey, columns, uniqueConstraint } = this.relationJoinColumnBuilder.build(joinColumns, relation); // create a foreign key based on its metadata args\n                if (foreignKey) {\n                    relation.registerForeignKeys(foreignKey); // push it to the relation and thus register there a join column\n                    entityMetadata.foreignKeys.push(foreignKey);\n                }\n                if (columns) {\n                    relation.registerJoinColumns(columns);\n                }\n                if (uniqueConstraint) {\n                    if (DriverUtils.isMySQLFamily(this.connection.driver) ||\n                        this.connection.driver.options.type ===\n                            \"aurora-mysql\" ||\n                        this.connection.driver.options.type ===\n                            \"mssql\" ||\n                        this.connection.driver.options.type === \"sap\" ||\n                        this.connection.driver.options.type ===\n                            \"spanner\") {\n                        const index = new IndexMetadata({\n                            entityMetadata: uniqueConstraint.entityMetadata,\n                            columns: uniqueConstraint.columns,\n                            args: {\n                                target: uniqueConstraint.target,\n                                name: uniqueConstraint.name,\n                                unique: true,\n                                synchronize: true,\n                            },\n                        });\n                        if (this.connection.driver.options.type ===\n                            \"mssql\") {\n                            index.where = index.columns\n                                .map((column) => {\n                                return `${this.connection.driver.escape(column.databaseName)} IS NOT NULL`;\n                            })\n                                .join(\" AND \");\n                        }\n                        if (this.connection.driver.options.type ===\n                            \"spanner\") {\n                            index.isNullFiltered = true;\n                        }\n                        if (relation.embeddedMetadata) {\n                            relation.embeddedMetadata.indices.push(index);\n                        }\n                        else {\n                            relation.entityMetadata.ownIndices.push(index);\n                        }\n                        this.computeEntityMetadataStep2(entityMetadata);\n                    }\n                    else {\n                        if (relation.embeddedMetadata) {\n                            relation.embeddedMetadata.uniques.push(uniqueConstraint);\n                        }\n                        else {\n                            relation.entityMetadata.ownUniques.push(uniqueConstraint);\n                        }\n                        this.computeEntityMetadataStep2(entityMetadata);\n                    }\n                }\n                if (foreignKey &&\n                    this.connection.driver.options.type ===\n                        \"cockroachdb\") {\n                    const index = new IndexMetadata({\n                        entityMetadata: relation.entityMetadata,\n                        columns: foreignKey.columns,\n                        args: {\n                            target: relation.entityMetadata.target,\n                            synchronize: true,\n                        },\n                    });\n                    if (relation.embeddedMetadata) {\n                        relation.embeddedMetadata.indices.push(index);\n                    }\n                    else {\n                        relation.entityMetadata.ownIndices.push(index);\n                    }\n                    this.computeEntityMetadataStep2(entityMetadata);\n                }\n            });\n            // create junction entity metadatas for entity many-to-many relations\n            entityMetadata.relations\n                .filter((relation) => relation.isManyToMany)\n                .forEach((relation) => {\n                const joinTable = this.metadataArgsStorage.findJoinTable(relation.target, relation.propertyName);\n                if (!joinTable)\n                    return; // no join table set - no need to do anything (it means this is many-to-many inverse side)\n                // here we create a junction entity metadata for a new junction table of many-to-many relation\n                const junctionEntityMetadata = this.junctionEntityMetadataBuilder.build(relation, joinTable);\n                relation.registerForeignKeys(...junctionEntityMetadata.foreignKeys);\n                relation.registerJoinColumns(junctionEntityMetadata.ownIndices[0].columns, junctionEntityMetadata.ownIndices[1].columns);\n                relation.registerJunctionEntityMetadata(junctionEntityMetadata);\n                // compute new entity metadata properties and push it to entity metadatas pool\n                this.computeEntityMetadataStep2(junctionEntityMetadata);\n                this.computeInverseProperties(junctionEntityMetadata, entityMetadatas);\n                entityMetadatas.push(junctionEntityMetadata);\n            });\n        });\n        // update entity metadata depend properties\n        entityMetadatas.forEach((entityMetadata) => {\n            entityMetadata.relationsWithJoinColumns =\n                entityMetadata.relations.filter((relation) => relation.isWithJoinColumn);\n            entityMetadata.hasNonNullableRelations =\n                entityMetadata.relationsWithJoinColumns.some((relation) => !relation.isNullable || relation.isPrimary);\n        });\n        // generate closure junction tables for all closure tables\n        entityMetadatas\n            .filter((metadata) => metadata.treeType === \"closure-table\")\n            .forEach((entityMetadata) => {\n            const closureJunctionEntityMetadata = this.closureJunctionEntityMetadataBuilder.build(entityMetadata);\n            entityMetadata.closureJunctionTable =\n                closureJunctionEntityMetadata;\n            this.computeEntityMetadataStep2(closureJunctionEntityMetadata);\n            this.computeInverseProperties(closureJunctionEntityMetadata, entityMetadatas);\n            entityMetadatas.push(closureJunctionEntityMetadata);\n        });\n        // generate keys for tables with single-table inheritance\n        entityMetadatas\n            .filter((metadata) => metadata.inheritancePattern === \"STI\" &&\n            metadata.discriminatorColumn)\n            .forEach((entityMetadata) => this.createKeysForTableInheritance(entityMetadata));\n        // build all indices (need to do it after relations and their join columns are built)\n        entityMetadatas.forEach((entityMetadata) => {\n            entityMetadata.indices.forEach((index) => index.build(this.connection.namingStrategy));\n        });\n        // build all unique constraints (need to do it after relations and their join columns are built)\n        entityMetadatas.forEach((entityMetadata) => {\n            entityMetadata.uniques.forEach((unique) => unique.build(this.connection.namingStrategy));\n        });\n        // build all check constraints\n        entityMetadatas.forEach((entityMetadata) => {\n            entityMetadata.checks.forEach((check) => check.build(this.connection.namingStrategy));\n        });\n        // build all exclusion constraints\n        entityMetadatas.forEach((entityMetadata) => {\n            entityMetadata.exclusions.forEach((exclusion) => exclusion.build(this.connection.namingStrategy));\n        });\n        // add lazy initializer for entity relations\n        entityMetadatas\n            .filter((metadata) => typeof metadata.target === \"function\")\n            .forEach((entityMetadata) => {\n            entityMetadata.relations\n                .filter((relation) => relation.isLazy)\n                .forEach((relation) => {\n                this.connection.relationLoader.enableLazyLoad(relation, entityMetadata.target.prototype);\n            });\n        });\n        entityMetadatas.forEach((entityMetadata) => {\n            entityMetadata.columns.forEach((column) => {\n                // const target = column.embeddedMetadata ? column.embeddedMetadata.type : column.target;\n                const generated = this.metadataArgsStorage.findGenerated(column.target, column.propertyName);\n                if (generated) {\n                    column.isGenerated = true;\n                    column.generationStrategy = generated.strategy;\n                    if (generated.strategy === \"uuid\") {\n                        column.type = \"uuid\";\n                    }\n                    else if (generated.strategy === \"rowid\") {\n                        column.type = \"int\";\n                    }\n                    else {\n                        column.type = column.type || Number;\n                    }\n                    column.build(this.connection);\n                    this.computeEntityMetadataStep2(entityMetadata);\n                }\n            });\n        });\n        return entityMetadatas;\n    }\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Creates entity metadata from the given table args.\n     * Creates column, relation, etc. metadatas for everything this entity metadata owns.\n     */\n    createEntityMetadata(tableArgs) {\n        // we take all \"inheritance tree\" from a target entity to collect all stored metadata args\n        // (by decorators or inside entity schemas). For example for target Post < ContentModel < Unit\n        // it will be an array of [Post, ContentModel, Unit] and we can then get all metadata args of those classes\n        const inheritanceTree = typeof tableArgs.target === \"function\"\n            ? MetadataUtils.getInheritanceTree(tableArgs.target)\n            : [tableArgs.target]; // todo: implement later here inheritance for string-targets\n        const tableInheritance = this.metadataArgsStorage.findInheritanceType(tableArgs.target);\n        const tableTree = this.metadataArgsStorage.findTree(tableArgs.target);\n        // if single table inheritance used, we need to copy all children columns in to parent table\n        let singleTableChildrenTargets;\n        if ((tableInheritance && tableInheritance.pattern === \"STI\") ||\n            tableArgs.type === \"entity-child\") {\n            singleTableChildrenTargets = this.metadataArgsStorage\n                .filterSingleTableChildren(tableArgs.target)\n                .map((args) => args.target)\n                .filter((target) => typeof target === \"function\");\n            inheritanceTree.push(...singleTableChildrenTargets);\n        }\n        return new EntityMetadata({\n            connection: this.connection,\n            args: tableArgs,\n            inheritanceTree: inheritanceTree,\n            tableTree: tableTree,\n            inheritancePattern: tableInheritance\n                ? tableInheritance.pattern\n                : undefined,\n        });\n    }\n    computeParentEntityMetadata(allEntityMetadatas, entityMetadata) {\n        // after all metadatas created we set parent entity metadata for table inheritance\n        if (entityMetadata.tableType === \"entity-child\") {\n            entityMetadata.parentEntityMetadata = allEntityMetadatas.find((allEntityMetadata) => {\n                return (allEntityMetadata.inheritanceTree.indexOf(entityMetadata.target) !== -1 &&\n                    allEntityMetadata.inheritancePattern === \"STI\");\n            });\n        }\n    }\n    computeEntityMetadataStep1(allEntityMetadatas, entityMetadata) {\n        const entityInheritance = this.metadataArgsStorage.findInheritanceType(entityMetadata.target);\n        const discriminatorValue = this.metadataArgsStorage.findDiscriminatorValue(entityMetadata.target);\n        if (typeof discriminatorValue !== \"undefined\") {\n            entityMetadata.discriminatorValue = discriminatorValue.value;\n        }\n        else {\n            entityMetadata.discriminatorValue = entityMetadata.target.name;\n        }\n        // if single table inheritance is used, we need to mark all embedded columns as nullable\n        entityMetadata.embeddeds = this.createEmbeddedsRecursively(entityMetadata, this.metadataArgsStorage.filterEmbeddeds(entityMetadata.inheritanceTree)).map((embedded) => {\n            if (entityMetadata.inheritancePattern === \"STI\") {\n                embedded.columns = embedded.columns.map((column) => {\n                    column.isNullable = true;\n                    return column;\n                });\n            }\n            return embedded;\n        });\n        entityMetadata.ownColumns = this.metadataArgsStorage\n            .filterColumns(entityMetadata.inheritanceTree)\n            .map((args) => {\n            // for single table children we reuse columns created for their parents\n            if (entityMetadata.tableType === \"entity-child\")\n                return entityMetadata.parentEntityMetadata.ownColumns.find((column) => column.propertyName === args.propertyName);\n            const column = new ColumnMetadata({\n                connection: this.connection,\n                entityMetadata,\n                args,\n            });\n            // if single table inheritance used, we need to mark all inherit table columns as nullable\n            const columnInSingleTableInheritedChild = allEntityMetadatas.find((otherEntityMetadata) => otherEntityMetadata.tableType === \"entity-child\" &&\n                otherEntityMetadata.target === args.target);\n            if (columnInSingleTableInheritedChild)\n                column.isNullable = true;\n            return column;\n        });\n        // for table inheritance we need to add a discriminator column\n        //\n        if (entityInheritance && entityInheritance.column) {\n            const discriminatorColumnName = entityInheritance.column && entityInheritance.column.name\n                ? entityInheritance.column.name\n                : \"type\";\n            let discriminatorColumn = entityMetadata.ownColumns.find((column) => column.propertyName === discriminatorColumnName);\n            if (!discriminatorColumn) {\n                discriminatorColumn = new ColumnMetadata({\n                    connection: this.connection,\n                    entityMetadata: entityMetadata,\n                    args: {\n                        target: entityMetadata.target,\n                        mode: \"virtual\",\n                        propertyName: discriminatorColumnName,\n                        options: entityInheritance.column || {\n                            name: discriminatorColumnName,\n                            type: \"varchar\",\n                            nullable: false,\n                        },\n                    },\n                });\n                discriminatorColumn.isVirtual = true;\n                discriminatorColumn.isDiscriminator = true;\n                entityMetadata.ownColumns.push(discriminatorColumn);\n            }\n            else {\n                discriminatorColumn.isDiscriminator = true;\n            }\n        }\n        // add discriminator column to the child entity metadatas\n        // discriminator column will not be there automatically since we are creating it in the code above\n        if (entityMetadata.tableType === \"entity-child\") {\n            const discriminatorColumn = entityMetadata.parentEntityMetadata.ownColumns.find((column) => column.isDiscriminator);\n            if (discriminatorColumn &&\n                !entityMetadata.ownColumns.find((column) => column === discriminatorColumn)) {\n                entityMetadata.ownColumns.push(discriminatorColumn);\n            }\n            // also copy the inheritance pattern & tree metadata\n            // this comes in handy when inheritance and trees are used together\n            entityMetadata.inheritancePattern =\n                entityMetadata.parentEntityMetadata.inheritancePattern;\n            if (!entityMetadata.treeType &&\n                !!entityMetadata.parentEntityMetadata.treeType) {\n                entityMetadata.treeType =\n                    entityMetadata.parentEntityMetadata.treeType;\n                entityMetadata.treeOptions =\n                    entityMetadata.parentEntityMetadata.treeOptions;\n                entityMetadata.treeParentRelation =\n                    entityMetadata.parentEntityMetadata.treeParentRelation;\n                entityMetadata.treeLevelColumn =\n                    entityMetadata.parentEntityMetadata.treeLevelColumn;\n            }\n        }\n        const { namingStrategy } = this.connection;\n        // check if tree is used then we need to add extra columns for specific tree types\n        if (entityMetadata.treeType === \"materialized-path\") {\n            entityMetadata.ownColumns.push(new ColumnMetadata({\n                connection: this.connection,\n                entityMetadata: entityMetadata,\n                materializedPath: true,\n                args: {\n                    target: entityMetadata.target,\n                    mode: \"virtual\",\n                    propertyName: \"mpath\",\n                    options: /*tree.column || */ {\n                        name: namingStrategy.materializedPathColumnName,\n                        type: String,\n                        nullable: true,\n                        default: \"\",\n                    },\n                },\n            }));\n        }\n        else if (entityMetadata.treeType === \"nested-set\") {\n            const { left, right } = namingStrategy.nestedSetColumnNames;\n            entityMetadata.ownColumns.push(new ColumnMetadata({\n                connection: this.connection,\n                entityMetadata: entityMetadata,\n                nestedSetLeft: true,\n                args: {\n                    target: entityMetadata.target,\n                    mode: \"virtual\",\n                    propertyName: left,\n                    options: /*tree.column || */ {\n                        name: left,\n                        type: Number,\n                        nullable: false,\n                        default: 1,\n                    },\n                },\n            }));\n            entityMetadata.ownColumns.push(new ColumnMetadata({\n                connection: this.connection,\n                entityMetadata: entityMetadata,\n                nestedSetRight: true,\n                args: {\n                    target: entityMetadata.target,\n                    mode: \"virtual\",\n                    propertyName: right,\n                    options: /*tree.column || */ {\n                        name: right,\n                        type: Number,\n                        nullable: false,\n                        default: 2,\n                    },\n                },\n            }));\n        }\n        entityMetadata.ownRelations = this.metadataArgsStorage\n            .filterRelations(entityMetadata.inheritanceTree)\n            .map((args) => {\n            // for single table children we reuse relations created for their parents\n            if (entityMetadata.tableType === \"entity-child\") {\n                const parentRelation = entityMetadata.parentEntityMetadata.ownRelations.find((relation) => relation.propertyName === args.propertyName);\n                const type = typeof args.type === \"function\"\n                    ? args.type()\n                    : args.type;\n                if (parentRelation.type !== type) {\n                    const clone = Object.create(parentRelation);\n                    clone.type = type;\n                    return clone;\n                }\n                return parentRelation;\n            }\n            return new RelationMetadata({ entityMetadata, args });\n        });\n        entityMetadata.relationIds = this.metadataArgsStorage\n            .filterRelationIds(entityMetadata.inheritanceTree)\n            .map((args) => {\n            // for single table children we reuse relation ids created for their parents\n            if (entityMetadata.tableType === \"entity-child\")\n                return entityMetadata.parentEntityMetadata.relationIds.find((relationId) => relationId.propertyName === args.propertyName);\n            return new RelationIdMetadata({ entityMetadata, args });\n        });\n        entityMetadata.relationCounts = this.metadataArgsStorage\n            .filterRelationCounts(entityMetadata.inheritanceTree)\n            .map((args) => {\n            // for single table children we reuse relation counts created for their parents\n            if (entityMetadata.tableType === \"entity-child\")\n                return entityMetadata.parentEntityMetadata.relationCounts.find((relationCount) => relationCount.propertyName === args.propertyName);\n            return new RelationCountMetadata({ entityMetadata, args });\n        });\n        entityMetadata.ownListeners = this.metadataArgsStorage\n            .filterListeners(entityMetadata.inheritanceTree)\n            .map((args) => {\n            return new EntityListenerMetadata({\n                entityMetadata: entityMetadata,\n                args: args,\n            });\n        });\n        entityMetadata.checks = this.metadataArgsStorage\n            .filterChecks(entityMetadata.inheritanceTree)\n            .map((args) => {\n            return new CheckMetadata({ entityMetadata, args });\n        });\n        // Only PostgreSQL supports exclusion constraints.\n        if (this.connection.driver.options.type === \"postgres\") {\n            entityMetadata.exclusions = this.metadataArgsStorage\n                .filterExclusions(entityMetadata.inheritanceTree)\n                .map((args) => {\n                return new ExclusionMetadata({ entityMetadata, args });\n            });\n        }\n        if (this.connection.driver.options.type === \"cockroachdb\") {\n            entityMetadata.ownIndices = this.metadataArgsStorage\n                .filterIndices(entityMetadata.inheritanceTree)\n                .filter((args) => !args.unique)\n                .map((args) => {\n                return new IndexMetadata({ entityMetadata, args });\n            });\n            const uniques = this.metadataArgsStorage\n                .filterIndices(entityMetadata.inheritanceTree)\n                .filter((args) => args.unique)\n                .map((args) => {\n                return new UniqueMetadata({\n                    entityMetadata: entityMetadata,\n                    args: {\n                        target: args.target,\n                        name: args.name,\n                        columns: args.columns,\n                    },\n                });\n            });\n            entityMetadata.ownUniques.push(...uniques);\n        }\n        else {\n            entityMetadata.ownIndices = this.metadataArgsStorage\n                .filterIndices(entityMetadata.inheritanceTree)\n                .map((args) => {\n                return new IndexMetadata({ entityMetadata, args });\n            });\n        }\n        // This drivers stores unique constraints as unique indices.\n        if (DriverUtils.isMySQLFamily(this.connection.driver) ||\n            this.connection.driver.options.type === \"aurora-mysql\" ||\n            this.connection.driver.options.type === \"sap\" ||\n            this.connection.driver.options.type === \"spanner\") {\n            const indices = this.metadataArgsStorage\n                .filterUniques(entityMetadata.inheritanceTree)\n                .map((args) => {\n                return new IndexMetadata({\n                    entityMetadata: entityMetadata,\n                    args: {\n                        target: args.target,\n                        name: args.name,\n                        columns: args.columns,\n                        unique: true,\n                        synchronize: true,\n                    },\n                });\n            });\n            entityMetadata.ownIndices.push(...indices);\n        }\n        else {\n            const uniques = this.metadataArgsStorage\n                .filterUniques(entityMetadata.inheritanceTree)\n                .map((args) => {\n                return new UniqueMetadata({ entityMetadata, args });\n            });\n            entityMetadata.ownUniques.push(...uniques);\n        }\n    }\n    /**\n     * Creates from the given embedded metadata args real embedded metadatas with its columns and relations,\n     * and does the same for all its sub-embeddeds (goes recursively).\n     */\n    createEmbeddedsRecursively(entityMetadata, embeddedArgs) {\n        return embeddedArgs.map((embeddedArgs) => {\n            const embeddedMetadata = new EmbeddedMetadata({\n                entityMetadata: entityMetadata,\n                args: embeddedArgs,\n            });\n            const targets = typeof embeddedMetadata.type === \"function\"\n                ? MetadataUtils.getInheritanceTree(embeddedMetadata.type)\n                : [embeddedMetadata.type]; // todo: implement later here inheritance for string-targets\n            embeddedMetadata.columns = this.metadataArgsStorage\n                .filterColumns(targets)\n                .map((args) => {\n                return new ColumnMetadata({\n                    connection: this.connection,\n                    entityMetadata,\n                    embeddedMetadata,\n                    args,\n                });\n            });\n            embeddedMetadata.relations = this.metadataArgsStorage\n                .filterRelations(targets)\n                .map((args) => {\n                return new RelationMetadata({\n                    entityMetadata,\n                    embeddedMetadata,\n                    args,\n                });\n            });\n            embeddedMetadata.listeners = this.metadataArgsStorage\n                .filterListeners(targets)\n                .map((args) => {\n                return new EntityListenerMetadata({\n                    entityMetadata,\n                    embeddedMetadata,\n                    args,\n                });\n            });\n            embeddedMetadata.indices = this.metadataArgsStorage\n                .filterIndices(targets)\n                .map((args) => {\n                return new IndexMetadata({\n                    entityMetadata,\n                    embeddedMetadata,\n                    args,\n                });\n            });\n            embeddedMetadata.uniques = this.metadataArgsStorage\n                .filterUniques(targets)\n                .map((args) => {\n                return new UniqueMetadata({\n                    entityMetadata,\n                    embeddedMetadata,\n                    args,\n                });\n            });\n            embeddedMetadata.relationIds = this.metadataArgsStorage\n                .filterRelationIds(targets)\n                .map((args) => {\n                return new RelationIdMetadata({ entityMetadata, args });\n            });\n            embeddedMetadata.relationCounts = this.metadataArgsStorage\n                .filterRelationCounts(targets)\n                .map((args) => {\n                return new RelationCountMetadata({ entityMetadata, args });\n            });\n            embeddedMetadata.embeddeds = this.createEmbeddedsRecursively(entityMetadata, this.metadataArgsStorage.filterEmbeddeds(targets));\n            embeddedMetadata.embeddeds.forEach((subEmbedded) => (subEmbedded.parentEmbeddedMetadata = embeddedMetadata));\n            entityMetadata.allEmbeddeds.push(embeddedMetadata);\n            return embeddedMetadata;\n        });\n    }\n    /**\n     * Computes all entity metadata's computed properties, and all its sub-metadatas (relations, columns, embeds, etc).\n     */\n    computeEntityMetadataStep2(entityMetadata) {\n        entityMetadata.embeddeds.forEach((embedded) => embedded.build(this.connection));\n        entityMetadata.embeddeds.forEach((embedded) => {\n            embedded.columnsFromTree.forEach((column) => column.build(this.connection));\n            embedded.relationsFromTree.forEach((relation) => relation.build());\n        });\n        entityMetadata.ownColumns.forEach((column) => column.build(this.connection));\n        entityMetadata.ownRelations.forEach((relation) => relation.build());\n        entityMetadata.relations = entityMetadata.embeddeds.reduce((relations, embedded) => relations.concat(embedded.relationsFromTree), entityMetadata.ownRelations);\n        entityMetadata.eagerRelations = entityMetadata.relations.filter((relation) => relation.isEager);\n        entityMetadata.lazyRelations = entityMetadata.relations.filter((relation) => relation.isLazy);\n        entityMetadata.oneToOneRelations = entityMetadata.relations.filter((relation) => relation.isOneToOne);\n        entityMetadata.oneToManyRelations = entityMetadata.relations.filter((relation) => relation.isOneToMany);\n        entityMetadata.manyToOneRelations = entityMetadata.relations.filter((relation) => relation.isManyToOne);\n        entityMetadata.manyToManyRelations = entityMetadata.relations.filter((relation) => relation.isManyToMany);\n        entityMetadata.ownerOneToOneRelations = entityMetadata.relations.filter((relation) => relation.isOneToOneOwner);\n        entityMetadata.ownerManyToManyRelations =\n            entityMetadata.relations.filter((relation) => relation.isManyToManyOwner);\n        entityMetadata.treeParentRelation = entityMetadata.relations.find((relation) => relation.isTreeParent);\n        entityMetadata.treeChildrenRelation = entityMetadata.relations.find((relation) => relation.isTreeChildren);\n        entityMetadata.columns = entityMetadata.embeddeds.reduce((columns, embedded) => columns.concat(embedded.columnsFromTree), entityMetadata.ownColumns);\n        entityMetadata.listeners = entityMetadata.embeddeds.reduce((listeners, embedded) => listeners.concat(embedded.listenersFromTree), entityMetadata.ownListeners);\n        entityMetadata.afterLoadListeners = entityMetadata.listeners.filter((listener) => listener.type === EventListenerTypes.AFTER_LOAD);\n        entityMetadata.afterInsertListeners = entityMetadata.listeners.filter((listener) => listener.type === EventListenerTypes.AFTER_INSERT);\n        entityMetadata.afterUpdateListeners = entityMetadata.listeners.filter((listener) => listener.type === EventListenerTypes.AFTER_UPDATE);\n        entityMetadata.afterRemoveListeners = entityMetadata.listeners.filter((listener) => listener.type === EventListenerTypes.AFTER_REMOVE);\n        entityMetadata.afterSoftRemoveListeners =\n            entityMetadata.listeners.filter((listener) => listener.type === EventListenerTypes.AFTER_SOFT_REMOVE);\n        entityMetadata.afterRecoverListeners = entityMetadata.listeners.filter((listener) => listener.type === EventListenerTypes.AFTER_RECOVER);\n        entityMetadata.beforeInsertListeners = entityMetadata.listeners.filter((listener) => listener.type === EventListenerTypes.BEFORE_INSERT);\n        entityMetadata.beforeUpdateListeners = entityMetadata.listeners.filter((listener) => listener.type === EventListenerTypes.BEFORE_UPDATE);\n        entityMetadata.beforeRemoveListeners = entityMetadata.listeners.filter((listener) => listener.type === EventListenerTypes.BEFORE_REMOVE);\n        entityMetadata.beforeSoftRemoveListeners =\n            entityMetadata.listeners.filter((listener) => listener.type === EventListenerTypes.BEFORE_SOFT_REMOVE);\n        entityMetadata.beforeRecoverListeners = entityMetadata.listeners.filter((listener) => listener.type === EventListenerTypes.BEFORE_RECOVER);\n        entityMetadata.indices = entityMetadata.embeddeds.reduce((indices, embedded) => indices.concat(embedded.indicesFromTree), entityMetadata.ownIndices);\n        entityMetadata.uniques = entityMetadata.embeddeds.reduce((uniques, embedded) => uniques.concat(embedded.uniquesFromTree), entityMetadata.ownUniques);\n        entityMetadata.primaryColumns = entityMetadata.columns.filter((column) => column.isPrimary);\n        entityMetadata.nonVirtualColumns = entityMetadata.columns.filter((column) => !column.isVirtual);\n        entityMetadata.ancestorColumns = entityMetadata.columns.filter((column) => column.closureType === \"ancestor\");\n        entityMetadata.descendantColumns = entityMetadata.columns.filter((column) => column.closureType === \"descendant\");\n        entityMetadata.hasMultiplePrimaryKeys =\n            entityMetadata.primaryColumns.length > 1;\n        entityMetadata.generatedColumns = entityMetadata.columns.filter((column) => column.isGenerated || column.isObjectId);\n        entityMetadata.hasUUIDGeneratedColumns =\n            entityMetadata.columns.filter((column) => column.isGenerated || column.generationStrategy === \"uuid\").length > 0;\n        entityMetadata.createDateColumn = entityMetadata.columns.find((column) => column.isCreateDate);\n        entityMetadata.updateDateColumn = entityMetadata.columns.find((column) => column.isUpdateDate);\n        entityMetadata.deleteDateColumn = entityMetadata.columns.find((column) => column.isDeleteDate);\n        entityMetadata.versionColumn = entityMetadata.columns.find((column) => column.isVersion);\n        entityMetadata.discriminatorColumn = entityMetadata.columns.find((column) => column.isDiscriminator);\n        entityMetadata.treeLevelColumn = entityMetadata.columns.find((column) => column.isTreeLevel);\n        entityMetadata.nestedSetLeftColumn = entityMetadata.columns.find((column) => column.isNestedSetLeft);\n        entityMetadata.nestedSetRightColumn = entityMetadata.columns.find((column) => column.isNestedSetRight);\n        entityMetadata.materializedPathColumn = entityMetadata.columns.find((column) => column.isMaterializedPath);\n        entityMetadata.objectIdColumn = entityMetadata.columns.find((column) => column.isObjectId);\n        entityMetadata.foreignKeys.forEach((foreignKey) => foreignKey.build(this.connection.namingStrategy));\n        entityMetadata.propertiesMap = entityMetadata.createPropertiesMap();\n        entityMetadata.relationIds.forEach((relationId) => relationId.build());\n        entityMetadata.relationCounts.forEach((relationCount) => relationCount.build());\n        entityMetadata.embeddeds.forEach((embedded) => {\n            embedded.relationIdsFromTree.forEach((relationId) => relationId.build());\n            embedded.relationCountsFromTree.forEach((relationCount) => relationCount.build());\n        });\n    }\n    /**\n     * Computes entity metadata's relations inverse side properties.\n     */\n    computeInverseProperties(entityMetadata, entityMetadatas) {\n        entityMetadata.relations.forEach((relation) => {\n            // compute inverse side (related) entity metadatas for all relation metadatas\n            const inverseEntityMetadata = entityMetadatas.find((m) => m.target === relation.type ||\n                (typeof relation.type === \"string\" &&\n                    (m.targetName === relation.type ||\n                        m.givenTableName === relation.type)));\n            if (!inverseEntityMetadata)\n                throw new TypeORMError(\"Entity metadata for \" +\n                    entityMetadata.name +\n                    \"#\" +\n                    relation.propertyPath +\n                    \" was not found. Check if you specified a correct entity object and if it's connected in the connection options.\");\n            relation.inverseEntityMetadata = inverseEntityMetadata;\n            relation.inverseSidePropertyPath =\n                relation.buildInverseSidePropertyPath();\n            // and compute inverse relation and mark if it has such\n            relation.inverseRelation = inverseEntityMetadata.relations.find((foundRelation) => foundRelation.propertyPath ===\n                relation.inverseSidePropertyPath);\n        });\n    }\n    /**\n     * Creates indices for the table of single table inheritance.\n     */\n    createKeysForTableInheritance(entityMetadata) {\n        entityMetadata.indices.push(new IndexMetadata({\n            entityMetadata: entityMetadata,\n            columns: [entityMetadata.discriminatorColumn],\n            args: {\n                target: entityMetadata.target,\n                unique: false,\n            },\n        }));\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}