{"ast":null,"code":"import _asyncToGenerator from \"C:/Users/practicas/Downloads/angular/tresOnline/frontend-tres-en-raya/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { MssqlParameter } from \"../driver/sqlserver/MssqlParameter\";\nimport { Table } from \"../schema-builder/table/Table\";\nimport { v4 as uuidv4 } from \"uuid\";\n/**\n * Caches query result into current database, into separate table called \"query-result-cache\".\n */\nexport class DbQueryResultCache {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(connection) {\n    this.connection = connection;\n    const {\n      schema\n    } = this.connection.driver.options;\n    const database = this.connection.driver.database;\n    const cacheOptions = typeof this.connection.options.cache === \"object\" ? this.connection.options.cache : {};\n    const cacheTableName = cacheOptions.tableName || \"query-result-cache\";\n    this.queryResultCacheDatabase = database;\n    this.queryResultCacheSchema = schema;\n    this.queryResultCacheTable = this.connection.driver.buildTableName(cacheTableName, schema, database);\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Creates a connection with given cache provider.\n   */\n  connect() {\n    return _asyncToGenerator(function* () {})();\n  }\n  /**\n   * Disconnects with given cache provider.\n   */\n  disconnect() {\n    return _asyncToGenerator(function* () {})();\n  }\n  /**\n   * Creates table for storing cache if it does not exist yet.\n   */\n  synchronize(queryRunner) {\n    var _this = this;\n    return _asyncToGenerator(function* () {\n      queryRunner = _this.getQueryRunner(queryRunner);\n      const driver = _this.connection.driver;\n      const tableExist = yield queryRunner.hasTable(_this.queryResultCacheTable); // todo: table name should be configurable\n      if (tableExist) return;\n      yield queryRunner.createTable(new Table({\n        database: _this.queryResultCacheDatabase,\n        schema: _this.queryResultCacheSchema,\n        name: _this.queryResultCacheTable,\n        columns: [{\n          name: \"id\",\n          isPrimary: true,\n          isNullable: false,\n          type: driver.normalizeType({\n            type: driver.mappedDataTypes.cacheId\n          }),\n          generationStrategy: driver.options.type === \"spanner\" ? \"uuid\" : \"increment\",\n          isGenerated: true\n        }, {\n          name: \"identifier\",\n          type: driver.normalizeType({\n            type: driver.mappedDataTypes.cacheIdentifier\n          }),\n          isNullable: true\n        }, {\n          name: \"time\",\n          type: driver.normalizeType({\n            type: driver.mappedDataTypes.cacheTime\n          }),\n          isPrimary: false,\n          isNullable: false\n        }, {\n          name: \"duration\",\n          type: driver.normalizeType({\n            type: driver.mappedDataTypes.cacheDuration\n          }),\n          isPrimary: false,\n          isNullable: false\n        }, {\n          name: \"query\",\n          type: driver.normalizeType({\n            type: driver.mappedDataTypes.cacheQuery\n          }),\n          isPrimary: false,\n          isNullable: false\n        }, {\n          name: \"result\",\n          type: driver.normalizeType({\n            type: driver.mappedDataTypes.cacheResult\n          }),\n          isNullable: false\n        }]\n      }));\n    })();\n  }\n  /**\n   * Get data from cache.\n   * Returns cache result if found.\n   * Returns undefined if result is not cached.\n   */\n  getFromCache(options, queryRunner) {\n    queryRunner = this.getQueryRunner(queryRunner);\n    const qb = this.connection.createQueryBuilder(queryRunner).select().from(this.queryResultCacheTable, \"cache\");\n    if (options.identifier) {\n      return qb.where(`${qb.escape(\"cache\")}.${qb.escape(\"identifier\")} = :identifier`).setParameters({\n        identifier: this.connection.driver.options.type === \"mssql\" ? new MssqlParameter(options.identifier, \"nvarchar\") : options.identifier\n      }).getRawOne();\n    } else if (options.query) {\n      if (this.connection.driver.options.type === \"oracle\") {\n        return qb.where(`dbms_lob.compare(${qb.escape(\"cache\")}.${qb.escape(\"query\")}, :query) = 0`, {\n          query: options.query\n        }).getRawOne();\n      }\n      return qb.where(`${qb.escape(\"cache\")}.${qb.escape(\"query\")} = :query`).setParameters({\n        query: this.connection.driver.options.type === \"mssql\" ? new MssqlParameter(options.query, \"nvarchar\") : options.query\n      }).getRawOne();\n    }\n    return Promise.resolve(undefined);\n  }\n  /**\n   * Checks if cache is expired or not.\n   */\n  isExpired(savedCache) {\n    const duration = typeof savedCache.duration === \"string\" ? parseInt(savedCache.duration) : savedCache.duration;\n    return (typeof savedCache.time === \"string\" ? parseInt(savedCache.time) : savedCache.time) + duration < new Date().getTime();\n  }\n  /**\n   * Stores given query result in the cache.\n   */\n  storeInCache(options, savedCache, queryRunner) {\n    var _this2 = this;\n    return _asyncToGenerator(function* () {\n      const shouldCreateQueryRunner = queryRunner === undefined || (queryRunner === null || queryRunner === void 0 ? void 0 : queryRunner.getReplicationMode()) === \"slave\";\n      if (queryRunner === undefined || shouldCreateQueryRunner) {\n        queryRunner = _this2.connection.createQueryRunner(\"master\");\n      }\n      let insertedValues = options;\n      if (_this2.connection.driver.options.type === \"mssql\") {\n        // todo: bad abstraction, re-implement this part, probably better if we create an entity metadata for cache table\n        insertedValues = {\n          identifier: new MssqlParameter(options.identifier, \"nvarchar\"),\n          time: new MssqlParameter(options.time, \"bigint\"),\n          duration: new MssqlParameter(options.duration, \"int\"),\n          query: new MssqlParameter(options.query, \"nvarchar\"),\n          result: new MssqlParameter(options.result, \"nvarchar\")\n        };\n      }\n      if (savedCache && savedCache.identifier) {\n        // if exist then update\n        const qb = queryRunner.manager.createQueryBuilder().update(_this2.queryResultCacheTable).set(insertedValues);\n        qb.where(`${qb.escape(\"identifier\")} = :condition`, {\n          condition: insertedValues.identifier\n        });\n        yield qb.execute();\n      } else if (savedCache && savedCache.query) {\n        // if exist then update\n        const qb = queryRunner.manager.createQueryBuilder().update(_this2.queryResultCacheTable).set(insertedValues);\n        if (_this2.connection.driver.options.type === \"oracle\") {\n          qb.where(`dbms_lob.compare(\"query\", :condition) = 0`, {\n            condition: insertedValues.query\n          });\n        } else {\n          qb.where(`${qb.escape(\"query\")} = :condition`, {\n            condition: insertedValues.query\n          });\n        }\n        yield qb.execute();\n      } else {\n        // Spanner does not support auto-generated columns\n        if (_this2.connection.driver.options.type === \"spanner\" && !insertedValues.id) {\n          insertedValues.id = uuidv4();\n        }\n        // otherwise insert\n        yield queryRunner.manager.createQueryBuilder().insert().into(_this2.queryResultCacheTable).values(insertedValues).execute();\n      }\n      if (shouldCreateQueryRunner) {\n        yield queryRunner.release();\n      }\n    })();\n  }\n  /**\n   * Clears everything stored in the cache.\n   */\n  clear(queryRunner) {\n    var _this3 = this;\n    return _asyncToGenerator(function* () {\n      return _this3.getQueryRunner(queryRunner).clearTable(_this3.queryResultCacheTable);\n    })();\n  }\n  /**\n   * Removes all cached results by given identifiers from cache.\n   */\n  remove(identifiers, queryRunner) {\n    var _this4 = this;\n    return _asyncToGenerator(function* () {\n      let _queryRunner = queryRunner || _this4.getQueryRunner();\n      yield Promise.all(identifiers.map(identifier => {\n        const qb = _queryRunner.manager.createQueryBuilder();\n        return qb.delete().from(_this4.queryResultCacheTable).where(`${qb.escape(\"identifier\")} = :identifier`, {\n          identifier\n        }).execute();\n      }));\n      if (!queryRunner) {\n        yield _queryRunner.release();\n      }\n    })();\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Gets a query runner to work with.\n   */\n  getQueryRunner(queryRunner) {\n    if (queryRunner) return queryRunner;\n    return this.connection.createQueryRunner();\n  }\n}","map":{"version":3,"names":["MssqlParameter","Table","v4","uuidv4","DbQueryResultCache","constructor","connection","schema","driver","options","database","cacheOptions","cache","cacheTableName","tableName","queryResultCacheDatabase","queryResultCacheSchema","queryResultCacheTable","buildTableName","connect","_asyncToGenerator","disconnect","synchronize","queryRunner","_this","getQueryRunner","tableExist","hasTable","createTable","name","columns","isPrimary","isNullable","type","normalizeType","mappedDataTypes","cacheId","generationStrategy","isGenerated","cacheIdentifier","cacheTime","cacheDuration","cacheQuery","cacheResult","getFromCache","qb","createQueryBuilder","select","from","identifier","where","escape","setParameters","getRawOne","query","Promise","resolve","undefined","isExpired","savedCache","duration","parseInt","time","Date","getTime","storeInCache","_this2","shouldCreateQueryRunner","getReplicationMode","createQueryRunner","insertedValues","result","manager","update","set","condition","execute","id","insert","into","values","release","clear","_this3","clearTable","remove","identifiers","_this4","_queryRunner","all","map","delete"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/cache/DbQueryResultCache.js"],"sourcesContent":["import { MssqlParameter } from \"../driver/sqlserver/MssqlParameter\";\nimport { Table } from \"../schema-builder/table/Table\";\nimport { v4 as uuidv4 } from \"uuid\";\n/**\n * Caches query result into current database, into separate table called \"query-result-cache\".\n */\nexport class DbQueryResultCache {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n    constructor(connection) {\n        this.connection = connection;\n        const { schema } = this.connection.driver.options;\n        const database = this.connection.driver.database;\n        const cacheOptions = typeof this.connection.options.cache === \"object\"\n            ? this.connection.options.cache\n            : {};\n        const cacheTableName = cacheOptions.tableName || \"query-result-cache\";\n        this.queryResultCacheDatabase = database;\n        this.queryResultCacheSchema = schema;\n        this.queryResultCacheTable = this.connection.driver.buildTableName(cacheTableName, schema, database);\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Creates a connection with given cache provider.\n     */\n    async connect() { }\n    /**\n     * Disconnects with given cache provider.\n     */\n    async disconnect() { }\n    /**\n     * Creates table for storing cache if it does not exist yet.\n     */\n    async synchronize(queryRunner) {\n        queryRunner = this.getQueryRunner(queryRunner);\n        const driver = this.connection.driver;\n        const tableExist = await queryRunner.hasTable(this.queryResultCacheTable); // todo: table name should be configurable\n        if (tableExist)\n            return;\n        await queryRunner.createTable(new Table({\n            database: this.queryResultCacheDatabase,\n            schema: this.queryResultCacheSchema,\n            name: this.queryResultCacheTable,\n            columns: [\n                {\n                    name: \"id\",\n                    isPrimary: true,\n                    isNullable: false,\n                    type: driver.normalizeType({\n                        type: driver.mappedDataTypes.cacheId,\n                    }),\n                    generationStrategy: driver.options.type === \"spanner\"\n                        ? \"uuid\"\n                        : \"increment\",\n                    isGenerated: true,\n                },\n                {\n                    name: \"identifier\",\n                    type: driver.normalizeType({\n                        type: driver.mappedDataTypes.cacheIdentifier,\n                    }),\n                    isNullable: true,\n                },\n                {\n                    name: \"time\",\n                    type: driver.normalizeType({\n                        type: driver.mappedDataTypes.cacheTime,\n                    }),\n                    isPrimary: false,\n                    isNullable: false,\n                },\n                {\n                    name: \"duration\",\n                    type: driver.normalizeType({\n                        type: driver.mappedDataTypes.cacheDuration,\n                    }),\n                    isPrimary: false,\n                    isNullable: false,\n                },\n                {\n                    name: \"query\",\n                    type: driver.normalizeType({\n                        type: driver.mappedDataTypes.cacheQuery,\n                    }),\n                    isPrimary: false,\n                    isNullable: false,\n                },\n                {\n                    name: \"result\",\n                    type: driver.normalizeType({\n                        type: driver.mappedDataTypes.cacheResult,\n                    }),\n                    isNullable: false,\n                },\n            ],\n        }));\n    }\n    /**\n     * Get data from cache.\n     * Returns cache result if found.\n     * Returns undefined if result is not cached.\n     */\n    getFromCache(options, queryRunner) {\n        queryRunner = this.getQueryRunner(queryRunner);\n        const qb = this.connection\n            .createQueryBuilder(queryRunner)\n            .select()\n            .from(this.queryResultCacheTable, \"cache\");\n        if (options.identifier) {\n            return qb\n                .where(`${qb.escape(\"cache\")}.${qb.escape(\"identifier\")} = :identifier`)\n                .setParameters({\n                identifier: this.connection.driver.options.type === \"mssql\"\n                    ? new MssqlParameter(options.identifier, \"nvarchar\")\n                    : options.identifier,\n            })\n                .getRawOne();\n        }\n        else if (options.query) {\n            if (this.connection.driver.options.type === \"oracle\") {\n                return qb\n                    .where(`dbms_lob.compare(${qb.escape(\"cache\")}.${qb.escape(\"query\")}, :query) = 0`, { query: options.query })\n                    .getRawOne();\n            }\n            return qb\n                .where(`${qb.escape(\"cache\")}.${qb.escape(\"query\")} = :query`)\n                .setParameters({\n                query: this.connection.driver.options.type === \"mssql\"\n                    ? new MssqlParameter(options.query, \"nvarchar\")\n                    : options.query,\n            })\n                .getRawOne();\n        }\n        return Promise.resolve(undefined);\n    }\n    /**\n     * Checks if cache is expired or not.\n     */\n    isExpired(savedCache) {\n        const duration = typeof savedCache.duration === \"string\"\n            ? parseInt(savedCache.duration)\n            : savedCache.duration;\n        return ((typeof savedCache.time === \"string\"\n            ? parseInt(savedCache.time)\n            : savedCache.time) +\n            duration <\n            new Date().getTime());\n    }\n    /**\n     * Stores given query result in the cache.\n     */\n    async storeInCache(options, savedCache, queryRunner) {\n        const shouldCreateQueryRunner = queryRunner === undefined ||\n            (queryRunner === null || queryRunner === void 0 ? void 0 : queryRunner.getReplicationMode()) === \"slave\";\n        if (queryRunner === undefined || shouldCreateQueryRunner) {\n            queryRunner = this.connection.createQueryRunner(\"master\");\n        }\n        let insertedValues = options;\n        if (this.connection.driver.options.type === \"mssql\") {\n            // todo: bad abstraction, re-implement this part, probably better if we create an entity metadata for cache table\n            insertedValues = {\n                identifier: new MssqlParameter(options.identifier, \"nvarchar\"),\n                time: new MssqlParameter(options.time, \"bigint\"),\n                duration: new MssqlParameter(options.duration, \"int\"),\n                query: new MssqlParameter(options.query, \"nvarchar\"),\n                result: new MssqlParameter(options.result, \"nvarchar\"),\n            };\n        }\n        if (savedCache && savedCache.identifier) {\n            // if exist then update\n            const qb = queryRunner.manager\n                .createQueryBuilder()\n                .update(this.queryResultCacheTable)\n                .set(insertedValues);\n            qb.where(`${qb.escape(\"identifier\")} = :condition`, {\n                condition: insertedValues.identifier,\n            });\n            await qb.execute();\n        }\n        else if (savedCache && savedCache.query) {\n            // if exist then update\n            const qb = queryRunner.manager\n                .createQueryBuilder()\n                .update(this.queryResultCacheTable)\n                .set(insertedValues);\n            if (this.connection.driver.options.type === \"oracle\") {\n                qb.where(`dbms_lob.compare(\"query\", :condition) = 0`, {\n                    condition: insertedValues.query,\n                });\n            }\n            else {\n                qb.where(`${qb.escape(\"query\")} = :condition`, {\n                    condition: insertedValues.query,\n                });\n            }\n            await qb.execute();\n        }\n        else {\n            // Spanner does not support auto-generated columns\n            if (this.connection.driver.options.type === \"spanner\" &&\n                !insertedValues.id) {\n                insertedValues.id = uuidv4();\n            }\n            // otherwise insert\n            await queryRunner.manager\n                .createQueryBuilder()\n                .insert()\n                .into(this.queryResultCacheTable)\n                .values(insertedValues)\n                .execute();\n        }\n        if (shouldCreateQueryRunner) {\n            await queryRunner.release();\n        }\n    }\n    /**\n     * Clears everything stored in the cache.\n     */\n    async clear(queryRunner) {\n        return this.getQueryRunner(queryRunner).clearTable(this.queryResultCacheTable);\n    }\n    /**\n     * Removes all cached results by given identifiers from cache.\n     */\n    async remove(identifiers, queryRunner) {\n        let _queryRunner = queryRunner || this.getQueryRunner();\n        await Promise.all(identifiers.map((identifier) => {\n            const qb = _queryRunner.manager.createQueryBuilder();\n            return qb\n                .delete()\n                .from(this.queryResultCacheTable)\n                .where(`${qb.escape(\"identifier\")} = :identifier`, {\n                identifier,\n            })\n                .execute();\n        }));\n        if (!queryRunner) {\n            await _queryRunner.release();\n        }\n    }\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Gets a query runner to work with.\n     */\n    getQueryRunner(queryRunner) {\n        if (queryRunner)\n            return queryRunner;\n        return this.connection.createQueryRunner();\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}