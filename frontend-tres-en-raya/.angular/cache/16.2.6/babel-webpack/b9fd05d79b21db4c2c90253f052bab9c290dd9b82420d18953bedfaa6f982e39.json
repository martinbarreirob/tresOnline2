{"ast":null,"code":"import { OrmUtils } from \"../../util/OrmUtils\";\nimport { DriverUtils } from \"../../driver/DriverUtils\";\nimport { ObjectUtils } from \"../../util/ObjectUtils\";\n/**\n * Transforms raw sql results returned from the database into entity object.\n * Entity is constructed based on its entity metadata.\n */\nexport class RawSqlResultsToEntityTransformer {\n  // -------------------------------------------------------------------------\n  // Constructor\n  // -------------------------------------------------------------------------\n  constructor(expressionMap, driver, rawRelationIdResults, rawRelationCountResults, queryRunner) {\n    this.expressionMap = expressionMap;\n    this.driver = driver;\n    this.rawRelationIdResults = rawRelationIdResults;\n    this.rawRelationCountResults = rawRelationCountResults;\n    this.queryRunner = queryRunner;\n  }\n  // -------------------------------------------------------------------------\n  // Public Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Since db returns a duplicated rows of the data where accuracies of the same object can be duplicated\n   * we need to group our result and we must have some unique id (primary key in our case)\n   */\n  transform(rawResults, alias) {\n    const group = this.group(rawResults, alias);\n    const entities = [];\n    group.forEach(results => {\n      const entity = this.transformRawResultsGroup(results, alias);\n      if (entity !== undefined && !Object.values(entity).every(value => value === null)) entities.push(entity);\n    });\n    return entities;\n  }\n  // -------------------------------------------------------------------------\n  // Protected Methods\n  // -------------------------------------------------------------------------\n  /**\n   * Groups given raw results by ids of given alias.\n   */\n  group(rawResults, alias) {\n    const map = new Map();\n    const keys = [];\n    if (alias.metadata.tableType === \"view\") {\n      keys.push(...alias.metadata.columns.map(column => DriverUtils.buildAlias(this.driver, undefined, alias.name, column.databaseName)));\n    } else {\n      keys.push(...alias.metadata.primaryColumns.map(column => DriverUtils.buildAlias(this.driver, undefined, alias.name, column.databaseName)));\n    }\n    rawResults.forEach(rawResult => {\n      const id = keys.map(key => {\n        const keyValue = rawResult[key];\n        if (Buffer.isBuffer(keyValue)) {\n          return keyValue.toString(\"hex\");\n        }\n        if (ObjectUtils.isObject(keyValue)) {\n          return JSON.stringify(keyValue);\n        }\n        return keyValue;\n      }).join(\"_\"); // todo: check partial\n      const items = map.get(id);\n      if (!items) {\n        map.set(id, [rawResult]);\n      } else {\n        items.push(rawResult);\n      }\n    });\n    return map;\n  }\n  /**\n   * Transforms set of data results into single entity.\n   */\n  transformRawResultsGroup(rawResults, alias) {\n    // let hasColumns = false; // , hasEmbeddedColumns = false, hasParentColumns = false, hasParentEmbeddedColumns = false;\n    let metadata = alias.metadata;\n    if (metadata.discriminatorColumn) {\n      const discriminatorValues = rawResults.map(result => result[DriverUtils.buildAlias(this.driver, undefined, alias.name, alias.metadata.discriminatorColumn.databaseName)]);\n      const discriminatorMetadata = metadata.childEntityMetadatas.find(childEntityMetadata => {\n        return typeof discriminatorValues.find(value => value === childEntityMetadata.discriminatorValue) !== \"undefined\";\n      });\n      if (discriminatorMetadata) metadata = discriminatorMetadata;\n    }\n    let entity = metadata.create(this.queryRunner, {\n      fromDeserializer: true,\n      pojo: this.expressionMap.options.indexOf(\"create-pojo\") !== -1\n    });\n    // get value from columns selections and put them into newly created entity\n    const hasColumns = this.transformColumns(rawResults, alias, entity, metadata);\n    const hasRelations = this.transformJoins(rawResults, entity, alias, metadata);\n    const hasRelationIds = this.transformRelationIds(rawResults, alias, entity, metadata);\n    const hasRelationCounts = this.transformRelationCounts(rawResults, alias, entity);\n    // if we have at least one selected column then return this entity\n    // since entity must have at least primary columns to be really selected and transformed into entity\n    if (hasColumns) return entity;\n    // if we don't have any selected column we should not return entity,\n    // except for the case when entity only contain a primary column as a relation to another entity\n    // in this case its absolutely possible our entity to not have any columns except a single relation\n    const hasOnlyVirtualPrimaryColumns = metadata.primaryColumns.filter(column => column.isVirtual === false).length === 0; // todo: create metadata.hasOnlyVirtualPrimaryColumns\n    if (hasOnlyVirtualPrimaryColumns && (hasRelations || hasRelationIds || hasRelationCounts)) return entity;\n    return undefined;\n  }\n  // get value from columns selections and put them into object\n  transformColumns(rawResults, alias, entity, metadata) {\n    let hasData = false;\n    metadata.columns.forEach(column => {\n      // if table inheritance is used make sure this column is not child's column\n      if (metadata.childEntityMetadatas.length > 0 && metadata.childEntityMetadatas.findIndex(childMetadata => childMetadata.target === column.target) !== -1) return;\n      const value = rawResults[0][DriverUtils.buildAlias(this.driver, undefined, alias.name, column.databaseName)];\n      if (value === undefined || column.isVirtual) return;\n      // if user does not selected the whole entity or he used partial selection and does not select this particular column\n      // then we don't add this column and its value into the entity\n      if (!this.expressionMap.selects.find(select => select.selection === alias.name || select.selection === alias.name + \".\" + column.propertyPath)) return;\n      column.setEntityValue(entity, this.driver.prepareHydratedValue(value, column));\n      if (value !== null)\n        // we don't mark it as has data because if we will have all nulls in our object - we don't need such object\n        hasData = true;\n    });\n    return hasData;\n  }\n  /**\n   * Transforms joined entities in the given raw results by a given alias and stores to the given (parent) entity\n   */\n  transformJoins(rawResults, entity, alias, metadata) {\n    let hasData = false;\n    // let discriminatorValue: string = \"\";\n    // if (metadata.discriminatorColumn)\n    //     discriminatorValue = rawResults[0][DriverUtils.buildAlias(this.connection.driver, alias.name, alias.metadata.discriminatorColumn!.databaseName)];\n    this.expressionMap.joinAttributes.forEach(join => {\n      // todo: we have problem here - when inner joins are used without selects it still create empty array\n      // skip joins without metadata\n      if (!join.metadata) return;\n      // if simple left or inner join was performed without selection then we don't need to do anything\n      if (!join.isSelected) return;\n      // this check need to avoid setting properties than not belong to entity when single table inheritance used. (todo: check if we still need it)\n      // const metadata = metadata.childEntityMetadatas.find(childEntityMetadata => discriminatorValue === childEntityMetadata.discriminatorValue);\n      if (join.relation && !metadata.relations.find(relation => relation === join.relation)) return;\n      // some checks to make sure this join is for current alias\n      if (join.mapToProperty) {\n        if (join.mapToPropertyParentAlias !== alias.name) return;\n      } else {\n        if (!join.relation || join.parentAlias !== alias.name || join.relationPropertyPath !== join.relation.propertyPath) return;\n      }\n      // transform joined data into entities\n      let result = this.transform(rawResults, join.alias);\n      result = !join.isMany ? result[0] : result;\n      result = !join.isMany && result === undefined ? null : result; // this is needed to make relations to return null when its joined but nothing was found in the database\n      if (result === undefined)\n        // if nothing was joined then simply return\n        return;\n      // if join was mapped to some property then save result to that property\n      if (join.mapToPropertyPropertyName) {\n        entity[join.mapToPropertyPropertyName] = result; // todo: fix embeds\n      } else {\n        // otherwise set to relation\n        join.relation.setEntityValue(entity, result);\n      }\n      hasData = true;\n    });\n    return hasData;\n  }\n  transformRelationIds(rawSqlResults, alias, entity, metadata) {\n    let hasData = false;\n    this.rawRelationIdResults.forEach((rawRelationIdResult, index) => {\n      if (rawRelationIdResult.relationIdAttribute.parentAlias !== alias.name) return;\n      const relation = rawRelationIdResult.relationIdAttribute.relation;\n      const valueMap = this.createValueMapFromJoinColumns(relation, rawRelationIdResult.relationIdAttribute.parentAlias, rawSqlResults);\n      if (valueMap === undefined || valueMap === null) {\n        return;\n      }\n      // prepare common data for this call\n      this.prepareDataForTransformRelationIds();\n      // Extract idMaps from prepared data by hash\n      const hash = this.hashEntityIds(relation, valueMap);\n      const idMaps = this.relationIdMaps[index][hash] || [];\n      // Map data to properties\n      const properties = rawRelationIdResult.relationIdAttribute.mapToPropertyPropertyPath.split(\".\");\n      const mapToProperty = (properties, map, value) => {\n        const property = properties.shift();\n        if (property && properties.length === 0) {\n          map[property] = value;\n          return map;\n        }\n        if (property && properties.length > 0) {\n          mapToProperty(properties, map[property], value);\n        } else {\n          return map;\n        }\n      };\n      if (relation.isOneToOne || relation.isManyToOne) {\n        if (idMaps[0] !== undefined) {\n          mapToProperty(properties, entity, idMaps[0]);\n          hasData = true;\n        }\n      } else {\n        mapToProperty(properties, entity, idMaps);\n        hasData = hasData || idMaps.length > 0;\n      }\n    });\n    return hasData;\n  }\n  transformRelationCounts(rawSqlResults, alias, entity) {\n    let hasData = false;\n    this.rawRelationCountResults.filter(rawRelationCountResult => rawRelationCountResult.relationCountAttribute.parentAlias === alias.name).forEach(rawRelationCountResult => {\n      const relation = rawRelationCountResult.relationCountAttribute.relation;\n      let referenceColumnName;\n      if (relation.isOneToMany) {\n        referenceColumnName = relation.inverseRelation.joinColumns[0].referencedColumn.databaseName; // todo: fix joinColumns[0]\n      } else {\n        referenceColumnName = relation.isOwning ? relation.joinColumns[0].referencedColumn.databaseName : relation.inverseRelation.joinColumns[0].referencedColumn.databaseName;\n      }\n      const referenceColumnValue = rawSqlResults[0][DriverUtils.buildAlias(this.driver, undefined, alias.name, referenceColumnName)]; // we use zero index since its grouped data // todo: selection with alias for entity columns wont work\n      if (referenceColumnValue !== undefined && referenceColumnValue !== null) {\n        entity[rawRelationCountResult.relationCountAttribute.mapToPropertyPropertyName] = 0;\n        rawRelationCountResult.results.filter(result => result[\"parentId\"] === referenceColumnValue).forEach(result => {\n          entity[rawRelationCountResult.relationCountAttribute.mapToPropertyPropertyName] = parseInt(result[\"cnt\"]);\n          hasData = true;\n        });\n      }\n    });\n    return hasData;\n  }\n  createValueMapFromJoinColumns(relation, parentAlias, rawSqlResults) {\n    let columns;\n    if (relation.isManyToOne || relation.isOneToOneOwner) {\n      columns = relation.entityMetadata.primaryColumns.map(joinColumn => joinColumn);\n    } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n      columns = relation.inverseRelation.joinColumns.map(joinColumn => joinColumn);\n    } else {\n      if (relation.isOwning) {\n        columns = relation.joinColumns.map(joinColumn => joinColumn);\n      } else {\n        columns = relation.inverseRelation.inverseJoinColumns.map(joinColumn => joinColumn);\n      }\n    }\n    return columns.reduce((valueMap, column) => {\n      rawSqlResults.forEach(rawSqlResult => {\n        if (relation.isManyToOne || relation.isOneToOneOwner) {\n          valueMap[column.databaseName] = this.driver.prepareHydratedValue(rawSqlResult[DriverUtils.buildAlias(this.driver, undefined, parentAlias, column.databaseName)], column);\n        } else {\n          valueMap[column.databaseName] = this.driver.prepareHydratedValue(rawSqlResult[DriverUtils.buildAlias(this.driver, undefined, parentAlias, column.referencedColumn.databaseName)], column.referencedColumn);\n        }\n      });\n      return valueMap;\n    }, {});\n  }\n  extractEntityPrimaryIds(relation, relationIdRawResult) {\n    let columns;\n    if (relation.isManyToOne || relation.isOneToOneOwner) {\n      columns = relation.entityMetadata.primaryColumns.map(joinColumn => joinColumn);\n    } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n      columns = relation.inverseRelation.joinColumns.map(joinColumn => joinColumn);\n    } else {\n      if (relation.isOwning) {\n        columns = relation.joinColumns.map(joinColumn => joinColumn);\n      } else {\n        columns = relation.inverseRelation.inverseJoinColumns.map(joinColumn => joinColumn);\n      }\n    }\n    return columns.reduce((data, column) => {\n      data[column.databaseName] = relationIdRawResult[column.databaseName];\n      return data;\n    }, {});\n  }\n  /*private removeVirtualColumns(entity: ObjectLiteral, alias: Alias) {\n      const virtualColumns = this.expressionMap.selects\n          .filter(select => select.virtual)\n          .map(select => select.selection.replace(alias.name + \".\", \"\"));\n       virtualColumns.forEach(virtualColumn => delete entity[virtualColumn]);\n  }*/\n  /** Prepare data to run #transformRelationIds, as a lot of result independent data is needed in every call */\n  prepareDataForTransformRelationIds() {\n    // Return early if the relationIdMaps were already calculated\n    if (this.relationIdMaps) {\n      return;\n    }\n    // Ensure this prepare function is only called once\n    this.relationIdMaps = this.rawRelationIdResults.map(rawRelationIdResult => {\n      const relation = rawRelationIdResult.relationIdAttribute.relation;\n      // Calculate column metadata\n      let columns;\n      if (relation.isManyToOne || relation.isOneToOneOwner) {\n        columns = relation.joinColumns;\n      } else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n        columns = relation.inverseEntityMetadata.primaryColumns;\n      } else {\n        // ManyToMany\n        if (relation.isOwning) {\n          columns = relation.inverseJoinColumns;\n        } else {\n          columns = relation.inverseRelation.joinColumns;\n        }\n      }\n      // Calculate the idMaps for the rawRelationIdResult\n      return rawRelationIdResult.results.reduce((agg, result) => {\n        let idMap = columns.reduce((idMap, column) => {\n          let value = result[column.databaseName];\n          if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n            if (column.isVirtual && column.referencedColumn && column.referencedColumn.propertyName !== column.propertyName) {\n              // if column is a relation\n              value = column.referencedColumn.createValueMap(value);\n            }\n            return OrmUtils.mergeDeep(idMap, column.createValueMap(value));\n          }\n          if (!column.isPrimary && column.referencedColumn.referencedColumn) {\n            // if column is a relation\n            value = column.referencedColumn.referencedColumn.createValueMap(value);\n          }\n          return OrmUtils.mergeDeep(idMap, column.referencedColumn.createValueMap(value));\n        }, {});\n        if (columns.length === 1 && !rawRelationIdResult.relationIdAttribute.disableMixedMap) {\n          if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n            idMap = columns[0].getEntityValue(idMap);\n          } else {\n            idMap = columns[0].referencedColumn.getEntityValue(idMap);\n          }\n        }\n        // If an idMap is found, set it in the aggregator under the correct hash\n        if (idMap !== undefined) {\n          const hash = this.hashEntityIds(relation, result);\n          if (agg[hash]) {\n            agg[hash].push(idMap);\n          } else {\n            agg[hash] = [idMap];\n          }\n        }\n        return agg;\n      }, {});\n    });\n  }\n  /**\n   * Use a simple JSON.stringify to create a simple hash of the primary ids of an entity.\n   * As this.extractEntityPrimaryIds always creates the primary id object in the same order, if the same relation is\n   * given, a simple JSON.stringify should be enough to get a unique hash per entity!\n   */\n  hashEntityIds(relation, data) {\n    const entityPrimaryIds = this.extractEntityPrimaryIds(relation, data);\n    return JSON.stringify(entityPrimaryIds);\n  }\n}","map":{"version":3,"names":["OrmUtils","DriverUtils","ObjectUtils","RawSqlResultsToEntityTransformer","constructor","expressionMap","driver","rawRelationIdResults","rawRelationCountResults","queryRunner","transform","rawResults","alias","group","entities","forEach","results","entity","transformRawResultsGroup","undefined","Object","values","every","value","push","map","Map","keys","metadata","tableType","columns","column","buildAlias","name","databaseName","primaryColumns","rawResult","id","key","keyValue","Buffer","isBuffer","toString","isObject","JSON","stringify","join","items","get","set","discriminatorColumn","discriminatorValues","result","discriminatorMetadata","childEntityMetadatas","find","childEntityMetadata","discriminatorValue","create","fromDeserializer","pojo","options","indexOf","hasColumns","transformColumns","hasRelations","transformJoins","hasRelationIds","transformRelationIds","hasRelationCounts","transformRelationCounts","hasOnlyVirtualPrimaryColumns","filter","isVirtual","length","hasData","findIndex","childMetadata","target","selects","select","selection","propertyPath","setEntityValue","prepareHydratedValue","joinAttributes","isSelected","relation","relations","mapToProperty","mapToPropertyParentAlias","parentAlias","relationPropertyPath","isMany","mapToPropertyPropertyName","rawSqlResults","rawRelationIdResult","index","relationIdAttribute","valueMap","createValueMapFromJoinColumns","prepareDataForTransformRelationIds","hash","hashEntityIds","idMaps","relationIdMaps","properties","mapToPropertyPropertyPath","split","property","shift","isOneToOne","isManyToOne","rawRelationCountResult","relationCountAttribute","referenceColumnName","isOneToMany","inverseRelation","joinColumns","referencedColumn","isOwning","referenceColumnValue","parseInt","isOneToOneOwner","entityMetadata","joinColumn","isOneToOneNotOwner","inverseJoinColumns","reduce","rawSqlResult","extractEntityPrimaryIds","relationIdRawResult","data","inverseEntityMetadata","agg","idMap","propertyName","createValueMap","mergeDeep","isPrimary","disableMixedMap","getEntityValue","entityPrimaryIds"],"sources":["C:/Users/practicas/Downloads/angular/tresOnline/node_modules/typeorm/browser/query-builder/transformer/RawSqlResultsToEntityTransformer.js"],"sourcesContent":["import { OrmUtils } from \"../../util/OrmUtils\";\nimport { DriverUtils } from \"../../driver/DriverUtils\";\nimport { ObjectUtils } from \"../../util/ObjectUtils\";\n/**\n * Transforms raw sql results returned from the database into entity object.\n * Entity is constructed based on its entity metadata.\n */\nexport class RawSqlResultsToEntityTransformer {\n    // -------------------------------------------------------------------------\n    // Constructor\n    // -------------------------------------------------------------------------\n    constructor(expressionMap, driver, rawRelationIdResults, rawRelationCountResults, queryRunner) {\n        this.expressionMap = expressionMap;\n        this.driver = driver;\n        this.rawRelationIdResults = rawRelationIdResults;\n        this.rawRelationCountResults = rawRelationCountResults;\n        this.queryRunner = queryRunner;\n    }\n    // -------------------------------------------------------------------------\n    // Public Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Since db returns a duplicated rows of the data where accuracies of the same object can be duplicated\n     * we need to group our result and we must have some unique id (primary key in our case)\n     */\n    transform(rawResults, alias) {\n        const group = this.group(rawResults, alias);\n        const entities = [];\n        group.forEach((results) => {\n            const entity = this.transformRawResultsGroup(results, alias);\n            if (entity !== undefined &&\n                !Object.values(entity).every((value) => value === null))\n                entities.push(entity);\n        });\n        return entities;\n    }\n    // -------------------------------------------------------------------------\n    // Protected Methods\n    // -------------------------------------------------------------------------\n    /**\n     * Groups given raw results by ids of given alias.\n     */\n    group(rawResults, alias) {\n        const map = new Map();\n        const keys = [];\n        if (alias.metadata.tableType === \"view\") {\n            keys.push(...alias.metadata.columns.map((column) => DriverUtils.buildAlias(this.driver, undefined, alias.name, column.databaseName)));\n        }\n        else {\n            keys.push(...alias.metadata.primaryColumns.map((column) => DriverUtils.buildAlias(this.driver, undefined, alias.name, column.databaseName)));\n        }\n        rawResults.forEach((rawResult) => {\n            const id = keys\n                .map((key) => {\n                const keyValue = rawResult[key];\n                if (Buffer.isBuffer(keyValue)) {\n                    return keyValue.toString(\"hex\");\n                }\n                if (ObjectUtils.isObject(keyValue)) {\n                    return JSON.stringify(keyValue);\n                }\n                return keyValue;\n            })\n                .join(\"_\"); // todo: check partial\n            const items = map.get(id);\n            if (!items) {\n                map.set(id, [rawResult]);\n            }\n            else {\n                items.push(rawResult);\n            }\n        });\n        return map;\n    }\n    /**\n     * Transforms set of data results into single entity.\n     */\n    transformRawResultsGroup(rawResults, alias) {\n        // let hasColumns = false; // , hasEmbeddedColumns = false, hasParentColumns = false, hasParentEmbeddedColumns = false;\n        let metadata = alias.metadata;\n        if (metadata.discriminatorColumn) {\n            const discriminatorValues = rawResults.map((result) => result[DriverUtils.buildAlias(this.driver, undefined, alias.name, alias.metadata.discriminatorColumn.databaseName)]);\n            const discriminatorMetadata = metadata.childEntityMetadatas.find((childEntityMetadata) => {\n                return (typeof discriminatorValues.find((value) => value ===\n                    childEntityMetadata.discriminatorValue) !== \"undefined\");\n            });\n            if (discriminatorMetadata)\n                metadata = discriminatorMetadata;\n        }\n        let entity = metadata.create(this.queryRunner, {\n            fromDeserializer: true,\n            pojo: this.expressionMap.options.indexOf(\"create-pojo\") !== -1,\n        });\n        // get value from columns selections and put them into newly created entity\n        const hasColumns = this.transformColumns(rawResults, alias, entity, metadata);\n        const hasRelations = this.transformJoins(rawResults, entity, alias, metadata);\n        const hasRelationIds = this.transformRelationIds(rawResults, alias, entity, metadata);\n        const hasRelationCounts = this.transformRelationCounts(rawResults, alias, entity);\n        // if we have at least one selected column then return this entity\n        // since entity must have at least primary columns to be really selected and transformed into entity\n        if (hasColumns)\n            return entity;\n        // if we don't have any selected column we should not return entity,\n        // except for the case when entity only contain a primary column as a relation to another entity\n        // in this case its absolutely possible our entity to not have any columns except a single relation\n        const hasOnlyVirtualPrimaryColumns = metadata.primaryColumns.filter((column) => column.isVirtual === false).length === 0; // todo: create metadata.hasOnlyVirtualPrimaryColumns\n        if (hasOnlyVirtualPrimaryColumns &&\n            (hasRelations || hasRelationIds || hasRelationCounts))\n            return entity;\n        return undefined;\n    }\n    // get value from columns selections and put them into object\n    transformColumns(rawResults, alias, entity, metadata) {\n        let hasData = false;\n        metadata.columns.forEach((column) => {\n            // if table inheritance is used make sure this column is not child's column\n            if (metadata.childEntityMetadatas.length > 0 &&\n                metadata.childEntityMetadatas.findIndex((childMetadata) => childMetadata.target === column.target) !== -1)\n                return;\n            const value = rawResults[0][DriverUtils.buildAlias(this.driver, undefined, alias.name, column.databaseName)];\n            if (value === undefined || column.isVirtual)\n                return;\n            // if user does not selected the whole entity or he used partial selection and does not select this particular column\n            // then we don't add this column and its value into the entity\n            if (!this.expressionMap.selects.find((select) => select.selection === alias.name ||\n                select.selection ===\n                    alias.name + \".\" + column.propertyPath))\n                return;\n            column.setEntityValue(entity, this.driver.prepareHydratedValue(value, column));\n            if (value !== null)\n                // we don't mark it as has data because if we will have all nulls in our object - we don't need such object\n                hasData = true;\n        });\n        return hasData;\n    }\n    /**\n     * Transforms joined entities in the given raw results by a given alias and stores to the given (parent) entity\n     */\n    transformJoins(rawResults, entity, alias, metadata) {\n        let hasData = false;\n        // let discriminatorValue: string = \"\";\n        // if (metadata.discriminatorColumn)\n        //     discriminatorValue = rawResults[0][DriverUtils.buildAlias(this.connection.driver, alias.name, alias.metadata.discriminatorColumn!.databaseName)];\n        this.expressionMap.joinAttributes.forEach((join) => {\n            // todo: we have problem here - when inner joins are used without selects it still create empty array\n            // skip joins without metadata\n            if (!join.metadata)\n                return;\n            // if simple left or inner join was performed without selection then we don't need to do anything\n            if (!join.isSelected)\n                return;\n            // this check need to avoid setting properties than not belong to entity when single table inheritance used. (todo: check if we still need it)\n            // const metadata = metadata.childEntityMetadatas.find(childEntityMetadata => discriminatorValue === childEntityMetadata.discriminatorValue);\n            if (join.relation &&\n                !metadata.relations.find((relation) => relation === join.relation))\n                return;\n            // some checks to make sure this join is for current alias\n            if (join.mapToProperty) {\n                if (join.mapToPropertyParentAlias !== alias.name)\n                    return;\n            }\n            else {\n                if (!join.relation ||\n                    join.parentAlias !== alias.name ||\n                    join.relationPropertyPath !== join.relation.propertyPath)\n                    return;\n            }\n            // transform joined data into entities\n            let result = this.transform(rawResults, join.alias);\n            result = !join.isMany ? result[0] : result;\n            result = !join.isMany && result === undefined ? null : result; // this is needed to make relations to return null when its joined but nothing was found in the database\n            if (result === undefined)\n                // if nothing was joined then simply return\n                return;\n            // if join was mapped to some property then save result to that property\n            if (join.mapToPropertyPropertyName) {\n                entity[join.mapToPropertyPropertyName] = result; // todo: fix embeds\n            }\n            else {\n                // otherwise set to relation\n                join.relation.setEntityValue(entity, result);\n            }\n            hasData = true;\n        });\n        return hasData;\n    }\n    transformRelationIds(rawSqlResults, alias, entity, metadata) {\n        let hasData = false;\n        this.rawRelationIdResults.forEach((rawRelationIdResult, index) => {\n            if (rawRelationIdResult.relationIdAttribute.parentAlias !==\n                alias.name)\n                return;\n            const relation = rawRelationIdResult.relationIdAttribute.relation;\n            const valueMap = this.createValueMapFromJoinColumns(relation, rawRelationIdResult.relationIdAttribute.parentAlias, rawSqlResults);\n            if (valueMap === undefined || valueMap === null) {\n                return;\n            }\n            // prepare common data for this call\n            this.prepareDataForTransformRelationIds();\n            // Extract idMaps from prepared data by hash\n            const hash = this.hashEntityIds(relation, valueMap);\n            const idMaps = this.relationIdMaps[index][hash] || [];\n            // Map data to properties\n            const properties = rawRelationIdResult.relationIdAttribute.mapToPropertyPropertyPath.split(\".\");\n            const mapToProperty = (properties, map, value) => {\n                const property = properties.shift();\n                if (property && properties.length === 0) {\n                    map[property] = value;\n                    return map;\n                }\n                if (property && properties.length > 0) {\n                    mapToProperty(properties, map[property], value);\n                }\n                else {\n                    return map;\n                }\n            };\n            if (relation.isOneToOne || relation.isManyToOne) {\n                if (idMaps[0] !== undefined) {\n                    mapToProperty(properties, entity, idMaps[0]);\n                    hasData = true;\n                }\n            }\n            else {\n                mapToProperty(properties, entity, idMaps);\n                hasData = hasData || idMaps.length > 0;\n            }\n        });\n        return hasData;\n    }\n    transformRelationCounts(rawSqlResults, alias, entity) {\n        let hasData = false;\n        this.rawRelationCountResults\n            .filter((rawRelationCountResult) => rawRelationCountResult.relationCountAttribute\n            .parentAlias === alias.name)\n            .forEach((rawRelationCountResult) => {\n            const relation = rawRelationCountResult.relationCountAttribute.relation;\n            let referenceColumnName;\n            if (relation.isOneToMany) {\n                referenceColumnName =\n                    relation.inverseRelation.joinColumns[0]\n                        .referencedColumn.databaseName; // todo: fix joinColumns[0]\n            }\n            else {\n                referenceColumnName = relation.isOwning\n                    ? relation.joinColumns[0].referencedColumn.databaseName\n                    : relation.inverseRelation.joinColumns[0]\n                        .referencedColumn.databaseName;\n            }\n            const referenceColumnValue = rawSqlResults[0][DriverUtils.buildAlias(this.driver, undefined, alias.name, referenceColumnName)]; // we use zero index since its grouped data // todo: selection with alias for entity columns wont work\n            if (referenceColumnValue !== undefined &&\n                referenceColumnValue !== null) {\n                entity[rawRelationCountResult.relationCountAttribute.mapToPropertyPropertyName] = 0;\n                rawRelationCountResult.results\n                    .filter((result) => result[\"parentId\"] === referenceColumnValue)\n                    .forEach((result) => {\n                    entity[rawRelationCountResult.relationCountAttribute.mapToPropertyPropertyName] = parseInt(result[\"cnt\"]);\n                    hasData = true;\n                });\n            }\n        });\n        return hasData;\n    }\n    createValueMapFromJoinColumns(relation, parentAlias, rawSqlResults) {\n        let columns;\n        if (relation.isManyToOne || relation.isOneToOneOwner) {\n            columns = relation.entityMetadata.primaryColumns.map((joinColumn) => joinColumn);\n        }\n        else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n            columns = relation.inverseRelation.joinColumns.map((joinColumn) => joinColumn);\n        }\n        else {\n            if (relation.isOwning) {\n                columns = relation.joinColumns.map((joinColumn) => joinColumn);\n            }\n            else {\n                columns = relation.inverseRelation.inverseJoinColumns.map((joinColumn) => joinColumn);\n            }\n        }\n        return columns.reduce((valueMap, column) => {\n            rawSqlResults.forEach((rawSqlResult) => {\n                if (relation.isManyToOne || relation.isOneToOneOwner) {\n                    valueMap[column.databaseName] =\n                        this.driver.prepareHydratedValue(rawSqlResult[DriverUtils.buildAlias(this.driver, undefined, parentAlias, column.databaseName)], column);\n                }\n                else {\n                    valueMap[column.databaseName] =\n                        this.driver.prepareHydratedValue(rawSqlResult[DriverUtils.buildAlias(this.driver, undefined, parentAlias, column.referencedColumn.databaseName)], column.referencedColumn);\n                }\n            });\n            return valueMap;\n        }, {});\n    }\n    extractEntityPrimaryIds(relation, relationIdRawResult) {\n        let columns;\n        if (relation.isManyToOne || relation.isOneToOneOwner) {\n            columns = relation.entityMetadata.primaryColumns.map((joinColumn) => joinColumn);\n        }\n        else if (relation.isOneToMany || relation.isOneToOneNotOwner) {\n            columns = relation.inverseRelation.joinColumns.map((joinColumn) => joinColumn);\n        }\n        else {\n            if (relation.isOwning) {\n                columns = relation.joinColumns.map((joinColumn) => joinColumn);\n            }\n            else {\n                columns = relation.inverseRelation.inverseJoinColumns.map((joinColumn) => joinColumn);\n            }\n        }\n        return columns.reduce((data, column) => {\n            data[column.databaseName] = relationIdRawResult[column.databaseName];\n            return data;\n        }, {});\n    }\n    /*private removeVirtualColumns(entity: ObjectLiteral, alias: Alias) {\n        const virtualColumns = this.expressionMap.selects\n            .filter(select => select.virtual)\n            .map(select => select.selection.replace(alias.name + \".\", \"\"));\n\n        virtualColumns.forEach(virtualColumn => delete entity[virtualColumn]);\n    }*/\n    /** Prepare data to run #transformRelationIds, as a lot of result independent data is needed in every call */\n    prepareDataForTransformRelationIds() {\n        // Return early if the relationIdMaps were already calculated\n        if (this.relationIdMaps) {\n            return;\n        }\n        // Ensure this prepare function is only called once\n        this.relationIdMaps = this.rawRelationIdResults.map((rawRelationIdResult) => {\n            const relation = rawRelationIdResult.relationIdAttribute.relation;\n            // Calculate column metadata\n            let columns;\n            if (relation.isManyToOne || relation.isOneToOneOwner) {\n                columns = relation.joinColumns;\n            }\n            else if (relation.isOneToMany ||\n                relation.isOneToOneNotOwner) {\n                columns = relation.inverseEntityMetadata.primaryColumns;\n            }\n            else {\n                // ManyToMany\n                if (relation.isOwning) {\n                    columns = relation.inverseJoinColumns;\n                }\n                else {\n                    columns = relation.inverseRelation.joinColumns;\n                }\n            }\n            // Calculate the idMaps for the rawRelationIdResult\n            return rawRelationIdResult.results.reduce((agg, result) => {\n                let idMap = columns.reduce((idMap, column) => {\n                    let value = result[column.databaseName];\n                    if (relation.isOneToMany ||\n                        relation.isOneToOneNotOwner) {\n                        if (column.isVirtual &&\n                            column.referencedColumn &&\n                            column.referencedColumn.propertyName !==\n                                column.propertyName) {\n                            // if column is a relation\n                            value =\n                                column.referencedColumn.createValueMap(value);\n                        }\n                        return OrmUtils.mergeDeep(idMap, column.createValueMap(value));\n                    }\n                    if (!column.isPrimary &&\n                        column.referencedColumn.referencedColumn) {\n                        // if column is a relation\n                        value =\n                            column.referencedColumn.referencedColumn.createValueMap(value);\n                    }\n                    return OrmUtils.mergeDeep(idMap, column.referencedColumn.createValueMap(value));\n                }, {});\n                if (columns.length === 1 &&\n                    !rawRelationIdResult.relationIdAttribute.disableMixedMap) {\n                    if (relation.isOneToMany ||\n                        relation.isOneToOneNotOwner) {\n                        idMap = columns[0].getEntityValue(idMap);\n                    }\n                    else {\n                        idMap =\n                            columns[0].referencedColumn.getEntityValue(idMap);\n                    }\n                }\n                // If an idMap is found, set it in the aggregator under the correct hash\n                if (idMap !== undefined) {\n                    const hash = this.hashEntityIds(relation, result);\n                    if (agg[hash]) {\n                        agg[hash].push(idMap);\n                    }\n                    else {\n                        agg[hash] = [idMap];\n                    }\n                }\n                return agg;\n            }, {});\n        });\n    }\n    /**\n     * Use a simple JSON.stringify to create a simple hash of the primary ids of an entity.\n     * As this.extractEntityPrimaryIds always creates the primary id object in the same order, if the same relation is\n     * given, a simple JSON.stringify should be enough to get a unique hash per entity!\n     */\n    hashEntityIds(relation, data) {\n        const entityPrimaryIds = this.extractEntityPrimaryIds(relation, data);\n        return JSON.stringify(entityPrimaryIds);\n    }\n}\n\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}